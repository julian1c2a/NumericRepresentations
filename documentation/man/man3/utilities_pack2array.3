.TH "utilities::pack2array< Ts >" 3 "Martes, 29 de Noviembre de 2022" "Version 0.8" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
utilities::pack2array< Ts > \- END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <utilities\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBarray_type\fP = std::array< typename \fBpack2tuple\fP< Ts\&.\&.\&. >\fB::elem_type\fP< 0 >,(sizeof\&.\&.\&.(Ts)) >"
.br
.ti -1c
.RI "using \fBelem_type\fP = typename \fBpack2tuple\fP< Ts\&.\&.\&. >::elem_type< 0 >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "constexpr \fBarray_type\fP && \fBoperator()\fP (Ts &&\&.\&.\&.args) const noexcept"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static constexpr std::size_t \fBpack_size\fP () noexcept"
.br
.ti -1c
.RI "template<std::size_t J> static constexpr \fBelem_type\fP \fBget\fP (Ts &&\&.\&.\&.args) noexcept"
.br
.ti -1c
.RI "template<std::size_t\&.\&.\&. I> static constexpr void \fBfor_each_impl\fP (\fBarray_type\fP &iarray, const Ts &\&.\&.\&.args, std::index_sequence< I\&.\&.\&. >) noexcept"
.br
.ti -1c
.RI "static constexpr void \fBfor_each\fP (\fBarray_type\fP &iarray, const Ts &\&.\&.\&.args) noexcept"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<typename\&.\&.\&. Ts>
.br
requires (all_are_the_same_type<Ts\&.\&.\&.>&&all_are_more_than_zero<Ts\&.\&.\&.>)
.br
struct utilities::pack2array< Ts >"END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES\&. 
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<typename\&.\&.\&. Ts> using \fButilities::pack2array\fP< Ts >::array_type =  std::array< typename \fBpack2tuple\fP<Ts\&.\&.\&.>\fB::elem_type\fP<0>, (sizeof\&.\&.\&.(Ts)) >"

.SS "template<typename\&.\&.\&. Ts> using \fButilities::pack2array\fP< Ts >::elem_type =  typename \fBpack2tuple\fP<Ts\&.\&.\&.>::elem_type<0>"

.SH "Documentación de las funciones miembro"
.PP 
.SS "template<typename\&.\&.\&. Ts> static constexpr void \fButilities::pack2array\fP< Ts >::for_each (\fBarray_type\fP & iarray, const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
138                                                                     {
139                 constexpr unsigned size_of_pack{sizeof\&.\&.\&.(args)};
140                 for_each_impl(
141                         iarray,
142                         args\&.\&.\&.,
143                         std::make_index_sequence<size_of_pack>{}
144                 );
145                 return;
146         }
.fi
.PP
Referenciado por \fButilities::assign_with_order()\fP\&.
.SS "template<typename\&.\&.\&. Ts> template<std::size_t\&.\&.\&. I> static constexpr void \fButilities::pack2array\fP< Ts >::for_each_impl (\fBarray_type\fP & iarray, const Ts &\&.\&.\&. args, std::index_sequence< I\&.\&.\&. >)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
ESTA FUNCION AUXILIAR ES NECESARIA PARA UNA POSTERIOR EXPANSION DEL PARAMETER PACK 
.PP
.nf
132         {
133                 ( ( iarray[I] = std::get<I>( std::make_tuple(args\&.\&.\&.) ) ) , \&.\&.\&.);
134                 return;
135         }
.fi
.SS "template<typename\&.\&.\&. Ts> template<std::size_t J> static constexpr \fBelem_type\fP \fButilities::pack2array\fP< Ts >::get (Ts &&\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
116                                                               {
117                 constexpr array_type  content = {std::forward(args\&.\&.\&.)};
118                 constexpr elem_type ret{std::get<J>(std::forward(content))};
119                 return std::move(ret);
120         }
.fi
.SS "template<typename\&.\&.\&. Ts> constexpr \fBarray_type\fP && \fButilities::pack2array\fP< Ts >::operator() (Ts &&\&.\&.\&. args) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
108                                                                        {
109                 constexpr array_type  content = array_type{std::forward(args\&.\&.\&.)};
110                 return  std::move(content);
111         }
.fi
.SS "template<typename\&.\&.\&. Ts> static constexpr std::size_t \fButilities::pack2array\fP< Ts >::pack_size ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
104                                                         {
105                 return (sizeof\&.\&.\&.(Ts));
106         }
.fi


.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
