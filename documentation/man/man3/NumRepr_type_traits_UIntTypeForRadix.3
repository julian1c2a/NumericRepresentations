.TH "NumRepr::type_traits::UIntTypeForRadix< Type, Radix >" 3 "Martes, 29 de Noviembre de 2022" "Version 0.8" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::type_traits::UIntTypeForRadix< Type, Radix > \- FUNCION TYPE_TRAITS DE AYUDA PARA TYPE_TRAITS::UINTTYPEFORRADIX\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <basic_types\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBactUIntType\fP = std::conditional_t< \fBbool_value\fP, \fBuint128_t\fP, \fBempty_type\fP >"
.br
.ti -1c
.RI "using \fBUIntType\fP = std::conditional_t< \fBbool_value\fP, typename \fBUIntTypeForRadix\fP< \fBuint128_t\fP, \fBuint_value\fP >::UIntType, \fBempty_type\fP >"
.br
.in -1c
.SS "Atributos públicos estáticos"

.in +1c
.ti -1c
.RI "static constexpr \fBuint128_t\fP \fBuint_value_max\fP = \fBmaxbase\fP<\fBuint128_t\fP>()"
.br
.ti -1c
.RI "static constexpr \fBuint128_t\fP \fBuint_value\fP = static_cast<\fBuint128_t\fP>(Radix)"
.br
.ti -1c
.RI "static constexpr bool \fBbool_value\fP"
.br
.ti -1c
.RI "static constexpr \fBactUIntType\fP \fBact_uint_value\fP = ( \fBbool_value\fP ? \fBuint_value\fP : 0 )"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<typename Type, Type Radix>
.br
struct NumRepr::type_traits::UIntTypeForRadix< Type, Radix >"FUNCION TYPE_TRAITS DE AYUDA PARA TYPE_TRAITS::UINTTYPEFORRADIX\&. 
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<typename Type , Type Radix> using \fBNumRepr::type_traits::UIntTypeForRadix\fP< Type, Radix >::actUIntType =  std::conditional_t< \fBbool_value\fP, \fBuint128_t\fP, \fBempty_type\fP >"

.SS "template<typename Type , Type Radix> using \fBNumRepr::type_traits::UIntTypeForRadix\fP< Type, Radix >::UIntType =  std::conditional_t< \fBbool_value\fP, typename \fBUIntTypeForRadix\fP< \fBuint128_t\fP, \fBuint_value\fP >::UIntType, \fBempty_type\fP >"

.SH "Documentación de los datos miembro"
.PP 
.SS "template<typename Type , Type Radix> constexpr \fBactUIntType\fP \fBNumRepr::type_traits::UIntTypeForRadix\fP< Type, Radix >::act_uint_value = ( \fBbool_value\fP ? \fBuint_value\fP : 0 )\fC [static]\fP, \fC [constexpr]\fP"

.SS "template<typename Type , Type Radix> constexpr bool \fBNumRepr::type_traits::UIntTypeForRadix\fP< Type, Radix >::bool_value\fC [static]\fP, \fC [constexpr]\fP"
\fBValor inicial:\fP
.PP
.nf
=   (Radix <= uint_value_max) &&
                                                                                                                                            (Radix > 1)                           &&
                                                                                                                                                std::is_integral_v<Type>
.fi
.SS "template<typename Type , Type Radix> constexpr \fBuint128_t\fP \fBNumRepr::type_traits::UIntTypeForRadix\fP< Type, Radix >::uint_value = static_cast<\fBuint128_t\fP>(Radix)\fC [static]\fP, \fC [constexpr]\fP"

.SS "template<typename Type , Type Radix> constexpr \fBuint128_t\fP \fBNumRepr::type_traits::UIntTypeForRadix\fP< Type, Radix >::uint_value_max = \fBmaxbase\fP<\fBuint128_t\fP>()\fC [static]\fP, \fC [constexpr]\fP"


.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
