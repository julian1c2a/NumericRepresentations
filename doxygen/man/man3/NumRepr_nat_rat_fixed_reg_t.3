.TH "NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nat_rat_fixed_reg_t\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> using \fBbase_NEXNF_t\fP = std::array< \fBdig_t\fP< UINT_T, B >, NE+NF >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_NEXNF_t\fP< LE, LF >"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> using \fBpfx_rat_reg_NExNF_digs_t\fP = \fBpfx_rat_reg_digs_t\fP< UINT_T, B, NE, NF >"
.br
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename \fBtype_traits::sig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> using \fBnat_reg_NExNF_digs_t\fP = \fBnat_reg_digs_t\fP< UINT_T, B, NE+NF >"
.br
.ti -1c
.RI "using \fBnat_reg_digs_t\fP = \fBnat_reg_digs_t\fP< UINT_T, B, LE+LF >"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> using \fBreg_ints_t\fP = typename std::array< UINT_T, NE+NF >"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> using \fBreg_suints_t\fP = typename std::array< \fBSIG_UINT_T\fP, NE+NF >"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> using \fBreg_ssints_t\fP = typename std::array< \fBSIG_SINT_T\fP, NE+NF >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBpfx_rat_reg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)void \fBcopy_arg_N\fP (const \fBbase_NEXNF_t\fP< NE, NF > &arg)"
.br
.RI "BEGIN : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<std::size_t N> 
.br
requires (N>0)void \fBmove_arg_N\fP (base_N_t< NE, NF > &&arg)"
.br
.ti -1c
.RI "template<std::size_t N> 
.br
requires (N>0)constexpr \fBpfx_rat_reg_digs_t\fP (const base_NExNF_t< NE, NF > &arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t N> 
.br
requires (N>0)constexpr \fBpfx_rat_reg_digs_t\fP (const base_NExNF_t< NE, NF > &&arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBpfx_rat_reg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP (\fBnat_reg_NExNF_digs_t\fP< NE, NF > &&arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP & \fBoperator=\fP (\fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP & \fBoperator=\fP (\fBnat_reg_NExNF_digs_t\fP< NE, NF > &&arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator=\fP (const nat_reg_N_digs_t< NE, NF > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE MODIFICAR EL ARGUMENTO\&. "
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP & \fBoperator=\fP (const \fBbase_NEXNF_t\fP< NE, NF > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA DESDE BASE_N_T\&. "
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBpfx_rat_reg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBconcat\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr reg_N_digs_t< LE+LF+1 > \fBconcat\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBconcat_inv\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr reg_N_digs_t< LE+LF+1 > \fBconcat_inv\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBconcat\fP (\fBnat_reg_NExNF_digs_t\fP< NE, NF > &&arg) noexcept"
.br
.ti -1c
.RI "constexpr reg_N_digs_t< LE+LF+1 > \fBconcat\fP (\fBdig_t\fP &&arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBconcat_inv\fP (\fBnat_reg_NExNF_digs_t\fP< NE, NF > &&arg) noexcept"
.br
.ti -1c
.RI "constexpr reg_N_digs_t< LE+LF+1 > \fBconcat_inv\fP (\fBdig_t\fP &&arg) noexcept"
.br
.ti -1c
.RI "template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend\-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBsubreg_digs\fP () const noexcept"
.br
.ti -1c
.RI "template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend\-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBrev_subreg_digs\fP () const noexcept"
.br
.ti -1c
.RI "template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend\-ibegin > \fBsubreg_digs_pe\fP () const noexcept"
.br
.ti -1c
.RI "template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend\-ibegin > \fBrev_subreg_digs_pe\fP () const noexcept"
.br
.ti -1c
.RI "template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBsubreg_digs_pf\fP () const noexcept"
.br
.ti -1c
.RI "template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBrev_subreg_digs_pf\fP () const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr Int_Type \fBIntPart\fP () const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator==\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator==\fP (const \fBpfx_rat_reg_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator!=\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator!=\fP (const \fBpfx_rat_reg_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator<=\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator<=\fP (const \fBpfx_rat_reg_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator>=\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator>=\fP (const \fBpfx_rat_reg_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator<\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator<\fP (const \fBpfx_rat_reg_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBoperator>\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr std::weak_ordering \fBoperator<=>\fP (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr std::strong_ordering \fBoperator<=>\fP (const \fBpfx_rat_reg_digs_t\fP< NE, NF > &arg) const noexcept"
.br
.ti -1c
.RI "template<std::int32_t I> 
.br
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr const \fBdig_t\fP & \fBget\fP () const noexcept"
.br
.ti -1c
.RI "template<std::int32_t I> 
.br
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void \fBput\fP (const \fBdig_t\fP &arg) noexcept"
.br
.ti -1c
.RI "template<std::int32_t I> 
.br
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void \fBput\fP (\fBdig_t\fP &&arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator[]\fP (std::int32_t idx) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator[]\fP (std::int32_t idx) noexcept"
.br
.ti -1c
.RI "constexpr UINT_T \fBoperator()\fP (std::int32_t idx) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator++\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator++\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator\-\-\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator\-\-\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBC_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBC_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator!\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator\-\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator+=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator\-=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBmult\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBadd\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "'@' = '+' "
.ti -1c
.RI "constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBsubst\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator+\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator\-\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator*\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator<<\fP (std::size_t n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator<<=\fP (std::size_t n) noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator>>\fP (std::size_t n) const noexcept"
.br
.RI "DIVIDE BY THE BASE B (/10_B) "
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator>>=\fP (std::size_t n) noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBrem_B\fP (std::size_t n) const noexcept"
.br
.RI "END : OPERATORS >> >>= << <<=\&. "
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBm_rem_B\fP (std::size_t n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator|=\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.RI "BEGIN : OPERATORS | & |= &=\&. "
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator|\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator&=\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator&\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr std::pair< \fBdig_t\fP, \fBpfx_rat_reg_digs_t\fP > \fBoperator+\fP (const \fBpfx_rat_reg_digs_t\fP &arg) const noexcept"
.br
.RI "END : OPERATORS | & |= &=\&. "
.ti -1c
.RI "constexpr std::pair< \fBdig_t\fP, \fBpfx_rat_reg_digs_t\fP > \fBoperator\-\fP (const \fBpfx_rat_reg_digs_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBoperator*\fP (const \fBpfx_rat_reg_digs_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator+\fP (const \fBbase_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator\-\fP (const \fBbase_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBpfx_rat_reg_digs_t\fP \fBoperator*\fP (const \fBbase_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator+=\fP (const \fBbase_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBbase_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator*=\fP (const \fBbase_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator+=\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBpfx_rat_reg_digs_t\fP & \fBoperator*=\fP (const \fBpfx_rat_reg_digs_t\fP &arg) noexcept"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBdig_0\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBdig_1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBdig_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBdig_max\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBdig_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBdig_submax\fP () noexcept"
.br
.ti -1c
.RI "static constexpr UINT_T \fBui_0\fP () noexcept"
.br
.ti -1c
.RI "static constexpr UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr UINT_T \fBui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBSIG_UINT_T\fP \fBsui_B\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBSIG_UINT_T\fP \fBsui_Bp1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr UINT_T \fBui_submax\fP () noexcept"
.br
.ti -1c
.RI "static constexpr UINT_T \fBui_max\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBpfx_rat_reg_digs_t\fP \fBregd_0\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBpfx_rat_reg_digs_t\fP \fBregd_1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBpfx_rat_reg_digs_t\fP \fBregd_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBpfx_rat_reg_digs_t\fP \fBregd_B\fP () noexcept"
.br
.ti -1c
.RI "template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBpfx_rat_reg_digs_t\fP \fBregd_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBpfx_rat_reg_digs_t\fP \fBregd_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBreg_ints_t\fP< LE+LF > \fBregi_0\fP () noexcept"
.br
.RI "ARRAYS DE ENTEROS QUE SON DE AYUDA\&. "
.ti -1c
.RI "static constexpr \fBreg_ints_t\fP< LE+LF > \fBregi_1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBreg_ints_t\fP< LE+LF > \fBregi_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBreg_ints_t\fP< LE+LF > \fBregi_B\fP () noexcept"
.br
.ti -1c
.RI "template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBreg_ints_t\fP< LE+LF > \fBregi_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBreg_ints_t\fP< LE+LF > \fBregi_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> 
.br
requires ((sizeof\&.\&.\&.(Ints_type))<=L)static constexpr \fBbase_t\fP \fBnormalize\fP (Ints_type \&.\&.\&. digits_pow_i) noexcept"
.br
.RI "END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "static constexpr std::size_t \fBcuenta_0s_desde_IZDA\fP (const \fBreg_ints_t\fP< LE+LF > &arg) noexcept"
.br
.ti -1c
.RI "static constexpr std::size_t \fBcuenta_0s_desde_DRCHA\fP (const \fBreg_ints_t\fP< LE+LF > &arg) noexcept"
.br
.in -1c
.SS "Atributos privados"

.in +1c
.ti -1c
.RI "\fBbase_t\fP \fBm_dc\fP"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF>
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>() && (LE>0))
.br
struct NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >"
.PP
Definición en la línea \fB12\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::base_NEXNF_t =  std::array<\fBdig_t\fP<UINT_T,B>,NE+NF>"

.PP
Definición en la línea \fB15\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::base_t =  \fBbase_NEXNF_t\fP<LE,LF>"

.PP
Definición en la línea \fB16\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_t =  \fBdig_t\fP<UINT_T,B>"

.PP
Definición en la línea \fB13\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::nat_reg_digs_t =  \fBnat_reg_digs_t\fP<UINT_T,B,LE+LF>"

.PP
Definición en la línea \fB24\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::nat_reg_NExNF_digs_t =  \fBnat_reg_digs_t\fP<UINT_T,B,NE+NF>"

.PP
Definición en la línea \fB23\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_NExNF_digs_t =  \fBpfx_rat_reg_digs_t\fP<UINT_T,B,NE,NF>"

.PP
Definición en la línea \fB19\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::reg_ints_t =  typename std::array<UINT_T,NE+NF>"

.PP
Definición en la línea \fB27\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::reg_ssints_t =  typename std::array<\fBSIG_SINT_T\fP,NE+NF>"

.PP
Definición en la línea \fB33\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::reg_suints_t =  typename std::array<\fBSIG_UINT_T\fP,NE+NF>"

.PP
Definición en la línea \fB30\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::SIG_SINT_T =  typename \fBtype_traits::sig_SInt_for_UInt_t\fP<UINT_T>"

.PP
Definición en la línea \fB21\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::SIG_UINT_T =  typename \fBtype_traits::sig_UInt_for_UInt_t\fP<UINT_T>"

.PP
Definición en la línea \fB20\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::add (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
'@' = '+' 
.PP
Definición en la línea \fB1455\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::C_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1238\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::C_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1229\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONCAT : CONCATENACION pfx_rat_reg_digs_t<23,7> var1{ \fBdig_t(1)\fP, \fBdig_t(2)\fP, \fBdig_t(3)\fP, \fBdig_t(4)\fP, \fBdig_t(5)\fP, \fBdig_t(6)\fP, \fBdig_t(7)\fP }; dig_t<23> var2{22}; var1\&.concat(var2) == nat#1:2:3:4:5:6:7:20#B23 
.PP
Definición en la línea \fB452\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION A SU VEZ PUEDEN SER POR COPIA Y POR MOVIMIENTO CONCAT : CONCATENACION pfx_rat_reg_digs_t<23,7> var1{ \fBdig_t(1)\fP, \fBdig_t(2)\fP, \fBdig_t(3)\fP, \fBdig_t(4)\fP, \fBdig_t(5)\fP, \fBdig_t(6)\fP, \fBdig_t(7)\fP } pfx_rat_reg_digs_t<23,3> var2{ \fBdig_t(22)\fP, \fBdig_t(21)\fP, \fBdig_t(20)\fP } var1\&.concat(var2) == nat#1:2:3:4:5:6:7:22:21:20#B23 
.PP
Definición en la línea \fB433\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat (\fBdig_t\fP && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB508\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat (\fBnat_reg_NExNF_digs_t\fP< NE, NF > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB494\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat_inv (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB480\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat_inv (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB466\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat_inv (\fBdig_t\fP && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB535\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBnat_reg_NExNF_digs_t\fP< LE+NE, LF+NF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::concat_inv (\fBnat_reg_NExNF_digs_t\fP< NE, NF > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB521\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)void \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::copy_arg_N (const \fBbase_NEXNF_t\fP< NE, NF > & arg)\fC [inline]\fP"

.PP
BEGIN : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. FUNCION DELEGADA PARA COPIA DE UN ARRAY DE DISTINTO TAMANO O TAMANO CUALQUIERA 'N' INTERNO 
.PP
Definición en la línea \fB175\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr std::size_t \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::cuenta_0s_desde_DRCHA (const \fBreg_ints_t\fP< LE+LF > & arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1911\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr std::size_t \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::cuenta_0s_desde_IZDA (const \fBreg_ints_t\fP< LE+LF > & arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1896\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBdig_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB37\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBdig_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB38\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBdig_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB39\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBdig_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_Bm2 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB41\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBdig_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_max ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB40\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBdig_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::dig_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB42\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t I> 
.br
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr const \fBdig_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::get () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t A{}; I en [LE-1,-LF] A\&.get<LE-1>() [devuelve el digito de peso B^(LE-1)] \&.\&.\&.\&.\&.\&.\&.\&.\&.\&. A\&.get<2>() [devuelve el digito de peso B^2] A\&.get<1>() [devuelve el digito de peso B^1] A\&.get<0>() [devuelve el digito de peso (B^0)==1] A\&.get<-1>() [devuelve el digito de peso B^-1] A\&.get<-2>() [devuelve el digito de peso B^-2] \&.\&.\&.\&.\&.\&.\&.\&.\&.\&.\&. A\&.get<-LF>() [devuelve el digito de peso B^-LF] MSB == MSB_E == LE-1 LSB_E == LF MSB_F == LF-1 LSB_F == 0 == LSB 
.PP
Definición en la línea \fB1090\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c Int_Type> constexpr Int_Type \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::IntPart () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB633\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::m_rem_B (std::size_t n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1710\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::mC_B ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1
.PP
Definición en la línea \fB1209\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::mC_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1199\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t N> 
.br
requires (N>0)void \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::move_arg_N (base_N_t< NE, NF > && arg)\fC [inline]\fP"
FUNCION DELEGADA PARA MOVER DE UN ARRAY DE DISTINTO TAMANO O TAMANO CUALQUIERA 'N' INTERNO 
.PP
Definición en la línea \fB210\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::mult (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACIONES '@'(REG_DIGS_T,DIG_T)->STD::ARRAY<REG_DIGS_T,2> '@' = MULT 
.PP
Definición en la línea \fB1373\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c \&.\&.\&. Ints_type> 
.br
requires ((sizeof\&.\&.\&.(Ints_type))<=L)static constexpr \fBbase_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::normalize (Ints_type \&.\&.\&. digits_pow_i)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. FUNCION DE NORMALIZACION A LA BASE B DE UN ARGUMENTOS EN UN PACK DE ENTEROS CUALQUIERA INTERNA 
.PP
Definición en la línea \fB244\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator! () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1246\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >\fB::operator!\fP= (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t<23,12> A; A = \&.\&.\&. pfx_rat_reg_digs_t<23,10> B; B = \&.\&.\&. A != B => true or false 
.PP
Definición en la línea \fB717\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >\fB::operator!\fP= (const \fBpfx_rat_reg_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB769\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator& (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1755\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator&= (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1746\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr UINT_T \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator() (std::int32_t idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1122\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator* (const \fBbase_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2066\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator* (const \fBpfx_rat_reg_digs_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
BEGIN : DECLARACIONES E INICIALIZACIONES
.PP
END : DECLARACIONES E INICIALIZACIONES
.PP
BEGIN : OBTENEMOS TODOS LOS SUMANDOS MULTIPLICANDO POR UN DIGITO FIJO COLOCADOS CONVENIENTEMENTE
.PP
COLOCADOS CONVENIENTEMENTE END : OBTENEMOS TODOS LOS SUMANDOS MULTIPLICANDO POR UN DIGITO FIJO
.PP
BEGIN : SUMAMOS TODOS LOS SUMANDOS
.PP
END : SUMAMOS TODOS LOS SUMANDOS BEGIN : PREPARAMOS EL PAR DE RETORNO
.PP
END : PREPARAMOS EL PAR DE RETORNO
.PP
Definición en la línea \fB1835\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr auto \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator* (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1522\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator*= (const \fBbase_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2119\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator*= (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2142\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator+ (const \fBbase_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2048\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::pair< \fBdig_t\fP, \fBpfx_rat_reg_digs_t\fP > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator+ (const \fBpfx_rat_reg_digs_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END : OPERATORS | & |= &=\&. CARRY INICIAL ES 0
.PP
INT_ARRAY TEMPORAL COPIA DE (*THIS) [SUMANDO 0]
.PP
INT_ARRAY TEMPORAL COPIA DE ARG [SUMANDO 1]
.PP
BUCLE FOR QUE SUMA RETINTS Y ARGINTS DESDE IDX=0 A IDX=L-1
.PP
GUARDAMOS EL CARRY FINAL Y RETORNAMOS LA SUMA
.PP
Definición en la línea \fB1772\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr auto \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator+ (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1506\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator++ ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CARRY INICIAL ES 1
.PP
BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1
.PP
Definición en la línea \fB1137\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator++ (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1159\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator+= (const \fBbase_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2101\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator+= (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2128\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator+= (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CARRY INICIAL ES 1
.PP
CASOS CARRY==0[ULTIMA], CARRY==1[VECES SIGUIENTES], CARRY=ARG [1A VEZ] SI ARG == 0 ENTONCES SE DEVUELVE SIN MÁS SI ARG == 1 ENTONCES ++CTHIS SI ARG > 1 ENTONCES 1a VEZ dig_BmArg 2a VEZ dig_Bm1 Y SIGUIENTES ULTIMA VEZ CARRY ==0
.PP
PRIMERA VEZ : ARG > 1 usamos dig_BmArg
.PP
SEGUNDA VEZ Y SIGUIENTES BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1
.PP
Definición en la línea \fB1277\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\- () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1254\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\- (const \fBbase_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2057\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::pair< \fBdig_t\fP, \fBpfx_rat_reg_digs_t\fP > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\- (const \fBpfx_rat_reg_digs_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
INICIALIZAMOS EL CARRY/BORROW A 0
.PP
GUARDAMOS EL COMPLEMENTO A LA BASE MENOS 1 DEL MINUENDO
.PP
COMPLETAMOS EL COMPLEMENTO A LA BASE SUMANDO 1 [carry_CB vale en el inicio 1]
.PP
SE HA COMPLETADO EL COMPLEMENTO A LA BASE
.PP
SUMAMOS SUMANDO_0 + C_B(SUMANDO_1)
.PP
Definición en la línea \fB1799\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr auto \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\- (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1514\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\-\- ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CARRY INICIAL ES EL COMPLEMENTO A LA BASE DE 1
.PP
BUCLE FOR QUE SUMA CTHIS Y C_B(1) DESDE IDX=0 A IDX=LE+LF-1
.PP
Definición en la línea \fB1167\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\-\- (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1182\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\-= (const \fBbase_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2110\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\-= (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB2135\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator\-= (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CARRY INICIAL ES 1
.PP
CASOS CARRY==0[ULTIMA], CARRY==1[VECES SIGUIENTES], CARRY=ARG [1A VEZ] SI ARG == 0 ENTONCES SE DEVUELVE SIN MÁS SI ARG == 1 ENTONCES --CTHIS SI ARG > 1 ENTONCES 1a VEZ dig_BmArg 2a VEZ dig_Bm1 Y SIGUIENTES ULTIMA VEZ CARRY ==0
.PP
PRIMERA VEZ : SUMAMOS EL COMPLEMENTO A LA BASE DE ARG
.PP
SEGUNDA VEZ Y SIGUIENTES BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1
.PP
Definición en la línea \fB1318\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator< (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t<23,12> A; A = \&.\&.\&. pfx_rat_reg_digs_t<23,10> B; B = \&.\&.\&. A < B => true or false 
.PP
Definición en la línea \fB919\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator< (const \fBpfx_rat_reg_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB973\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator<< (std::size_t n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
BEGIN : OPERATORS >> >>= << <<= MULTIPLY BY THE BASE B (10) 
.PP
Definición en la línea \fB1632\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator<<= (std::size_t n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1647\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator<= (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t<23,12> A; A = \&.\&.\&. pfx_rat_reg_digs_t<23,10> B; B = \&.\&.\&. A <= B => true or false 
.PP
Definición en la línea \fB783\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator<= (const \fBpfx_rat_reg_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB837\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr std::weak_ordering \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator<=> (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR COMPARACION OPERADOR SPACESHIP C++20 Comparaciones con un array estandar de otra longitud La salida devuelta es greater,less,equivalent 
.PP
Definición en la línea \fB1044\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr std::strong_ordering \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator<=> (const \fBpfx_rat_reg_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1058\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator= (const \fBbase_NEXNF_t\fP< NE, NF > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA DESDE BASE_N_T\&. 
.PP
Definición en la línea \fB376\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator= (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION COPIA DESDE UN DIGITO (CONVERSION) dig_t<13> a{3}; pfx_rat_reg_digs_t<13,16> A{}; A = a; A = nat#0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:3#B13 
.PP
Definición en la línea \fB387\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator= (const nat_reg_N_digs_t< NE, NF > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE MODIFICAR EL ARGUMENTO\&. 
.PP
Definición en la línea \fB366\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c Int_Type> constexpr \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator= (Int_Type arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) pfx_rat_reg_digs_t<16,4> var{}; var = 1324; 1324/%16 = 82|12 82/%16 = 5|2 => var == nat#5:2:12#B16 
.PP
Definición en la línea \fB400\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator= (\fBnat_reg_NExNF_digs_t\fP< NE, NF > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION ASIGNACION POR MOVIMIENTO reg_N_digs_t == std::array<dig_t,N>; pfx_rat_reg_digs_t<21,5> var{}; pfx_rat_reg_digs_t var2{}; var2 = std::move(var); var2 == antigua var; var actual no sabemos su valor; 
.PP
Definición en la línea \fB356\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator= (\fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION ASIGNACION POR COPIA EN LA QUE SE PUEDE COPIAR reg_N_digs_t == std::array<dig_t,N>; pfx_rat_reg_digs_t<21,5> var{}; pfx_rat_reg_digs_t var2{}; var2 = var; var2 == var 
.PP
Definición en la línea \fB341\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator== (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t<23,12> A; A = \&.\&.\&. pfx_rat_reg_digs_t<23,10> B; B = \&.\&.\&. A == B => true or false 
.PP
Definición en la línea \fB657\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator== (const \fBpfx_rat_reg_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB703\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator> (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t<23,12> A; A = \&.\&.\&. pfx_rat_reg_digs_t<23,10> B; B = \&.\&.\&. A > B => true or false 
.PP
Definición en la línea \fB987\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator>= (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t<23,12> A; A = \&.\&.\&. pfx_rat_reg_digs_t<23,10> B; B = \&.\&.\&. A >= B => true or false 
.PP
Definición en la línea \fB851\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr bool \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator>= (const \fBpfx_rat_reg_digs_t\fP< NE, NF > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB905\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator>> (std::size_t n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
DIVIDE BY THE BASE B (/10_B) 
.PP
Definición en la línea \fB1664\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator>>= (std::size_t n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1679\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBdig_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator[] (std::int32_t idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1108\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBdig_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator[] (std::int32_t idx)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1115\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator| (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1738\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const \fBpfx_rat_reg_digs_t\fP & \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::operator|= (const \fBpfx_rat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
BEGIN : OPERATORS | & |= &=\&. REMAINDER BY THE BASE B (%10_B) END : 'OPERATORS' REM_B^n AND M_REM_B^n 
.PP
Definición en la línea \fB1729\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR POR DEFECTO pfx_rat_reg_digs_t<10,3,2> var(); var == nat#0:0:0:s:0:0#B10 
.PP
Definición en la línea \fB152\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const base_NExNF_t< NE, NF > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS INTERNO 
.PP
Definición en la línea \fB234\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const base_NExNF_t< NE, NF > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR COPIA REFERENCIA DESDE UN ARRAY DE DIGITOS INTERNO 
.PP
Definición en la línea \fB227\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const \fBnat_reg_NExNF_digs_t\fP< NE, NF > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR COPIA pfx_rat_reg_digs_t<10,3,2> var{1,3,2,5,6}; pfx_rat_reg_digs_t<10,3,2> var2(var); 
.PP
Definición en la línea \fB322\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const std::initializer_list< \fBdig_t\fP > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR POR LISTA DE DIGITOS pfx_rat_reg_digs_t<10,3,2> var{\fBdig_t(1)\fP,\fBdig_t(3)\fP,\fBdig_t(2)\fP,\fBdig_t(5)\fP,\fBdig_t(6)\fP}; var == nat#1:3:2:s:5:6#B10 
.PP
Definición en la línea \fB158\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO pfx_rat_reg_digs_t<10,3,2> var(\fBdig_t(1)\fP,\fBdig_t(3)\fP,\fBdig_t(2)\fP,\fBdig_t(5)\fP,\fBdig_t(6)\fP); var == nat#1:3:2:5:6#B10 
.PP
Definición en la línea \fB166\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (Ints_type \&.\&.\&. dig_pow_i)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO pfx_rat_reg_digs_t<10,3,2> var{1,3,2,5,6}; var == nat#1:3:2:s:5:6#B10 
.PP
Definición en la línea \fB315\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> 
.br
requires (NE>0)constexpr \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (\fBnat_reg_NExNF_digs_t\fP< NE, NF > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR MOVIMIENTO pfx_rat_reg_digs_t<10,3,2> var{1,3,2,5,6}; pfx_rat_reg_digs_t<10,3,2> var2(std::move(var)); var queda no sabemos su valor 
.PP
Definición en la línea \fB330\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t I> 
.br
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::put (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
pfx_rat_reg_digs_t A{}; A\&.put<2>(B-1-A\&.get<2>()) [pone un valor en un digito por su indice] 
.PP
Definición en la línea \fB1098\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t I> 
.br
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::put (\fBdig_t\fP && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1104\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regd_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB51\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regd_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB58\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regd_B ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB68\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regd_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB63\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regd_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB76\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regd_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB83\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBreg_ints_t\fP< LE+LF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regi_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
ARRAYS DE ENTEROS QUE SON DE AYUDA\&. 
.PP
Definición en la línea \fB94\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBreg_ints_t\fP< LE+LF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regi_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB102\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBreg_ints_t\fP< LE+LF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regi_B ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB114\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBreg_ints_t\fP< LE+LF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regi_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB108\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBreg_ints_t\fP< LE+LF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regi_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB122\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> 
.br
requires ((n < LE) && (n > \-(LF+1)))static constexpr \fBreg_ints_t\fP< LE+LF > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::regi_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB130\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr \fBpfx_rat_reg_digs_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::rem_B (std::size_t n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END : OPERATORS >> >>= << <<=\&. BEGIN : 'OPERATORS' REM_B^n AND M_REM_B^n REMAINDER BY THE BASE B (%10_B) 
.PP
Definición en la línea \fB1698\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend\-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::rev_subreg_digs () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB562\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend\-ibegin > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::rev_subreg_digs_pe () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB588\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::rev_subreg_digs_pf () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB614\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend\-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::subreg_digs () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB549\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend\-ibegin > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::subreg_digs_pe () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB575\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> 
.br
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend\-ibegin > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::subreg_digs_pf () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB601\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< \fBpfx_rat_reg_digs_t\fP, 2 > \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::subst (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
TO DO REPASAR '@' = '-' 
.PP
Definición en la línea \fB1476\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBSIG_UINT_T\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::sui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB46\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr \fBSIG_UINT_T\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::sui_Bp1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB47\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::ui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB43\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::ui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB44\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::ui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB45\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::ui_max ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB49\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::ui_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB48\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SH "Documentación de los datos miembro"
.PP 
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> \fBbase_t\fP \fBNumRepr::nat_rat_fixed_reg_t\fP< UINT_T, B, LE, LF >::m_dc\fC [private]\fP"

.PP
Definición en la línea \fB35\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
