.TH "nat_reg_digs_t (Copia en conflicto de MSI 2022-11-24).hpp" 3 "Lunes, 28 de Noviembre de 2022" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nat_reg_digs_t (Copia en conflicto de MSI 2022-11-24).hpp
.SH SYNOPSIS
.br
.PP
\fC#include 'dig_t\&.hpp'\fP
.br
\fC#include 'utilities\&.hpp'\fP
.br

.SS "Clases"

.in +1c
.ti -1c
.RI "struct \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBNumRepr\fP"
.br
.in -1c
.SS "typedefs"

.in +1c
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename type_traits::sig_UInt_for_UInt_t< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename type_traits::sig_SInt_for_UInt_t< UINT_T >"
.br
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBbase_N_t\fP = std::array< \fBdig_t\fP, N >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_N_t\fP< L >"
.br
.ti -1c
.RI "template<binop_e op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP = typename auxiliary_types::result_operation_t< \fBbase_N_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<binop_e op> using \fBres_base_op_t\fP = typename auxiliary_types::result_operation_t< \fBbase_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBnat_reg_N_digs_t\fP = \fBnat_reg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "template<binop_e op, \fBsize_t\fP N> using \fBres_N_op_t\fP = typename auxiliary_types::result_operation_t< \fBnat_reg_N_digs_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<binop_e op> using \fBres_op_t\fP = typename auxiliary_types::result_operation_t< \fBnat_reg_digs_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_ints_t\fP = typename std::array< UINT_T, N >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_suints_t\fP = typename std::array< \fBSIG_UINT_T\fP, N >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_ssints_t\fP = typename std::array< \fBSIG_SINT_T\fP, N >"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> 
.br
requires (suitable_base<UINT_T,B>() && (L>0))struct \fBNumRepr::nat_reg_digs_t\fP \fBNumRepr::operator\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "consteval \fBnat_reg_digs_t\fP () noexcept"
.br
.RI "CONSTRUCTOR POR DEFECTO\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.RI "CONSTRUCTOR POR LISTA DE DIGITOS\&. "
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBnat_reg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.RI "CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBnat_reg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. "
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_dig\fP (\fBdig_t\fP arg) noexcept"
.br
.RI "OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_0\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_Bm1\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_dig\fP (\fBdig_t\fP dig) noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN DIGITO (CONVERSION) "
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "SUBREPR => SUB REPRESENTACION\&. "
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat_inv\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat_inv\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBsubrepr\fP () const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBoperator Int_Type\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_B\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_Bp1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_B_pow_m1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_B_pow\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_Bm1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n, \fBdig_t\fP d> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_filled_of\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator==\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator!=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBoperator<=>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBoperator<=>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr std::weak_ordering \fBoperator<=>\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBget\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBput\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator[]\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBoperator()\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBbase_t\fP & \fBconst_ref_data\fP () const"
.br
.ti -1c
.RI "constexpr \fBbase_t\fP \fBcpy_data\fP () const"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBC_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBC_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator!\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator<<\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator<<=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator>>\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator>>=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBrem_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_rem_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBmer_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_mer_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator|=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator|\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator&=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator&\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr auto \fBNumRepr::operator\-\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBNumRepr::operator*\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator/\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "DIVISION BY A DIGIT\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator%\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "REMAINDER BY A DIGIT\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::operator+=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::operator+=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::operator\-=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::operator\-=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::operator*=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::operator*=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator+\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "TO DO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator\-\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator*\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator+\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator\-\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator*\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator/\fP (const \fBnat_reg_digs_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBNumRepr::operator%\fP (const \fBnat_reg_digs_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, \fBsize_t\fP Length> 
.br
requires (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))std::istream & \fBoperator>>\fP (std::istream &is, \fBnat_reg_digs_t\fP< Int_Type, Base, Length > &arg)"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, \fBsize_t\fP Long> 
.br
requires (type_traits::suitable_base<Int_Type,Base>())std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBnat_reg_digs_t\fP< Int_Type, Base, Long > &arg)"
.br
.in -1c
.SH "Documentación de los 'typedefs'"
.PP 
.SS "template<\fBsize_t\fP N> using \fBbase_N_t\fP =  std::array<\fBdig_t\fP,N>"

.SS "using \fBbase_t\fP =  \fBbase_N_t\fP<L>"

.SS "using \fBdig_t\fP =  \fBdig_t\fP<UINT_T,B>"

.SS "template<\fBsize_t\fP N> using \fBnat_reg_N_digs_t\fP =  \fBnat_reg_digs_t\fP<UINT_T,B,N>"

.SS "template<\fBsize_t\fP N> using \fBreg_ints_t\fP =  typename std::array<UINT_T,N>"

.SS "template<\fBsize_t\fP N> using \fBreg_ssints_t\fP =  typename std::array<\fBSIG_SINT_T\fP,N>"

.SS "template<\fBsize_t\fP N> using \fBreg_suints_t\fP =  typename std::array<\fBSIG_UINT_T\fP,N>"

.SS "template<binop_e op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP =  typename auxiliary_types::result_operation_t<\fBbase_N_t\fP<N>,op,N>"

.SS "template<binop_e op> using \fBres_base_op_t\fP =  typename auxiliary_types::result_operation_t<\fBbase_t\fP,op,L>"

.SS "template<binop_e op, \fBsize_t\fP N> using \fBres_N_op_t\fP =  typename auxiliary_types::result_operation_t<\fBnat_reg_N_digs_t\fP<N>,op,N>"

.SS "template<binop_e op> using \fBres_op_t\fP =  typename auxiliary_types::result_operation_t<\fBnat_reg_digs_t\fP,op,L>"

.SS "using \fBSIG_SINT_T\fP =  typename type_traits::sig_SInt_for_UInt_t<UINT_T>"

.SS "using \fBSIG_UINT_T\fP =  typename type_traits::sig_UInt_for_UInt_t<UINT_T>"

.SH "Documentación de las funciones"
.PP 
.SS "constexpr \fBnat_reg_digs_t\fP operator::C_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::C_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > operator::cat (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
SUBREPR => SUB REPRESENTACION\&. FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION NAT_REG_N_T<L+M> NAT_REG_T::CAT(NAT_REG_N_T<M>) NAT_REG_N_T<L+M> NAT_REG_T::CAT_INV(NAT_REG_N_T<M>) NAT_REG_N_T<L+1> NAT_REG_T::CAT(DIG_T) NAT_REG_N_T<L+1> NAT_REG_T::CAT_INV(DIG_T) 
.SS "constexpr \fBnat_reg_N_digs_t\fP< L+1 > operator::cat (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > operator::cat_inv (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_N_digs_t\fP< L+1 > operator::cat_inv (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBbase_t\fP & operator::const_ref_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Referenciado por \fBNumRepr::reg_digs_t< UINT_T, B, L >::back()\fP, \fBNumRepr::reg_digs_t< UINT_T, B, L >::empty()\fP, \fBNumRepr::reg_digs_t< UINT_T, B, L >::front()\fP, \fBNumRepr::reg_digs_t< UINT_T, B, L >::max_size()\fP y \fBNumRepr::reg_digs_t< UINT_T, B, L >::size()\fP\&.
.SS "constexpr \fBbase_t\fP operator::cpy_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.SS "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP operator::get () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr bool operator::is_0 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3693                                                                     {(c>='0') && (c<='9')};
3694                                                 const bool num_base_lt_Base {numero_base_recogido < Base};
3695                                                 const bool num_base_eq_Base {numero_base_recogido == Base};
.fi
.PP
Referenciado por \fBNumRepr::dig_t< UINT_T, B >::is_0_divisor()\fP, \fBNumRepr::dig_t< UINT_T, B >::is_maxormin()\fP, \fBNumRepr::dig_t< UINT_T, B >::is_near_maxormin()\fP, \fBNumRepr::dig_t< UINT_T, B >::is_unit()\fP, \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator!=()\fP, \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator\-=()\fP, \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator<()\fP, \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator<=()\fP, \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator==()\fP, \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator>()\fP y \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator>=()\fP\&.
.SS "constexpr bool operator::is_1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3701                                                                                         {
.fi
.PP
Referenciado por \fBNumRepr::dig_t< UINT_T, B >::is_near_maxormin()\fP, \fBNumRepr::dig_t< UINT_T, B >::is_unit()\fP, \fBNumRepr::dig_t< UINT_T, B >::mult_inv()\fP y \fBNumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >::operator\-=()\fP\&.
.SS "constexpr bool operator::is_B () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3713                                            :
3714                                         {
.fi
.SS "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool operator::is_B_pow () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3727                                                                                      {
3728                 using inttype = typename type_traits::sig_UInt_for_UInt_t<Int_Type>;
3729                 os << "reg_dig#";
.fi
.SS "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool operator::is_B_pow_m1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.SS "constexpr bool operator::is_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3707                                                       {
.fi
.PP
Referenciado por \fBNumRepr::dig_t< UINT_T, B >::is_Bm1orBm2()\fP, \fBNumRepr::dig_t< UINT_T, B >::is_maxormin()\fP y \fBNumRepr::dig_t< UINT_T, B >::is_near_maxormin()\fP\&.
.SS "constexpr bool operator::is_Bp1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3713                                            :
3714                                         {
3715                                                 est_act = e0fin;
.fi
.SS "template<\fBsize_t\fP n, \fBdig_t\fP d> 
.br
requires ((n>0) && (n<L))constexpr bool operator::is_filled_of () const\fC [inline]\fP, \fC [constexpr]\fP"

.SS "constexpr bool operator::is_filled_of_1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
3732                                        :';
3733                 }
3734                 os << static_cast<inttype>(arg(0));
.fi
.SS "constexpr bool operator::is_filled_of_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::m_mer_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::m_rem_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::mC_B ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::mC_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::mer_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "consteval operator::nat_reg_digs_t ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR DEFECTO\&. 
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr operator::nat_reg_digs_t (const \fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. 
.PP
.nf
2937                                                      {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr operator::nat_reg_digs_t (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. 
.PP
.nf
2919                                                                               {result[1]};
2920                                                         }
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr operator::nat_reg_digs_t (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. 
.PP
.nf
3006                                              {
.fi
.SS "constexpr operator::nat_reg_digs_t (const std::initializer_list< \fBdig_t\fP > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR LISTA DE DIGITOS\&. 
.PP
.nf
2836                 {
.fi
.SS "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr operator::nat_reg_digs_t (const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. 
.PP
.nf
2843                                                             {regd_base_N_0<3>()};
.fi
.SS "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr operator::nat_reg_digs_t (Ints_type \&.\&.\&. dig_pow_i)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO\&. 
.PP
.nf
2992                                                                                       {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr operator::nat_reg_digs_t (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR MOVIMIENTO\&. 
.PP
.nf
3006                                              {
.fi
.SS "template<type_traits::integral_c Int_Type> constexpr operator::operator Int_Type () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3489                                               {0};
3490                 size_t longitud{0};
3491                 inttype                 numero_base_recogido{0};
3493                 nat_reg_digs_t& numero_ret{arg};
3495                 estado_e est_act = e0ini;
3497                 char c{'\0'};
3499                 is >> sds;
3501                 do {
3502                         c = sds[indice];
.fi
.SS "constexpr \fBnat_reg_digs_t\fP operator::operator! () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator::operator!\fP= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator::operator!\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator& (const \fBnat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator&= (const \fBnat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type operator::operator() (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator+ (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator++ ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator++ (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator+= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator\- () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator\- (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator\-\- ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator\-\- (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator\-= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator< (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator< (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator<< (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, \fBsize_t\fP Long> 
.br
requires (type_traits::suitable_base<Int_Type,Base>())std::ostream & operator<< (std::ostream & os, const \fBnat_reg_digs_t\fP< Int_Type, Base, Long > & arg)"

.PP
.nf
3727                                                                                      {
3728                 using inttype = typename type_traits::sig_UInt_for_UInt_t<Int_Type>;
3729                 os << "reg_dig#";
3730                 for(int32_t ix{Long-1} ; ix > 0 ; --ix) {
3731                                 os << static_cast<inttype>(arg(ix));
3732                                 os << ':';
3733                 }
3734                 os << static_cast<inttype>(arg(0));
3735                 os << "#B";
3736                 os << static_cast<inttype>(Base);
3737                 return (os);
3738         }
.fi
.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator<<= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator<= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator<= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering operator::operator<=> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.SS "constexpr std::weak_ordering operator::operator<=> (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering operator::operator<=> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & operator::operator= (\fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. 
.PP
.nf
3112                 {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & operator::operator= (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. 
.PP
.nf
3112                 {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & operator::operator= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. 
.PP
.nf
3012                                                       {coc_uint};
3013                                         rem[1] = dig_0();
3014                                         rem[0] = dig_t{rem_uint};
3015                                 }
.fi
.SS "constexpr \fBnat_reg_digs_t\fP & operator::operator= (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN DIGITO (CONVERSION) 
.PP
.nf
3255                 {
3256                         nat_reg_digs_t ret(*this);
3257                         ret += arg;
3258                         return std::move(ret);
3259                 }
3260 
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & operator::operator= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. 
.PP
.nf
3112                 {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & operator::operator= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. 
.PP
.nf
3112                 {
.fi
.SS "template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & operator::operator= (Int_Type arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) 
.PP
.nf
3300                 {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & operator::operator= (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR MOVIMIENTO\&. 
.PP
.nf
3112                 {
.fi
.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator== (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator== (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator>= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool operator::operator>= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator>> (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, \fBsize_t\fP Length> 
.br
requires (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))std::istream & operator>> (std::istream & is, \fBnat_reg_digs_t\fP< Int_Type, Base, Length > & arg)"
TODO ESTA VERSION + VERSION CON TRATAMIENTO DE ERRORES EN RUNTIME STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN
.PP
TIPOS A SER UTILIZADOS EN LA FUNCIÓN: NOMBRE DE TIPOS CORTOS
.PP
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA
.PP
VARIABLES PARA ACCIONES EN LOS ESTADOS
.PP
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)
.PP
ESTADO ACTUAL
.PP
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN
.PP
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA
.PP
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA
.PP
.nf
3474                                                                                  {
3475                 enum estado_e {
3476                         e0ini   , e1r           , e1e           , e1g                   , e1sep         ,
3477                         e1d             , e1i           , e2g           , e2start       , e2dig         ,
3478                         e2dp    , e2end , e2B           , e3dig         , e0fin
3479                 };
3481                 std::string sds;
3483                 using inttype = typename type_traits::sig_UInt_for_UInt_t<Int_Type>;
3484                 using dig_t = dig_t<Int_Type,Base>;
3485                 using nat_reg_digs_t = nat_reg_digs_t<Int_Type,Base,Length>;
3487                 size_t  indice{0};
3489                 Int_Type                digito{0};
3490                 size_t longitud{0};
3491                 inttype                 numero_base_recogido{0};
3493                 nat_reg_digs_t& numero_ret{arg};
3495                 estado_e est_act = e0ini;
3497                 char c{'\0'};
3499                 is >> sds;
3501                 do {
3502                         c = sds[indice];
3503                         switch(est_act) {
3504                                 case e0ini :
3505                                         {
3506                                                 if (c=='r') {
3507                                                         est_act = e1r;
3508                                                 } else {
3509                                                         est_act = e0ini;
3510                                                 }
3511                                         }
3512                                         break;
3513                                 case e1r :
3514                                         {
3515                                                 {
3516                                                         if (c=='e') {
3517                                                                 est_act = e1e;
3518                                                         }
3519                                                         else {
3520                                                                 est_act = e0ini;
3521                                                         }
3522                                                 }
3523                                         }
3524                                         break;
3525                                 case e1e :
3526                                         {
3527                                                 if (c=='g') {
3528                                                         est_act = e1g;
3529                                                 }
3530                                                 else  {
3531                                                         est_act = e0ini;
3532                                                 }
3533                                         }
3534                                         break;
3535                                 case e1g :
3536                                         {
3537                                                 if (c=='_') {
3538                                                         est_act = e1sep;
3539                                                 }
3540                                                 else  {
3541                                                         est_act = e0ini;
3542                                                 }
3543                                         }
3544                                         break;
3545                                 case e1sep :
3546                                         {
3547                                                 if (c=='d') {
3548                                                         est_act = e1d;
3549                                                 }
3550                                                 else  {
3551                                                         est_act = e0ini;
3552                                                 }
3553                                         }
3554                                         break;
3555                                 case e1d :
3556                                         {
3557                                                 if (c=='i') {
3558                                                         est_act = e1i;
3559                                                 }
3560                                                 else  {
3561                                                         est_act = e0ini;
3562                                                 }
3563                                         }
3564                                         break;
3565                                 case e1i :
3566                                         {
3567                                                 if (c=='g') {
3568                                                         est_act = e2g;
3569                                                 }
3570                                                 else  {
3571                                                         est_act = e0ini;
3572                                                 }
3573                                         }
3574                                         break;
3575                                 case e2g :
3576                                         {
3577                                                 if (c=='#') {
3578                                                         est_act = e2start;
3579                                                 }
3580                                                 else  {
3581                                                         est_act = e0ini;
3582                                                 }
3583                                         }
3584                                         break;
3585                                 case e2start :
3586                                         {
3587                                                 if (((c>='0')&&(c<='9'))&&(std::abs(c-'0')<Base)) {
3588                                                         est_act = e2dig;
3589                                                         digito = (c-'0');
3590                                                         longitud = 0;
3591                                                         numero_base_recogido = 0;
3592                                                         numero_ret = nat_reg_digs_t::regd_0();
3593                                                 }
3594                                                 else  {
3595                                                         est_act = e0ini;
3596                                                         digito = 0;
3597                                                         longitud = 0;
3598                                                         numero_base_recogido = 0;
3599                                                         numero_ret = nat_reg_digs_t::regd_0();
3600                                                 }
3601                                         }
3602                                         break;
3603                                 case e2dig :
3604                                         {
3605                                                 const bool dig_c {(c >= '0') && (c <= '9')};
3606                                                 const bool dig_lt_Base{digito<Base};
3607                                                 const bool c_es_dig_B {dig_c && dig_lt_Base};
3608                                                 const bool dig_B_cdl {c_es_dig_B && (longitud < Length-1)};
3609                                                 const bool tt_dig_B_cdl {(c==':')&&dig_lt_Base&&(longitud < Length-1)};
3610                                                 const bool tf_dig_B_cdl {(c=='#')&&dig_lt_Base&&(longitud == Length-1)};
3611                                                 if (dig_B_cdl) {
3612                                                         digito *= 10;
3613                                                         digito += (c-'0');
3614                                                         est_act = e2dig;
3615                                                 }
3616                                                 else if (tt_dig_B_cdl) {
3617                                                         est_act = e2dp;
3618                                                 }
3619                                                 else if (tf_dig_B_cdl) {
3620                                                         est_act = e2end;
3621                                                 }
3622                                                 else  {
3623                                                         est_act = e0ini;
3624                                                         digito = 0;
3625                                                         longitud = 0;
3626                                                         numero_base_recogido = 0;
3627                                                         numero_ret = nat_reg_digs_t::regd_0();
3628                                                 }
3629                                         }
3630                                         break;
3631                                 case e2dp :
3632                                         {
3633                                                 const bool dig_c {(c >= '0') && (c <= '9')};
3634                                                 const bool c_es_dig_B {(std::abs(c-'0')<Base) && (digito<Base)};
3635                                                 const bool dig_B_cdl {dig_c && c_es_dig_B && (longitud < Length-1)};
3636                                                 const bool rdig_B_cdl {dig_c && c_es_dig_B && dig_B_cdl};
3637                                                 if (rdig_B_cdl) {
3638                                                         est_act = e2dig;
3639                                                         numero_ret[Length-1-longitud] = dig_t(digito);
3640                                                         ++longitud;
3641                                                         digito = c-'0';
3642                                                 }
3643                                                 else  {
3644                                                         est_act = e0ini;
3645                                                         digito = 0;
3646                                                         longitud = 0;
3647                                                         numero_base_recogido = 0;
3648                                                         indice = 0;
3649                                                         numero_ret = nat_reg_digs_t::regd_0();
3650                                                 }
3651                                         }
3652                                         break;
3653                                 case e2end :
3654                                         {
3655                                                 const bool c_es_sepfin {c == 'B'};
3656                                                 const bool d_es_digB {digito < Base};
3657                                                 const bool l_coincide {longitud == Length-1};// llega al cero ?
3658                                                 const bool rdigB_cdl {c_es_sepfin && d_es_digB && l_coincide};
3659                                                 if (rdigB_cdl) {
3660                                                         est_act = e2B;
3661                                                         numero_ret[Length-1-longitud] = dig_t(digito);
3662                                                         digito = 0;
3663                                                         longitud = 0;
3664                                                 }
3665                                                 else  {
3666                                                         est_act = e0ini;
3667                                                         indice = 0;
3668                                                         digito = 0;
3669                                                         longitud = 0;
3670                                                         numero_ret = nat_reg_digs_t::regd_0();
3671                                                 }
3672                                         }
3673                                         break;
3674                                 case e2B :
3675                                         {
3676                                                 if ((c >= '0')&&(c <= '9')) {
3677                                                         est_act = e3dig;
3678                                                         numero_base_recogido = c-'0';
3679                                                         digito = 0;
3680                                                 }
3681                                                 else  {
3682                                                         est_act = e0ini;
3683                                                         digito = 0;
3684                                                         longitud = 0;
3685                                                         numero_base_recogido = 0;
3686                                                         numero_ret = nat_reg_digs_t::regd_0();
3687                                                 }
3688                                         }
3689                                         break;
3690                                 case e3dig :
3691                                         {
3692                                                 const bool espacio_c {c < 16};
3693                                                 const bool digito_c {(c>='0') && (c<='9')};
3694                                                 const bool num_base_lt_Base {numero_base_recogido < Base};
3695                                                 const bool num_base_eq_Base {numero_base_recogido == Base};
3696                                                 if (digito_c && num_base_lt_Base) {
3697                                                         est_act = e3dig;
3698                                                         numero_base_recogido *= 10;
3699                                                         numero_base_recogido += (c-'0');
3700                                                 }
3701                                                 else if (espacio_c && num_base_eq_Base) {
3702                                                         numero_base_recogido *= 10;
3703                                                         numero_base_recogido += (c-'0');
3704                                                                 est_act = e0fin;
3705                                                                 numero_base_recogido = 0;
3706                                                 }
3707                                                 else  {
3708                                                         est_act = e0ini;
3709                                                         numero_base_recogido = 0;
3710                                                 }
3711                                         }
3712                                         break;
3713                                 case e0fin :
3714                                         {
3715                                                 est_act = e0fin;
3716                                         }
3717                         }
3718                         ++indice;
3719                 } while (est_act!=e0fin);
3720 
3721                 return (is);
3722         }
.fi
.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator>>= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBdig_t\fP & operator[] (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::operator| (const \fBnat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr const \fBnat_reg_digs_t\fP & operator::operator|= (const \fBnat_reg_digs_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP operator::put (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr \fBnat_reg_digs_t\fP operator::rem_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SS "constexpr void operator::set_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. 
.PP
.nf
3216         {
.fi
.PP
Referenciado por \fBNumRepr::reg_digs_t< UINT_T, B, L >::operator=()\fP\&.
.SS "constexpr void operator::set_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. 
.PP
.nf
3216         {
3217                 nat_reg_digs_t cpthis{*this};
3218                 nat_reg_digs_t& cthis{0};
.fi
.SS "constexpr void operator::set_dig (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. 
.PP
.nf
3230         {
.fi
.SS "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void operator::set_interval_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
3255                 {
.fi
.SS "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void operator::set_interval_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
3255                 {
.fi
.SS "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void operator::set_interval_dig (\fBdig_t\fP dig)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
3255                 {
.fi
.SS "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > operator::subrepr () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
