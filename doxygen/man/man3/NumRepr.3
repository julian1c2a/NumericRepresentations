.TH "NumRepr" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBauxiliary_functions\fP"
.br
.ti -1c
.RI "namespace \fBauxiliary_types\fP"
.br
.ti -1c
.RI "namespace \fBdetail\fP"
.br
.ti -1c
.RI "namespace \fBlex\fP"
.br
.ti -1c
.RI "namespace \fBtype_traits\fP"
.br
.in -1c
.SS "Clases"

.in +1c
.ti -1c
.RI "struct \fBbase_num_t\fP"
.br
.ti -1c
.RI "struct \fBdig_t\fP"
.br
.ti -1c
.RI "struct \fBnat_rat_fixed_reg_t\fP"
.br
.ti -1c
.RI "struct \fBnat_reg_digs_t\fP"
.br
.ti -1c
.RI "struct \fBreg_digs_t\fP"
.br
.RI "DEFINCION DE template<uint128_t Radix> register_of_digits_t{};\&. "
.in -1c
.SS "typedefs"

.in +1c
.ti -1c
.RI "using \fBchint_t\fP = char"
.br
.RI "NUEVOS NOMBRES PARA LOS ENTEROS O PARECIDOS\&. "
.ti -1c
.RI "using \fBschint_t\fP = signed char"
.br
.ti -1c
.RI "using \fBssint_t\fP = signed short int"
.br
.ti -1c
.RI "using \fBsint_t\fP = signed int"
.br
.ti -1c
.RI "using \fBslint_t\fP = signed long int"
.br
.ti -1c
.RI "using \fBsllint_t\fP = signed long long int"
.br
.ti -1c
.RI "using \fBuchint_t\fP = unsigned char"
.br
.ti -1c
.RI "using \fBusint_t\fP = unsigned short int"
.br
.ti -1c
.RI "using \fBuint_t\fP = unsigned int"
.br
.ti -1c
.RI "using \fBulint_t\fP = unsigned long int"
.br
.ti -1c
.RI "using \fBullint_t\fP = unsigned long long int"
.br
.ti -1c
.RI "using \fBuint128_t\fP = __uint128_t"
.br
.ti -1c
.RI "using \fBsint128_t\fP = __int128_t"
.br
.ti -1c
.RI "using \fBsize_t\fP = std::size_t"
.br
.ti -1c
.RI "using \fBsint8_t\fP = std::int8_t"
.br
.ti -1c
.RI "using \fBsint16_t\fP = std::int16_t"
.br
.ti -1c
.RI "using \fBsint32_t\fP = std::int32_t"
.br
.ti -1c
.RI "using \fBsint64_t\fP = std::int64_t"
.br
.ti -1c
.RI "using \fBint8_t\fP = std::int8_t"
.br
.ti -1c
.RI "using \fBint16_t\fP = std::int16_t"
.br
.ti -1c
.RI "using \fBint32_t\fP = std::int32_t"
.br
.ti -1c
.RI "using \fBint64_t\fP = std::int64_t"
.br
.ti -1c
.RI "using \fBfast8_t\fP = std::int_fast8_t"
.br
.ti -1c
.RI "using \fBfast16_t\fP = std::int_fast16_t"
.br
.ti -1c
.RI "using \fBfast32_t\fP = std::int_fast32_t"
.br
.ti -1c
.RI "using \fBfast64_t\fP = std::int_fast64_t"
.br
.ti -1c
.RI "using \fBleast8_t\fP = std::int_least8_t"
.br
.ti -1c
.RI "using \fBleast16_t\fP = std::int_least16_t"
.br
.ti -1c
.RI "using \fBleast32_t\fP = std::int_least32_t"
.br
.ti -1c
.RI "using \fBleast64_t\fP = std::int_least64_t"
.br
.ti -1c
.RI "using \fBuint8_t\fP = std::uint8_t"
.br
.ti -1c
.RI "using \fBuint16_t\fP = std::uint16_t"
.br
.ti -1c
.RI "using \fBuint32_t\fP = std::uint32_t"
.br
.ti -1c
.RI "using \fBuint64_t\fP = std::uint64_t"
.br
.ti -1c
.RI "using \fBufast8_t\fP = std::uint_fast8_t"
.br
.ti -1c
.RI "using \fBufast16_t\fP = std::uint_fast16_t"
.br
.ti -1c
.RI "using \fBufast32_t\fP = std::uint_fast32_t"
.br
.ti -1c
.RI "using \fBufast64_t\fP = std::uint_fast64_t"
.br
.ti -1c
.RI "using \fBuleast8_t\fP = std::uint_least8_t"
.br
.ti -1c
.RI "using \fBuleast16_t\fP = std::uint_least16_t"
.br
.ti -1c
.RI "using \fBuleast32_t\fP = std::uint_least32_t"
.br
.ti -1c
.RI "using \fBuleast64_t\fP = std::uint_least64_t"
.br
.ti -1c
.RI "using \fBintmax_t\fP = std::intmax_t"
.br
.ti -1c
.RI "using \fBuintmax_t\fP = std::uintmax_t"
.br
.ti -1c
.RI "template<\fBuint128_t\fP B> using \fBdigit_t\fP = \fBdig_t\fP< \fBtype_traits::TypeFromIntNumber_t\fP< static_cast< \fBuint128_t\fP >(B)>, static_cast< \fBtype_traits::TypeFromIntNumber_t\fP< static_cast< \fBuint128_t\fP >(B)> >(static_cast< \fBuint128_t\fP >(B)) >"
.br
.RI "SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o \&.\&.\&. "
.ti -1c
.RI "template<\fBuint128_t\fP B, \fBsize_t\fP L> using \fBregister_of_digits_t\fP = \fBreg_digs_t\fP< \fBtype_traits::TypeFromIntNumber_t\fP< B >, static_cast< \fBtype_traits::TypeFromIntNumber_t\fP< B > >(B), L >"
.br
.ti -1c
.RI "template<\fBuint128_t\fP B, \fBsize_t\fP L> using \fBregister_digs_t\fP = \fBreg_digs_t\fP< \fBTypeFromIntNumber_t\fP< static_cast< \fBuint128_t\fP >(B)>, static_cast< \fBTypeFromIntNumber_t\fP< static_cast< \fBuint128_t\fP >(B)> >(static_cast< \fBuint128_t\fP >(B)), L >"
.br
.in -1c
.SS "Enumeraciones"

.in +1c
.ti -1c
.RI "enum class \fBsign_e\fP : bool { \fBvminus\fP = true, \fBvplus\fP = false }"
.br
.ti -1c
.RI "enum class \fBsign_funct_e\fP : char { \fBvzero\fP = 0, \fBvminus\fP = -1, \fBvplus\fP = +1 }"
.br
.RI "INTRODUCIDO\&. "
.ti -1c
.RI "enum class \fBdig_format_e\fP : unsigned char { \fBBINnat\fP =0, \fBBCDnat\fP =1, \fBBCDexc3\fP =2, \fBBCDaitk\fP =3, \fBjohnson_n\fP =4, \fBbiquinario\fP =5 }"
.br
.ti -1c
.RI "enum class \fBnum_type_e\fP : unsigned char { \fBnatural\fP =0, \fBentero\fP =1, \fBracional\fP =2, \fBreal\fP =3 }"
.br
.RI "A INTRODUCIR\&. "
.ti -1c
.RI "enum class \fBnat_num_format_e\fP : bool { \fBnatural\fP =false, \fBexc_n\fP =true }"
.br
.RI "YA INTRODUCIDO, PERO NO EXPLICITAMENTE NI COMPLETAMENTE\&. "
.ti -1c
.RI "enum class \fBint_num_format_e\fP : unsigned char { \fBint_CB\fP =0, \fBint_CBm1\fP =1, \fBint_MS\fP =2, \fBint_EXC_n\fP =3 }"
.br
.RI "SOLO NATURAL\&. "
.ti -1c
.RI "enum class \fBrat_num_format_e\fP : unsigned char { \fBpair_num_den\fP =0, \fBfxd_pt\fP =1, \fBflt_pt\fP =2 }"
.br
.RI "EN C_B YA QUEDA EN MS\&. "
.ti -1c
.RI "enum class \fBbinop_e\fP { \fBadd\fP, \fBsub\fP, \fBmult\fP, \fBdiv\fP, \fBrem\fP, \fBfediv\fP, \fBother\fP }"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "constexpr \fBsign_e\fP \fBChar2Sign\fP (char ch) noexcept"
.br
.ti -1c
.RI "template<type_traits::arith_integral_c IntT> constexpr \fBsign_e\fP \fBInt2Sign\fP (IntT nu) noexcept"
.br
.ti -1c
.RI "template<type_traits::arith_integral_c IntT> constexpr \fBsign_funct_e\fP \fBInt2SignFunct\fP (IntT nu) noexcept"
.br
.ti -1c
.RI "template<type_traits::arith_natural_c NatIntT> constexpr \fBsign_funct_e\fP \fBNat2SignFunct\fP (NatIntT nu) noexcept"
.br
.ti -1c
.RI "template<typename Int_T , usint B> constexpr ullint \fBpot_max_base_B_en_Int_T\fP () noexcept"
.br
.ti -1c
.RI "template<typename Int_T , ullint B> constexpr ullint \fBnum_digs_max_base_B_en_Int_T\fP () noexcept"
.br
.ti -1c
.RI "template<typename Int_T , ullint B> constexpr ullint \fBmax_base_B_en_Int_T\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T, B>())consteval UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T, B>())consteval \fBdig_t\fP< UINT_T, B > \fBdig_max\fP () noexcept"
.br
.RI "DEFINCION DE template<uint128_t Radix> digito_t{};\&. "
.ti -1c
.RI "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,Base>())std::istream & \fBoperator>>\fP (std::istream &is, \fBdig_t\fP< UINT_T, Base > &arg)"
.br
.ti -1c
.RI "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,Base>())std::ostream & \fBoperator<<\fP (std::ostream &os, \fBdig_t\fP< UINT_T, Base > arg)"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Length> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>()&&(Length > 0))std::istream & \fBoperator>>\fP (std::istream &is, pfx_rat_reg_digs_t< Int_Type, Base, Length > &arg)"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Long> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>())std::ostream & \fBoperator<<\fP (std::ostream &os, const pfx_rat_reg_digs_t< Int_Type, Base, Long > &arg)"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP LE> bool \fBis_nat_reg_digs_type_id\fP (std::string in)"
.br
.RI "ESPECIALIZACIONES PARA NAT_REG_DIGS\&. "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP LE> std::string \fBto_nat_reg_digs_type_string\fP ()"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP LE> \fBsize_t\fP \fBsize_of_nat_reg_digs_type_string_idT\fP ()"
.br
.ti -1c
.RI "template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, \fBsize_t\fP Length> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>()&&(Length > 0))std::istream & \fBoperator>>\fP (std::istream &is, \fBnat_reg_digs_t\fP< Int_Type, Base, Length > &arg)"
.br
.ti -1c
.RI "template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, \fBsize_t\fP Long> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>())std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBnat_reg_digs_t\fP< Int_Type, Base, Long > &arg)"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBreg_digs_t\fP< UInt_t, B, N > \fBconcat\fP (const \fBreg_digs_t\fP< UInt_t, B, N > &larg) noexcept"
.br
.RI "STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))constexpr \fBreg_digs_t\fP< UInt_t, B, N+M > \fBconcat\fP (const \fBreg_digs_t\fP< UInt_t, B, N > &larg, const \fBreg_digs_t\fP< UInt_t, B, M > &rarg) noexcept"
.br
.RI "STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP N> 
.br
requires (N > 0)constexpr \fBreg_digs_t\fP< UInt_t, B, N+1 > \fBconcat\fP (const \fBreg_digs_t\fP< UInt_t, B, N > &larg, \fBdig_t\fP< UInt_t, B > rarg) noexcept"
.br
.RI "STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP M> 
.br
requires (M > 0)constexpr \fBreg_digs_t\fP< UInt_t, B, 1+M > \fBconcat\fP (\fBdig_t\fP< UInt_t, B > larg, const \fBreg_digs_t\fP< UInt_t, B, M > &rarg) noexcept"
.br
.RI "STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B> constexpr \fBreg_digs_t\fP< UInt_t, B, 1 > \fBconcat\fP (\fBdig_t\fP< UInt_t, B > larg) noexcept"
.br
.RI "STATIC BASE_N_T<1> CONCAT(DIG_T) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B> constexpr \fBreg_digs_t\fP< UInt_t, B, 2 > \fBconcat\fP (\fBdig_t\fP< UInt_t, B > larg, \fBdig_t\fP< UInt_t, B > rarg) noexcept"
.br
.RI "STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, typename T0 , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP<UInt_t,B>>)&&\&.\&.\&.) && (std::is_same_v<T0,\fBdig_t\fP<UInt_t,B>>) )constexpr \fBreg_digs_t\fP< UInt_t, B, 1+(sizeof \&.\&.\&.(Ts))> \fBconcat\fP (T0 dig0, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP N, typename T , typename \&.\&.\&. Ts> 
.br
requires (((std::is_same_v<Ts,\fBdig_t\fP<UInt_t,B>>)&&\&.\&.\&.)&&(std::is_same_v<T,\fBdig_t\fP<UInt_t,B>>)&&(N>0))constexpr \fBreg_digs_t\fP< UInt_t, B, N+1+(sizeof \&.\&.\&.(Ts))> \fBconcat\fP (\fBreg_digs_t\fP< UInt_t, B, N > larg, T dig, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP M, typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP<UInt_t,B>>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP<UInt_t,B>>) && (M>0) )constexpr \fBreg_digs_t\fP< UInt_t, B, M+1+(sizeof \&.\&.\&.(Ts))> \fBconcat\fP (T dig, Ts \&.\&.\&. dig_pack, \fBreg_digs_t\fP< UInt_t, B, M > rarg) noexcept"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, \fBsize_t\fP N, \fBsize_t\fP \&.\&.\&. N_pack> 
.br
requires ((N>0)&&((N_pack>0)&&\&.\&.\&.))constexpr \fBreg_digs_t\fP< UInt_t, B, N+(\&.\&.\&.+(N_pack))> \fBconcat\fP (\fBreg_digs_t\fP< UInt_t, B, N > larg, \fBreg_digs_t\fP< UInt_t, B, N_pack > \&.\&.\&. rarg_pack) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBoperator<<\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & \fBoperator<<=\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & \fBoperator>>=\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBoperator>>\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBrem_B\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & \fBm_rem_B\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBmer_B\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & \fBm_mer_B\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & \fBoperator|=\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, const \fBreg_digs_t\fP< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBoperator|\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &larg, const \fBreg_digs_t\fP< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & \fBoperator&=\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, const \fBreg_digs_t\fP< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBoperator&\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, const \fBreg_digs_t\fP< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBm_incr\fP (\fBreg_digs_t\fP< UINT_T, B, N > &rarg) noexcept"
.br
.RI "TODO 31/12/2022\&. "
.ti -1c
.RI "template<typename UINT_T , UINT_T B> constexpr \fBdig_t\fP< UINT_T, B > \fBm_sum_digs_carryin1\fP (\fBdig_t\fP< UINT_T, B > &left, \fBdig_t\fP< UINT_T, B > right) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B> constexpr \fBdig_t\fP< UINT_T, B > \fBm_sum_digs_carryin0\fP (\fBdig_t\fP< UINT_T, B > &left, \fBdig_t\fP< UINT_T, B > right) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> constexpr \fBdig_t\fP< UINT_T, B > \fBm_sum\fP (\fBreg_digs_t\fP< UINT_T, B, N > &larg, const \fBreg_digs_t\fP< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> 
.br
requires (N>1)constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBaprox_units_divB\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &arg) noexcept"
.br
.RI "< PRECONDITIONS : ARG != 0 AND ARG != 1 > "
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n > 0) && (n < N) && (N > 1))constexpr \fBreg_digs_t\fP< UINT_T, B, N > \fBaprox_units_divB_n\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &arg) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> 
.br
requires (N > 0)constexpr std::array< \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >, 2 > \fBaprox_coc_rem\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &\fBrem\fP, const \fBreg_digs_t\fP< UINT_T, B, N > &dsor) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> 
.br
requires (N > 0)constexpr std::array< \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >, 2 > \fBaprox_coc_rem\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &\fBrem\fP, const \fBreg_digs_t\fP< UINT_T, B, N > &dsor, \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T > coc_calculado, \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T > rem_calculado) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, \fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires (N > 0)&&(M > 0)constexpr std::array< \fBreg_digs_t\fP< UINT_T, B, std::max(N, M)>, 2 > \fBfediv\fP (const \fBreg_digs_t\fP< UINT_T, B, N > &larg, const \fBreg_digs_t\fP< UINT_T, B, M > &rarg) noexcept"
.br
.RI "END\&. "
.ti -1c
.RI "template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool \fBget_digit_token\fP (std::istream &is, \fBdig_t\fP< UINT_T, B > &dig_value)"
.br
.RI "FUNCION QUE CONSIGUE EL TOKEN DIGITO\&. "
.ti -1c
.RI "template<type_traits::unsigned_integral_c T, T B> bool \fBget_radix_token\fP (std::istream &is)"
.br
.RI "FUNCION QUE CONSIGUE EL TOKEN BASE\&. "
.ti -1c
.RI "template<type_traits::unsigned_integral_c T, T B, \fBsize_t\fP L> bool \fBget_digit_loop_token\fP (std::istream &is, \fBreg_digs_t\fP< T, B, L > &value) noexcept"
.br
.ti -1c
.RI "template<type_traits::unsigned_integral_c T, T B, \fBsize_t\fP L> bool \fBread\fP (std::istream &is, \fBreg_digs_t\fP< T, B, L > &value) noexcept"
.br
.RI "DEFINCION DE template<uint128_t Radix> digito_t{};\&. "
.ti -1c
.RI "template<typename Int_Type , Int_Type Base, \fBsize_t\fP Length> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>()&&(Length > 0))std::istream & \fBoperator>>\fP (std::istream &is, \fBreg_digs_t\fP< Int_Type, Base, Length > &arg)"
.br
.RI "SOBRECARGA DE ISTREAM Y OSTREAM CON LOS OPERADORES DE DESPLAZAMEINTO\&. "
.ti -1c
.RI "template<typename Int_Type , Int_Type Base, \fBsize_t\fP Long> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>())std::ostream & \fBoperator<<\fP (std::ostream &os, const \fBreg_digs_t\fP< Int_Type, Base, Long > &arg)"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_constr_UINT_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_constr_SINT_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_constr_defecto_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_constr_copia_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_constr_movimiento_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_assign_UINT_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_assign_SINT_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_assign_copia_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_assign_movimiento_dig_t\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_preincrement\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_postincrement\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_predecrement\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_postdecrement\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_add_assign\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_add_assign_uint\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_substract_assign\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_substract_assign_uint\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_mult_assign\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_mult_assign_uint\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_ediv_assign\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_ediv_assign_uint\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_erem_assign\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_erem_assign_uint\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_add\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_add_int\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_substract\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_substract_int\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_multiply\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_multiply_int\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_edivision\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_edivision_int\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_C_B\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_operator_C_Bm1\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_prop_C_B_eq_inv_C_B\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_prop_C_Bm1_eq_inv_C_Bm1\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_prop_C_B_minus_1_eq_C_Bm1\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_unary_operator_minus\fP ()"
.br
.ti -1c
.RI "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void \fBdisplay_unary_operator_neg\fP ()"
.br
.in -1c
.SH "Documentación de los 'typedefs'"
.PP 
.SS "using \fBNumRepr::chint_t\fP = typedef char"

.PP
NUEVOS NOMBRES PARA LOS ENTEROS O PARECIDOS\&. 
.PP
Definición en la línea \fB58\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<\fBuint128_t\fP B> using \fBNumRepr::digit_t\fP = typedef \fBdig_t\fP< \fBTypeFromIntNumber_t\fP<static_cast<\fBuint128_t\fP>(B)>, static_cast<\fBTypeFromIntNumber_t\fP<static_cast<\fBuint128_t\fP>(B)> >(static_cast<\fBuint128_t\fP>(B)) >"

.PP
SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o \&.\&.\&. 
.PP
Definición en la línea \fB1494\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "using \fBNumRepr::fast16_t\fP = typedef std::int_fast16_t"

.PP
Definición en la línea \fB81\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::fast32_t\fP = typedef std::int_fast32_t"

.PP
Definición en la línea \fB82\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::fast64_t\fP = typedef std::int_fast64_t"

.PP
Definición en la línea \fB83\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::fast8_t\fP = typedef std::int_fast8_t"

.PP
Definición en la línea \fB80\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::int16_t\fP = typedef std::int16_t"

.PP
Definición en la línea \fB77\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::int32_t\fP = typedef std::int32_t"

.PP
Definición en la línea \fB78\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::int64_t\fP = typedef std::int64_t"

.PP
Definición en la línea \fB79\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::int8_t\fP = typedef std::int8_t"

.PP
Definición en la línea \fB76\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::intmax_t\fP = typedef std::intmax_t"

.PP
Definición en la línea \fB104\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::least16_t\fP = typedef std::int_least16_t"

.PP
Definición en la línea \fB85\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::least32_t\fP = typedef std::int_least32_t"

.PP
Definición en la línea \fB86\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::least64_t\fP = typedef std::int_least64_t"

.PP
Definición en la línea \fB87\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::least8_t\fP = typedef std::int_least8_t"

.PP
Definición en la línea \fB84\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<\fBuint128_t\fP B, \fBsize_t\fP L> using \fBNumRepr::register_digs_t\fP = typedef \fBreg_digs_t\fP< \fBTypeFromIntNumber_t\fP<static_cast<\fBuint128_t\fP>(B)>, static_cast<\fBTypeFromIntNumber_t\fP<static_cast<\fBuint128_t\fP>(B)> >(static_cast<\fBuint128_t\fP>(B)), L >"

.PP
Definición en la línea \fB2434\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<\fBuint128_t\fP B, \fBsize_t\fP L> using \fBNumRepr::register_of_digits_t\fP = typedef \fBreg_digs_t\fP< \fBtype_traits::TypeFromIntNumber_t\fP<B>, static_cast<\fBtype_traits::TypeFromIntNumber_t\fP<B> >(B), L >"

.PP
Definición en la línea \fB1576\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "using \fBNumRepr::schint_t\fP = typedef signed char"

.PP
Definición en la línea \fB59\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sint128_t\fP = typedef __int128_t"

.PP
Definición en la línea \fB70\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sint16_t\fP = typedef std::int16_t"

.PP
Definición en la línea \fB73\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sint32_t\fP = typedef std::int32_t"

.PP
Definición en la línea \fB74\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sint64_t\fP = typedef std::int64_t"

.PP
Definición en la línea \fB75\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sint8_t\fP = typedef std::int8_t"

.PP
Definición en la línea \fB72\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sint_t\fP = typedef signed int"

.PP
Definición en la línea \fB61\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::size_t\fP = typedef std::size_t"

.PP
Definición en la línea \fB71\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::slint_t\fP = typedef signed long int"

.PP
Definición en la línea \fB62\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::sllint_t\fP = typedef signed long long int"

.PP
Definición en la línea \fB63\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ssint_t\fP = typedef signed short int"

.PP
Definición en la línea \fB60\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uchint_t\fP = typedef unsigned char"

.PP
Definición en la línea \fB64\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ufast16_t\fP = typedef std::uint_fast16_t"

.PP
Definición en la línea \fB94\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ufast32_t\fP = typedef std::uint_fast32_t"

.PP
Definición en la línea \fB95\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ufast64_t\fP = typedef std::uint_fast64_t"

.PP
Definición en la línea \fB96\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ufast8_t\fP = typedef std::uint_fast8_t"

.PP
Definición en la línea \fB93\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uint128_t\fP = typedef __uint128_t"

.PP
Definición en la línea \fB69\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uint16_t\fP = typedef std::uint16_t"

.PP
Definición en la línea \fB90\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uint32_t\fP = typedef std::uint32_t"

.PP
Definición en la línea \fB91\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uint64_t\fP = typedef std::uint64_t"

.PP
Definición en la línea \fB92\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uint8_t\fP = typedef std::uint8_t"

.PP
Definición en la línea \fB89\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uint_t\fP = typedef unsigned int"

.PP
Definición en la línea \fB66\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uintmax_t\fP = typedef std::uintmax_t"

.PP
Definición en la línea \fB105\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uleast16_t\fP = typedef std::uint_least16_t"

.PP
Definición en la línea \fB98\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uleast32_t\fP = typedef std::uint_least32_t"

.PP
Definición en la línea \fB99\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uleast64_t\fP = typedef std::uint_least64_t"

.PP
Definición en la línea \fB100\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::uleast8_t\fP = typedef std::uint_least8_t"

.PP
Definición en la línea \fB97\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ulint_t\fP = typedef unsigned long int"

.PP
Definición en la línea \fB67\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::ullint_t\fP = typedef unsigned long long int"

.PP
Definición en la línea \fB68\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "using \fBNumRepr::usint_t\fP = typedef unsigned short int"

.PP
Definición en la línea \fB65\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SH "Documentación de las enumeraciones"
.PP 
.SS "enum class \fBNumRepr::binop_e\fP\fC [strong]\fP"

.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIadd \fP\fP
.TP
\fB\fIsub \fP\fP
.TP
\fB\fImult \fP\fP
.TP
\fB\fIdiv \fP\fP
.TP
\fB\fIrem \fP\fP
.TP
\fB\fIfediv \fP\fP
.TP
\fB\fIother \fP\fP
.PP
Definición en la línea \fB32\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::dig_format_e\fP : unsigned char\fC [strong]\fP"

.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIBINnat \fP\fP
.TP
\fB\fIBCDnat \fP\fP
.TP
\fB\fIBCDexc3 \fP\fP
.TP
\fB\fIBCDaitk \fP\fP
.TP
\fB\fIjohnson_n \fP\fP
.TP
\fB\fIbiquinario \fP\fP
.PP
Definición en la línea \fB17\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::int_num_format_e\fP : unsigned char\fC [strong]\fP"

.PP
SOLO NATURAL\&. 
.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIint_CB \fP\fP
.TP
\fB\fIint_CBm1 \fP\fP
.TP
\fB\fIint_MS \fP\fP
.TP
\fB\fIint_EXC_n \fP\fP
.PP
Definición en la línea \fB25\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::nat_num_format_e\fP : bool\fC [strong]\fP"

.PP
YA INTRODUCIDO, PERO NO EXPLICITAMENTE NI COMPLETAMENTE\&. 
.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fInatural \fP\fP
.TP
\fB\fIexc_n \fP\fP
.PP
Definición en la línea \fB22\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::num_type_e\fP : unsigned char\fC [strong]\fP"

.PP
A INTRODUCIR\&. 
.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fInatural \fP\fP
.TP
\fB\fIentero \fP\fP
.TP
\fB\fIracional \fP\fP
.TP
\fB\fIreal \fP\fP
.PP
Definición en la línea \fB19\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::rat_num_format_e\fP : unsigned char\fC [strong]\fP"

.PP
EN C_B YA QUEDA EN MS\&. 
.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIpair_num_den \fP\fP
.TP
\fB\fIfxd_pt \fP\fP
.TP
\fB\fIflt_pt \fP\fP
.PP
Definición en la línea \fB28\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::sign_e\fP : bool\fC [strong]\fP"

.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIvminus \fP\fP
.TP
\fB\fIvplus \fP\fP
.PP
Definición en la línea \fB15\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SS "enum class \fBNumRepr::sign_funct_e\fP : char\fC [strong]\fP"

.PP
INTRODUCIDO\&. 
.PP
\fBValores de enumeraciones\fP
.in +1c
.TP
\fB\fIvzero \fP\fP
.TP
\fB\fIvminus \fP\fP
.TP
\fB\fIvplus \fP\fP
.PP
Definición en la línea \fB16\fP del archivo \fBauxiliary_types\&.hpp\fP\&.
.SH "Documentación de las funciones"
.PP 
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> 
.br
requires (N > 0)constexpr std::array< \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >, 2 > NumRepr::aprox_coc_rem (const \fBreg_digs_t\fP< UINT_T, B, N > & rem, const \fBreg_digs_t\fP< UINT_T, B, N > & dsor)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
std::array<SIG_UINT_T,2>{}[0] == COC std::array<SIG_UINT_T,2>{}[1] == REM PRECONDICION DSOR != 0 Y DSOR != 1 FUNCION DE RECURSION PARA LA DIVISION SOBRECARGA DE LA ANTERIOR PARA LA RECURSION QUE NO SEA EL PRIMER CASO CASO EXACTO
.PP
SIZE(DIVISOR) == 1 DIGITO !=0 !=1
.PP
SIZE(DIVISOR) >= 2 2545/278 o mayores
.PP
CORRECTO EN COC
.PP
NOS HEMOS PASADO EN EL COC
.PP
NOS HEMOS QUEDADO CORTOS EN EL COC rem_aprox + dsor_uint <= rem
.PP
Definición en la línea \fB2044\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> 
.br
requires (N > 0)constexpr std::array< \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >, 2 > NumRepr::aprox_coc_rem (const \fBreg_digs_t\fP< UINT_T, B, N > & rem, const \fBreg_digs_t\fP< UINT_T, B, N > & dsor, \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T > coc_calculado, \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T > rem_calculado)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
std::array<SIG_UINT_T,2>{}[0] == COC std::array<SIG_UINT_T,2>{}[1] == REM PRECONDICION DSOR != 0 Y DSOR != 1 SUPONEMOS QUE REM TIENE TAMANO 1 o 2
.PP
DSOR YA REDUCIDO TIENE TAMANO 1
.PP
SIZE(DIVISOR) == 1 DIGITO !=0 !=1
.PP
CORRECTO EN COC
.PP
NOS HEMOS PASADO EN EL COC
.PP
NOS HEMOS QUEDADO CORTOS EN EL COC rem_aprox + dsor_uint <= rem
.PP
24/7
.PP
SIZE(DIVISOR) >= 2 2545/278 o mayores
.PP
CORRECTO EN COC
.PP
NOS HEMOS PASADO EN EL COC
.PP
NOS HEMOS QUEDADO CORTOS EN EL COC rem_aprox + dsor_uint <= rem
.PP
Definición en la línea \fB2123\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> 
.br
requires (N>1)constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::aprox_units_divB (const \fBreg_digs_t\fP< UINT_T, B, N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
< PRECONDITIONS : ARG != 0 AND ARG != 1 > FUNCIONES DE IMPLEMENTACION DE LA DIVISION ENTRE DOS REGISTROS DE DIGITOS BEGIN POSTCONDICION RET[N-1] == (DIG_1() | DIG_0()) POSTCONDICION RET[N-1] == DIG_1() => RET[N-2,0] == REGD_N_0() HAY QUE VER SI ES POTENCIA DE B : is_any_B_pow CASO EN QUE LA LONGITUD PERMANECE 999 ; 998 ; 997 ; 996 099,9 ; 099,8 ; 099,7 ; 099,6 100 ; 100 ; 100 ; 100
.PP
CPARG == Bm1 Bm1 Bm1 \&.\&.\&. Bm1 Bm1 Bm1 d0<B/2
.PP
CPARG == Bm1 dnm2 dnm3 \&.\&.\&. d3 d2 d1 d0
.PP
Definición en la línea \fB1981\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n > 0) && (n < N) && (N > 1))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::aprox_units_divB_n (const \fBreg_digs_t\fP< UINT_T, B, N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
FUNCION DE RECURSION PARA LA DIVISION APROX_COC_REM APROXIMA REMAINDER A 2 DIGITOS Y DIVISOR A 1 DIGITO 
.PP
Definición en la línea \fB2021\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "constexpr \fBsign_e\fP NumRepr::Char2Sign (char ch)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB9\fP del archivo \fBauxiliary_functions\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBreg_digs_t\fP< UInt_t, B, N > NumRepr::concat (const \fBreg_digs_t\fP< UInt_t, B, N > & larg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) STATIC BASE_N_T<1> CONCAT(DIG_T) STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) STATIC BASE_N_T<SIZEOF\&.\&.\&.(DIG_PACK)> CONCAT(DIG_T\&.\&.\&.DIG_PACK) VARIADIC PACK 
.PP
Definición en la línea \fB1595\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))constexpr \fBreg_digs_t\fP< UInt_t, B, N+M > NumRepr::concat (const \fBreg_digs_t\fP< UInt_t, B, N > & larg, const \fBreg_digs_t\fP< UInt_t, B, M > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) 
.PP
Definición en la línea \fB1604\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP N> 
.br
requires (N > 0)constexpr \fBreg_digs_t\fP< UInt_t, B, N+1 > NumRepr::concat (const \fBreg_digs_t\fP< UInt_t, B, N > & larg, \fBdig_t\fP< UInt_t, B > rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) 
.PP
Definición en la línea \fB1620\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B> constexpr \fBreg_digs_t\fP< UInt_t, B, 1 > NumRepr::concat (\fBdig_t\fP< UInt_t, B > larg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC BASE_N_T<1> CONCAT(DIG_T) 
.PP
Definición en la línea \fB1649\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP M> 
.br
requires (M > 0)constexpr \fBreg_digs_t\fP< UInt_t, B, 1+M > NumRepr::concat (\fBdig_t\fP< UInt_t, B > larg, const \fBreg_digs_t\fP< UInt_t, B, M > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) 
.PP
Definición en la línea \fB1635\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B> constexpr \fBreg_digs_t\fP< UInt_t, B, 2 > NumRepr::concat (\fBdig_t\fP< UInt_t, B > larg, \fBdig_t\fP< UInt_t, B > rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) 
.PP
Definición en la línea \fB1655\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP N, \fBsize_t\fP \&.\&.\&. N_pack> 
.br
requires ((N>0)&&((N_pack>0)&&\&.\&.\&.))constexpr \fBreg_digs_t\fP< UInt_t, B, N+(\&.\&.\&.+(N_pack))> NumRepr::concat (\fBreg_digs_t\fP< UInt_t, B, N > larg, \fBreg_digs_t\fP< UInt_t, B, N_pack > \&.\&.\&. rarg_pack)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC BASE_N_T<SIZE_T N,SIZE_T \&.\&.\&. N_PACK> CONCAT(BASE_N_T<N> LARG,BASE_N_T<N_PACK> \&.\&.\&. RARG_PACK) VARIADIC 
.PP
Definición en la línea \fB1713\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP N, typename T , typename \&.\&.\&. Ts> 
.br
requires (((std::is_same_v<Ts,\fBdig_t\fP<UInt_t,B>>)&&\&.\&.\&.)&&(std::is_same_v<T,\fBdig_t\fP<UInt_t,B>>)&&(N>0))constexpr \fBreg_digs_t\fP< UInt_t, B, N+1+(sizeof \&.\&.\&.(Ts))> NumRepr::concat (\fBreg_digs_t\fP< UInt_t, B, N > larg, T dig, Ts \&.\&.\&. dig_pack)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC BASE_N_T<N+1+(SIZEOF\&.\&.\&.(DIG_PACK))> CONCAT(BASE_N_T<N>,DIG_T,DIG_T \&.\&.\&. DIG_PACK) VARIADIC 
.PP
Definición en la línea \fB1682\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP M, typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP<UInt_t,B>>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP<UInt_t,B>>) && (M>0) )constexpr \fBreg_digs_t\fP< UInt_t, B, M+1+(sizeof \&.\&.\&.(Ts))> NumRepr::concat (T dig, Ts \&.\&.\&. dig_pack, \fBreg_digs_t\fP< UInt_t, B, M > rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC BASE_N_T<M+1+(SIZEOF\&.\&.\&.(DIG_PACK))> CONCAT(DIG_T,DIG_T \&.\&.\&. DIG_PACK,BASE_N_T<M>) VARIADIC 
.PP
Definición en la línea \fB1699\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, typename T0 , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP<UInt_t,B>>)&&\&.\&.\&.) && (std::is_same_v<T0,\fBdig_t\fP<UInt_t,B>>) )constexpr \fBreg_digs_t\fP< UInt_t, B, 1+(sizeof \&.\&.\&.(Ts))> NumRepr::concat (T0 dig0, Ts \&.\&.\&. dig_pack)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC BASE_N_T<SIZEOF\&.\&.\&.(DIG_PACK)> CONCAT(DIG_T,DIG_T \&.\&.\&. DIG_PACK) VARIADIC 
.PP
Definición en la línea \fB1671\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T, B>())consteval \fBdig_t\fP< UINT_T, B > NumRepr::dig_max ()\fC [noexcept]\fP"

.PP
DEFINCION DE template<uint128_t Radix> digito_t{};\&. 
.PP
Definición en la línea \fB1488\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_constr_copia_dig_t ()"

.PP
Definición en la línea \fB66\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_constr_defecto_dig_t ()"

.PP
Definición en la línea \fB51\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_constr_movimiento_dig_t ()"

.PP
Definición en la línea \fB87\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_constr_SINT_dig_t ()"

.PP
Definición en la línea \fB28\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_constr_UINT_dig_t ()"

.PP
Definición en la línea \fB10\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_add ()"

.PP
Definición en la línea \fB770\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_add_assign ()"

.PP
Definición en la línea \fB309\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_add_assign_uint ()"

.PP
Definición en la línea \fB348\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_add_int ()"

.PP
Definición en la línea \fB812\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_assign_copia_dig_t ()"

.PP
Definición en la línea \fB151\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_assign_movimiento_dig_t ()"

.PP
Definición en la línea \fB174\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_assign_SINT_dig_t ()"

.PP
Definición en la línea \fB133\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_assign_UINT_dig_t ()"

.PP
Definición en la línea \fB113\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_C_B ()"

.PP
Definición en la línea \fB1133\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_C_Bm1 ()"

.PP
Definición en la línea \fB1178\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_ediv_assign ()"

.PP
Definición en la línea \fB552\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_ediv_assign_uint ()"

.PP
Definición en la línea \fB603\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_edivision ()"

.PP
Definición en la línea \fB1019\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_edivision_int ()"

.PP
Definición en la línea \fB1080\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_erem_assign ()"

.PP
Definición en la línea \fB661\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_erem_assign_uint ()"

.PP
Definición en la línea \fB713\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_mult_assign ()"

.PP
Definición en la línea \fB466\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_mult_assign_uint ()"

.PP
Definición en la línea \fB509\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_multiply ()"

.PP
Definición en la línea \fB936\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_multiply_int ()"

.PP
Definición en la línea \fB978\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_postdecrement ()"

.PP
Definición en la línea \fB281\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_postincrement ()"

.PP
Definición en la línea \fB225\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_predecrement ()"

.PP
Definición en la línea \fB253\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_preincrement ()"

.PP
Definición en la línea \fB197\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_substract ()"

.PP
Definición en la línea \fB853\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_substract_assign ()"

.PP
Definición en la línea \fB380\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_substract_assign_uint ()"

.PP
Definición en la línea \fB423\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_operator_substract_int ()"

.PP
Definición en la línea \fB895\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_prop_C_B_eq_inv_C_B ()"

.PP
Definición en la línea \fB1223\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_prop_C_B_minus_1_eq_C_Bm1 ()"

.PP
Definición en la línea \fB1291\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_prop_C_Bm1_eq_inv_C_Bm1 ()"

.PP
Definición en la línea \fB1257\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_unary_operator_minus ()"

.PP
Definición en la línea \fB1327\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,B>())void NumRepr::display_unary_operator_neg ()"

.PP
Definición en la línea \fB1372\fP del archivo \fBtest_dig_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires (N > 0)&&(M > 0)constexpr std::array< \fBreg_digs_t\fP< UINT_T, B, std::max(N, M)>, 2 > NumRepr::fediv (const \fBreg_digs_t\fP< UINT_T, B, N > & larg, const \fBreg_digs_t\fP< UINT_T, B, M > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END\&. FUNCIONES DE IMPLEMENTACION DE LA DIVISION ENTRE DOS REGISTROS DE DIGITOS MOST SIGNIFICANT DIGIT DEL DIVISOR [DEL NUMERO NO DEL TIPO]
.PP
MOST SIGNIFICANT DIGIT DEL DIVIDENDO [DEL NUMERO NO DEL TIPO]
.PP
else if (rem >= dsor*dig_B()) { este caso no se deberia de dar nunca }
.PP
Definición en la línea \fB2205\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::unsigned_integral_c T, T B, \fBsize_t\fP L> bool NumRepr::get_digit_loop_token (std::istream & is, \fBreg_digs_t\fP< T, B, L > & value)\fC [noexcept]\fP"

.PP
Definición en la línea \fB2375\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool NumRepr::get_digit_token (std::istream & is, \fBdig_t\fP< UINT_T, B > & dig_value)"

.PP
FUNCION QUE CONSIGUE EL TOKEN DIGITO\&. 
.PP
Definición en la línea \fB2298\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::unsigned_integral_c T, T B> bool NumRepr::get_radix_token (std::istream & is)"

.PP
FUNCION QUE CONSIGUE EL TOKEN BASE\&. 
.PP
Definición en la línea \fB2370\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::arith_integral_c IntT> constexpr \fBsign_e\fP NumRepr::Int2Sign (IntT nu)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB19\fP del archivo \fBauxiliary_functions\&.hpp\fP\&.
.SS "template<type_traits::arith_integral_c IntT> constexpr \fBsign_funct_e\fP NumRepr::Int2SignFunct (IntT nu)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB29\fP del archivo \fBauxiliary_functions\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP LE> bool NumRepr::is_nat_reg_digs_type_id (std::string in)"

.PP
ESPECIALIZACIONES PARA NAT_REG_DIGS\&. 
.PP
Definición en la línea \fB1748\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::m_incr (\fBreg_digs_t\fP< UINT_T, B, N > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
TODO 31/12/2022\&. 
.PP
Definición en la línea \fB1865\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & NumRepr::m_mer_B (\fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1807\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & NumRepr::m_rem_B (\fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1788\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B, \fBsize_t\fP N> constexpr \fBdig_t\fP< UINT_T, B > NumRepr::m_sum (\fBreg_digs_t\fP< UINT_T, B, N > & larg, const \fBreg_digs_t\fP< UINT_T, B, N > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1955\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B> constexpr \fBdig_t\fP< UINT_T, B > NumRepr::m_sum_digs_carryin0 (\fBdig_t\fP< UINT_T, B > & left, \fBdig_t\fP< UINT_T, B > right)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1934\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B> constexpr \fBdig_t\fP< UINT_T, B > NumRepr::m_sum_digs_carryin1 (\fBdig_t\fP< UINT_T, B > & left, \fBdig_t\fP< UINT_T, B > right)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1906\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename Int_T , ullint B> constexpr ullint NumRepr::max_base_B_en_Int_T ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB127\fP del archivo \fBbase_num_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::mer_B (const \fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1797\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::arith_natural_c NatIntT> constexpr \fBsign_funct_e\fP NumRepr::Nat2SignFunct (NatIntT nu)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB41\fP del archivo \fBauxiliary_functions\&.hpp\fP\&.
.SS "template<typename Int_T , ullint B> constexpr ullint NumRepr::num_digs_max_base_B_en_Int_T ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB91\fP del archivo \fBbase_num_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::operator& (\fBreg_digs_t\fP< UINT_T, B, N > & larg, const \fBreg_digs_t\fP< UINT_T, B, N > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1854\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & NumRepr::operator&= (\fBreg_digs_t\fP< UINT_T, B, N > & larg, const \fBreg_digs_t\fP< UINT_T, B, N > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1841\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::operator<< (const \fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1718\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, \fBsize_t\fP Long> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>())std::ostream & NumRepr::operator<< (std::ostream & os, const \fBnat_reg_digs_t\fP< Int_Type, Base, Long > & arg)"

.PP
Definición en la línea \fB2033\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Long> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>())std::ostream & NumRepr::operator<< (std::ostream & os, const pfx_rat_reg_digs_t< Int_Type, Base, Long > & arg)"

.PP
Definición en la línea \fB2429\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<typename Int_Type , Int_Type Base, \fBsize_t\fP Long> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>())std::ostream & NumRepr::operator<< (std::ostream & os, const \fBreg_digs_t\fP< Int_Type, Base, Long > & arg)"

.PP
Definición en la línea \fB2711\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,Base>())std::ostream & NumRepr::operator<< (std::ostream & os, \fBdig_t\fP< UINT_T, Base > arg)"

.PP
Definición en la línea \fB1608\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & NumRepr::operator<<= (\fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1736\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::operator>> (const \fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1768\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T,Base>())std::istream & NumRepr::operator>> (std::istream & is, \fBdig_t\fP< UINT_T, Base > & arg)"

.PP
Definición en la línea \fB1508\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, \fBsize_t\fP Length> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>()&&(Length > 0))std::istream & NumRepr::operator>> (std::istream & is, \fBnat_reg_digs_t\fP< Int_Type, Base, Length > & arg)"
TODO ESTA VERSION + VERSION CON TRATAMIENTO DE ERRORES EN RUNTIME STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN
.PP
TIPOS A SER UTILIZADOS EN LA FUNCIÓN: NOMBRE DE TIPOS CORTOS
.PP
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA
.PP
VARIABLES PARA ACCIONES EN LOS ESTADOS
.PP
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)
.PP
ESTADO ACTUAL
.PP
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN
.PP
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA
.PP
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA
.PP
Definición en la línea \fB1781\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Length> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>()&&(Length > 0))std::istream & NumRepr::operator>> (std::istream & is, pfx_rat_reg_digs_t< Int_Type, Base, Length > & arg)"
STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN
.PP
TIPOS A SER UTILIZADOS EN LA FUNCIÓN: NOMBRE DE TIPOS CORTOS
.PP
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA
.PP
VARIABLES PARA ACCIONES EN LOS ESTADOS
.PP
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)
.PP
ESTADO ACTUAL
.PP
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN
.PP
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA
.PP
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA
.PP
Definición en la línea \fB2177\fP del archivo \fBnat_rat_fixed_reg_t\&.hpp\fP\&.
.SS "template<typename Int_Type , Int_Type Base, \fBsize_t\fP Length> 
.br
requires (\fBtype_traits::suitable_base\fP<Int_Type,Base>()&&(Length > 0))std::istream & NumRepr::operator>> (std::istream & is, \fBreg_digs_t\fP< Int_Type, Base, Length > & arg)"

.PP
SOBRECARGA DE ISTREAM Y OSTREAM CON LOS OPERADORES DE DESPLAZAMEINTO\&. STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN
.PP
TIPOS A SER UTILIZADOS EN LA FUNCIÓN: NOMBRE DE TIPOS CORTOS
.PP
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA
.PP
VARIABLES PARA ACCIONES EN LOS ESTADOS
.PP
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)
.PP
ESTADO ACTUAL
.PP
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN
.PP
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA
.PP
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA
.PP
Definición en la línea \fB2444\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & NumRepr::operator>>= (\fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1752\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::operator| (const \fBreg_digs_t\fP< UINT_T, B, N > & larg, const \fBreg_digs_t\fP< UINT_T, B, N > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1829\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const \fBreg_digs_t\fP< UINT_T, B, N > & NumRepr::operator|= (\fBreg_digs_t\fP< UINT_T, B, N > & larg, const \fBreg_digs_t\fP< UINT_T, B, N > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1816\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename Int_T , usint B> constexpr ullint NumRepr::pot_max_base_B_en_Int_T ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB77\fP del archivo \fBbase_num_t\&.hpp\fP\&.
.SS "template<type_traits::unsigned_integral_c T, T B, \fBsize_t\fP L> bool NumRepr::read (std::istream & is, \fBreg_digs_t\fP< T, B, L > & value)\fC [noexcept]\fP"

.PP
DEFINCION DE template<uint128_t Radix> digito_t{};\&. SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o \&.\&.\&. 
.PP
Definición en la línea \fB2401\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr \fBreg_digs_t\fP< UINT_T, B, N > NumRepr::rem_B (const \fBreg_digs_t\fP< UINT_T, B, N > & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1778\fP del archivo \fBreg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP LE> \fBsize_t\fP NumRepr::size_of_nat_reg_digs_type_string_idT ()"

.PP
Definición en la línea \fB1770\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<typename UInt_t , UInt_t B, \fBsize_t\fP LE> std::string NumRepr::to_nat_reg_digs_type_string ()"

.PP
Definición en la línea \fB1766\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> 
.br
requires (\fBtype_traits::suitable_base\fP<UINT_T, B>())consteval UINT_T NumRepr::ui_1 ()\fC [noexcept]\fP"

.PP
Definición en la línea \fB1484\fP del archivo \fBdig_t\&.hpp\fP\&.
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
