.TH "NumRepr::type_traits" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::type_traits
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBugly_details_for_greater_suitable_type_deduction\fP"
.br
.ti -1c
.RI "namespace \fBugly_details_for_suitable_type_deduction\fP"
.br
.ti -1c
.RI "namespace \fBugly_details_sig_SInt_for_UInt\fP"
.br
.ti -1c
.RI "namespace \fBugly_details_SInt_for_SInt\fP"
.br
.ti -1c
.RI "namespace \fBugly_details_UInt_for_SInt\fP"
.br
.ti -1c
.RI "namespace \fBugly_details_UInt_for_UInt\fP"
.br
.in -1c
.SS "Concepts"

.in +1c
.ti -1c
.RI "concept \fBarith_integral_c\fP"
.br
.RI "TYPE_TRAITS AND CONCEPTS\&. "
.ti -1c
.RI "concept \fBarith_natural_c\fP"
.br
.ti -1c
.RI "concept \fBchar_type_c\fP"
.br
.ti -1c
.RI "concept \fBuint_type_for_radix_c\fP"
.br
.RI "CONCEPT FOR UNSIGNED INTEGRAL TYPES VALID FOR THE RADIX\&. "
.ti -1c
.RI "concept \fBunsigned_integral_c\fP"
.br
.RI "CONCEPT FOR UNSIGNED INTEGRAL TYPES\&. "
.ti -1c
.RI "concept \fBsigned_integral_c\fP"
.br
.RI "CONCEPT FOR SIGNED INTEGRAL TYPES\&. "
.ti -1c
.RI "concept \fBintegral_c\fP"
.br
.in -1c
.SS "typedefs"

.in +1c
.ti -1c
.RI "template<typename UInt_t > using \fBsig_UInt_for_UInt_t\fP = typename \fBugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t\fP< UInt_t >::type"
.br
.ti -1c
.RI "template<typename UInt_t > using \fBsig_SInt_for_UInt_t\fP = typename \fBugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t\fP< UInt_t >::type"
.br
.ti -1c
.RI "template<typename Int_t > using \fBsig_UInt_for_SInt_t\fP = typename \fBugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t\fP< Int_t >::type"
.br
.ti -1c
.RI "template<typename SInt_t > using \fBsig_SInt_for_SInt_t\fP = typename \fBugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t\fP< SInt_t >::type"
.br
.ti -1c
.RI "template<\fBullint_t\fP Radix> using \fBTypeFromIntNumber_t\fP = typename \fBUIntTypeForRadix\fP< decltype(Radix), Radix >::UIntType"
.br
.ti -1c
.RI "template<integral_c IntType, IntType Radix> using \fBGreaterTypeFromIntNumber_t\fP = typename \fBUIntTypeForRadixContainsMultResult\fP< decltype(Radix), Radix >::UIntType"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "char * \fBclear_ccad\fP (char *, \fBusint_t\fP)"
.br
.ti -1c
.RI "template<template< \fBuchint_t\fP B > class T, \fBuchint_t\fP B> constexpr const char * \fBdevCadenaC\fP (T< B > arg, std::size_t long_ccad=64) noexcept"
.br
.ti -1c
.RI "constexpr char * \fBclear_ccad\fP (char *cad_c, std::size_t long_de_cad_c) noexcept"
.br
.ti -1c
.RI "constexpr unsigned long long \fBatoull\fP (char *text) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBmaxbase\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBsubmaxbase\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBminbase\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBsubminbase\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBmonobase\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBnobase\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBmaxdigit\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBsubmaxdigit\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBdigit_0\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBdigit_1\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBbase_2\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B> consteval bool \fBbase_geqt_2\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B> consteval bool \fBbase_leqt_max\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B> consteval bool \fBsuitable_base\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBmiddle_max\fP ()"
.br
.ti -1c
.RI "template<typename UINT_T > consteval UINT_T \fBsqrt_max\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "template<char_type_c CharT> constexpr CharT \fBnullchar\fP {CharT('\\0')}"
.br
.ti -1c
.RI "template<typename UINT_T > constexpr bool \fBis_uint_type_for_radix_v\fP = std::is_unsigned_v<UINT_T> && (! std::is_same_v<UINT_T,\fBuint128_t\fP>)"
.br
.ti -1c
.RI "template<typename UINT_T > constexpr bool \fBis_unsigned_type_v\fP"
.br
.ti -1c
.RI "template<typename SINT_T > constexpr bool \fBis_signed_type_v\fP = std::is_signed_v<SINT_T>"
.br
.RI "METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES SIGNED\&. "
.ti -1c
.RI "template<typename INT_TYPE > constexpr bool \fBis_integral_type_v\fP = std::is_integral_v<INT_TYPE>"
.br
.RI "METAOPERADOR QUE NOS DA SI UN TIPO ES INTEGRAL\&. "
.ti -1c
.RI "template<typename T , typename S > constexpr bool \fBeq_sz_v\fP = (sizeof(T) == sizeof(S))"
.br
.RI "METAOPERADORES DE COMPARACION DE CAPACIDAD DE INTEGERS\&. "
.ti -1c
.RI "template<typename T , typename S > constexpr bool \fBgt_sz_v\fP = (sizeof(T) > sizeof(S))"
.br
.ti -1c
.RI "template<typename T , typename S > constexpr bool \fBlt_sz_v\fP = (sizeof(T) < sizeof(S))"
.br
.ti -1c
.RI "template<typename T , typename S > constexpr bool \fBge_sz_v\fP = \fBgt_sz_v\fP<T,S>||\fBeq_sz_v\fP<T,S>"
.br
.ti -1c
.RI "template<typename T , typename S > constexpr bool \fBle_sz_v\fP = \fBlt_sz_v\fP<T,S>||\fBeq_sz_v\fP<T,S>"
.br
.in -1c
.SH "Documentación de los 'typedefs'"
.PP 
.SS "template<integral_c IntType, IntType Radix> using \fBNumRepr::type_traits::GreaterTypeFromIntNumber_t\fP = typedef typename \fBUIntTypeForRadixContainsMultResult\fP<decltype(Radix),Radix>::UIntType"

.PP
Definición en la línea \fB671\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename SInt_t > using \fBNumRepr::type_traits::sig_SInt_for_SInt_t\fP = typedef typename \fBugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t\fP<SInt_t>::type"
METAFUNCIONES PARA DAR CON LOS MAXIMOS NUMEROS QUE CABEN EN UN TIPO Y SIMILARES 
.PP
Definición en la línea \fB472\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UInt_t > using \fBNumRepr::type_traits::sig_SInt_for_UInt_t\fP = typedef typename \fBugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t\fP<UInt_t>::type"
METAFUNCION : DA EL SIGUIENTE TIPO NATURAL PARA EL ACTUAL TIPO ENTERO POR ESPECIALIZACION EXPLICITA 
.PP
Definición en la línea \fB363\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename Int_t > using \fBNumRepr::type_traits::sig_UInt_for_SInt_t\fP = typedef typename \fBugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t\fP<Int_t>::type"
METAFUNCION : DA EL SIGUIENTE TIPO ENTERO PARA EL ACTUAL TIPO ENTERO POR ESPECIALIZACION EXPLICITA 
.PP
Definición en la línea \fB401\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UInt_t > using \fBNumRepr::type_traits::sig_UInt_for_UInt_t\fP = typedef typename \fBugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t\fP<UInt_t>::type"
METAFUNCION : DA EL SIGUIENTE TIPO ENTERO PARA EL ACTUAL TIPO NATURAL POR ESPECIALIZACION EXPLICITA 
.PP
Definición en la línea \fB288\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<\fBullint_t\fP Radix> using \fBNumRepr::type_traits::TypeFromIntNumber_t\fP = typedef typename \fBUIntTypeForRadix\fP<decltype(Radix),Radix>::UIntType"
QUEREMOS FABRICAR LA METAFUNCION TypeFromIntNumberLTSqrtMaxOfType_t<numero> QUE DEVUELVA EL TIPO ENTERO SIN SIGNO MAS PEQUENO PARA EL NUMERO numero TAL QUE SQRT(TYPE::MAX())>=B-1 
.PP
Definición en la línea \fB620\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SH "Documentación de las funciones"
.PP 
.SS "constexpr unsigned long long NumRepr::type_traits::atoull (char * text)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB156\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::base_2 ()"

.PP
Definición en la línea \fB528\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B> consteval bool NumRepr::type_traits::base_geqt_2 ()"

.PP
Definición en la línea \fB533\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B> consteval bool NumRepr::type_traits::base_leqt_max ()"

.PP
Definición en la línea \fB538\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "char * NumRepr::type_traits::clear_ccad (char *, \fBusint_t\fP)"

.SS "constexpr char * NumRepr::type_traits::clear_ccad (char * cad_c, std::size_t long_de_cad_c)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB149\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<template< \fBuchint_t\fP B > class T, \fBuchint_t\fP B> constexpr const char * NumRepr::type_traits::devCadenaC (T< B > arg, std::size_t long_ccad = \fC64\fP)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB132\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::digit_0 ()"

.PP
Definición en la línea \fB518\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::digit_1 ()"

.PP
Definición en la línea \fB523\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::maxbase ()"

.PP
Definición en la línea \fB478\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::maxdigit ()"

.PP
Definición en la línea \fB508\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::middle_max ()"

.PP
Definición en la línea \fB548\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::minbase ()"

.PP
Definición en la línea \fB488\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::monobase ()"

.PP
Definición en la línea \fB498\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::nobase ()"

.PP
Definición en la línea \fB503\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::sqrt_max ()"
QUEREMOS FABRICAR LA METAFUNCION TypeFromIntNumber_t<numero_sin_signo> QUE DEVUELVA EL TIPO ENTERO SIN SIGNO MAS PEQUENO PARA EL NUMERO numero_sin_signo 
.PP
Definición en la línea \fB557\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::submaxbase ()"

.PP
Definición en la línea \fB483\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::submaxdigit ()"

.PP
Definición en la línea \fB513\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > consteval UINT_T NumRepr::type_traits::subminbase ()"

.PP
Definición en la línea \fB493\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T , UINT_T B> consteval bool NumRepr::type_traits::suitable_base ()"

.PP
Definición en la línea \fB543\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SH "Documentación de las variables"
.PP 
.SS "template<typename T , typename S > constexpr bool NumRepr::type_traits::eq_sz_v = (sizeof(T) == sizeof(S))\fC [constexpr]\fP"

.PP
METAOPERADORES DE COMPARACION DE CAPACIDAD DE INTEGERS\&. 
.PP
Definición en la línea \fB206\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename T , typename S > constexpr bool NumRepr::type_traits::ge_sz_v = \fBgt_sz_v\fP<T,S>||\fBeq_sz_v\fP<T,S>\fC [constexpr]\fP"

.PP
Definición en la línea \fB212\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename T , typename S > constexpr bool NumRepr::type_traits::gt_sz_v = (sizeof(T) > sizeof(S))\fC [constexpr]\fP"

.PP
Definición en la línea \fB208\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename INT_TYPE > constexpr bool NumRepr::type_traits::is_integral_type_v = std::is_integral_v<INT_TYPE>\fC [inline]\fP, \fC [constexpr]\fP"

.PP
METAOPERADOR QUE NOS DA SI UN TIPO ES INTEGRAL\&. 
.PP
Definición en la línea \fB199\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename SINT_T > constexpr bool NumRepr::type_traits::is_signed_type_v = std::is_signed_v<SINT_T>\fC [constexpr]\fP"

.PP
METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES SIGNED\&. 
.PP
Definición en la línea \fB192\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > constexpr bool NumRepr::type_traits::is_uint_type_for_radix_v = std::is_unsigned_v<UINT_T> && (! std::is_same_v<UINT_T,\fBuint128_t\fP>)\fC [constexpr]\fP"
'CLASS' TYPE TYPE DEFINITION template<typename              int_type,int_type base> class digito<int_type,base> {}; CONCEPT TYPE TYPE DEFINITION template<allowable_base_type_c int_type,int_type base> class digito<int_type,base> {}; METAOPERADOR QUE NOS DA LA ADECUACION DE UN TIPO PARA SER BASE DE UN SISTEMA DE NUMERACION VALE CUALQUIER TIPO UNSIGNED INTEGRAL QUE NO SEA EL MAYOR CONSIDERADO AQUI EL MAYOR CONSIDERADO ES UINT128_T 
.PP
Definición en la línea \fB175\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename UINT_T > constexpr bool NumRepr::type_traits::is_unsigned_type_v\fC [constexpr]\fP"
\fBValor inicial:\fP.PP
.nf
=
                        is_uint_type_for_radix_v<UINT_T>        || std::is_same_v<UINT_T,uint128_t>
.fi
METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES UNSIGNED VALEN LOS QUE VALEN PARA RADIX MAS LOS TIPO MAS GRANDES POR LO TANTO UINT128_T SE CONSIDERA UN UNSIGNED INTEGRAL TYPE 
.PP
Definición en la línea \fB184\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename T , typename S > constexpr bool NumRepr::type_traits::le_sz_v = \fBlt_sz_v\fP<T,S>||\fBeq_sz_v\fP<T,S>\fC [constexpr]\fP"
METAFUNCION : DA EL SIGUIENTE TIPO NATURAL PARA EL ACTUAL TIPO NATURAL POR ESPECIALIZACION EXPLICITA 
.PP
Definición en la línea \fB214\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<typename T , typename S > constexpr bool NumRepr::type_traits::lt_sz_v = (sizeof(T) < sizeof(S))\fC [constexpr]\fP"

.PP
Definición en la línea \fB210\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SS "template<char_type_c CharT> constexpr CharT NumRepr::type_traits::nullchar {CharT('\\0')}\fC [inline]\fP, \fC [constexpr]\fP"

.PP
Definición en la línea \fB126\fP del archivo \fBbasic_types\&.hpp\fP\&.
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
