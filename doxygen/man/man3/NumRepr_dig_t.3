.TH "NumRepr::dig_t< UINT_T, B >" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::dig_t< UINT_T, B >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <dig_t\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBSIG_UINT_T\fP = \fBsig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = \fBsig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBuintspair\fP = std::array< UINT_T, 2 >"
.br
.ti -1c
.RI "using \fBdigspair\fP = std::array< \fBdig_t\fP, 2 >"
.br
.ti -1c
.RI "using \fBuintspairlist\fP = std::array< \fBuintspair\fP, B >"
.br
.ti -1c
.RI "using \fBuintspairtbl\fP = std::array< \fBuintspairlist\fP, B >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBresbinop_t\fP = \fBauxiliary_types::resbinop_t\fP< \fBdig_t\fP, op >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "constexpr \fBoperator UINT_T\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const UINT_T & \fBget\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBoperator SIG_UINT_T\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBoperator SIG_SINT_T\fP () const noexcept"
.br
.ti -1c
.RI "constexpr UINT_T \fBoperator()\fP () const noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_Bm2\fP () noexcept"
.br
.ti -1c
.RI "consteval \fBdig_t\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr \fBdig_t\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP (const \fBdig_t\fP &) noexcept=default"
.br
.RI "CONSTRUCTOR COPIA POR REFERENCIA\&. "
.ti -1c
.RI "constexpr \fBdig_t\fP (\fBdig_t\fP &&) noexcept=default"
.br
.RI "CONSTRUCTOR POR MOVIMIENTO\&. "
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBoperator=\fP (const Int_t &a) noexcept"
.br
.RI "SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN INT_T\&. "
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator=\fP (const \fBdig_t\fP &) noexcept=default"
.br
.RI "SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN DIG_T\&. "
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator=\fP (\fBdig_t\fP &&) noexcept=default"
.br
.RI "SOBRECARGA DEL OPERATOR=() MEDIANTE MOVIMIENTO DESDE UN DIG_T\&. "
.ti -1c
.RI "constexpr bool \fBis_unit\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0_divisor\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBmult_inv\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator&\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator&=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator|\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator|=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::unsigned_integral_c UIntType> constexpr const \fBdig_t\fP & \fBoperator^=\fP (UIntType exp) noexcept"
.br
.ti -1c
.RI "template<type_traits::unsigned_integral_c UIntType> constexpr \fBdig_t\fP \fBoperator^\fP (UIntType exp) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator==\fP (\fBdig_t\fP a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator!=\fP (\fBdig_t\fP a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator>=\fP (\fBdig_t\fP a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator>\fP (\fBdig_t\fP a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator<=\fP (\fBdig_t\fP a) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator<\fP (\fBdig_t\fP a) const noexcept"
.br
.ti -1c
.RI "constexpr std::strong_ordering \fBoperator<=>\fP (\fBdig_t\fP rhs) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr bool \fBoperator==\fP (Int_t rhs) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr std::weak_ordering \fBoperator<=>\fP (Int_t rhs) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator+=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBoperator+=\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator\-=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBoperator\-=\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator*=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBoperator*=\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator/=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBoperator/=\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator%=\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBoperator%=\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator++\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator++\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator\-\-\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator\-\-\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator+\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator\-\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator*\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator/\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator%\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBoperator+\fP (Int_type arg) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBoperator\-\fP (Int_type arg) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBoperator*\fP (Int_type arg) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBoperator/\fP (Int_type arg) const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBoperator%\fP (Int_type arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator!\fP () const noexcept"
.br
.RI "EN BASE B, B-1-m_d ES EL COMPL_Bm1(m_d) "
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator\-\fP () const noexcept"
.br
.RI "EN BASE B, B-m_d ES EL COMPL_B(m_d) "
.ti -1c
.RI "constexpr \fBdig_t\fP \fBC_Bm1\fP () const noexcept"
.br
.RI "'C_Bm1' es identico a 'operator!()' "
.ti -1c
.RI "constexpr \fBdig_t\fP \fBC_B\fP () const noexcept"
.br
.RI "'C_B' es identico a 'operator-()' "
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0or1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_0\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_0or1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1orBm2\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_Bm1orBm2\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm2\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_Bm2\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_not_maxormin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_maxormin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_far_maxormin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_near_maxormin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr std::string \fBto_string\fP () const noexcept"
.br
.ti -1c
.RI "bool \fBget_type_template_string_id_token\fP (std::istream &is) noexcept"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "template<UINT_T n, UINT_T m> 
.br
requires ((n<B)&&(m<B))static consteval \fBuintspair\fP \fBmult\fP () noexcept"
.br
.ti -1c
.RI "static consteval bool \fBis_prime\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBssi_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBssi_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBssi_1\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_t> static constexpr UINT_T \fBnormaliza\fP (Int_t arg) noexcept"
.br
.ti -1c
.RI "static constexpr \fBdig_t\fP \fBsum_carry\fP (\fBdig_t\fP arg_1, \fBdig_t\fP arg_2) noexcept"
.br
.ti -1c
.RI "static constexpr bool \fBis_type_template_string_id\fP (std::string in) noexcept"
.br
.RI "el parser/lexer del \fBdig_t\fP "
.ti -1c
.RI "static constexpr std::string \fBto_type_template_string_id\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBsize_t\fP \fBsize_of_type_template_string_id\fP () noexcept"
.br
.ti -1c
.RI "static constexpr bool \fBget_digit_token\fP (std::istream &is, UINT_T &uint_value)"
.br
.RI "FUNCION QUE CONSIGUE EL TOKEN DIGITO\&. "
.ti -1c
.RI "static bool \fBget_radix_token\fP (std::istream &is)"
.br
.RI "FUNCION QUE CONSIGUE EL TOKEN BASE\&. "
.ti -1c
.RI "static bool \fBread\fP (std::istream &is, \fBdig_t\fP &value) noexcept"
.br
.in -1c
.SS "Métodos privados"

.in +1c
.ti -1c
.RI "constexpr std::string \fBnum_to_string\fP () const noexcept"
.br
.RI "TIENE QUE DEVOLVER STD::STRING\&. "
.in -1c
.SS "Métodos privados estáticos"

.in +1c
.ti -1c
.RI "static constexpr std::string \fBradix_str\fP () noexcept"
.br
.in -1c
.SS "Atributos privados"

.in +1c
.ti -1c
.RI "UINT_T \fBm_d\fP"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<uint_type_for_radix_c UINT_T, UINT_T B>
.br
requires (suitable_base<UINT_T,B>())
.br
struct NumRepr::dig_t< UINT_T, B >"< WRAPPER PARA UN TIPO UINT_T QUE UNSIGNED_INTEGRAL_T<UINT_T> SE SOBRECARGAN LOS OPERADORES ARITMETICOS PARA ARITMETICA MODULAR DIG_T = SUMA Y MULTIPLICACION CIRCULAR (MODULAR CON MOD B) 
.PP
Definición en la línea \fB19\fP del archivo \fBdig_t\&.hpp\fP\&.
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> using \fBNumRepr::dig_t\fP< UINT_T, B >::digspair =  std::array<\fBdig_t\fP,2>"

.PP
Definición en la línea \fB29\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<\fBbinop_e\fP op> using \fBNumRepr::dig_t\fP< UINT_T, B >::resbinop_t =  \fBauxiliary_types::resbinop_t\fP<\fBdig_t\fP,op>"
BEGIN : CONSTRUCCION DE LAS TABLAS DE MULTIPLICAR ESTATICAS PARA TODA LA CLASE 
.PP
Definición en la línea \fB34\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> using \fBNumRepr::dig_t\fP< UINT_T, B >::SIG_SINT_T =  \fBsig_SInt_for_UInt_t\fP<UINT_T>"

.PP
Definición en la línea \fB26\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> using \fBNumRepr::dig_t\fP< UINT_T, B >::SIG_UINT_T =  \fBsig_UInt_for_UInt_t\fP<UINT_T>"

.PP
Definición en la línea \fB24\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> using \fBNumRepr::dig_t\fP< UINT_T, B >::uintspair =  std::array<UINT_T,2>"

.PP
Definición en la línea \fB28\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> using \fBNumRepr::dig_t\fP< UINT_T, B >::uintspairlist =  std::array<\fBuintspair\fP,B>"

.PP
Definición en la línea \fB30\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> using \fBNumRepr::dig_t\fP< UINT_T, B >::uintspairtbl =  std::array<\fBuintspairlist\fP,B>"

.PP
Definición en la línea \fB31\fP del archivo \fBdig_t\&.hpp\fP\&.
.SH "Documentación del constructor y destructor"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> consteval \fBNumRepr::dig_t\fP< UINT_T, B >::dig_t ()\fC [inline]\fP, \fC [noexcept]\fP"
< CONSTRUCTORES CONSTRUCTOR POR DEFECTO NORMALIZA ES UNA FUNCION QUE BASICAMENTE SI ENTRA 1524 DEVUELVE 1524B TENIENDO EN CUENTA TIPOS Y SIGNOS 
.PP
Definición en la línea \fB213\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr \fBNumRepr::dig_t\fP< UINT_T, B >::dig_t (Int_t arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
CONSTRUCTOR A PARTIR DE UN ENTERO ARG ARG EQUIV ARG+Z*B DONDE Z ES UN ENTERO EN m_d SOLO QUEREMOS QUE HAYA UN NUMERO ENTRE 0 Y B-1 INCLUSIVES 
.PP
Definición en la línea \fB290\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBNumRepr::dig_t\fP< UINT_T, B >::dig_t (const \fBdig_t\fP< UINT_T, B > &)\fC [inline]\fP, \fC [constexpr]\fP, \fC [default]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA POR REFERENCIA\&. 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBNumRepr::dig_t\fP< UINT_T, B >::dig_t (\fBdig_t\fP< UINT_T, B > &&)\fC [inline]\fP, \fC [constexpr]\fP, \fC [default]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR MOVIMIENTO\&. 
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::C_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
'C_B' es identico a 'operator-()' 
.PP
Definición en la línea \fB962\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::C_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
'C_Bm1' es identico a 'operator!()' 
.PP
Definición en la línea \fB956\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::dig_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB160\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::dig_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB161\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::dig_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB158\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::dig_Bm2 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB159\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::dig_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB156\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::dig_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB157\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const UINT_T & \fBNumRepr::dig_t\fP< UINT_T, B >::get () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB121\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::get_digit_token (std::istream & is, UINT_T & uint_value)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
FUNCION QUE CONSIGUE EL TOKEN DIGITO\&. 
.PP
Definición en la línea \fB1313\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static bool \fBNumRepr::dig_t\fP< UINT_T, B >::get_radix_token (std::istream & is)\fC [inline]\fP, \fC [static]\fP"

.PP
FUNCION QUE CONSIGUE EL TOKEN BASE\&. 
.PP
Definición en la línea \fB1378\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> bool \fBNumRepr::dig_t\fP< UINT_T, B >::get_type_template_string_id_token (std::istream & is)\fC [inline]\fP, \fC [noexcept]\fP"
FUNCION GENERICA QUE CONSIGUE EL TOKEN TYPE PARA LA OBTENCION DEL OBJETO CORRESPONDIENTE POR TECLADO 
.PP
Definición en la línea \fB1183\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_0 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
dig_t<uchint,7> a,b,c; a = 5; b = 2; c = 0; !a == 1 is TRUE a\&.C_Bm1() == 1 is TRUE !b == 4 is TRUE b\&.C_Bm1() == 4 is TRUE !c == 6 is TRUE c\&.C_Bm1() == 6 is TRUE -a == 2 is TRUE a\&.C_B() == 2 is TRUE -b == 5 is TRUE b\&.C_B() == 5 is TRUE -c == 0 is TRUE c\&.C_B() == 0 is TRUE a\&.mC_Bm1() == 1 is TRUE a == 1 is TRUE b\&.mC_Bm1() == 4 is TRUE b == 4 is TRUE c\&.mC_Bm1() == 6 is TRUE c == 6 is TRUE a\&.mC_B() == 2 is TRUE a == 2 is TRUE b\&.mC_B() == 5 is TRUE b == 5 is TRUE c\&.mC_B() == 0 is TRUE c == 0 is TRUE 
.PP
Definición en la línea \fB1013\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_0_divisor () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB362\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_0or1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1025\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1019\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1049\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_Bm1orBm2 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1061\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_Bm2 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1073\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_far_maxormin () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1097\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_maxormin () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1091\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_near_maxormin () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1108\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_0 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1037\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_0or1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1043\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1031\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1055\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_Bm1orBm2 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1067\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_Bm2 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1079\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_not_maxormin () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1085\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_prime ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB152\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_type_template_string_id (std::string in)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
el parser/lexer del \fBdig_t\fP Funciones de ayuda para 
.PP
Definición en la línea \fB1162\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::is_unit () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
a y b son digitos; a = std::move(b); a es identico a b; en b puede no queda nada; 
.PP
Definición en la línea \fB338\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::mC_B ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB981\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::mC_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB974\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<UINT_T n, UINT_T m> 
.br
requires ((n<B)&&(m<B))static consteval \fBuintspair\fP \fBNumRepr::dig_t\fP< UINT_T, B >::mult ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB41\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::mult_inv () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB385\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> static constexpr UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::normaliza (Int_t arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB219\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr std::string \fBNumRepr::dig_t\fP< UINT_T, B >::num_to_string () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
TIENE QUE DEVOLVER STD::STRING\&. 
.PP
Definición en la línea \fB1127\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBNumRepr::dig_t\fP< UINT_T, B >::operator \fBSIG_SINT_T\fP () const\fC [inline]\fP, \fC [explicit]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB129\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBNumRepr::dig_t\fP< UINT_T, B >::operator \fBSIG_UINT_T\fP () const\fC [inline]\fP, \fC [explicit]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB125\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBNumRepr::dig_t\fP< UINT_T, B >::operator UINT_T () const\fC [inline]\fP, \fC [explicit]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
PARA B=3 2*2 1 COMIENZAN POR 2 B-2 PARA B=4 2*2 2*3 3*4 3 COMIENZAN POR 2 B-2, 3 B-3 PARA B=5 2*2 2*3 2*4 3*3 3*4 4*4 6 COMIENZAN POR 2 B-2, 3 B-3, 4 B-4 PARA B=6 2*2 2*3 2*4 2*5 3*3 3*4 3*5 4*4 4*5 5*5 10 COMIENZAN POR 2 B-2, 3 B-3, 4 B-4, 5 B-5 PARA B=r 2*2 2*(2+1) \&.\&.\&. 2*(r-1) r-1 r COMIENZAN POR 2 B-2, 3 B-3, 4 B-4, 5 B-1, \&.\&.\&. , r-1 B-r+1 3*3 \&.\&.\&. 3*(r-1) r-2 \&.\&.\&. (r-1)*(r-1) r-(r-1) 
.PP
 (r-2)r-(r-1)*r/2 + 1 = [2(r-2)-((r-2)+1)]r/2 + 1 = ((r-3)r + 2)/2 = (r^2 - 3r + 2) / 2 
.SS "a r^2 + b r + c"
1 = a 9 + b 3 + c 3 = a 16 + b 4 + c 
.SS "6 = a 25 + b 5 + c"
1 = a 9 + b 3 + c 2 = a 7 + b 1 
.SS "5 = a 16 + b 2"
1 = a 9 + b 3 + c 2 = a 7 + b 
.SS "1 = a  2"
c = 2/2 b = -3/2 
.SS "a =  1/2"
SIZE = (B^2 - 3B + 2)/2 2+3+4+\&.\&.\&.+B-1 = 1+2+3+4+\&.\&.\&.+B-1 - 1 = (B-1)B/2 - 2(B-1)/2 = (B^2 - B - 2B +2)/2 = =(B^2-3B+2)/2
.PP
FALTARIA HACER SOLO PARA BASES MAYORES QUE 2 CODE NEW USING TYPES : using pair_map = std::pair<uintspair,uintspair>; CODE MULTTABLE: static consteval std::array<pair_map,(B^2 - 3B + 2)/2> multtable{make_multtables()}; CODE FOR MAKE_MULTTABLES(): static consteval std::array<pair_map,(B^2 - 3B + 2)/2> make_multtables() noexcept { std::array<pair_map,(B^2 - 3B + 2)/2> ret; /// ESTO QUE SIGUE HABRIA QUE HACERLO POR UNROOLING LOOP EN COMPILE TIME /// YA QUE IDX E IDY NO SON CONSTANTES EN TIEMPO DE COMPILACION /// LO MEJOR ES HACERLO EN UNA CLASE TEMPLATE POR RECURSION for(size_t idx{2} ; idx < B ; ++idx) { for(size_t idy{idx} ; idy < B ; ++idy) { make_pair(make_array(idx,idy),\fBmult<idx,idy>()\fP); } } } 
.PP
Definición en la línea \fB117\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator! () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
EN BASE B, B-1-m_d ES EL COMPL_Bm1(m_d) 
.PP
Definición en la línea \fB944\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >\fB::operator!\fP= (\fBdig_t\fP< UINT_T, B > a) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB575\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator% (\fBdig_t\fP< UINT_T, B > arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB877\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator% (Int_type arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB926\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator%= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB785\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator%= (Int_t arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB793\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator& (const \fBdig_t\fP< UINT_T, B > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
DEVOLVER EL MENOR: ANDBITWISE NO TIENE POSIBILIDAD DE ERROR 
.PP
Definición en la línea \fB485\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator&= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
DEVOLVER EL MENOR HABIENDOLO ASIGNADO ANDBITWISE AND ASSIGN NO TIENE POSIBILIDAD DE ERROR 
.PP
Definición en la línea \fB494\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::operator() () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB133\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator* (\fBdig_t\fP< UINT_T, B > arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB861\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator* (Int_type arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB905\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator*= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB703\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator*= (Int_t arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB719\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator+ (\fBdig_t\fP< UINT_T, B > arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB845\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator+ (Int_type arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB886\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator++ ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
Tengo serias dudas que la division y el resto euclideo tengan cabida entre los operadores aritmeticos de un tipo \fBdig_t\fP DUDA SATISFECHA: TIENEN CABIDA PORQUE EL INVERSO MULTIPLICATIVO ETC\&. SOLO NOS SIRVE SI ESTUVIERAMOS CONSTRUYENDO NUMEROS DE UN ANILLO FINITO 
.PP
Definición en la línea \fB812\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator++ (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB819\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator+= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB637\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator+= (Int_t arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB659\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator\- () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
EN BASE B, B-m_d ES EL COMPL_B(m_d) 
.PP
Definición en la línea \fB950\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator\- (\fBdig_t\fP< UINT_T, B > arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB853\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator\- (Int_type arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB895\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator\-\- ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB825\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator\-\- (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB832\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator\-= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB681\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator\-= (Int_t arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB692\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator/ (\fBdig_t\fP< UINT_T, B > arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB869\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator/ (Int_type arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB915\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator/= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB768\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator/= (Int_t arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB776\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::operator< (\fBdig_t\fP< UINT_T, B > a) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB583\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::operator<= (\fBdig_t\fP< UINT_T, B > a) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB581\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr std::strong_ordering \fBNumRepr::dig_t\fP< UINT_T, B >::operator<=> (\fBdig_t\fP< UINT_T, B > rhs) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
SI COMPARAMOS O HACEMOS UNA OPERACION CON UN INT_T SIEMPRE SERA DIG_T @ INT_T -> DIG_T Y NUNCA INT_T @ DIG_T -> ANY_TYPE METODO PROPIO DE C++20 
.PP
Definición en la línea \fB589\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr std::weak_ordering \fBNumRepr::dig_t\fP< UINT_T, B >::operator<=> (Int_t rhs) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
METODO PROPIO DE C++20 ESTABLECEMOS UN ORDEN PARCIAL SOBRE LOS ENTEROS SI a b EN Z ESTANDO EN ESTE AMBITO DE BASE B SI a mod B = b mod B 
.PP
Definición en la línea \fB619\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator= (const \fBdig_t\fP< UINT_T, B > &)\fC [inline]\fP, \fC [constexpr]\fP, \fC [default]\fP, \fC [noexcept]\fP"

.PP
SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN DIG_T\&. 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator= (const Int_t & a)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN INT_T\&. PODEMOS PASAR ARGUMENTOS POR COPIA, REFERENCIA (PUNTEROS) Y MOVIMIENTO COPIA : COPIA EL ARGUMENTO LITERALMENTE PARA PASARLO: EL ORIGINAL INTACTO REFERENCIA: COPIA LA DIRECCION DEL ARGUMENTO (SI ES CONST EL COMPILADOR NO TE DEJA COMPILAR SI LO CAMBIAS) MOVIMIENTO: SI EL ARGUMETO NO SE VA A UTILIZAR MAS SE LE PASA LA PROPIEDAD A LA FUNCION 
.PP
Definición en la línea \fB314\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator= (\fBdig_t\fP< UINT_T, B > &&)\fC [inline]\fP, \fC [constexpr]\fP, \fC [default]\fP, \fC [noexcept]\fP"

.PP
SOBRECARGA DEL OPERATOR=() MEDIANTE MOVIMIENTO DESDE UN DIG_T\&. 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::operator== (\fBdig_t\fP< UINT_T, B > a) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB573\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::operator== (Int_t rhs)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB604\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::operator> (\fBdig_t\fP< UINT_T, B > a) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB579\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool \fBNumRepr::dig_t\fP< UINT_T, B >::operator>= (\fBdig_t\fP< UINT_T, B > a) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB577\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UIntType> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator^ (UIntType exp) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB559\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UIntType> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator^= (UIntType exp)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB532\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::operator| (const \fBdig_t\fP< UINT_T, B > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
DEVOLVER EL MAYOR ORBITWISE NO TIENE POSIBILIDAD DE ERROR 
.PP
Definición en la línea \fB505\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const \fBdig_t\fP & \fBNumRepr::dig_t\fP< UINT_T, B >::operator|= (\fBdig_t\fP< UINT_T, B > arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
DEVOLVER EL MAYOR HABIENDOLO ASIGNADO ORBITWISE AND ASSIGN NO TIENE POSIBILIDAD DE ERROR 
.PP
Definición en la línea \fB514\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr std::string \fBNumRepr::dig_t\fP< UINT_T, B >::radix_str ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1138\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static bool \fBNumRepr::dig_t\fP< UINT_T, B >::read (std::istream & is, \fBdig_t\fP< UINT_T, B > & value)\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1457\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void \fBNumRepr::dig_t\fP< UINT_T, B >::set_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
dig_t<uchint,10> digito{4}; digito() devuelve un 4 de tipo uchint 
.PP
Definición en la línea \fB138\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void \fBNumRepr::dig_t\fP< UINT_T, B >::set_1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB141\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void \fBNumRepr::dig_t\fP< UINT_T, B >::set_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB144\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void \fBNumRepr::dig_t\fP< UINT_T, B >::set_Bm2 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB147\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr \fBsize_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::size_of_type_template_string_id ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1177\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::ssi_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB195\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::ssi_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB198\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_SINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::ssi_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB186\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_SINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::ssi_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB189\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::ssi_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB192\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::sui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB179\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::sui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB182\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::sui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB170\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::sui_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB173\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval \fBSIG_UINT_T\fP \fBNumRepr::dig_t\fP< UINT_T, B >::sui_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB176\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr \fBdig_t\fP \fBNumRepr::dig_t\fP< UINT_T, B >::sum_carry (\fBdig_t\fP< UINT_T, B > arg_1, \fBdig_t\fP< UINT_T, B > arg_2)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB413\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr std::string \fBNumRepr::dig_t\fP< UINT_T, B >::to_string () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1149\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr std::string \fBNumRepr::dig_t\fP< UINT_T, B >::to_type_template_string_id ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1173\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::ui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB167\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::ui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB168\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::ui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB165\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::ui_Bm2 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB166\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::ui_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB163\fP del archivo \fBdig_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::ui_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB164\fP del archivo \fBdig_t\&.hpp\fP\&.
.SH "Documentación de los datos miembro"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B> UINT_T \fBNumRepr::dig_t\fP< UINT_T, B >::m_d\fC [private]\fP"

.PP
Definición en la línea \fB21\fP del archivo \fBdig_t\&.hpp\fP\&.

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
