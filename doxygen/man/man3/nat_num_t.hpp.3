.TH "nat_num_t.hpp" 3 "Lunes, 28 de Noviembre de 2022" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
nat_num_t.hpp
.SH SYNOPSIS
.br
.PP
\fC#include 'base_num_t\&.hpp'\fP
.br

.SS "Clases"

.in +1c
.ti -1c
.RI "class \fBnat_num_t< UINT_T, B >\fP"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "template<const \fBuchint\fP Base> istream & \fBoperator>>\fP (istream &is, \fBnat_num_t\fP< Base > &arg)"
.br
.ti -1c
.RI "template<const \fBuchint\fP Base> ostream & \fBoperator<<\fP (ostream &os, const \fBnat_num_t\fP< Base > &arg)"
.br
.in -1c
.SH "Documentación de las funciones"
.PP 
.SS "template<const \fBuchint\fP Base> ostream & operator<< (ostream & os, const \fBnat_num_t\fP< Base > & arg)"

.PP
.nf
2103                                                                  {
2104         usint sz = arg\&.size();
2105         os  << "uint#";
2106         for (int k=0 ; k<sz ; ++k) {
2107                 if (k==0)
2108                         os      << arg[k]\&.Dig2Int();
2109                 else
2110                         os      << ":" << arg[k]\&.Dig2Int();
2111         }
2112         os      <<"#B"
2113                 << static_cast<int>(Base) ;
2114         return os;
2115 }
.fi
.PP
Hace referencia a \fBnat_num_t< UINT_T, B >::size()\fP\&.
.SS "template<const \fBuchint\fP Base> istream & operator>> (istream & is, \fBnat_num_t\fP< Base > & arg)"

.PP
.nf
1965                                                            {
1966         enum estado_e {e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13};
1967         vector<string> num(255);
1968         string sds;
1969         string num_digint;
1970         string num_base;
1971         usint numero_base_recogido      = 0;
1972         usint ind_sds                           = 0;
1973         usint digint                            = 0;
1974         usint ind_num                           = 0;
1975         estado_e est_act                        = e0;
1976         char c;
1977         is >> sds;
1978         do {
1979                 c = sds[ind_sds];
1980                 switch (est_act) {
1981                 case e0 :
1982                         {
1983                                 num_digint\&.clear();
1984                                 num_base\&.clear();
1985                                 numero_base_recogido = 0;
1986                                 digint = 0;
1987                                 ind_num = 0;
1988                         }
1989                         if (c=='u') est_act = e1;
1990                         break;
1991 
1992                 case e1 :
1993                         if (c=='i') est_act = e2;
1994                         else est_act = e0;
1995                         break;
1996 
1997                 case e2 :
1998                         if (c=='n') est_act = e3;
1999                         else est_act = e0;
2000                         break;
2001 
2002                 case e3 :
2003                         if (c=='t') est_act = e4;
2004                         else est_act = e0;
2005                         break;
2006 
2007                 case e4 :
2008                         if (c=='#') est_act = e5;
2009                         else est_act = e0;
2010                         break;
2011 
2012                 case e5 :
2013                         if ((c>='1')and(c<='9')) {
2014                                 num[ind_num]\&.push_back(c-'0');
2015                                 est_act = e6;
2016                         }
2017                         else est_act=e0;
2018                         break;
2019                 case e6 :
2020                         if ((c>='0')and(c<='9')) {
2021                                 num[ind_num]\&.push_back(c-'0');
2022                         }
2023                         else if (c==':') {
2024                                 est_act=e7;
2025                                 ++ind_num;
2026                         }
2027                         else if (c=='#') {
2028                                 est_act=e8;
2029                                 ++ind_num;
2030                         }
2031                         else est_act=e0;
2032                         break;
2033                 case e7 :
2034                         if ((c>='0')and(c<='9')) {
2035                                 est_act = e6;
2036                                 num[ind_num]\&.push_back(c-'0');
2037                         }
2038                         else est_act = e0;
2039                         break;
2040                 case e8 :
2041                         if (c=='B') {
2042                                 est_act = e9;
2043                         }
2044                         else est_act = e0;
2045                         break;
2046                 case e9 :
2047                         if ((c<='9')and(c>='2')){
2048                                 est_act = e10;
2049                                 num_base\&.push_back(c-'0');
2050                         }
2051                         else if (c=='1') {
2052                                 est_act = e11;
2053                                 num_base\&.push_back(1);
2054                         }
2055                         else if (c==' ' || c=='\0')
2056                                 est_act = e12;
2057                         else est_act=e0;
2058                         break;
2059                 case e10 :
2060                         if ((c<='9')and(c>='0'))
2061                                 num_base\&.push_back(c-'0');
2062                         else if(c==' ' || c=='\0')
2063                                 est_act = e12;
2064                         else est_act = e0;
2065                         break;
2066                 case e11 :
2067                         if ((c<='9')and(c>='0')) {
2068                                 est_act=e9;
2069                                 num_base\&.push_back(c-'0');
2070                         }
2071                         else if(c==' ' || c=='\0')
2072                                 est_act = e12;
2073                         else est_act = e0;
2074                         break;
2075                 case e12 :
2076                         for (uint k=0 ; k < num_base\&.size() ; ++k ) {
2077                                 numero_base_recogido *= 10;
2078                                 numero_base_recogido += num_base[k];
2079                         }
2080                         if (numero_base_recogido!=Base) est_act = e0;
2081                         else est_act = e13;
2082                 case e13 : break;
2083                 default  : est_act=e0;
2084                 }
2085                 ++ind_sds;
2086         } while ((est_act!=e13)and(c!='\0'));
2087 
2088         arg\&.clear();
2089         uchint numero;
2090         for (uchint j=0 ; j < ind_num ; ++j) {
2091                 numero=0;
2092                 for (uint k=0 ; k < num[j]\&.size() ; ++k ) {
2093                         numero *= 10;
2094                         numero += num[j][k];
2095                 }
2096                 arg\&.push_back(dig_t<Base>(numero));
2097         }
2098         arg\&.p_aux(pardigs_t<Base>());
2099         return is;
2100 }
.fi
.PP
Hace referencia a \fBnat_num_t< UINT_T, B >::clear()\fP, \fBnat_num_t< UINT_T, B >::p_aux()\fP y \fBnat_num_t< UINT_T, B >::push_back()\fP\&.
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
