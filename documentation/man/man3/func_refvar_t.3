.TH "func_refvar_t< aT, T >" 3 "Martes, 29 de Noviembre de 2022" "Version 0.8" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
func_refvar_t< aT, T >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <memory_handler\&.hpp>\fP
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "\fBfunc_refvar_t\fP ()"
.br
.ti -1c
.RI "\fB~func_refvar_t\fP ()"
.br
.ti -1c
.RI "void \fBborra_var\fP (string nombre)"
.br
.ti -1c
.RI "bool \fBexiste_lugar_de_base\fP (\fBuchint\fP Base)"
.br
.ti -1c
.RI "bool \fBeste_nombre_ya_ha_sido_declarado\fP (string nombre)"
.br
.ti -1c
.RI "template<const \fBuchint\fP B> T< B > \fBget\fP (string nombre)"
.br
.ti -1c
.RI "template<const \fBuchint\fP B> bool \fBoperator()\fP (string nombre, string lhs)"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<typename aT, template< \fBuchint\fP > class T>
.br
class func_refvar_t< aT, T >"
.SH "Documentación del constructor y destructor"
.PP 
.SS "template<typename aT , template< \fBuchint\fP > class T> \fBfunc_refvar_t\fP< aT, T >\fB::func_refvar_t\fP ()\fC [inline]\fP"

.PP
.nf
218         {
219                 //inicia_matriz_digs_y_pp(matd,256u,256u);
220                 matd = construye_matriz_de_variables<ppT,pT,T>(matd);
221                 mapmem\&.resize(256);
222                 cuentavars\&.resize(256);
223                 for(uint I=0 ; I < 256 ; ++I){
224                         mapmem[I]\&.resize(256);
225                         cuentavars[I]=0;
226                         for(uint J=0 ; J < 256 ; ++J){
227                                 mapmem[I][J]=false;
228                         }
229                 }
230         }
.fi
.SS "template<typename aT , template< \fBuchint\fP > class T> \fBfunc_refvar_t\fP< aT, T >::~\fBfunc_refvar_t\fP ()\fC [inline]\fP"

.PP
.nf
233         {
234                 destruye_matriz_de_variables<T,T>(matd);
235         }
.fi
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<typename aT , template< \fBuchint\fP > class T> void \fBfunc_refvar_t\fP< aT, T >::borra_var (string nombre)\fC [inline]\fP"

.PP
.nf
254                                         {
255                 map< string , par_dir_t >::iterator it = mapvd\&.begin();
256                 map< string , par_dir_t >::const_iterator itend = mapvd\&.end();
257                 for( ; it != itend ; ++it) {
258                         if ((*it)\&.first==nombre) {
259                                 mapmem[(*it)\&.second\&.first][(*it)\&.second\&.second]=false;
260                                 --cuentavars[(*it)\&.second\&.first];
261                                 mapvd\&.erase(it);// ponerlo a 0
262                                 return;
263                         }
264                 }
265                 return;
266         }
.fi
.SS "template<typename aT , template< \fBuchint\fP > class T> bool \fBfunc_refvar_t\fP< aT, T >::este_nombre_ya_ha_sido_declarado (string nombre)\fC [inline]\fP"

.PP
.nf
277                                                             {
278                 map< string , par_dir_t >::iterator it = mapvd\&.begin();
279                 map< string , par_dir_t >::const_iterator itend = mapvd\&.end();
280                 for( ; it != itend ; ++it) {
281                         if ((*it)\&.first==nombre) {
282                                 return true;
283                         }
284                 }
285                 return false;
286         }
.fi
.PP
Referenciado por \fBfunc_refvar_t< aT, T >::operator()()\fP, \fBfunc_refvar_t< INT **, INT *, INT >::operator()()\fP y \fBfunc_refvar_t< UINT **, UINT *, UINT >::operator()()\fP\&.
.SS "template<typename aT , template< \fBuchint\fP > class T> bool \fBfunc_refvar_t\fP< aT, T >::existe_lugar_de_base (\fBuchint\fP Base)\fC [inline]\fP"

.PP
.nf
268                                                  {
269                 bool ret = true;
270                 for(uint I=0; I < 256 ; ++I){
271                         ret = ret and mapmem[Base][I];
272                         if (!ret) return true;
273                 }
274                 return false;
275         }
.fi
.SS "template<typename aT , template< \fBuchint\fP > class T> template<const \fBuchint\fP B> T< B > \fBfunc_refvar_t\fP< aT, T >::get (string nombre)\fC [inline]\fP"

.PP
.nf
290         {
291                 return (reinterpret_cast< T<B>* >(matd[B]))[mapvd[nombre]\&.second];
292         }
.fi
.SS "template<typename aT , template< \fBuchint\fP > class T> template<const \fBuchint\fP B> bool \fBfunc_refvar_t\fP< aT, T >::operator() (string nombre, string lhs)\fC [inline]\fP"

.PP
.nf
296         {
297                 T<B> temp(lhs);
298                 bool se_puede_hacer = este_nombre_ya_ha_sido_declarado(nombre);
299                 if (se_puede_hacer) (reinterpret_cast< T<B>* >(matd[B]))[mapvd[nombre]\&.second]=temp;
300                 return se_puede_hacer;
301         }
.fi
.PP
Hace referencia a \fBfunc_refvar_t< aT, T >::este_nombre_ya_ha_sido_declarado()\fP\&.

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
