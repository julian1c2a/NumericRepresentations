.TH "utilities::pack2tuple< Ts >" 3 "Martes, 29 de Noviembre de 2022" "Version 0.8" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
utilities::pack2tuple< Ts >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <utilities\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBtuple_type\fP = std::tuple< Ts\&.\&.\&. >"
.br
.ti -1c
.RI "template<unsigned K> using \fBelem_type\fP = typename std::tuple_element< K, \fBtuple_type\fP >::type"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "constexpr \fBtuple_type\fP \fBoperator()\fP (Ts &&\&.\&.\&.args) noexcept"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static constexpr unsigned \fBpack_size\fP () noexcept"
.br
.ti -1c
.RI "template<unsigned J> static constexpr \fBelem_type\fP< J >::type \fBget\fP (Ts &&\&.\&.\&.args) noexcept"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<typename\&.\&.\&. Ts>
.br
struct utilities::pack2tuple< Ts >"template<class type_0, class type_1, \&.\&.\&. , class type_Nm1> struct apilamiento_de_tipos_t { type_0 obj_0; type_1 obj_1; \&.\&.\&.\&.\&.\&. \&.\&.\&.\&.\&. type_Nm1 obj_Nm1; }; example: apilamiento_de_tipos<int,std::string,double> objeto{1,'abc',2\&.98105}; objeto\&.obj_0 == 1; objeto\&.obj_1 == 'abc'; objeto\&.obj_Nm1 == 2\&.98105; A partir del estandar de C++11 template<class \&.\&.\&.type_i> struct apilamiento_de_tipos_t { type_0 obj_0; // sabemos type_i pero no type_0 type_1 obj_1; // sabemos type_i pero no type_1 \&.\&.\&.\&.\&.\&. \&.\&.\&.\&.\&. type_Nm1 obj_Nm1;// sabemos type_i pero no type_Nm1 }; type_i es un PACK tipo std::tupla<class \&.\&.\&. Ts>; 
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<typename\&.\&.\&. Ts> template<unsigned K> using \fButilities::pack2tuple\fP< Ts >::elem_type =  typename std::tuple_element<K,\fBtuple_type\fP>::type"

.SS "template<typename\&.\&.\&. Ts> using \fButilities::pack2tuple\fP< Ts >::tuple_type =  std::tuple<Ts\&.\&.\&.>"

.SH "Documentación de las funciones miembro"
.PP 
.SS "template<typename\&.\&.\&. Ts> template<unsigned J> static constexpr \fBelem_type\fP< J >::type \fButilities::pack2tuple\fP< Ts >::get (Ts &&\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
50                                                                      {
51                 tuple_type  content = std::make_tuple(std::forward(args\&.\&.\&.));
52                 elem_type<J> ret{std::get<J>(std::forward(content))};
53                 return ret;
54         }
.fi
.SS "template<typename\&.\&.\&. Ts> constexpr \fBtuple_type\fP \fButilities::pack2tuple\fP< Ts >::operator() (Ts &&\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
43                                                                {
44                 tuple_type  content = std::make_tuple(std::forward(args\&.\&.\&.));
45                 return  std::move(content);
46         }
.fi
.SS "template<typename\&.\&.\&. Ts> static constexpr unsigned \fButilities::pack2tuple\fP< Ts >::pack_size ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
42 {return (sizeof\&.\&.\&.(Ts));}
.fi


.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
