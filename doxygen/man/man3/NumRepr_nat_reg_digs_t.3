.TH "NumRepr::nat_reg_digs_t< UINT_T, B, L >" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::nat_reg_digs_t< UINT_T, B, L >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nat_reg_digs_t\&.hpp>\fP
.PP
Herencias \fBNumRepr::reg_digs_t< UINT_T, B, L >\fP\&.
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename \fBtype_traits::sig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBbase_N_t\fP = \fBreg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_N_t\fP< L >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_N_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_base_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBnat_reg_N_digs_t\fP = \fBnat_reg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBnat_reg_N_digs_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBnat_reg_digs_t\fP, op, L >"
.br
.in -1c

Tipos públicos heredados desde \fBNumRepr::reg_digs_t< UINT_T, B, L >\fP
.in +1c
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBbase_N_t\fP = std::array< \fBdig_t\fP, N >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_N_t\fP< L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_N_digs_t\fP = \fBreg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename \fBtype_traits::sig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_N_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_base_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_t\fP, op, L >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "consteval \fBnat_reg_digs_t\fP () noexcept"
.br
.RI "CONSTRUCTOR POR DEFECTO\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.RI "CONSTRUCTOR POR LISTA DE DIGITOS\&. "
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBnat_reg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.RI "CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. "
.ti -1c
.RI "constexpr const \fBbase_t\fP *const \fBconst_base_this\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBbase_t\fP \fBbase_cpy_cthis\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const \fBbase_t\fP & \fBbase_const_ref_cthis\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBconst_by_index\fP (\fBsize_t\fP ix) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBcpy_by_index\fP (\fBsize_t\fP ix) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBcopy_arg_N\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBmove_arg_N\fP (\fBbase_N_t\fP< N > &&arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBcopy_arg_N\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBmove_arg_N\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBnat_reg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.RI "END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. "
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_dig\fP (\fBdig_t\fP arg) noexcept"
.br
.RI "OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_0\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_Bm1\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_dig\fP (\fBdig_t\fP dig) noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN DIGITO (CONVERSION) "
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "SUBREPR => SUB REPRESENTACION\&. "
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat_inv\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat_inv\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBsubrepr\fP () const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBoperator Int_Type\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBoperator<=>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBoperator<=>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr std::weak_ordering \fBoperator<=>\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator[]\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP idx) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBoperator()\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator<<\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator<<=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator>>\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator>>=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBrem_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_rem_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBmer_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_mer_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator|=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.RI "END : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator|\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator&=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator&\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator+\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator\-\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator*\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator/\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "DIVISION BY A DIGIT\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator%\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "REMAINDER BY A DIGIT\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator*=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator*=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "TO DO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator*\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator*\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator%\fP (const \fBnat_reg_digs_t\fP &arg) const noexcept"
.br
.in -1c

Métodos públicos heredados desde \fBNumRepr::reg_digs_t< UINT_T, B, L >\fP
.in +1c
.ti -1c
.RI "const \fBbase_t\fP *const \fBconst_base_this\fP () const noexcept"
.br
.RI "devolucion de punteros a la clase base "
.ti -1c
.RI "\fBbase_t\fP * \fBbase_this\fP () noexcept"
.br
.ti -1c
.RI "\fBbase_t\fP & \fBr_base_cthis\fP () noexcept"
.br
.RI "devolucion de referencias a la clase base "
.ti -1c
.RI "const \fBbase_t\fP & \fBcr_base_cthis\fP () const noexcept"
.br
.RI "devolucion de copia de la clase base "
.ti -1c
.RI "\fBbase_t\fP \fBcp_base_cthis\fP () const noexcept"
.br
.ti -1c
.RI "\fBreg_digs_t\fP & \fBr_cthis\fP () noexcept"
.br
.RI "devolucion de referencias de la clase actual "
.ti -1c
.RI "const \fBreg_digs_t\fP & \fBcr_cthis\fP () const noexcept"
.br
.ti -1c
.RI "\fBreg_digs_t\fP \fBcp_cthis\fP () const noexcept"
.br
.RI "devolucion de copia de la clase actual "
.ti -1c
.RI "\fBdig_t\fP \fBcp_cthis_at\fP (\fBsize_t\fP k) const noexcept"
.br
.RI "devoluciones por referencias y por copia de los elementos "
.ti -1c
.RI "\fBdig_t\fP & \fBr_cthis_at\fP (\fBsize_t\fP k) noexcept"
.br
.ti -1c
.RI "const \fBdig_t\fP & \fBcr_cthis_at\fP (\fBsize_t\fP k) const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBbegin\fP () noexcept"
.br
.RI "En este bloque hacemos esta clase wrapper como si fuese una clase derivada de base_t Para esto replicamos y sobrecargamos cada una de las funciones por defecto de std::array Nota: lo anterior se escribio cuando no era clase derivada sino un wrapper\&. "
.ti -1c
.RI "constexpr decltype(auto) \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBend\fP () noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBrend\fP () noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBsize_t\fP \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBsize_t\fP \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBfront\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP const & \fBfront\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBback\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP const & \fBback\fP () const noexcept"
.br
.ti -1c
.RI "constexpr void \fBfill\fP (const \fBdig_t\fP &value) noexcept"
.br
.ti -1c
.RI "constexpr void \fBswap\fP (\fBbase_t\fP &\fBother\fP) noexcept"
.br
.ti -1c
.RI "constexpr void \fBreverse\fP () noexcept"
.br
.ti -1c
.RI "consteval \fBreg_digs_t\fP () noexcept"
.br
.RI "Constructores de \fBreg_digs_t\fP\&. "
.ti -1c
.RI "constexpr \fBreg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.RI "Constructor por lista de digitos utilizando la función make_base_t\&. "
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBreg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.RI "Constructor por argumentos tipo \fBdig_t\fP: deduce el tipo\&. "
.ti -1c
.RI "constexpr \fBreg_digs_t\fP (const \fBbase_t\fP &rarg) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE EL TIPO BASE\&. "
.ti -1c
.RI "constexpr \fBreg_digs_t\fP (\fBbase_t\fP &&rarg) noexcept"
.br
.RI "CONSTRUCTOR MOVIMIENTO DESDE EL TIPO BASE\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "Constructor copia desde un array cualquiera de dígitos \fBdig_t\fP (usando copy_arg_N<N>) "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP (const \fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "Constructor por movimiento desde un array cualquiera de dígitos \fBdig_t\fP (usando move_arg_N<N>) "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> 
.br
requires ((sizeof\&.\&.\&.(Ints_type))==L)constexpr \fBreg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr const \fBreg_digs_t\fP & \fBoperator=\fP (const \fBreg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "Sobrecarga del operador copia\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP & \fBoperator=\fP (\fBreg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr const \fBbase_t\fP & \fBoperator=\fP (\fBreg_N_digs_t\fP< N > &&arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN DIGITO (CONVERSION) "
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr const \fBreg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBoperator Int_Type\fP () const noexcept"
.br
.RI "SE PODRÍA HACER PARA UINT128_T\&. "
.ti -1c
.RI "constexpr const \fBdig_t\fP *const \fBdata\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcpy_data\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP ix) const noexcept"
.br
.RI "<summary='Sobrecarga del const dig_t & operator[](size_t) const'> "
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP ix) noexcept"
.br
.RI "<summary='Sobrecarga del dig_t & operator[](size_t)'> "
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.RI "Funciones que ponen a constantes (constexpr) los objetos base_t\&. "
.ti -1c
.RI "constexpr void \fBset_1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_dig\fP (\fBdig_t\fP d) noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_fill_dig\fP (\fBdig_t\fP d) noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_fill_1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_fill_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_0\fP () noexcept"
.br
.RI "'Funciones que ponen a constantes(constexpr) los objetos un subintervalo
o subrango de base_t cualquiera' "
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_dig\fP (\fBdig_t\fP dig) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bp1\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires (n<L)constexpr bool \fBis_B_pow_m1\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires (n<L\-1)constexpr bool \fBis_B_pow\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_any_B_pow\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of\fP (\fBdig_t\fP d) const"
.br
.ti -1c
.RI "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < L)&&(ibegin != iend))constexpr \fBreg_N_digs_t\fP<(ibegin< iend)?(iend\-ibegin):(ibegin\-iend)> \fBsubregister\fP () const noexcept"
.br
.RI "TAKE A SUBREGISTER OF A REGISTER OF DIGITS\&. "
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBC_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBC_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator!\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator\-\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator<<\fP (\fBsize_t\fP n) const noexcept"
.br
.RI "OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. "
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator<<=\fP (\fBsize_t\fP n) noexcept"
.br
.RI "TODO TO DO VOY POR AQUI CON EL TEMA DE LOS CTHIS\&. "
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator>>=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator>>\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBrem_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBm_rem_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBmer_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBm_mer_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator|=\fP (const \fBbase_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator|\fP (const \fBreg_digs_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator&=\fP (const \fBreg_digs_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator&\fP (const \fBreg_digs_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBint64_t\fP \fBindex_of_MSDig\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator==\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.RI "COMPARACIONES ENTRE BASE_T Y DIG_T EN FORMA BASE_T @ DIG_T\&. "
.ti -1c
.RI "constexpr bool \fBoperator!=\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator>\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator<\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator>=\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator<=\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator==\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator!=\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator>\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator<\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator>=\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator<=\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr std::strong_ordering \fBoperator<=>\fP (const \fBreg_N_digs_t\fP< M > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr std::weak_ordering \fBoperator<=>\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBregd_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBregd_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> static constexpr const \fBbase_t\fP & \fBassign\fP (\fBbase_t\fP &larg, Int_Type arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T\&. "
.ti -1c
.RI "template<bool with_result_type> static constexpr auto \fBm_add\fP (\fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept \-> typename std::conditional_t< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::add\fP >, \fBbase_t\fP >"
.br
.RI "END : OPERATORS | & |= &=\&. "
.ti -1c
.RI "static constexpr const \fBbase_t\fP & \fBm_sub\fP (\fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.RI "OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB\&. "
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBadd\fP (const \fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBsub\fP (const \fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.in -1c

Métodos públicos estáticos heredados desde \fBNumRepr::reg_digs_t< UINT_T, B, L >\fP
.in +1c
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bp1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_Bp1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_0\fP () noexcept"
.br
.RI "PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_0\fP () noexcept"
.br
.RI "IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL\&. "
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_0\fP () noexcept"
.br
.RI "IDEM QUE ANTES PERO CON LA CLASE DERIVADA, LA ACTUAL TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL\&. "
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "template<typename \&.\&.\&. Ints_type> 
.br
requires ((sizeof\&.\&.\&.(Ints_type)) == L)static constexpr \fBbase_t\fP \fBnormalize\fP (Ints_type \&.\&.\&. digits_pow_i) noexcept"
.br
.ti -1c
.RI "static constexpr \fBreg_digs_t\fP \fBcat\fP (const \fBreg_digs_t\fP &arg) noexcept"
.br
.RI "STATIC REG_DIGS_T CAT(REG_DIGS_T) "
.ti -1c
.RI "template<\fBsize_t\fP M> static constexpr \fBreg_N_digs_t\fP< L+M > \fBcat\fP (const \fBreg_digs_t\fP &larg, const \fBreg_N_digs_t\fP< M > &rarg) noexcept"
.br
.RI "STATIC <M> REG_N_DIGS_T<L+M> CAT(REG_DIGS_T,REG_N_DIGS_T<M>) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< L+1 > \fBcat\fP (const \fBreg_digs_t\fP &larg, \fBdig_t\fP rarg) noexcept"
.br
.RI "STATIC REG_DIGS_T<L+1> CAT(REG_DIGS_T,DIG_T) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< 1+L > \fBcat\fP (\fBdig_t\fP larg, const \fBreg_digs_t\fP &rarg) noexcept"
.br
.RI "REG_N_DIGS_T<1+L> CAT(DIG_T,REG_DIGS_T) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< 1 > \fBcat\fP (\fBdig_t\fP larg) noexcept"
.br
.RI "STATIC REG_N_DIGS_T<1> CAT(DIG_T) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< 2 > \fBcat\fP (\fBdig_t\fP larg, \fBdig_t\fP rarg) noexcept"
.br
.RI "STATIC REG_N_DIGS_T<1+1> CAT(DIG_T,DIG_T) "
.ti -1c
.RI "template<typename T0 , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.)&& (std::is_same_v<T0,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< 1+(sizeof \&.\&.\&.(Ts))> \fBcat\fP (T0 dig0, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< L+1+(sizeof \&.\&.\&.(Ts))> \fBcat\fP (\fBreg_digs_t\fP larg, T dig, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< L+1+(sizeof \&.\&.\&.(Ts))> \fBcat\fP (T dig, Ts \&.\&.\&. dig_pack, \fBreg_digs_t\fP rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP \&.\&.\&. N_pack> 
.br
requires ((N>0)&&((N_pack>0)&&\&.\&.\&.))static constexpr \fBreg_N_digs_t\fP< N+(\&.\&.\&.+(N_pack))> \fBcat\fP (\fBreg_N_digs_t\fP< N > larg, \fBreg_N_digs_t\fP< N_pack > \&.\&.\&. rarg_pack) noexcept"
.br
.ti -1c
.RI "static bool \fBis_type_template_string_id\fP (std::string in) noexcept"
.br
.RI "el parser/lexer del \fBreg_digs_t\fP "
.ti -1c
.RI "static std::string \fBto_type_template_string_id\fP () noexcept"
.br
.ti -1c
.RI "static \fBsize_t\fP \fBsize_of_type_template_string_id\fP () noexcept"
.br
.ti -1c
.RI "static bool \fBget_type_template_string_id_token\fP (std::istream &is)"
.br
.in -1c
.SS "Métodos privados"

.in +1c
.ti -1c
.RI "constexpr \fBbase_t\fP *const \fBbase_this\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBbase_t\fP & \fBbase_ref_cthis\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBby_index\fP (\fBsize_t\fP ix) noexcept"
.br
.ti -1c
.RI "template<bool with_result_type> constexpr auto \fBpredecrement\fP (\fBbase_t\fP &arg) noexcept \-> std::conditional< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::sub\fP >, const \fBbase_t\fP & >"
.br
.ti -1c
.RI "template<bool with_result_type> constexpr auto \fBpostdecrement\fP (\fBbase_t\fP &arg) noexcept \-> std::conditional< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::sub\fP >, const \fBbase_t\fP & >"
.br
.ti -1c
.RI "template<bool with_result_type> constexpr auto \fBmult\fP (\fBdig_t\fP arg) const noexcept \-> std::conditional_t< with_result_type, \fBres_base_op_t\fP< binop_e::mult >, const \fBbase_t\fP & >"
.br
.in -1c
.SS "Métodos privados estáticos"

.in +1c
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_0\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_1\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_Bm1\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_dig\fP (\fBbase_N_t\fP< N > &larg, \fBdig_t\fP d) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_fill_dig\fP (\fBbase_N_t\fP< N > &larg, \fBdig_t\fP d) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_fill_1\fP (\fBbase_N_t\fP< N > &larg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBset_fill_Bm1\fP (\fBbase_N_t\fP< N > &larg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void \fBset_interval_0\fP (\fBbase_N_t\fP< N > &larg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void \fBset_interval_Bm1\fP (\fBbase_N_t\fP< N > &larg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void \fBset_interval_dig\fP (\fBbase_N_t\fP< N > &larg, \fBdig_t\fP dig) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void \fBset_interval_0\fP (\fBbase_t\fP &larg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void \fBset_interval_Bm1\fP (\fBbase_t\fP &larg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void \fBset_interval_dig\fP (\fBbase_t\fP &larg, \fBdig_t\fP dig) noexcept"
.br
.ti -1c
.RI "template<bool with_result_type> static constexpr auto \fBpreincrement\fP (\fBbase_t\fP &arg) noexcept \-> std::conditional_t< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::add\fP >, const \fBbase_t\fP & >"
.br
.ti -1c
.RI "template<bool with_result_type> static constexpr auto \fBpostincrement\fP (\fBbase_t\fP &arg) noexcept \-> std::conditional< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::add\fP >, const \fBbase_t\fP & >"
.br
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBrem_B\fP (const \fBbase_t\fP &larg, \fBsize_t\fP n) noexcept"
.br
.RI "BEGIN : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. "
.ti -1c
.RI "static constexpr const \fBbase_t\fP & \fBm_rem_B\fP (\fBbase_t\fP &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBmer_B\fP (const \fBbase_t\fP &larg, \fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "static constexpr const \fBbase_t\fP & \fBm_mer_B\fP (\fBbase_t\fP &larg, \fBsize_t\fP n) noexcept"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L>
.br
requires (suitable_base<UINT_T,B>() && (L>0))
.br
struct NumRepr::nat_reg_digs_t< UINT_T, B, L >"
.PP
Definición en la línea \fB14\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::base_N_t =  \fBreg_digs_t\fP<UINT_T,B,N>"

.PP
Definición en la línea \fB23\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::base_t =  \fBbase_N_t\fP<L>"

.PP
Definición en la línea \fB24\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_t =  \fBdig_t\fP<UINT_T,B>"

.PP
Definición en la línea \fB19\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_N_digs_t =  \fBnat_reg_digs_t\fP<UINT_T,B,N>"

.PP
Definición en la línea \fB35\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::res_base_N_op_t =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_N_t\fP<N>,op,N>"

.PP
Definición en la línea \fB27\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::res_base_op_t =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_t\fP,op,L>"

.PP
Definición en la línea \fB30\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::res_N_op_t =  typename \fBauxiliary_types::result_operation_t\fP<\fBnat_reg_N_digs_t\fP<N>,op,N>"

.PP
Definición en la línea \fB38\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::res_op_t =  typename \fBauxiliary_types::result_operation_t\fP<\fBnat_reg_digs_t\fP,op,L>"

.PP
Definición en la línea \fB41\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::SIG_SINT_T =  typename \fBtype_traits::sig_SInt_for_UInt_t\fP<UINT_T>"

.PP
Definición en la línea \fB17\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::SIG_UINT_T =  typename \fBtype_traits::sig_UInt_for_UInt_t\fP<UINT_T>"

.PP
Definición en la línea \fB16\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SH "Documentación del constructor y destructor"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR DEFECTO\&. 
.PP
Definición en la línea \fB94\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const std::initializer_list< \fBdig_t\fP > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR LISTA DE DIGITOS\&. 
.PP
Definición en la línea \fB98\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. 
.PP
Definición en la línea \fB104\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. 
.PP
Definición en la línea \fB202\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. 
.PP
Definición en la línea \fB209\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (Ints_type \&.\&.\&. dig_pow_i)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO 
.PP
Definición en la línea \fB217\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. 
.PP
Definición en la línea \fB223\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR MOVIMIENTO\&. 
.PP
Definición en la línea \fB229\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::add (const \fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1276\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::assign (\fBbase_t\fP & larg, Int_Type arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T\&. 
.PP
Definición en la línea \fB491\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::base_const_ref_cthis () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB112\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::base_cpy_cthis () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB110\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::base_ref_cthis ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB121\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBbase_t\fP *const \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::base_this ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB119\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBdig_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::by_index (\fBsize_t\fP ix)\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB123\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
SUBREPR => SUB REPRESENTACION\&. NAT_REG_N_T<L+M> NAT_REG_T::CAT(NAT_REG_N_T<M>) NAT_REG_N_T<L+M> NAT_REG_T::CAT_INV(NAT_REG_N_T<M>) NAT_REG_N_T<L+1> NAT_REG_T::CAT(DIG_T) NAT_REG_N_T<L+1> NAT_REG_T::CAT_INV(DIG_T) 
.PP
Definición en la línea \fB575\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB579\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat_inv (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB585\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat_inv (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB589\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBbase_t\fP *const \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::const_base_this () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB108\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBdig_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::const_by_index (\fBsize_t\fP ix) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB114\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::copy_arg_N (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
BEGIN : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS FUNCION DELEGADA PARA COPIA DE UN ARRAY DEL MISMO TAMANO O UN TAMANO CUALQUIERA 'N' < Z < W or Z == W
.PP
Definición en la línea \fB134\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::copy_arg_N (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
FUNCION DELEGADA PARA COPIA DE UN NAT_REG_N_DIGS_T DEL MISMO TAMANO O UN TAMANO CUALQUIERA 'N' 
.PP
Definición en la línea \fB183\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cpy_by_index (\fBsize_t\fP ix) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB116\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> static constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_add (\fBbase_t\fP & larg, const \fBdig_t\fP & rarg) \-> typename std::conditional_t<
			with_result_type,
				\fBres_base_op_t\fP<\fBbinop_e::add\fP>,
				\fBbase_t\fP
		>
	\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END : OPERATORS | & |= &=\&. OPERACIONES BINARIAS CON/SIN TIPO RESULTADO OPERACIONES BINARIAS BASE_T @ DIG_T OPERATOR BASE_T += DIG_T CON NOMBRE M_ADDITION CARRY INICIAL POR DEFECTO
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
INICIALIZACION
.PP
NOMBRE CORTO PARA RET\&.RESULT_CONTENT_LOW
.PP
NOMBRE CORTO PARA RET\&.CARRY
.PP
NOMBRE CORTO PARA RET\&.GOOD_RESULT
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
Definición en la línea \fB1157\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_mer_B (\fBbase_t\fP & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1032\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_mer_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1091\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_rem_B (\fBbase_t\fP & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1016\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_rem_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1077\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_sub (\fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB\&. COPIA DE RARG
.PP
CARRY INICIAL POR DEFECTO: NULO
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE RESTA RARG A LARG DESDE IDX=1 A IDX=L-1
.PP
Definición en la línea \fB1240\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mer_B (const \fBbase_t\fP & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1024\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mer_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1084\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::move_arg_N (\fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
FUNCION DELEGADA PARA MOVER DE UN ARRAY DEL MISMO TAMANO O UN TAMANO CUALQUIERA 'N' < Z < W or Z == W
.PP
Definición en la línea \fB159\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::move_arg_N (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
FUNCION DELEGADA PARA MOVER DE UN NAT_REG_N_DIGS_T DEL MISMO TAMANO O UN TAMANO CUALQUIERA 'N' 
.PP
Definición en la línea \fB192\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mult (\fBdig_t\fP arg) const \-> std::conditional_t<
			with_result_type,
				\fBres_base_op_t\fP<binop_e::mult>,
				const \fBbase_t\fP &
		>
	\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACIONES '@'(REG_DIGS_T,DIG_T)->RESULT_TYPE<'@'> '@' = MULT 
.PP
Definición en la línea \fB1321\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator Int_Type () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB605\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator% (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1718\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator% (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
REMAINDER BY A DIGIT\&. 
.PP
Definición en la línea \fB1529\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator& (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1126\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator&= (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1119\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator() (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB671\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator* (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1683\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator* (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1710\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator* (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1505\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator*= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1626\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator*= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1640\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+ (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
TO DO\&. TO DO 
.PP
Definición en la línea \fB1665\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+ (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1304\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+ (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1692\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+ (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1489\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator++ ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB786\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator++ (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB818\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1544\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1290\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator+= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1583\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\- (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1674\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\- (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1310\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\- (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1701\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\- (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1497\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\-\- ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB909\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\-\- (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB941\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\-= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
< cparg pasa a ser el complemento a la base menos 1 de cparg
.PP
Definición en la línea \fB1592\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\-= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1297\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator\-= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1617\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator/ (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
DIVISION BY A DIGIT\&. 
.PP
Definición en la línea \fB1522\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator<< (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1042\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator<<= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1050\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator<=> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
Definición en la línea \fB641\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr std::weak_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator<=> (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
Definición en la línea \fB648\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator<=> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
Definición en la línea \fB632\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (\fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. 
.PP
Definición en la línea \fB258\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. 
.PP
Definición en la línea \fB247\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. 
.PP
Definición en la línea \fB236\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN DIGITO (CONVERSION) 
.PP
Definición en la línea \fB479\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. 
.PP
Definición en la línea \fB269\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. 
.PP
Definición en la línea \fB291\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (Int_Type arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION COPIA DESDE UN ENTERO CONVERSION A LA BASE B DEL OBJETO ARG DE TIPO INT_TYPE 
.PP
Definición en la línea \fB520\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator= (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR MOVIMIENTO\&. 
.PP
Definición en la línea \fB280\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator>> (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1057\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator>>= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1063\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator[] (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB659\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator[] (\fBsize_t\fP idx)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB665\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator| (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1111\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator|= (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
END : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. BEGIN : OPERATORS | & |= &= 
.PP
Definición en la línea \fB1104\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::postdecrement (\fBbase_t\fP & arg) \-> std::conditional<
				with_result_type,
						\fBres_base_op_t\fP<\fBbinop_e::sub\fP>,
						const \fBbase_t\fP&
				>
	\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB919\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> static constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::postincrement (\fBbase_t\fP & arg) \-> std::conditional<
					with_result_type,
							\fBres_base_op_t\fP<\fBbinop_e::add\fP>,
							const \fBbase_t\fP &
			>
	\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB796\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::predecrement (\fBbase_t\fP & arg) \-> std::conditional<
				with_result_type,
						\fBres_base_op_t\fP<\fBbinop_e::sub\fP>,
						const \fBbase_t\fP&
				>
	\fC [inline]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
BORROW INICIAL POR DEFECTO
.PP
RESTA 1 A ARG EN IDX == 0
.PP
BUCLE FOR QUE RESTA A ARG UN 1 DESDE IDX=1 A IDX=L-1
.PP
CREAMOS EL RETORNO RET
.PP
NOMBRE CORTO PARA RET\&.RESULT_CONTENT_LOW
.PP
NOMBRE CORTO PARA RET\&.BORROW
.PP
NOMBRE CORTO PARA RET\&.GOOD_RESULT
.PP
RESTA 1 A ARG EN IDX == 0
.PP
BUCLE FOR QUE RESTA BORROW A ARG [DESDE 1 EN IDX=0] DESDE IDX=1 A IDX=L-1
.PP
Definición en la línea \fB828\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> static constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::preincrement (\fBbase_t\fP & arg) \-> std::conditional_t<
					with_result_type,
						\fBres_base_op_t\fP<\fBbinop_e::add\fP>,
						const \fBbase_t\fP &
			>
	\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
< PREINCREMENT(OBJ) == ++OBJ SOLO QUE DEVUELVE CARRY TAMBIÉN PREINCREMENT(OBJ) -> CONDICIONALMENTE BIEN RES_BASE_OP_T (con CARRY), BIEN BASE_T (sin CARRY) < result_content_low result_content_high carry borrow result_content_quotient result_content_remainder good_result true == tipo resultado
.PP
CREAMOS EL RETORNO RET DE TIPO RESULTADO
.PP
NOMBRE CORTO PARA RET\&.CARRY
.PP
NOMBRE CORTO PARA RET\&.RESULT_CONTENT_LOW
.PP
NOMBRE CORTO PARA RET\&.GOOD_RESULT
.PP
INCREMENTO DEL PRIMER DIGITO
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
CARRY INICIAL POR DEFECTO
.PP
INCREMENTO DEL PRIMER DIGITO
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
Definición en la línea \fB701\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
FUNCIONES INMEDIATAS QUE NOS DAN CONSTANTES DEL TIPO DE LA ACTUAL CLASE SE HACE CREANDO UNA VARIABLE RVALUE TEMPORAL CON LA FUNCION HOMOLOGA PARA BASE_T 
.PP
Definición en la línea \fB50\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB55\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB65\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB60\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB72\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB79\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::rem_B (const \fBbase_t\fP & larg, \fBsize_t\fP n)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
BEGIN : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. MULTIPLY BY THE BASE B (10) << <<= DIVIDE BY THE BASE B (10) >> >>= REMAINDER BY THE BASE B (10) REM_B_N M_REM_B_N MULTIPLICATIVE CARRY BY THE BASE B (10) MER_B_N M_MER_B_N 
.PP
Definición en la línea \fB1008\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::rem_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1070\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. 
.PP
Definición en la línea \fB436\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_0 (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB301\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_1 (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB310\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. 
.PP
Definición en la línea \fB442\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_Bm1 (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB320\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_dig (\fBbase_N_t\fP< N > & larg, \fBdig_t\fP d)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB330\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_dig (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. 
.PP
Definición en la línea \fB448\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_fill_1 (\fBbase_N_t\fP< N > & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB349\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_fill_Bm1 (\fBbase_N_t\fP< N > & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB358\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_fill_dig (\fBbase_N_t\fP< N > & larg, \fBdig_t\fP d)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB340\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
Definición en la línea \fB457\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_0 (\fBbase_N_t\fP< N > & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG_0 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> 
.PP
Definición en la línea \fB370\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_0 (\fBbase_t\fP & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG_0 DEL ARRAY DESDE [N_0 , N_1) EN BASE_T ESPECIALIZACION PARA N==L 
.PP
Definición en la línea \fB404\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
Definición en la línea \fB465\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_Bm1 (\fBbase_N_t\fP< N > & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG_Bm1 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> 
.PP
Definición en la línea \fB381\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_Bm1 (\fBbase_t\fP & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG_Bm1 DEL ARRAY DESDE [N_0 , N_1) EN BASE_T ESPECIALIZACION PARA N==L 
.PP
Definición en la línea \fB416\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_dig (\fBbase_N_t\fP< N > & larg, \fBdig_t\fP dig)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> 
.PP
Definición en la línea \fB392\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_dig (\fBbase_t\fP & larg, \fBdig_t\fP dig)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [private]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG DEL ARRAY DESDE [N_0 , N_1) EN BASE_T ESPECIALIZACION PARA N==L 
.PP
Definición en la línea \fB428\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_dig (\fBdig_t\fP dig)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
Definición en la línea \fB473\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sub (const \fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB1282\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.
.SS "template<uint_type_for_radix_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::subrepr () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB595\fP del archivo \fBnat_reg_digs_t\&.hpp\fP\&.

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
