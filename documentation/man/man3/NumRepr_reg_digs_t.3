.TH "NumRepr::reg_digs_t< UINT_T, B, L >" 3 "Martes, 29 de Noviembre de 2022" "Version 0.8" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::reg_digs_t< UINT_T, B, L >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <reg_digs_t\&.hpp>\fP
.PP
Herencias std::array< dig_t< UINT_T, B >, L >\&.
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBbase_N_t\fP = std::array< \fBdig_t\fP, N >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_N_t\fP< L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_N_digs_t\fP = \fBreg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename \fBtype_traits::sig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_N_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_base_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_t\fP, op, L >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "consteval const \fBreg_digs_t\fP & \fBcr_cthis\fP () const noexcept"
.br
.RI "#define crrefcthis const \fBreg_digs_t\fP & cr_cthis{*this} "
.ti -1c
.RI "consteval const \fBbase_t\fP * \fBc_base_this\fP () const noexcept"
.br
.ti -1c
.RI "consteval const \fBbase_t\fP & \fBcr_base_cthis\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBcr_cthis\fP (\fBsize_t\fP k) const noexcept"
.br
.ti -1c
.RI "consteval \fBreg_digs_t\fP & \fBr_cthis\fP () noexcept"
.br
.RI "#define rrefcthis \fBreg_digs_t\fP & r_cthis{*this} "
.ti -1c
.RI "consteval \fBbase_t\fP * \fBbase_this\fP () noexcept"
.br
.ti -1c
.RI "consteval \fBbase_t\fP & \fBr_base_cthis\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBr_cthis\fP (\fBsize_t\fP k) noexcept"
.br
.ti -1c
.RI "consteval \fBreg_digs_t\fP \fBcp_cthis\fP () const noexcept"
.br
.RI "#define cpcthis \fBreg_digs_t\fP cp_cthis{*this} "
.ti -1c
.RI "consteval \fBbase_t\fP \fBcp_base_cthis\fP () const noexcept"
.br
.ti -1c
.RI "constexpr const \fBdig_t\fP & \fBcp_cthis\fP (\fBsize_t\fP k) const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBbegin\fP () noexcept"
.br
.RI "En este bloque hacemos esta clase wrapper como si fuese una clase derivada de base_t Para esto replicamos y sobrecargamos cada una de las funciones por defecto de std::array  "
.ti -1c
.RI "constexpr decltype(auto) \fBcbegin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBend\fP () noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcend\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBrbegin\fP () noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcrbegin\fP () const noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBrend\fP () noexcept"
.br
.ti -1c
.RI "constexpr decltype(auto) \fBcrend\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBsize_t\fP \fBsize\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBsize_t\fP \fBmax_size\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBempty\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBfront\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP const & \fBfront\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBback\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP const & \fBback\fP () const noexcept"
.br
.ti -1c
.RI "constexpr void \fBfill\fP (const \fBdig_t\fP &value) noexcept"
.br
.ti -1c
.RI "constexpr void \fBswap\fP (\fBbase_t\fP &\fBother\fP) noexcept"
.br
.ti -1c
.RI "consteval \fBreg_digs_t\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.RI "Constructor por lista de digitos utilizando la función make_base_t  "
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBreg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.RI "Constructor por argumentos tipo \fBdig_t\fP: deduce el tipo  "
.ti -1c
.RI "constexpr \fBreg_digs_t\fP (const \fBbase_t\fP &rarg) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE EL TIPO BASE\&. "
.ti -1c
.RI "constexpr \fBreg_digs_t\fP (\fBbase_t\fP &&rarg) noexcept"
.br
.RI "CONSTRUCTOR MOVIMIENTO DESDE EL TIPO BASE\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "Constructor copia desde un array cualquiera de dígitos \fBdig_t\fP (usando copy_arg_N<N>)  "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP (const \fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "Constructor por movimiento desde un array cualquiera de dígitos \fBdig_t\fP (usando move_arg_N<N>)  "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBreg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr const \fBreg_digs_t\fP & \fBoperator=\fP (const \fBreg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "Sobrecarga del operador copia  "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP & \fBoperator=\fP (\fBreg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr const \fBbase_t\fP & \fBoperator=\fP (\fBreg_N_digs_t\fP< N > &&arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN DIGITO (CONVERSION) "
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr const \fBreg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBoperator Int_Type\fP () const noexcept"
.br
.RI "SE PODRÍA HACER PARA UINT128_T\&. "
.ti -1c
.RI "constexpr const \fBdig_t\fP * \fBdata\fP () const noexcept"
.br
.ti -1c
.RI "constexpr auto & \fBref_data\fP () const"
.br
.ti -1c
.RI "constexpr auto \fBcpy_data\fP () const"
.br
.ti -1c
.RI "const \fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP ix) const"
.br
.RI "<summary='Sobrecarga del const dig_t & operator[](size_t) const'> "
.ti -1c
.RI "\fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP ix)"
.br
.RI "<summary='Sobrecarga del dig_t & operator[](size_t)'> "
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.RI "Funciones que ponen a constantes (constexpr) los objetos base_t  "
.ti -1c
.RI "constexpr void \fBset_1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_dig\fP (\fBdig_t\fP d) noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_fill_dig\fP (\fBdig_t\fP d) noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_fill_1\fP () noexcept"
.br
.ti -1c
.RI "constexpr void \fBset_fill_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_0\fP () noexcept"
.br
.RI "'Funciones que ponen a constantes(constexpr) los objetos un subintervalo
o subrango de base_t cualquiera'  "
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_dig\fP (\fBdig_t\fP dig) noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_Bp1\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires (n<L)constexpr bool \fBis_B_pow_m1\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires (n<L\-1)constexpr bool \fBis_B_pow\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_any_B_pow\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of\fP (\fBdig_t\fP d) const"
.br
.ti -1c
.RI "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < L)&&(ibegin != iend))constexpr \fBreg_N_digs_t\fP<(ibegin< iend)?(iend\-ibegin):(ibegin\-iend)> \fBsubregister\fP () const noexcept"
.br
.RI "TAKE A SUBREGISTER OF A REGISTER OF DIGITS\&. "
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBC_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBC_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator!\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator\-\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator<<\fP (\fBsize_t\fP n) const noexcept"
.br
.RI "OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. "
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator<<=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator>>=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator>>\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBrem_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBm_rem_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBmer_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBm_mer_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator|=\fP (const \fBbase_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator|\fP (const \fBreg_digs_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBreg_digs_t\fP & \fBoperator&=\fP (const \fBreg_digs_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBreg_digs_t\fP \fBoperator&\fP (const \fBreg_digs_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr int32_t \fBindex_of_MSDig\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator==\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.RI "COMPARACIONES ENTRE BASE_T Y DIG_T EN FORMA BASE_T @ DIG_T\&. "
.ti -1c
.RI "constexpr bool \fBoperator!=\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator>\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator<\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator>=\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBoperator<=\fP (const \fBdig_t\fP &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator==\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator!=\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator>\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator<\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator>=\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr bool \fBoperator<=\fP (const \fBreg_N_digs_t\fP< M > &rarg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP M> constexpr std::strong_ordering \fBoperator<=>\fP (const \fBreg_N_digs_t\fP< M > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr std::weak_ordering \fBoperator<=>\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bp1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_SINT_T\fP \fBssi_Bp1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_0\fP () noexcept"
.br
.RI "PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL  "
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBregd_base_N_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_0\fP () noexcept"
.br
.RI "IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL  "
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_0\fP () noexcept"
.br
.RI "IDEM QUE ANTES PERO CON LA CLASE DERIVADA, LA ACTUAL TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL  "
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_digs_t\fP \fBregd_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBmake_base_t\fP (const std::initializer_list< \fBdig_t\fP > &larg)"
.br
.RI "Funcion miembro para generar un objeto tipo base_t y devolverlo desde un std::initializer_list<dig_t>  "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type, \fBsize_t\fP N> 
.br
requires (((sizeof\&.\&.\&.(Ints_type)) <= L)&&(N>0))static constexpr \fBbase_N_t\fP< N > \fBnormalize\fP (Ints_type \&.\&.\&. digits_pow_i) noexcept"
.br
.ti -1c
.RI "static constexpr \fBreg_digs_t\fP \fBcat\fP (const \fBreg_digs_t\fP &arg) noexcept"
.br
.RI "STATIC REG_DIGS_T CAT(REG_DIGS_T) "
.ti -1c
.RI "template<\fBsize_t\fP M> static constexpr \fBreg_N_digs_t\fP< L+M > \fBcat\fP (const \fBreg_digs_t\fP &larg, const \fBreg_N_digs_t\fP< M > &rarg) noexcept"
.br
.RI "STATIC <M> REG_N_DIGS_T<L+M> CAT(REG_DIGS_T,REG_N_DIGS_T<M>) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< L+1 > \fBcat\fP (const \fBreg_digs_t\fP &larg, \fBdig_t\fP rarg) noexcept"
.br
.RI "STATIC REG_DIGS_T<L+1> CAT(REG_DIGS_T,DIG_T) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< 1+L > \fBcat\fP (\fBdig_t\fP larg, const \fBreg_digs_t\fP &rarg) noexcept"
.br
.RI "REG_N_DIGS_T<1+L> CAT(DIG_T,REG_DIGS_T) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< 1 > \fBcat\fP (\fBdig_t\fP larg) noexcept"
.br
.RI "STATIC REG_N_DIGS_T<1> CAT(DIG_T) "
.ti -1c
.RI "static constexpr \fBreg_N_digs_t\fP< 2 > \fBcat\fP (\fBdig_t\fP larg, \fBdig_t\fP rarg) noexcept"
.br
.RI "STATIC REG_N_DIGS_T<1+1> CAT(DIG_T,DIG_T) "
.ti -1c
.RI "template<typename T0 , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.)&& (std::is_same_v<T0,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< 1+(sizeof \&.\&.\&.(Ts))> \fBcat\fP (T0 dig0, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< L+1+(sizeof \&.\&.\&.(Ts))> \fBcat\fP (\fBreg_digs_t\fP larg, T dig, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< L+1+(sizeof \&.\&.\&.(Ts))> \fBcat\fP (T dig, Ts \&.\&.\&. dig_pack, \fBreg_digs_t\fP rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP \&.\&.\&. N_pack> 
.br
requires ((N>0)&&((N_pack>0)&&\&.\&.\&.))static constexpr \fBreg_N_digs_t\fP< N+(\&.\&.\&.+(N_pack))> \fBcat\fP (\fBreg_N_digs_t\fP< N > larg, \fBreg_N_digs_t\fP< N_pack > \&.\&.\&. rarg_pack) noexcept"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L>
.br
requires ((suitable_base<UINT_T,B>())&&(L > 0))
.br
struct NumRepr::reg_digs_t< UINT_T, B, L >"
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::base_N_t\fP =  std::array<\fBdig_t\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::base_t\fP =  \fBbase_N_t\fP<L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::dig_t\fP =  \fBdig_t\fP<UINT_T,B>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_N_digs_t =  \fBreg_digs_t\fP<UINT_T,B,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::res_base_N_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_N_t\fP<N>,op,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::res_base_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_t\fP,op,L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::SIG_SINT_T\fP =  typename \fBtype_traits::sig_SInt_for_UInt_t\fP<UINT_T>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::SIG_UINT_T\fP =  typename \fBtype_traits::sig_UInt_for_UInt_t\fP<UINT_T>"

.SH "Documentación del constructor y destructor"
.PP 
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
Constructores de \fBreg_digs_t\fP
.PP
Constructor por defecto (rellena de \fBdig_t(0)\fP todo el array)  
.PP
.nf
334                  : base_t{regd_base_0()} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (const std::initializer_list< \fBdig_t\fP > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Constructor por lista de digitos utilizando la función make_base_t  
.PP
.nf
368                  : base_t{make_base_t(arg)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Constructor por argumentos tipo \fBdig_t\fP: deduce el tipo  
.PP
.nf
377                  : base_t{(utilities::pack2array<Ts\&.\&.\&.>{})(args\&.\&.\&.)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (const \fBbase_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE EL TIPO BASE\&. 
.PP
.nf
381 : base_t{rarg} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (\fBbase_t\fP && rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR MOVIMIENTO DESDE EL TIPO BASE\&. 
.PP
.nf
384 : base_t{std::move(rarg)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Constructor copia desde un array cualquiera de dígitos \fBdig_t\fP (usando copy_arg_N<N>)  
.PP
.nf
458                  : base_t{copy_arg_N<N>(arg)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (const \fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Constructor por movimiento desde un array cualquiera de dígitos \fBdig_t\fP (usando move_arg_N<N>)  
.PP
.nf
466                  : base_t{move_arg_N<N>(std::move(arg))} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::reg_digs_t (Ints_type \&.\&.\&. dig_pow_i)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
<summary='Constructor copia desde una sucesión de objetos enteros variádica, normalizándolos'>  
.PP
.nf
544                                                                       :
545                 base_t(normalize<Ints_type\&.\&.\&.>(dig_pow_i\&.\&.\&.)) {}
.fi
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP const  & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::back () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
310         { return (this->base_t::back()); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::back ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
308         { return (this->base_t::back()); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBbase_t\fP * \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::base_this ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
.nf
61                                               {
62         return static_cast<const base_t*>(this);
63 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::begin ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
En este bloque hacemos esta clase wrapper como si fuese una clase derivada de base_t Para esto replicamos y sobrecargamos cada una de las funciones por defecto de std::array  
.PP
.nf
280         { return base_t::begin(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::C_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1134         { return std::move(reg_digs_t{*this}\&.mC_B());    }
.fi
.PP
Hace referencia a \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval const \fBbase_t\fP * \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::c_base_this () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
.nf
47                                                                {
48         return static_cast<const base_t*>(this);
49 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::C_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1130         {       return std::move(reg_digs_t{*this}\&.mC_Bm1()); }
.fi
.PP
Hace referencia a \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (const \fBreg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC REG_DIGS_T CAT(REG_DIGS_T) STATIC FUNCTIONS : CONCATENATE REGISTERS AND DIGITS reg_digs_t<1> \fBcat(dig_t)\fP \fBreg_digs_t\fP<1+1> \fBcat(dig_t,dig_t)\fP \fBreg_digs_t\fP cat(reg_digs_t) <M> reg_N_digs_t<L+M> cat(reg_digs_t,reg_N_digs_t<M>) reg_N_digs_t<L+1> cat(reg_digs_t,dig_t) reg_N_digs_t<1+L> cat(dig_t,reg_digs_t) reg_N_digs_t<sizeof\&.\&.\&.(dig_pack)> cat(dig_t \&.\&.\&. dig_pack) VARIADIC PACK 
.PP
.nf
965         {       return std::move(reg_digs_t{arg});      }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> static constexpr \fBreg_N_digs_t\fP< L+M > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (const \fBreg_digs_t\fP< UINT_T, B, L > & larg, const \fBreg_N_digs_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC <M> REG_N_DIGS_T<L+M> CAT(REG_DIGS_T,REG_N_DIGS_T<M>) 
.PP
.nf
972                  {
973                 base_N_t<L+M> ret;
974                 for(size_t ix{0} ; ix < L ; ++ix)
975                         ret[ix] = larg[ix];
976                 for(size_t ix{L} ; ix < M ; ++ix)
977                         ret[ix] = rarg[ix];
978                 return std::move(ret);
979         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBreg_N_digs_t\fP< L+1 > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (const \fBreg_digs_t\fP< UINT_T, B, L > & larg, \fBdig_t\fP rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC REG_DIGS_T<L+1> CAT(REG_DIGS_T,DIG_T) 
.PP
.nf
984                  {
985                 reg_N_digs_t<L+1> ret;
986                 for(size_t ix{0} ; ix < L ; ++ix)
987                         ret[ix] = larg[ix];
988                 ret[L] = rarg;
989                 return std::move(ret);
990         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBreg_N_digs_t\fP< 1 > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (\fBdig_t\fP larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC REG_N_DIGS_T<1> CAT(DIG_T) 
.PP
.nf
1006         {       return std::move(reg_N_digs_t<1>{larg});        }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBreg_N_digs_t\fP< 1+L > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (\fBdig_t\fP larg, const \fBreg_digs_t\fP< UINT_T, B, L > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
REG_N_DIGS_T<1+L> CAT(DIG_T,REG_DIGS_T) 
.PP
.nf
995                  {
996                 reg_N_digs_t<1+L> ret;
997                 ret[0] = larg;
998                 for(size_t ix{1} ; ix < L+1 ; ++ix)
999                         ret[ix] = rarg[ix-1];
1000                 return std::move(ret);
1001         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBreg_N_digs_t\fP< 2 > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (\fBdig_t\fP larg, \fBdig_t\fP rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
STATIC REG_N_DIGS_T<1+1> CAT(DIG_T,DIG_T) 
.PP
.nf
1010                                                             {
1011                 reg_N_digs_t<2> ret;
1012                 ret[0] = larg;
1013                 ret[1] = rarg;
1014                 return std::move(ret);
1015         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< L+1+(sizeof \&.\&.\&.(Ts))> \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (\fBreg_digs_t\fP< UINT_T, B, L > larg, T dig, Ts \&.\&.\&. dig_pack)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC REG_N_DIGS_T<L+1+(SIZEOF\&.\&.\&.(DIG_PACK))> CAT(REG_DIGS_T,DIG_T,DIG_T \&.\&.\&. DIG_PACK) VARIADIC 
.PP
.nf
1039                                                                     {
1040                 return cat(larg,cat(dig,dig_pack\&.\&.\&.));
1041         }
.fi
.PP
Hace referencia a \fBcat()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP \&.\&.\&. N_pack> 
.br
requires ((N>0)&&((N_pack>0)&&\&.\&.\&.))static constexpr \fBreg_N_digs_t\fP< N+(\&.\&.\&.+(N_pack))> \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (\fBreg_N_digs_t\fP< N > larg, \fBreg_N_digs_t\fP< N_pack > \&.\&.\&. rarg_pack)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC REG_N_DIGS_T<SIZE_T N,SIZE_T \&.\&.\&. N_PACK> CAT(REG_N_DIGS_T<N> LARG,
                REG_N_DIGS_T<N_PACK> \&.\&.\&. RARG_PACK
        ) VARIADIC PACK 
.PP
.nf
1066                                 {
1067                 return cat(larg,rarg_pack\&.\&.\&.);
1068         }
.fi
.PP
Hace referencia a \fBcat()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.) && (std::is_same_v<T,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< L+1+(sizeof \&.\&.\&.(Ts))> \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (T dig, Ts \&.\&.\&. dig_pack, \fBreg_digs_t\fP< UINT_T, B, L > rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC REG_N_DIGS_T<L+1+(SIZEOF\&.\&.\&.(DIG_PACK))> CAT(DIG_T,DIG_T \&.\&.\&. DIG_PACK,REG_DIGS_T) VARIADIC 
.PP
.nf
1053                  {
1054                 return cat(cat(dig,dig_pack\&.\&.\&.),rarg);
1055         }
.fi
.PP
Hace referencia a \fBcat()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename T0 , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,\fBdig_t\fP>)&&\&.\&.\&.)&& (std::is_same_v<T0,\fBdig_t\fP>) )static constexpr \fBreg_N_digs_t\fP< 1+(sizeof \&.\&.\&.(Ts))> \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cat (T0 dig0, Ts \&.\&.\&. dig_pack)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
STATIC REG_N_DIGS_T<SIZEOF\&.\&.\&.(DIG_PACK)> CAT(DIG_T,DIG_T \&.\&.\&. DIG_PACK) VARIADIC 
.PP
.nf
1026                                                                       {
1027                 return cat(dig_0,dig_pack\&.\&.\&.);
1028         }
.fi
.PP
Hace referencia a \fBcat()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cbegin () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
282         { return base_t::cbegin(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cend () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
286         { return base_t::cend(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cp_base_cthis () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
.nf
75                                                        {
76         return std::move(base_t{*(cr_base_cthis())});
77 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cp_cthis () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
#define cpcthis \fBreg_digs_t\fP cp_cthis{*this} 
.PP
.nf
72                                                       {
73         return std::move(reg_digs_t{*this});
74 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBdig_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cp_cthis (\fBsize_t\fP k) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
78                                                                  {
79         base_t cthis{ cp_base_cthis() };
80         return std::move(cthis[k]);
81 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cpy_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
668                               {
669                 auto cpy_this{*(this->data())};
670                 return cpy_this;
671         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval const \fBbase_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cr_base_cthis () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
.nf
50                                                                {
51         return (*(c_base_this()));
52 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cr_cthis () const\fC [inline]\fP, \fC [noexcept]\fP"

.PP
#define crrefcthis const \fBreg_digs_t\fP & cr_cthis{*this} cthis significa this_content y es referencia u objeto copia cr_cthis == const actual_type & cr_cthis{*this}; r_cthis == actual_type & r_cthis{*this}; cp_cthis == actual_type cp_cthis{*this}; 
.PP
.nf
44                                                                {
45         return (*this);
46 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBdig_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::cr_cthis (\fBsize_t\fP k) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
53                                                                  {
54         const base_t& cthis{ cr_base_cthis() };
55         return (cthis[k]);
56 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::crbegin () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
290         { return base_t::crbegin(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::crend () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
294         { return base_t::crend(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBdig_t\fP * \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::data () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
<summary=' sobrecarga de las funciones miembro : '> constexpr const dig_t* \fBdata() const \fPnoexcept;  
.PP
\fBDevuelve\fP
.RS 4

.RE
.PP

.PP
.nf
660                                                      {
661                 return (static_cast<const dig_t*>(this->base_t::data()));
662         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::dig_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
97         {return dig_t::dig_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::dig_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
99         {return dig_t::dig_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::dig_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
101         {return dig_t::dig_Bm1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::dig_Bm2 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
105         {return dig_t::dig_Bm2();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::dig_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
103         {return dig_t::dig_max();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::dig_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
107         {return dig_t::dig_submax();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::empty () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
301         { return base_t::empty(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::end ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
284         { return base_t::end(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::fill (const \fBdig_t\fP & value)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
313         { this->base_t::fill(value); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP const  & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::front () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
306         { return (this->base_t::front()); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::front ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
304         { return (this->base_t::front()); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr int32_t \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::index_of_MSDig () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
NOS DEVUELVE EL ÍNDICE DEL DÍGITO NO 0 DE POTENCIA DE B MAS GRANDE NOS DEVUELVE 0 SI ES UN DÍGITO NO 0 NOS DEVUELVE -1 SI ES EL DÍGITO 0 CUALQUIER OTRO CASO NOS DARÁ MAYOR QUE 0 
.PP
.nf
1260                                                 {
1261                 for(int32_t ix{L-1} ; ix > -1 ; --ix) {
1262                         if (cr_cthis()[ix]\&.is_not_0())
1263                                 return ix;
1264                 }
1265                 return (-1);
1266         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_0 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
774         {
775                 for(const auto elem : cr_cthis()) {
776                         if(elem\&.is_not_0())
777                                 return false;
778                 }
779                 return true;
780         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
783                                    {
784                 if (cr_cthis()[0]\&.is_not_1())
785                         return false;
786                 for(size_t ix{1} ; ix<L ; ++ix) {
787                         if(cr_cthis()[ix]\&.is_not_0())
788                                 return false;
789                 }
790                 return true;
791         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_any_B_pow () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
915         {
916                 const auto pred_not_0 = [](dig_t d){return (d\&.is_not_0());};
917                 const auto it{std::find_if(cr_cthis()\&.begin(),cr_cthis()\&.end(),pred_not_0)};
918                 if (it != cr_cthis()\&.end()) {
919                         const size_t card{std::count_if(cr_cthis()\&.begin(),cr_cthis()\&.end(),pred_not_0)};
920                         if (card != 1)
921                                 return false;
922                         else
923                                 return (it->is_0());
924                 }
925                 return false;
926         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
806         {
807                 if constexpr (L == 1) return false;
808                 else {
809                         if (cr_cthis()[0]\&.is_not_0())
810                                 return false;
811                         if (cr_cthis()[1]\&.is_not_1())
812                                 return false;
813                         for (size_t ix{ 2 }; ix < L; ++ix) {
814                                 if (cr_cthis()[ix]\&.is_not_0())
815                                         return false;
816                         }
817                         return true;
818                 }
819         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires (n<L\-1)constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_B_pow () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
871         {
872                 if constexpr (n == 0) {
873                         if (cr_cthis()[0]\&.is_not_1())
874                                 return false;
875                         for (size_t ix{1} ; ix < L ; ++ix)
876                                 if (cr_cthis()[ix]\&.is_not_0())
877                                         return false;
878                         return true;
879                 }
880                 else if constexpr (n == 1) {
881                         if (cr_cthis()[0]\&.is_not_0())
882                                 return false;
883                         if (cr_cthis()[1]\&.is_not_1())
884                                 return false;
885                         for (size_t ix{2} ; ix < L ; ++ix)
886                                 if (cr_cthis()[ix]\&.is_not_0())
887                                         return false;
888                         return true;
889                 }
890                 else if constexpr (n == 2) {
891                         if (cr_cthis()[0]\&.is_not_0() || cr_cthis()[1]\&.is_not_0())
892                                 return false;
893                         if (cr_cthis()[2]\&.is_not_1())
894                                 return false;
895                         for (size_t ix{3} ; ix < L ; ++ix)
896                                 if (cr_cthis()[ix]\&.is_not_0())
897                                         return false;
898                         return true;
899                 }
900                 else {
901                         for (size_t ix{0} ; ix < n ; ++ix)
902                                 if (cr_cthis()[ix]\&.is_not_0())
903                                         return false;
904                         if (cr_cthis()[n]\&.is_not_1())
905                                 return false;
906                         for (size_t ix{n+1} ; ix < L ; ++ix)
907                                 if (cr_cthis()[ix]\&.is_not_0())
908                                         return false;
909                         return true;
910                 }
911         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires (n<L)constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_B_pow_m1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
841         {
842                 if constexpr (n == 0) {
843                         return cr_cthis()\&.is_0();
844                 }
845                 else if constexpr (n == 1) {
846                         return cr_cthis()\&.is_Bm1();
847                 }
848                 else if constexpr (n == 2) {
849                         if (cr_cthis()[1]\&.is_not_Bm1() || cr_cthis()[0]\&.is_not_Bm1())
850                                 return false;
851                         for(size_t ix{2} ; ix < L ; ++ix)
852                                 if (cr_cthis()[ix]\&.is_not_0())
853                                         return false;
854                         return true;
855                 }
856                 else {
857                         for(size_t ix{0} ; ix < n ; ++ix)
858                                 if (cr_cthis()[ix]\&.is_not_Bm1())
859                                         return false;
860                         for(size_t ix{n} ; ix < L ; ++ix)
861                                 if (cr_cthis()[ix]\&.is_not_0())
862                                         return false;
863                         return true;
864                 }
865         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
794                                      {
795                 if (cr_cthis()[0]\&.is_not_Bm1())
796                         return false;
797                 for(size_t ix{1} ; ix<L ; ++ix) {
798                         if(cr_cthis()[ix]\&.is_not_0())
799                                 return false;
800                 }
801                 return true;
802         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_Bp1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
822                                      {
823                 if constexpr (L == 1) return false;
824                 else {
825                         if (cr_cthis()[0]\&.is_not_1())
826                                 return false;
827                         if (cr_cthis()[1]\&.is_not_1())
828                                 return false;
829                         for (size_t ix{ 2 }; ix < L; ++ix) {
830                                 if (cr_cthis()[ix]\&.is_not_0())
831                                         return false;
832                         }
833                         return true;
834                 }
835         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_filled_of (\fBdig_t\fP d) const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
945                                          {
946                 for (size_t ix{0} ; ix < L ; ++ix)
947                         if (cr_cthis()[ix] != d)
948                                 return false;
949                 return true;
950         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_filled_of_1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
929                                              {
930                 for (size_t ix{0} ; ix < L ; ++ix)
931                         if (cr_cthis()[ix]\&.is_not_1())
932                                 return false;
933                 return true;
934         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::is_filled_of_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
937                                                {
938                 for (size_t ix{0} ; ix < L ; ++ix)
939                         if (cr_cthis()[ix]\&.is_not_Bm1())
940                                 return false;
941                 return true;
942         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::m_mer_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1217                                                       {
1218                 reg_digs_t& cthis{*this};
1219                 cthis >>= L-n;
1220                 return (cthis);
1221         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::m_rem_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1202                                                       {
1203                 reg_digs_t & cthis{*this};
1204                 cthis <<= L-n;
1205                 return (*this);
1206         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::make_base_t (const std::initializer_list< \fBdig_t\fP > & larg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
Funcion miembro para generar un objeto tipo base_t y devolverlo desde un std::initializer_list<dig_t>  <function name='make_base_t'></function> 
.PP
\fBParámetros\fP
.RS 4
\fIconst std::initializer_list<dig_t>& larg\fP 
.RE
.PP
<returns='rarg : base_t'>
.PP
.nf
344                                                                                     {
345                 base_t rarg;
346                 if (larg\&.size() >= L) {
347                         for (size_t ix{ 0 }; ix < L; ++ix) {
348                                 rarg[ix] = larg[ix];
349                         }
350                 }
351                 else {
352                         for (size_t ix{ 0 }; ix < larg\&.size() ; ++ix) {
353                                 rarg[ix] = larg[ix];
354                         }
355                         for (size_t ix{ larg\&.size() }; ix < L ; ++ix) {
356                                 rarg[ix] = larg[ix];
357                         }
358                 }
359                 return std::move(rarg);
360         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBsize_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::max_size () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
299         { return base_t::max_size(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::mC_B ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1113                                            {
1114                 reg_digs_t& cthis{*this};
1115                 cthis\&.mC_Bm1();
1116                 for(size_t ix{0} ; ix < L ; ++ix) {
1117                         if (cthis[ix]\&.is_not_Bm1()) {
1118                                 ++cthis[ix];
1119                                 return (cthis);
1120                         }
1121                         else {
1122                                 cthis[ix]\&.set_0();
1123                         }
1124                 }
1125                 return (cthis);
1126         }
.fi
.PP
Hace referencia a \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP y \fBNumRepr::reg_digs_t< UINT_T, B, L >::set_0()\fP\&.
.PP
Referenciado por \fBNumRepr::reg_digs_t< UINT_T, B, L >::C_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::mC_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
A partir de aquí no he hecho las sustituciones de const \fBreg_digs_t\fP & cthis{*this}; / \fBreg_digs_t\fP & cthis{*this}; / \fBreg_digs_t\fP cthis{*this}; Por las correspondientes funciones \fBcr_cthis()\fP / \fBr_cthis()\fP / \fBcp_cthis()\fP OPERADORES ARITMETICOS \fBC_B()\fP \fBC_Bm1()\fP \fBmC_B()\fP \fBmC_Bm1()\fP \fBoperator!()\fP \fBoperator-()\fP 
.PP
.nf
1104                                              {
1105                 reg_digs_t& cthis{*this};
1106                 for(size_t ix{0} ; ix < L ; ++ix) {
1107                                 cthis[ix]\&.mC_Bm1();
1108                 }
1109                 return (cthis);
1110         }
.fi
.PP
Hace referencia a \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP\&.
.PP
Referenciado por \fBNumRepr::reg_digs_t< UINT_T, B, L >::C_Bm1()\fP, \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_B()\fP y \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::mer_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1210                                                   {
1211                 reg_digs_t ret{*this};
1212                 ret >>= L-n;
1213                 return std::move(ret);
1214         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c \&.\&.\&. Ints_type, \fBsize_t\fP N> 
.br
requires (((sizeof\&.\&.\&.(Ints_type)) <= L)&&(N>0))static constexpr \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::normalize (Ints_type \&.\&.\&. digits_pow_i)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
<summary='Función de normalización a dig_t (dígitos base B) que construye un objeto de tipo '>  <summary='base_t desde una sucesión variádica de enteros cualquiera'>  <function name='normalize'></function> 
.PP
\fBParámetros\fP
.RS 4
\fIInts_type \&.\&.\&. digits_pow_i\fP 
.RE
.PP
<returns='base_t'>< CREA UN STD_ARRAY DEL TIPO INT PASADO POR ARGUMENTOS DE TAMANO EL PACK DE ARGUMENTOS PASADO (MENOR O IGUAL QUE L)
.PP
< DEVUELVE EL TIPO INTERNO DE ELEMENTO DEL ARRAY ANTERIOR [UN TIPO ENTERO]
.PP
< DEVUELVE EL TAMANO DEL ARRAY ANTERIOR (TAMAÑO <= L)
.PP
< ELIGE ENTRE CUATRO TIPOS DE ENTEROS SEGUN TENGAN SIGNO O NO Y SU TAMANO SEA MAYOR O MENOR QUE EL PROPIO DE LA BASE UINT_T TIPO PROPIO ES : UINT_T TIPO PASADO COMO ARGUMENTO ES : UNIQUE_TYPE LOS TIPOS PASADOS EN LOS ARGUMENTOS HAN DE SER IGUALES ENTRE SI PARA EL INTERROGANTE CONDICIONAL UTILIZAMOS UNSIGNED_INTEGRAL_C PRIMERA PREGUNTA O MAS EXTERIOR IS_UNISGNED_SZ_GT_V<T,S> PREGUNTAS SEGUNDAS O MAS INTERIORES PARA ELEGIR EL TIPO APROPIADO EN CADA CASO USAMOS SIG_UINT_FOR_UINT_T<UINT_T> SIG_UINT_FOR_UINT_T<UNIQUE_TYPE> SIG_UINT_FOR_UINT_T<UINT_T> SIG_UINT_FOR_SINT_T<UNIQUE_TYPE>
.PP

.PP
.nf
481                  {
484                 using pack_type         = typename utilities::pack2array<Ints_type\&.\&.\&.>;
487                 using unique_type = typename pack_type::elem_type;
489                 constexpr size_t pack_sz{pack_type::pack_size()};
504                 using namespace NumRepr::type_traits;
505                 using SUInt_type =
506                         typename std::conditional_t
507                         <
508                                         unsigned_integral_c<unique_type>,
509                                         typename std::conditional_t<
510                                                 is_unsigned_sz_gt_v<UINT_T,unique_type>,
511                                                         sig_UInt_for_UInt_t<UINT_T>,
512                                                         sig_UInt_for_UInt_t<unique_type>
513                                          >,
514                                         typename std::conditional_t<
515                                                 is_unsigned_sz_gt_v<UINT_T,sig_UInt_for_SInt_t<unique_type>>,
516                                                         sig_UInt_for_UInt_t<UINT_T>,
517                                                         sig_UInt_for_SInt_t<unique_type>
518                                         >
519                         >;
520                 std::array<SUInt_type,pack_sz> ret_array{digits_pow_i\&.\&.\&.};
521                 base_N_t<pack_sz> ret;
522                 if constexpr (N <= pack_sz) {
523                         for (size_t ix{ 0 }; ix < pack_sz; ++ix) {
524                                 ret[ix] = dig_t(ret_array[ix]);
525                         }
526                 }
527                 else {
528                         for (size_t ix{ 0 }; ix < pack_sz; ++ix) {
529                                 ret[ix] = dig_t(ret_array[ix]);
530                         }
531                         for (size_t ix{ pack_sz }; ix < L; ++ix) {
532                                 ret[ix] = dig_t(0);
533                         }
534                 }
535                 return std::move(ret);
536         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP Int_Type () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
SE PODRÍA HACER PARA UINT128_T\&. Algunas Conversiones 
.PP
.nf
631                                                             {
632                 using type_traits::maxbase;
633                 uint64_t retInt{0};
634                 uint64_t BasePowIx{1};
635                 for(size_t k{0} ; k < L ; ++k) {
636                         retInt += cr_cthis(k)*BasePowIx;
637                         BasePowIx *= B;
638                         if(     (k+1 < L)
639                                                 &&
640                                         (maxbase<Int_Type>() < (retInt+((cr_cthis(k+1)*BasePowIx)))
641                                 ))
642                         {       return retInt; }
643                 }
644                 return retInt;
645         }
.fi
.PP
Hace referencia a \fBNumRepr::type_traits::maxbase()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::operator! () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1138         { return C_Bm1(); }
.fi
.PP
Hace referencia a \fBC_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBdig_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1287                                                             {
1288                 const reg_digs_t & cthis{*this};
1289                 for(size_t ix{1} ; ix < L ; ++ix)
1290                         if (cthis[ix]\&.is_not_0())
1291                                 return true;
1292                 if (cthis[0] != rarg)
1293                         return true;
1294                 return false;
1295 
1296         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBreg_N_digs_t\fP< M > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1375                                                                        {
1376                 const reg_digs_t & cthis{*this};
1377 
1378                 constexpr size_t P{std::min(L,M)};
1379                 constexpr size_t Q{std::max(L,M)};
1380                 constexpr bool L_gt_M{L>M};
1381 
1382                 if constexpr (L!=M) {
1383                         for (size_t ix{P} ; ix < Q ; ++ix) {
1384                                 if constexpr (L_gt_M) {
1385                                         if (cthis[ix]\&.is_not_0())
1386                                                 return true;
1387                                 }
1388                                 else {
1389                                         if (rarg[ix]\&.is_not_0())
1390                                                 return true;
1391                                 }
1392                         }
1393                 }
1394                 for(size_t ix{0} ; ix < P ; ++ix)
1395                         if (cthis[ix] != rarg[ix])
1396                                 return true;
1397                 return false;
1398         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP& (const \fBreg_digs_t\fP< UINT_T, B, L > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1249                                                                  {
1250                 reg_digs_t ret{*this};
1251                 ret &= rarg;
1252                 return std::move(ret);
1253         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP&= (const \fBreg_digs_t\fP< UINT_T, B, L > & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1240                                                                          {
1241                 reg_digs_t& cthis{*this};
1242                 for(size_t ix{0} ; ix < L ; ++ix) {
1243                         cthis[ix] &= rarg[ix];
1244                 }
1245                 return (cthis);
1246         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1142         { return C_B(); }
.fi
.PP
Hace referencia a \fBC_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBdig_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1310                                                            {
1311                 const reg_digs_t & cthis{*this};
1312                 for(size_t ix{1} ; ix < L ; ++ix)
1313                         if (cthis[ix]\&.is_not_0())
1314                                 return false;
1315                 if (cthis[0] >= rarg)
1316                         return false;
1317                 return true;
1318         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBreg_N_digs_t\fP< M > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1429                                                                      {
1430                 const reg_digs_t & cthis{*this};
1431                 constexpr size_t P{std::min(L,M)};
1432                 constexpr size_t Q{std::max(L,M)};
1433                 constexpr bool L_gt_M{L>M};
1434 
1435                 if constexpr (L != M) {
1436                         for(size_t ix{P} ; ix < Q ; ++ix) {
1437                                 if constexpr (L_gt_M) {
1438                                         if (cthis[ix]\&.is_not_0())
1439                                                 return false;
1440                                 }
1441                                 else {
1442                                         if (rarg[ix]\&.is_not_0())
1443                                                 return true;
1444                                 }
1445                         }
1446                 }
1447 
1448                 for(int32_t ix{L} ; ix > -1 ; --ix)
1449                         if (cthis[ix] < rarg[ix])
1450                                 return true;
1451                 return false;
1452         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<< (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N\&. MULTIPLY BY THE BASE B (10) << <<= DIVIDE BY THE BASE B (10) >> >>= REMAINDER BY THE BASE B (10) REM_B_N M_REM_B_N MULTIPLICATIVE CARRY BY THE BASE B (10) MER_B_N M_MER_B_N 
.PP
.nf
1152                                                          {
1153                 reg_digs_t cpthis{*this};
1154                 for(int32_t ix{L-1-n} ; ix > -1 ; --ix) {
1155                         cpthis[ix+n]    = cpthis[ix];
1156                 }
1157                 for(int32_t ix{0} ; ix < n ; ++ix) {
1158                         cpthis[ix]              = dig_0();
1159                 }
1160                 return std::move(cpthis);
1161         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<<= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1164                                                             {
1165                 reg_digs_t & cthis{*this};
1166                 for(int32_t ix{L-1-n} ; ix > -1 ; --ix) {
1167                         cthis[ix+n]     = cthis[ix];
1168                 }
1169                 for(int32_t ix{0} ; ix < n ; ++ix) {
1170                         cthis[ix]       = dig_0();
1171                 }
1172                 return (*this);
1173         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBdig_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1332                                                             {
1333                 const reg_digs_t & cthis{*this};
1334                 for(size_t ix{1} ; ix < L ; ++ix)
1335                         if (cthis[ix]\&.is_not_0())
1336                                 return false;
1337                 if (cthis[0] > rarg)
1338                         return false;
1339                 else
1340                         return true;
1341         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBreg_N_digs_t\fP< M > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1462                                                                       {
1463                 const reg_digs_t & cthis{*this};
1464                 return (!(cthis > rarg));       }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr std::weak_ordering \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1484         {
1485                 const reg_digs_t& cthis{*this};
1486                 if (cthis > arg)
1487                         return std::weak_ordering::greater;
1488                 else if (cthis < arg)
1489                         return std::weak_ordering::less;
1490                 else
1491                         return std::weak_ordering::equivalent;
1492         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr std::strong_ordering \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBreg_N_digs_t\fP< M > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1471                  {
1472                 const reg_digs_t& cthis{*this};
1473                 if (cthis == arg)
1474                         return std::strong_ordering::equal;
1475                 else if (cthis < arg)
1476                         return std::strong_ordering::less;
1477                 else
1478                         return std::strong_ordering::greater;
1479         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN DIGITO (CONVERSION) 
.PP
.nf
587                  {
588                 if ((&(r_cthis(0)))!=(&arg)) {
589                         r_cthis()\&.set_0();
590                         r_cthis(0) = arg;
591                 }
592                 return (*this);
593         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBreg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Sobrecarga del operador copia  OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE REG_N_DIGS_T EN LA IZQUIERDA 
.PP
.nf
556         {
557                 if (this!= &arg)
558                         copy_arg_N<N>(arg);
559                 return (*this);
560         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (Int_Type arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN REG_DIGS_T 
.PP
.nf
599                                                              {
600                 using type_traits::maxbase;
601                 constexpr sint128_t B_128t_v{static_cast<sint128_t>(B)};
602                 constexpr bool puede_multiplicarse{
603                                 (maxbase<sint128_t>()/B_128t_v) > 0
604                 };
605                 if ((&(this->m_dc)) != (&arg)) {
606                         sint128_t creg_g{static_cast<sint128_t>(arg)};
607                         sint128_t BasePowIx{B_128t_v};
608                         for(size_t k{1u} ; k < L ; ++k) {
609                                 if constexpr (puede_multiplicarse)
610                                         BasePowIx *= B_128t_v;
611                                 else
612                                         break;
613                         }
614                         while (creg_g < 0) {
615                                 creg_g += BasePowIx;
616                         }
617                         for(size_t k{0u} ; k < L ; ++k){
618                                 r_cthis(k) = dig_t(creg_g%B_128t_v);
619                                 creg_g /= B_128t_v;
620                         }
621                 }
622                 return (cr_cthis());
623         }
.fi
.PP
Hace referencia a \fBNumRepr::type_traits::maxbase()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr const \fBbase_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBreg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION ASIGNACION POR MOVIMIENTO DESDE REGS_N_DIGS_T EN LA QUE NO SE PUEDE COPIAR 
.PP
.nf
578         {
579                 if (this!=(&arg))
580                         move_arg_N<N>(std::move(arg));
581                 return (*this);
582         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBreg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE REG_N_DIGS_T EN LA IZQUIERDA 
.PP
.nf
567         {
568                 if (this != &arg)
569                         copy_arg_N<N>(arg);
570                 return (*this);
571         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBdig_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
COMPARACIONES ENTRE BASE_T Y DIG_T EN FORMA BASE_T @ DIG_T\&. SOBRECARGA DE LOS OPERADORES DE COMPARACION Y ORDEN 
.PP
.nf
1276                                                             {
1277                 const reg_digs_t & cthis{*this};
1278                 if (cthis[0] != rarg)
1279                         return false;
1280                 for(size_t ix{1} ; ix < L ; ++ix)
1281                         if (cthis[ix]\&.is_not_0())
1282                                 return false;
1283                 return true;
1284         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBreg_N_digs_t\fP< M > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
COMPARACIONES ENTRE REG_DIGS_T Y REG_N_DIGS_T HETEROGENEOS EN GENERAL EN FORMA REG_DIGS_T @ REG_N_DIGS_T<M> 
.PP
.nf
1348                                                                       {
1349                 const reg_digs_t & cthis{*this};
1350 
1351                 constexpr size_t P{std::min(L,M)};
1352                 constexpr size_t Q{std::max(L,M)};
1353                 constexpr bool L_gt_M{L>M};
1354 
1355                 if constexpr (L!=M) {
1356                         for (size_t ix{P} ; ix < Q ; ++ix) {
1357                                 if constexpr (L_gt_M) {
1358                                         if (cthis[ix]\&.is_not_0())
1359                                                 return false;
1360                                 }
1361                                 else {
1362                                         if (rarg[ix]\&.is_not_0())
1363                                                 return false;
1364                                 }
1365                         }
1366                 }
1367                 for(size_t ix{0} ; ix < P ; ++ix)
1368                         if (cthis[ix] != rarg[ix])
1369                                 return false;
1370                 return true;
1371         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBdig_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1299                                                            {
1300                 const reg_digs_t & cthis{*this};
1301                 for(size_t ix{1} ; ix < L ; ++ix)
1302                         if (cthis[ix]\&.is_not_0())
1303                                 return true;
1304                 if (cthis[0] > rarg)
1305                         return true;
1306                 return false;
1307         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBreg_N_digs_t\fP< M > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1402                                                                      {
1403                 const reg_digs_t & cthis{*this};
1404                 constexpr size_t P{std::min(L,M)};
1405                 constexpr size_t Q{std::max(L,M)};
1406                 constexpr bool L_gt_M{L>M};
1407 
1408                 if constexpr (L != M) {
1409                         for(size_t ix{P} ; ix < Q ; ++ix) {
1410                                 if constexpr (L>M) {
1411                                         if (cthis[ix]\&.is_not_0())
1412                                                 return true;
1413                                 }
1414                                 else {
1415                                         if (rarg[ix]\&.is_not_0())
1416                                                 return false;
1417                                 }
1418                         }
1419                 }
1420 
1421                 for(int32_t ix{L} ; ix > -1 ; --ix)
1422                         if (cthis[ix] > rarg[ix])
1423                                 return true;
1424                 return false;
1425         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBdig_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1321                                                             {
1322                 const reg_digs_t & cthis{*this};
1323                 for(size_t ix{1} ; ix < L ; ++ix)
1324                         if (cthis[ix]\&.is_not_0())
1325                                 return true;
1326                 if (cthis[0] >= rarg)
1327                         return true;
1328                 return false;
1329         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP M> constexpr bool \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBreg_N_digs_t\fP< M > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1456                                                                       {
1457                 const reg_digs_t & cthis{*this};
1458                 return (!(cthis < rarg));       }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>> (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1188                                                          {
1189                 reg_digs_t ret{*this};
1190                 ret >>= n;
1191                 return std::move(ret);
1192         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>>= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1176                                                             {
1177                 reg_digs_t & cthis{*this};
1178                 for(int32_t ix{0} ; ix < L-n ; ++ix) {
1179                         cthis[ix]               = cthis[ix+n];
1180                 }
1181                 for(int32_t ix{L-n} ; ix < L ; ++ix) {
1182                         cthis[ix]               =       dig_0();
1183                 }
1184                 return (*this);
1185         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> \fBdig_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP[] (\fBsize_t\fP ix)\fC [inline]\fP"

.PP
<summary='Sobrecarga del dig_t & operator[](size_t)'> 
.PP
.nf
679                                      {
680                 return (r_cthis()\&.base_t::operator[](ix));
681         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> const \fBdig_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP[] (\fBsize_t\fP ix) const\fC [inline]\fP"

.PP
<summary='Sobrecarga del const dig_t & operator[](size_t) const'> 
.PP
.nf
674                                                  {
675                 return (cr_cthis()\&.base_t::operator[](ix));
676         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP| (const \fBreg_digs_t\fP< UINT_T, B, L > & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1233                                                                        {
1234                 reg_digs_t ret{*this};
1235                 ret |= rarg;
1236                 return std::move(ret);
1237         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP|= (const \fBbase_t\fP & rarg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1224                                                                             {
1225                 reg_digs_t& cthis{*this};
1226                 for(size_t ix{0} ; ix < L ; ++ix) {
1227                         cthis[ix] |= rarg[ix];
1228                 }
1229                 return (cthis);
1230         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBbase_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::r_base_cthis ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
.nf
64                                                   {
65         return (*base_this());
66 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBreg_digs_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::r_cthis ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
#define rrefcthis \fBreg_digs_t\fP & r_cthis{*this} 
.PP
.nf
58                                                  {
59         return (*this);
60 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::r_cthis (\fBsize_t\fP k)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
67                                                     {
68         auto& cthis{ r_base_cthis() };
69         return (cthis[k]);
70 }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::rbegin ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
288         { return base_t::rbegin(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto & \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ref_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
664                                {
665                 return (*(this->data()));
666         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
IDEM QUE ANTES PERO CON LA CLASE DERIVADA, LA ACTUAL TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL  
.PP
.nf
245                                      {
246                 return reg_digs_t{regd_base_N_0<L>()};
247         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
250                                           {
251                 return reg_digs_t{regd_base_N_1<L>()};
252         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
260                                           {
261                 return reg_digs_t{regd_base_N_B<L>()};
262         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL  
.PP
.nf
210                                       {
211                 return base_t{regd_base_N_0<L>()};
212         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
215                                        {
216                 return base_t{regd_base_N_1<L>()};
217         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
225                                        {
226                 return base_t{regd_base_N_B<L>()};
227         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
220                                          {
221                 return base_t{regd_base_N_Bm1<L>()};
222         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_N_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL  
.PP
.nf
148                                                  {
149                 base_N_t<N> ret;
150                 for(dig_t& dig : ret) {
151                         dig = dig_0();
152                 }
153                 return ret;
154         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_N_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
158                                                  {
159                 base_N_t<N> ret{regd_base_N_0<N>()};
160                 ret[0] = dig_1();
161                 return ret;
162         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_N_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
174                                                  {
175                 base_N_t<N> ret{regd_base_N_0<N>()};
176                 ret[1] = dig_1();
177                 return ret;
178         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> static consteval \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_N_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
166                                                    {
167                 base_N_t<N> ret{regd_base_N_0<N>()};
168                 ret[0] = dig_Bm1();
169                 return ret;
170         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_N_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
183                                                        {
184                 base_N_t<N> ret{regd_base_N_0<N>()};
185                 ret[n] = dig_1();
186                 return ret;
187         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_N_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
192                                                           {
193                 base_N_t<N> ret{};
194                 for(size_t ix{0} ; ix < n ; ++ix) {
195                         ret[ix] = dig_Bm1();
196                 }
197                 for(size_t ix{n} ; ix < N ; ++ix) {
198                         ret[ix] = dig_0();
199                 }
200                 return ret;
201         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
230                                                  {
231                 return base_t{regd_base_N_pow_n_B<L>()};
232         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_base_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
235                                                 {
236                 return base_t{regd_base_N_pow_n_B_m1<L>()};
237         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
255                                             {
256                 return reg_digs_t{regd_base_N_Bm1<L>()};
257         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
265                                                  {
266                 return reg_digs_t{regd_base_N_pow_n_B<L>()};
267         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
270                                                         {
271                 return reg_digs_t{regd_base_N_pow_n_B_m1<L>()};
272         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBreg_digs_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::rem_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1195                                                   {
1196                 reg_digs_t ret{*this};
1197                 ret <<= L-n;
1198                 return std::move(ret);
1199         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr decltype(auto) \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::rend ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
292         { return base_t::rend(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Funciones que ponen a constantes (constexpr) los objetos base_t  
.PP
\fBParámetros del template\fP
.RS 4
\fIsize_t\fP 
.RE
.PP
<nontypeparam name='N'></nontypeparam> 
.PP
\fBParámetros\fP
.RS 4
\fIthis\fP 
.RE
.PP
\fBDevuelve\fP
.RS 4
.RE
.PP

.PP
.nf
694         {       r_cthis()\&.fill(dig_0()); }
.fi
.PP
Referenciado por \fBNumRepr::reg_digs_t< UINT_T, B, L >::mC_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
698         {       r_cthis()\&.fill(dig_0());
699                 r_cthis()[0]\&.set_1();    }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
703         {       r_cthis()\&.fill(dig_0());
704                 r_cthis()[0]\&.set_Bm1();  }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_dig (\fBdig_t\fP d)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
708         {       r_cthis()\&.fill(d);
709                 r_cthis()[0] = d;       }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_fill_1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
717         {       r_cthis()\&.fill(dig_1()); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_fill_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
722         {       r_cthis()\&.fill(dig_Bm1());       }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_fill_dig (\fBdig_t\fP d)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
713         {       r_cthis()\&.fill(d);       }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_interval_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
'Funciones que ponen a constantes(constexpr) los objetos un subintervalo
o subrango de base_t cualquiera'  
.PP
\fBParámetros del template\fP
.RS 4
\fIsize_t\fP 
.RE
.PP
<nontypeparam name='N_i'></nontypeparam> <nontypeparam name='N_pf'></nontypeparam> 
.PP
\fBParámetros\fP
.RS 4
\fIthis\fP 
.RE
.PP
\fBDevuelve\fP
.RS 4
.RE
.PP
OPERACION DE PONER A VALOR DIG_0 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> 
.PP
.nf
741                                        {
742                 for (size_t ix{N_i} ; ix < N_pf ; ++ix)
743                         r_cthis()[ix]\&.set_0();
744         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_interval_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG_Bm1 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> 
.PP
.nf
752                                          {
753                 for (size_t ix{N_i} ; ix < N_pf ; ++ix)
754                         r_cthis()[ix]\&.set_Bm1();
755         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::set_interval_dig (\fBdig_t\fP dig)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
OPERACION DE PONER A VALOR DIG DEL ARRAY DESDE [N_0 , N_1) EN BASE_T summary='Funciones comparativas con constantes tipo constexpr'> param name='this'>
.PP
returns='bool'>
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBsize_t\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::size () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
297         { return base_t::size(); }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_SINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ssi_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
131         {return dig_t::ssi_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_SINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ssi_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
133         {return dig_t::ssi_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_SINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ssi_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
137         {return dig_t::ssi_B();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_SINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ssi_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
135         {return dig_t::ssi_B()-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_SINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ssi_Bp1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
139         {return dig_t::ssi_B()+1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < L)&&(ibegin != iend))constexpr \fBreg_N_digs_t\fP<(ibegin< iend)?(iend\-ibegin):(ibegin\-iend)> \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::subregister () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
TAKE A SUBREGISTER OF A REGISTER OF DIGITS\&. 
.PP
.nf
1075                                      {
1076                 const reg_digs_t & cthis{*this};
1077                 if constexpr (ibegin < iend) {
1078                         reg_N_digs_t<iend-ibegin> ret;
1079                         for(size_t ix{ibegin} ; ix < iend ; ++ix) {
1080                                 ret[ix-ibegin] = cthis[ix];
1081                         }
1082                         return std::move(ret);
1083                 }
1084                 else {
1085                         reg_N_digs_t<iend-ibegin> ret;
1086                         for(int32_t ix{iend} ; ix > ibegin-1 ; --ix) {
1087                                 ret[ix-ibegin] = cthis[L-1-ix];
1088                         }
1089                         return std::move(ret);
1090                 }
1091         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::sui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
121         {return dig_t::sui_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::sui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
123         {return dig_t::sui_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::sui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
127         {return dig_t::sui_B();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::sui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
125         {return dig_t::sui_B()-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::sui_Bp1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
129         {return dig_t::sui_B()+1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::swap (\fBbase_t\fP & other)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
315         { this->base_t::swap(*other\&.data()); }
.fi
.PP
Hace referencia a \fBNumRepr::other\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
109         {return dig_t::ui_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
111         {return dig_t::ui_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
115         {return B;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
113         {return B-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ui_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
119         {return dig_t::ui_max();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::reg_digs_t\fP< UINT_T, B, L >::ui_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
117         {return dig_t::ui_submax();}
.fi


.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
