.TH "reg_digs_t.hpp" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
reg_digs_t.hpp
.SH SYNOPSIS
.br
.PP
\fC#include 'dig_t\&.hpp'\fP
.br
\fC#include 'utilities\&.hpp'\fP
.br
\fC#include 'lexer_parser\&.hpp'\fP
.br

.SS "Clases"

.in +1c
.ti -1c
.RI "struct \fBNumRepr::reg_digs_t< UINT_T, B, L >\fP"
.br
.RI "DEFINCION DE template<uint128_t Radix> register_of_digits_t{};\&. "
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBNumRepr\fP"
.br
.in -1c
.SS "typedefs"

.in +1c
.ti -1c
.RI "template<uint128_t B, size_t L> using \fBNumRepr::register_of_digits_t\fP = reg_digs_t< type_traits::TypeFromIntNumber_t< B >, static_cast< type_traits::TypeFromIntNumber_t< B > >(B), L >"
.br
.ti -1c
.RI "template<uint128_t B, size_t L> using \fBNumRepr::register_digs_t\fP = reg_digs_t< TypeFromIntNumber_t< static_cast< uint128_t >(B)>, static_cast< TypeFromIntNumber_t< static_cast< uint128_t >(B)> >(static_cast< uint128_t >(B)), L >"
.br
.in -1c
.SS "Funciones"

.in +1c
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t N> 
.br
requires (N>0)constexpr reg_digs_t< UInt_t, B, N > \fBNumRepr::concat\fP (const reg_digs_t< UInt_t, B, N > &larg) noexcept"
.br
.RI "STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t N, size_t M> 
.br
requires ((N>0)&&(M>0))constexpr reg_digs_t< UInt_t, B, N+M > \fBNumRepr::concat\fP (const reg_digs_t< UInt_t, B, N > &larg, const reg_digs_t< UInt_t, B, M > &rarg) noexcept"
.br
.RI "STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t N> 
.br
requires (N > 0)constexpr reg_digs_t< UInt_t, B, N+1 > \fBNumRepr::concat\fP (const reg_digs_t< UInt_t, B, N > &larg, dig_t< UInt_t, B > rarg) noexcept"
.br
.RI "STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t M> 
.br
requires (M > 0)constexpr reg_digs_t< UInt_t, B, 1+M > \fBNumRepr::concat\fP (dig_t< UInt_t, B > larg, const reg_digs_t< UInt_t, B, M > &rarg) noexcept"
.br
.RI "STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B> constexpr reg_digs_t< UInt_t, B, 1 > \fBNumRepr::concat\fP (dig_t< UInt_t, B > larg) noexcept"
.br
.RI "STATIC BASE_N_T<1> CONCAT(DIG_T) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B> constexpr reg_digs_t< UInt_t, B, 2 > \fBNumRepr::concat\fP (dig_t< UInt_t, B > larg, dig_t< UInt_t, B > rarg) noexcept"
.br
.RI "STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) "
.ti -1c
.RI "template<typename UInt_t , UInt_t B, typename T0 , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&\&.\&.\&.) && (std::is_same_v<T0,dig_t<UInt_t,B>>) )constexpr reg_digs_t< UInt_t, B, 1+(sizeof \&.\&.\&.(Ts))> \fBNumRepr::concat\fP (T0 dig0, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t N, typename T , typename \&.\&.\&. Ts> 
.br
requires (((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&\&.\&.\&.)&&(std::is_same_v<T,dig_t<UInt_t,B>>)&&(N>0))constexpr reg_digs_t< UInt_t, B, N+1+(sizeof \&.\&.\&.(Ts))> \fBNumRepr::concat\fP (reg_digs_t< UInt_t, B, N > larg, T dig, Ts \&.\&.\&. dig_pack) noexcept"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t M, typename T , typename \&.\&.\&. Ts> 
.br
requires ( ((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&\&.\&.\&.) && (std::is_same_v<T,dig_t<UInt_t,B>>) && (M>0) )constexpr reg_digs_t< UInt_t, B, M+1+(sizeof \&.\&.\&.(Ts))> \fBNumRepr::concat\fP (T dig, Ts \&.\&.\&. dig_pack, reg_digs_t< UInt_t, B, M > rarg) noexcept"
.br
.ti -1c
.RI "template<typename UInt_t , UInt_t B, size_t N, size_t \&.\&.\&. N_pack> 
.br
requires ((N>0)&&((N_pack>0)&&\&.\&.\&.))constexpr reg_digs_t< UInt_t, B, N+(\&.\&.\&.+(N_pack))> \fBNumRepr::concat\fP (reg_digs_t< UInt_t, B, N > larg, reg_digs_t< UInt_t, B, N_pack > \&.\&.\&. rarg_pack) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::operator<<\fP (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & \fBNumRepr::operator<<=\fP (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & \fBNumRepr::operator>>=\fP (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::operator>>\fP (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::rem_B\fP (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & \fBNumRepr::m_rem_B\fP (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::mer_B\fP (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & \fBNumRepr::m_mer_B\fP (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & \fBNumRepr::operator|=\fP (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::operator|\fP (const reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & \fBNumRepr::operator&=\fP (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> 
.br
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::operator&\fP (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N> constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::m_incr\fP (reg_digs_t< UINT_T, B, N > &rarg) noexcept"
.br
.RI "TODO 31/12/2022\&. "
.ti -1c
.RI "template<typename UINT_T , UINT_T B> constexpr dig_t< UINT_T, B > \fBNumRepr::m_sum_digs_carryin1\fP (dig_t< UINT_T, B > &left, dig_t< UINT_T, B > right) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B> constexpr dig_t< UINT_T, B > \fBNumRepr::m_sum_digs_carryin0\fP (dig_t< UINT_T, B > &left, dig_t< UINT_T, B > right) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N> constexpr dig_t< UINT_T, B > \fBNumRepr::m_sum\fP (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N> 
.br
requires (N>1)constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::aprox_units_divB\fP (const reg_digs_t< UINT_T, B, N > &arg) noexcept"
.br
.RI "< PRECONDITIONS : ARG != 0 AND ARG != 1 > "
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N, size_t n> 
.br
requires ((n > 0) && (n < N) && (N > 1))constexpr reg_digs_t< UINT_T, B, N > \fBNumRepr::aprox_units_divB_n\fP (const reg_digs_t< UINT_T, B, N > &arg) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N> 
.br
requires (N > 0)constexpr std::array< type_traits::sig_UInt_for_UInt_t< UINT_T >, 2 > \fBNumRepr::aprox_coc_rem\fP (const reg_digs_t< UINT_T, B, N > &rem, const reg_digs_t< UINT_T, B, N > &dsor) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N> 
.br
requires (N > 0)constexpr std::array< type_traits::sig_UInt_for_UInt_t< UINT_T >, 2 > \fBNumRepr::aprox_coc_rem\fP (const reg_digs_t< UINT_T, B, N > &rem, const reg_digs_t< UINT_T, B, N > &dsor, type_traits::sig_UInt_for_UInt_t< UINT_T > coc_calculado, type_traits::sig_UInt_for_UInt_t< UINT_T > rem_calculado) noexcept"
.br
.ti -1c
.RI "template<typename UINT_T , UINT_T B, size_t N, size_t M> 
.br
requires (N > 0)&&(M > 0)constexpr std::array< reg_digs_t< UINT_T, B, std::max(N, M)>, 2 > \fBNumRepr::fediv\fP (const reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, M > &rarg) noexcept"
.br
.RI "END\&. "
.ti -1c
.RI "template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool \fBNumRepr::get_digit_token\fP (std::istream &is, dig_t< UINT_T, B > &dig_value)"
.br
.RI "FUNCION QUE CONSIGUE EL TOKEN DIGITO\&. "
.ti -1c
.RI "template<type_traits::unsigned_integral_c T, T B> bool \fBNumRepr::get_radix_token\fP (std::istream &is)"
.br
.RI "FUNCION QUE CONSIGUE EL TOKEN BASE\&. "
.ti -1c
.RI "template<type_traits::unsigned_integral_c T, T B, size_t L> bool \fBNumRepr::get_digit_loop_token\fP (std::istream &is, reg_digs_t< T, B, L > &value) noexcept"
.br
.ti -1c
.RI "template<type_traits::unsigned_integral_c T, T B, size_t L> bool \fBNumRepr::read\fP (std::istream &is, reg_digs_t< T, B, L > &value) noexcept"
.br
.RI "DEFINCION DE template<uint128_t Radix> digito_t{};\&. "
.ti -1c
.RI "template<typename Int_Type , Int_Type Base, size_t Length> 
.br
requires (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))std::istream & \fBNumRepr::operator>>\fP (std::istream &is, reg_digs_t< Int_Type, Base, Length > &arg)"
.br
.RI "SOBRECARGA DE ISTREAM Y OSTREAM CON LOS OPERADORES DE DESPLAZAMEINTO\&. "
.ti -1c
.RI "template<typename Int_Type , Int_Type Base, size_t Long> 
.br
requires (type_traits::suitable_base<Int_Type,Base>())std::ostream & \fBNumRepr::operator<<\fP (std::ostream &os, const reg_digs_t< Int_Type, Base, Long > &arg)"
.br
.in -1c
.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
