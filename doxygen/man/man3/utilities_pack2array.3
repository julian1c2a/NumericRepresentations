.TH "utilities::pack2array< Ts >" 3 "Lunes, 2 de Enero de 2023" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
utilities::pack2array< Ts > \- END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <utilities\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBarray_type\fP = std::array< typename \fBpack2tuple\fP< Ts\&.\&.\&. >\fB::elem_type\fP< 0 >,(sizeof\&.\&.\&.(Ts)) >"
.br
.ti -1c
.RI "using \fBelem_type\fP = typename \fBpack2tuple\fP< Ts\&.\&.\&. >::elem_type< 0 >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "constexpr \fBarray_type\fP \fBoperator()\fP (Ts &&\&.\&.\&.args) const noexcept"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static constexpr std::size_t \fBpack_size\fP () noexcept"
.br
.ti -1c
.RI "template<std::size_t J> static constexpr \fBelem_type\fP \fBget\fP (Ts &&\&.\&.\&.args) noexcept"
.br
.ti -1c
.RI "template<std::size_t\&.\&.\&. I> static constexpr void \fBfor_each_impl\fP (\fBarray_type\fP &iarray, const Ts\&.\&.\&.args, std::index_sequence< I\&.\&.\&. >) noexcept"
.br
.ti -1c
.RI "static constexpr void \fBfor_each\fP (\fBarray_type\fP &iarray, const Ts\&.\&.\&.args) noexcept"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<typename\&.\&.\&. Ts>
.br
requires (all_are_the_same_type_c<Ts\&.\&.\&.>&&there_is_one_or_more_c<Ts\&.\&.\&.>)
.br
struct utilities::pack2array< Ts >"END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES\&. 
.PP
Definición en la línea \fB105\fP del archivo \fButilities\&.hpp\fP\&.
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<typename\&.\&.\&. Ts> using \fButilities::pack2array\fP< Ts >::array_type =  std::array< typename \fBpack2tuple\fP<Ts\&.\&.\&.>\fB::elem_type\fP<0>, (sizeof\&.\&.\&.(Ts)) >"

.PP
Definición en la línea \fB106\fP del archivo \fButilities\&.hpp\fP\&.
.SS "template<typename\&.\&.\&. Ts> using \fButilities::pack2array\fP< Ts >::elem_type =  typename \fBpack2tuple\fP<Ts\&.\&.\&.>::elem_type<0>"

.PP
Definición en la línea \fB119\fP del archivo \fButilities\&.hpp\fP\&.
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<typename\&.\&.\&. Ts> static constexpr void \fButilities::pack2array\fP< Ts >::for_each (\fBarray_type\fP & iarray, const Ts\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB144\fP del archivo \fButilities\&.hpp\fP\&.
.SS "template<typename\&.\&.\&. Ts> template<std::size_t\&.\&.\&. I> static constexpr void \fButilities::pack2array\fP< Ts >::for_each_impl (\fBarray_type\fP & iarray, const Ts\&.\&.\&. args, std::index_sequence< I\&.\&.\&. >)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
ESTA FUNCION AUXILIAR ES NECESARIA PARA UNA POSTERIOR EXPANSION DEL PARAMETER PACK 
.PP
Definición en la línea \fB133\fP del archivo \fButilities\&.hpp\fP\&.
.SS "template<typename\&.\&.\&. Ts> template<std::size_t J> static constexpr \fBelem_type\fP \fButilities::pack2array\fP< Ts >::get (Ts &&\&.\&.\&. args)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB122\fP del archivo \fButilities\&.hpp\fP\&.
.SS "template<typename\&.\&.\&. Ts> constexpr \fBarray_type\fP \fButilities::pack2array\fP< Ts >::operator() (Ts &&\&.\&.\&. args) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB114\fP del archivo \fButilities\&.hpp\fP\&.
.SS "template<typename\&.\&.\&. Ts> static constexpr std::size_t \fButilities::pack2array\fP< Ts >::pack_size ()\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
Definición en la línea \fB110\fP del archivo \fButilities\&.hpp\fP\&.

.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
