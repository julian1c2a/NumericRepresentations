.TH "NumRepr::nat_reg_digs_t< UINT_T, B, L >" 3 "Lunes, 28 de Noviembre de 2022" "NumericRepresentations" \" -*- nroff -*-
.ad l
.nh
.SH NAME
NumRepr::nat_reg_digs_t< UINT_T, B, L >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <nat_reg_digs_t (Copia en conflicto de MSI 2022\-11\-24)\&.hpp>\fP
.SS "Tipos públicos"

.in +1c
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename \fBtype_traits::sig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBbase_N_t\fP = std::array< \fBdig_t\fP, N >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_N_t\fP< L >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_N_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_base_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBnat_reg_N_digs_t\fP = \fBnat_reg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBnat_reg_N_digs_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBnat_reg_digs_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_ints_t\fP = typename std::array< UINT_T, N >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_suints_t\fP = typename std::array< \fBSIG_UINT_T\fP, N >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_ssints_t\fP = typename std::array< \fBSIG_SINT_T\fP, N >"
.br
.ti -1c
.RI "using \fBSIG_UINT_T\fP = typename \fBtype_traits::sig_UInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBSIG_SINT_T\fP = typename \fBtype_traits::sig_SInt_for_UInt_t\fP< UINT_T >"
.br
.ti -1c
.RI "using \fBdig_t\fP = \fBdig_t\fP< UINT_T, B >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBbase_N_t\fP = std::array< \fBdig_t\fP, N >"
.br
.ti -1c
.RI "using \fBbase_t\fP = \fBbase_N_t\fP< L >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_base_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_N_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_base_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBbase_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBnat_reg_N_digs_t\fP = \fBnat_reg_digs_t\fP< UINT_T, B, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBres_N_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBnat_reg_N_digs_t\fP< N >, op, N >"
.br
.ti -1c
.RI "template<\fBbinop_e\fP op> using \fBres_op_t\fP = typename \fBauxiliary_types::result_operation_t\fP< \fBnat_reg_digs_t\fP, op, L >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_ints_t\fP = typename std::array< UINT_T, N >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_suints_t\fP = typename std::array< \fBSIG_UINT_T\fP, N >"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> using \fBreg_ssints_t\fP = typename std::array< \fBSIG_SINT_T\fP, N >"
.br
.in -1c
.SS "Métodos públicos"

.in +1c
.ti -1c
.RI "consteval \fBnat_reg_digs_t\fP () noexcept"
.br
.RI "CONSTRUCTOR POR DEFECTO\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.RI "CONSTRUCTOR POR LISTA DE DIGITOS\&. "
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBnat_reg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.RI "CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBnat_reg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. "
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_dig\fP (\fBdig_t\fP arg) noexcept"
.br
.RI "OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_0\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_Bm1\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_dig\fP (\fBdig_t\fP dig) noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN DIGITO (CONVERSION) "
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "SUBREPR => SUB REPRESENTACION\&. "
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat_inv\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat_inv\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBsubrepr\fP () const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBoperator Int_Type\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_B\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_Bp1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_B_pow_m1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_B_pow\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_Bm1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n, \fBdig_t\fP d> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_filled_of\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator==\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator!=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBoperator<=>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBoperator<=>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr std::weak_ordering \fBoperator<=>\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBget\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBput\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator[]\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP idx) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBoperator()\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBbase_t\fP & \fBconst_ref_data\fP () const"
.br
.ti -1c
.RI "constexpr \fBbase_t\fP \fBcpy_data\fP () const"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBC_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBC_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator!\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator<<\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator<<=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator>>\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator>>=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBrem_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_rem_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBmer_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_mer_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator|=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator|\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator&=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator&\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "consteval \fBnat_reg_digs_t\fP () noexcept"
.br
.RI "CONSTRUCTOR POR DEFECTO\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP (const std::initializer_list< \fBdig_t\fP > &arg) noexcept"
.br
.RI "CONSTRUCTOR POR LISTA DE DIGITOS\&. "
.ti -1c
.RI "template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBnat_reg_digs_t\fP (const Ts &\&.\&.\&. args) noexcept"
.br
.RI "CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. "
.ti -1c
.RI "template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBnat_reg_digs_t\fP (Ints_type \&.\&.\&. dig_pow_i) noexcept"
.br
.RI "CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "CONSTRUCTOR POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBbase_N_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (\fBnat_reg_N_digs_t\fP< N > &&arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR MOVIMIENTO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.RI "OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. "
.ti -1c
.RI "constexpr void \fBset_0\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_Bm1\fP () noexcept"
.br
.RI "OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr void \fBset_dig\fP (\fBdig_t\fP arg) noexcept"
.br
.RI "OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_0\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_Bm1\fP () noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBset_interval_dig\fP (\fBdig_t\fP dig) noexcept"
.br
.RI "OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (const \fBdig_t\fP &arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN DIGITO (CONVERSION) "
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBoperator=\fP (Int_Type arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "SUBREPR => SUB REPRESENTACION\&. "
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBcat_inv\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBcat_inv\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBsubrepr\fP () const noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> constexpr \fBoperator Int_Type\fP () const noexcept"
.br
.ti -1c
.RI "constexpr bool \fBis_0\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_Bm1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_B\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_Bp1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_B_pow_m1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_B_pow\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_1\fP () const"
.br
.ti -1c
.RI "constexpr bool \fBis_filled_of_Bm1\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP n, \fBdig_t\fP d> 
.br
requires ((n>0) && (n<L))constexpr bool \fBis_filled_of\fP () const"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator==\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator!=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator<\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBoperator>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBoperator<=>\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBoperator<=>\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "constexpr std::weak_ordering \fBoperator<=>\fP (const \fBdig_t\fP &arg) const noexcept"
.br
.RI "OPERADOR COMPARACION SPACESHIP C++20\&. "
.ti -1c
.RI "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBget\fP () const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBput\fP (\fBdig_t\fP arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP \fBoperator[]\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr \fBdig_t\fP & \fBoperator[]\fP (\fBsize_t\fP idx) noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBoperator()\fP (\fBsize_t\fP idx) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBbase_t\fP & \fBconst_ref_data\fP () const"
.br
.ti -1c
.RI "constexpr \fBbase_t\fP \fBcpy_data\fP () const"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator++\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-\-\fP (int) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBmC_B\fP () noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBmC_Bm1\fP () noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBC_Bm1\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBC_B\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator!\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP () const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator<<\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator<<=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator>>\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator>>=\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBrem_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_rem_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBmer_B\fP (\fBsize_t\fP n) const noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBm_mer_B\fP (\fBsize_t\fP n) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator|=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator|\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator&=\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator&\fP (const \fBnat_reg_digs_t\fP &arg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator+\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator\-\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr auto \fBoperator*\fP (\fBdig_t\fP arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator/\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "DIVISION BY A DIGIT\&. "
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator%\fP (\fBdig_t\fP arg) const noexcept"
.br
.RI "REMAINDER BY A DIGIT\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator+=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator\-=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator*=\fP (const \fBbase_N_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBoperator*=\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.RI "TO DO\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator*\fP (const \fBbase_N_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator+\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator\-\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBoperator*\fP (const \fBnat_reg_N_digs_t\fP< N > &arg) const noexcept"
.br
.ti -1c
.RI "constexpr \fBnat_reg_digs_t\fP \fBoperator%\fP (const \fBnat_reg_digs_t\fP &arg) const noexcept"
.br
.in -1c
.SS "Métodos públicos estáticos"

.in +1c
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bp1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_0\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBregd_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBregd_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_0\fP () noexcept"
.br
.RI "ARRAYS DE ENTEROS (CONSTANTES EN TIEMPO DE COMPILACION INMEDIATAS) "
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBregi_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBregi_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> static constexpr const \fBbase_t\fP & \fBassign\fP (\fBbase_t\fP &larg, Int_Type arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<bool with_result_type> static constexpr auto \fBm_add\fP (\fBbase_t\fP &larg, const \fBdig_t\fP &rarg) \-> typename std::conditional_t< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::add\fP >, \fBbase_t\fP const & > noexcept"
.br
.RI "END : OPERATORS | & |= &=\&. "
.ti -1c
.RI "static constexpr const \fBbase_t\fP & \fBm_sub\fP (\fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.RI "OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB\&. "
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBadd\fP (const \fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBsub\fP (const \fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_Bm2\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBdig_t\fP \fBdig_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_submax\fP () noexcept"
.br
.ti -1c
.RI "static consteval UINT_T \fBui_max\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBSIG_UINT_T\fP \fBsui_Bp1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_0\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_Bm1\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBregd_base_N_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBregd_base_N_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBbase_t\fP \fBregd_base_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_0\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBnat_reg_digs_t\fP \fBregd_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBregd_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBregd_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_0\fP () noexcept"
.br
.RI "ARRAYS DE ENTEROS (CONSTANTES EN TIEMPO DE COMPILACION INMEDIATAS) "
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_Bm1\fP () noexcept"
.br
.ti -1c
.RI "static consteval \fBreg_ints_t\fP< L > \fBregi_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBregi_pow_n_B\fP () noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBregi_pow_n_B_m1\fP () noexcept"
.br
.ti -1c
.RI "template<type_traits::integral_c Int_Type> static constexpr const \fBbase_t\fP & \fBassign\fP (\fBbase_t\fP &larg, Int_Type arg) noexcept"
.br
.RI "OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T\&. "
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &larg, const \fBdig_t\fP &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator==\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator!=\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg)"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator>\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator<\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator>=\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBoperator<=\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< M > &rarg) noexcept"
.br
.ti -1c
.RI "template<bool with_result_type> static constexpr auto \fBm_add\fP (\fBbase_t\fP &larg, const \fBdig_t\fP &rarg) \-> typename std::conditional_t< with_result_type, \fBres_base_op_t\fP< \fBbinop_e::add\fP >, \fBbase_t\fP const & > noexcept"
.br
.RI "END : OPERATORS | & |= &=\&. "
.ti -1c
.RI "static constexpr const \fBbase_t\fP & \fBm_sub\fP (\fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.RI "OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB\&. "
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBadd\fP (const \fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "static constexpr \fBbase_t\fP \fBsub\fP (const \fBbase_t\fP &larg, const \fBdig_t\fP &rarg) noexcept"
.br
.ti -1c
.RI "template<\fBsize_t\fP N> static constexpr auto \fBfediv\fP (const \fBbase_N_t\fP< N > &larg, const \fBbase_N_t\fP< 1 > &rarg) \-> \fBres_base_N_op_t\fP< binop_e::fediv > noexcept"
.br
.in -1c
.SH "Descripción detallada"
.PP 

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L>
.br
requires (suitable_base<UINT_T,B>() && (L>0))
.br
struct NumRepr::nat_reg_digs_t< UINT_T, B, L >"
.SH "Documentación de los 'Typedef' miembros de la clase"
.PP 
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::base_N_t\fP =  std::array<\fBdig_t\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::base_N_t\fP =  std::array<\fBdig_t\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::base_t\fP =  \fBbase_N_t\fP<L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::base_t\fP =  \fBbase_N_t\fP<L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::dig_t\fP =  \fBdig_t\fP<UINT_T,B>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::dig_t\fP =  \fBdig_t\fP<UINT_T,B>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::nat_reg_N_digs_t\fP =  \fBnat_reg_digs_t\fP<UINT_T,B,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::nat_reg_N_digs_t\fP =  \fBnat_reg_digs_t\fP<UINT_T,B,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::reg_ints_t\fP =  typename std::array<UINT_T,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::reg_ints_t\fP =  typename std::array<UINT_T,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::reg_ssints_t\fP =  typename std::array<\fBSIG_SINT_T\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::reg_ssints_t\fP =  typename std::array<\fBSIG_SINT_T\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::reg_suints_t\fP =  typename std::array<\fBSIG_UINT_T\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::reg_suints_t\fP =  typename std::array<\fBSIG_UINT_T\fP,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_base_N_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_N_t\fP<N>,op,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_base_N_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_N_t\fP<N>,op,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_base_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_t\fP,op,L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_base_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBbase_t\fP,op,L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_N_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBnat_reg_N_digs_t\fP<N>,op,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op, \fBsize_t\fP N> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_N_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBnat_reg_N_digs_t\fP<N>,op,N>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBnat_reg_digs_t\fP,op,L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBbinop_e\fP op> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::res_op_t\fP =  typename \fBauxiliary_types::result_operation_t\fP<\fBnat_reg_digs_t\fP,op,L>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::SIG_SINT_T\fP =  typename \fBtype_traits::sig_SInt_for_UInt_t\fP<UINT_T>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::SIG_SINT_T\fP =  typename \fBtype_traits::sig_SInt_for_UInt_t\fP<UINT_T>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::SIG_UINT_T\fP =  typename \fBtype_traits::sig_UInt_for_UInt_t\fP<UINT_T>"

.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> using \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::SIG_UINT_T\fP =  typename \fBtype_traits::sig_UInt_for_UInt_t\fP<UINT_T>"

.SH "Documentación del constructor y destructor"
.PP 
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR DEFECTO\&. 
.PP
.nf
274                  : m_dc{dig_0()} {}
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const std::initializer_list< \fBdig_t\fP > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR LISTA DE DIGITOS\&. 
.PP
.nf
278                  : m_dc{arg} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. 
.PP
.nf
284                  : m_dc{(utility::pack2array<Ts\&.\&.\&.>{})(args\&.\&.\&.)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. 
.PP
.nf
362                  : m_dc{copy_arg_N<N>(arg)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. 
.PP
.nf
369                  : m_dc{move_arg_N<N>(std::move(arg))} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (Ints_type \&.\&.\&. dig_pow_i)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO\&. 
.PP
.nf
433                                                                           :
434                 m_dc{normalize<Ints_type\&.\&.\&.>(dig_pow_i\&.\&.\&.)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. 
.PP
.nf
439                                                                                   :
440                 m_dc{copy_arg_N<N>(arg\&.const_ref_data())} {}
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR MOVIMIENTO\&. 
.PP
.nf
445                                                                              :
446                 m_dc{move_arg_N(std::move(*(arg\&.data())))} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> consteval \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t ()\fC [inline]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR DEFECTO\&. 
.PP
.nf
274                  : m_dc{dig_0()} {}
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const std::initializer_list< \fBdig_t\fP > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR LISTA DE DIGITOS\&. 
.PP
.nf
278                  : m_dc{arg} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<typename \&.\&.\&. Ts> 
.br
requires (std::is_same_v<Ts,\fBdig_t\fP>&&\&.\&.\&.)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const Ts &\&.\&.\&. args)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO\&. 
.PP
.nf
284                  : m_dc{(utility::pack2array<Ts\&.\&.\&.>{})(args\&.\&.\&.)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS\&. 
.PP
.nf
362                  : m_dc{copy_arg_N<N>(arg)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS\&. 
.PP
.nf
369                  : m_dc{move_arg_N<N>(std::move(arg))} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c \&.\&.\&. Ints_type> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (Ints_type \&.\&.\&. dig_pow_i)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO\&. 
.PP
.nf
433                                                                           :
434                 m_dc{normalize<Ints_type\&.\&.\&.>(dig_pow_i\&.\&.\&.)} {}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE\&. 
.PP
.nf
439                                                                                   :
440                 m_dc{copy_arg_N<N>(arg\&.const_ref_data())} {}
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::nat_reg_digs_t (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
CONSTRUCTOR POR MOVIMIENTO\&. 
.PP
.nf
445                                                                              :
446                 m_dc{move_arg_N(std::move(*(arg\&.data())))} {}
.fi
.SH "Documentación de las funciones miembro"
.PP 
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::add (const \fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2288         {
2289                 return m_add<false>(larg,rarg);
2290         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::add (const \fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2316         {
2317                 return m_add<false>(larg,rarg);
2318         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::assign (\fBbase_t\fP & larg, Int_Type arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T\&. 
.PP
.nf
707                                                                  {
708                 using type_traits::maxbase();
709                 constexpr int128_t B_128t_v{static_cast<int128_t>(B)};
710                 constexpr bool puede_multiplicarse{
711                                 (maxbase<int128_t>()/B_128t_v) > 0
712                 };
713                 if ((&larg)!=(&arg)) {
714                         int128_t creg_g{static_cast<int128_t>(arg)};
715                         int128_t BasePowIx{B_128t_v};
716                         for(size_t k{1u} ; k < L ; ++k) {
717                                 if constexpr (puede_multiplicarse)
718                                         BasePowIx *= B_128t_v;
719                                 else
720                                         break;
721                         }
722                         while (creg_g < 0) {
723                                 creg_g += BasePowIx;
724                         }
725                         for(size_t k{0u} ; k < L ; ++k){
726                                 larg[k] = dig_t(creg_g%B_128t_v);
727                                 creg_g /= B_128t_v;
728                         }
729                 }
730                 return (*this);
731         }
.fi
.PP
Hace referencia a \fBNumRepr::type_traits::maxbase()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator=()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::assign (\fBbase_t\fP & larg, Int_Type arg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T\&. 
.PP
.nf
707                                                                  {
708                 using type_traits::maxbase();
709                 constexpr int128_t B_128t_v{static_cast<int128_t>(B)};
710                 constexpr bool puede_multiplicarse{
711                                 (maxbase<int128_t>()/B_128t_v) > 0
712                 };
713                 if ((&larg)!=(&arg)) {
714                         int128_t creg_g{static_cast<int128_t>(arg)};
715                         int128_t BasePowIx{B_128t_v};
716                         for(size_t k{1u} ; k < L ; ++k) {
717                                 if constexpr (puede_multiplicarse)
718                                         BasePowIx *= B_128t_v;
719                                 else
720                                         break;
721                         }
722                         while (creg_g < 0) {
723                                 creg_g += BasePowIx;
724                         }
725                         for(size_t k{0u} ; k < L ; ++k){
726                                 larg[k] = dig_t(creg_g%B_128t_v);
727                                 creg_g /= B_128t_v;
728                         }
729                 }
730                 return (*this);
731         }
.fi
.PP
Hace referencia a \fBNumRepr::type_traits::maxbase()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::C_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1915         {
1916                 return nat_reg_digs_t{C_B(m_dc)};
1917         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_B()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_B()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator\-()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::C_B () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1943         {
1944                 return nat_reg_digs_t{C_B(m_dc)};
1945         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::C_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1909         {
1910                 return nat_reg_digs_t{C_Bm1(m_dc)};
1911         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_Bm1()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator!()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::C_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1937         {
1938                 return nat_reg_digs_t{C_Bm1(m_dc)};
1939         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
SUBREPR => SUB REPRESENTACION\&. FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION NAT_REG_N_T<L+M> NAT_REG_T::CAT(NAT_REG_N_T<M>) NAT_REG_N_T<L+M> NAT_REG_T::CAT_INV(NAT_REG_N_T<M>) NAT_REG_N_T<L+1> NAT_REG_T::CAT(DIG_T) NAT_REG_N_T<L+1> NAT_REG_T::CAT_INV(DIG_T) 
.PP
.nf
892         {
893                 return (concat<L,N>(m_dc,arg));
894         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
SUBREPR => SUB REPRESENTACION\&. FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION NAT_REG_N_T<L+M> NAT_REG_T::CAT(NAT_REG_N_T<M>) NAT_REG_N_T<L+M> NAT_REG_T::CAT_INV(NAT_REG_N_T<M>) NAT_REG_N_T<L+1> NAT_REG_T::CAT(DIG_T) NAT_REG_N_T<L+1> NAT_REG_T::CAT_INV(DIG_T) 
.PP
.nf
892         {
893                 return (concat<L,N>(m_dc,arg));
894         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
898                  {
899                 return (concat<L>(m_dc,arg));
900         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
898                  {
899                 return (concat<L>(m_dc,arg));
900         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat_inv (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
906         {
907                 return (concat<N,L>(arg,m_dc));
908         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_N_digs_t\fP< N+L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat_inv (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
906         {
907                 return (concat<N,L>(arg,m_dc));
908         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat_inv (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
912         {
913                 return (concat<L>(arg,m_dc));
914         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_N_digs_t\fP< L+1 > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cat_inv (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
912         {
913                 return (concat<L>(arg,m_dc));
914         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::const_ref_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1571                                               {
1572                 return (this->m_dc);
1573         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::nat_reg_digs_t()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator!=()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator<()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator<=()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator<=>()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator=()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator==()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator>()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator>=()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::const_ref_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1599                                               {
1600                 return (this->m_dc);
1601         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cpy_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1575                                 {
1576                 return this->m_dc;
1577         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::cpy_data () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1603                                 {
1604                 return this->m_dc;
1605         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
60         {return dig_t::dig_0();}
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_add()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_sub()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::nat_reg_digs_t()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_0()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_pow_n_B_m1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
60         {return dig_t::dig_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
62         {return dig_t::dig_1();}
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_add()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_sub()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator+=()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator\-=()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_B()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_pow_n_B()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_B()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_pow_n_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
62         {return dig_t::dig_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
64         {return dig_t::dig_Bm1();}
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_add()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_sub()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_Bm1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_N_pow_n_B_m1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
64         {return dig_t::dig_Bm1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_Bm2 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
68         {return dig_t::dig_Bm2();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_Bm2 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
68         {return dig_t::dig_Bm2();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
66         {return dig_t::dig_max();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
66         {return dig_t::dig_max();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
70         {return dig_t::dig_submax();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::dig_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
70         {return dig_t::dig_submax();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> static constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::fediv (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< 1 > & rarg) \-> \fBres_base_N_op_t\fP<binop_e::fediv>
		noexcept \fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
2851                          {
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::get () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1529         {
1530                 return (m_dc[I]);
1531         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::get () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1557         {
1558                 return (m_dc[I]);
1559         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_0 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1135                           {
1136                 return is_0(m_dc);
1137         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_0()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_0()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_sub()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_0 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1163                           {
1164                 return is_0(m_dc);
1165         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1140                           {
1141                 return is_1(m_dc);
1142         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_1()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1168                           {
1169                 return is_1(m_dc);
1170         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_B () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1150                           {
1151                 return is_B(m_dc);
1152         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_B()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_B () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1178                           {
1179                 return is_B(m_dc);
1180         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_B_pow () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1169                               {
1170                 return is_B_pow<L,n>(m_dc);
1171         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_B_pow () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1197                               {
1198                 return is_B_pow<L,n>(m_dc);
1199         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_B_pow_m1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1162                                  {
1163                 return is_B_pow_m1<L,n>(m_dc);
1164         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>0) && (n<L))constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_B_pow_m1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1190                                  {
1191                 return is_B_pow_m1<L,n>(m_dc);
1192         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1145                             {
1146                 return is_Bm1(m_dc);
1147         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bm1()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::m_add()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1173                             {
1174                 return is_Bm1(m_dc);
1175         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_Bp1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1155                             {
1156                 return is_Bp1(m_dc);
1157         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bp1()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bp1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_Bp1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1183                             {
1184                 return is_Bp1(m_dc);
1185         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bp1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n, \fBdig_t\fP d> 
.br
requires ((n>0) && (n<L))constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_filled_of () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1186                                   {
1187                 return is_filled_of<L,n,d>(m_dc);
1188         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n, \fBdig_t\fP d> 
.br
requires ((n>0) && (n<L))constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_filled_of () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1214                                   {
1215                 return is_filled_of<L,n,d>(m_dc);
1216         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_filled_of_1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1174                                     {
1175                 return is_filled_of_1<L>(m_dc);
1176         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_filled_of_1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1202                                     {
1203                 return is_filled_of_1<L>(m_dc);
1204         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_filled_of_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1179                                       {
1180                 return is_filled_of_Bm1<L>(m_dc);
1181         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::is_filled_of_Bm1 () const\fC [inline]\fP, \fC [constexpr]\fP"

.PP
.nf
1207                                       {
1208                 return is_filled_of_Bm1<L>(m_dc);
1209         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> static constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_add (\fBbase_t\fP & larg, const \fBdig_t\fP & rarg) \-> typename std::conditional_t<
			with_result_type,
				\fBres_base_op_t\fP<\fBbinop_e::add\fP>,
				\fBbase_t\fP const&
		>                                           noexcept
	\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
END : OPERATORS | & |= &=\&. OPERACIONES BINARIAS CON/SIN TIPO RESULTADO OPERACIONES BINARIAS BASE_T @ DIG_T OPERATOR BASE_T += DIG_T CON NOMBRE M_ADDITION CARRY INICIAL POR DEFECTO
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
INICIALIZACION
.PP
NOMBRE CORTO PARA RET\&.RESULT_CONTENT_LOW
.PP
NOMBRE CORTO PARA RET\&.CARRY
.PP
NOMBRE CORTO PARA RET\&.GOOD_RESULT
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
.nf
2176         {
2177                 constexpr auto UINT_T middle_max{std::numeric_limits<UINT_T>::max()/2};
2178                 using uint_type = std::conditional_t<B<=middle_max,UINT_T,SIG_UINT_T>;
2179                 using dig_t = dig_t<uint_type,B>;
2180                 if constexpr (! with_result_type) {
2182                         dig_t carry{dig_0()};
2184                         if (larg[0] <= dig_Bm1()-rarg) {
2185                                 larg[0] += rarg;
2186                                 return (larg);
2187                         }
2188                         else {
2189                                 larg[0] -= (dig_Bm1()-rarg+1);
2190                                 carry = dig_1();
2191                         }
2193                         for(size_t ix{1} ; ix < L ; ++ix) {
2194                                 if (carry\&.is_1()) {
2195                                         if (larg[ix]\&.is_Bm1()) {
2196                                                 larg[ix] = dig_0();
2197                                                 carry = dig_1();
2198                                         }
2199                                         else {
2200                                                 ++larg[ix];
2201                                                 return (larg);
2202                                         }
2203                                 }
2204                         }
2205                         return (larg);
2206                 }
2207                 else {
2209                         res_base_op_t<binop_e::add> ret{
2210                                 \&.result_content_low              =               larg,
2211                                 \&.carry                                                           =               dig_0(),
2212                                 \&.good_result                                     =               true
2213                         };
2215                         auto&           result{ret\&.result_content_low};
2217                         dig_t&  carry{ret\&.carry};
2219                         bool&           good{ret\&.good_result};
2221                         if (larg[0] <= dig_Bm1()-rarg) {
2222                                 result[0]       +=      rarg;
2223                                 carry                                            =      dig_0();
2224                                 return std::move(ret);
2225                         }
2226                         else {
2227                                 ret\&.result_content[0]   -= (dig_B()-rarg);
2228                                 carry                    = dig_1();
2229                         }
2231                         for(size_t ix{1} ; ix < L ; ++ix) {
2232                                 if (carry\&.is_not_0()) {
2233                                         if (result[ix]\&.is_Bm1()) {
2234                                                 result[ix]  = dig_0();
2235                                                 carry       = dig_1();
2236                                         }
2237                                         else {
2238                                                 ++result[ix];
2239                                                 carry = dig_0();
2240                                         }
2241                                 }
2242                         }
2243                         if (carry\&.is_not_0())
2244                                 good = false;
2245                         return std::move(ret);
2246                 }
2247         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<bool with_result_type> static constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_add (\fBbase_t\fP & larg, const \fBdig_t\fP & rarg) \-> typename std::conditional_t<
			with_result_type,
				\fBres_base_op_t\fP<\fBbinop_e::add\fP>,
				\fBbase_t\fP const&
		>                                           noexcept
	\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
END : OPERATORS | & |= &=\&. OPERACIONES BINARIAS CON/SIN TIPO RESULTADO OPERACIONES BINARIAS BASE_T @ DIG_T OPERATOR BASE_T += DIG_T CON NOMBRE M_ADDITION CARRY INICIAL POR DEFECTO
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
INICIALIZACION
.PP
NOMBRE CORTO PARA RET\&.RESULT_CONTENT_LOW
.PP
NOMBRE CORTO PARA RET\&.CARRY
.PP
NOMBRE CORTO PARA RET\&.GOOD_RESULT
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1
.PP
.nf
2204         {
2205                 constexpr auto UINT_T middle_max{std::numeric_limits<UINT_T>::max()/2};
2206                 using uint_type = std::conditional_t<B<=middle_max,UINT_T,SIG_UINT_T>;
2207                 using dig_t = dig_t<uint_type,B>;
2208                 if constexpr (! with_result_type) {
2210                         dig_t carry{dig_0()};
2212                         if (larg[0] <= dig_Bm1()-rarg) {
2213                                 larg[0] += rarg;
2214                                 return (larg);
2215                         }
2216                         else {
2217                                 larg[0] -= (dig_Bm1()-rarg+1);
2218                                 carry = dig_1();
2219                         }
2221                         for(size_t ix{1} ; ix < L ; ++ix) {
2222                                 if (carry\&.is_1()) {
2223                                         if (larg[ix]\&.is_Bm1()) {
2224                                                 larg[ix] = dig_0();
2225                                                 carry = dig_1();
2226                                         }
2227                                         else {
2228                                                 ++larg[ix];
2229                                                 return (larg);
2230                                         }
2231                                 }
2232                         }
2233                         return (larg);
2234                 }
2235                 else {
2237                         res_base_op_t<binop_e::add> ret{
2238                                 \&.result_content_low              =               larg,
2239                                 \&.carry                                                           =               dig_0(),
2240                                 \&.good_result                                     =               true
2241                         };
2243                         auto&           result{ret\&.result_content_low};
2245                         dig_t&  carry{ret\&.carry};
2247                         bool&           good{ret\&.good_result};
2249                         if (larg[0] <= dig_Bm1()-rarg) {
2250                                 result[0]       +=      rarg;
2251                                 carry                                            =      dig_0();
2252                                 return std::move(ret);
2253                         }
2254                         else {
2255                                 ret\&.result_content[0]   -= (dig_B()-rarg);
2256                                 carry                    = dig_1();
2257                         }
2259                         for(size_t ix{1} ; ix < L ; ++ix) {
2260                                 if (carry\&.is_not_0()) {
2261                                         if (result[ix]\&.is_Bm1()) {
2262                                                 result[ix]  = dig_0();
2263                                                 carry       = dig_1();
2264                                         }
2265                                         else {
2266                                                 ++result[ix];
2267                                                 carry = dig_0();
2268                                         }
2269                                 }
2270                         }
2271                         if (carry\&.is_not_0())
2272                                 good = false;
2273                         return std::move(ret);
2274                 }
2275         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_mer_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2069         {
2070                 m_mer_B(m_dc,n);
2071                 return (*this);
2072         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_mer_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2097         {
2098                 m_mer_B(m_dc,n);
2099                 return (*this);
2100         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_rem_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2055         {
2056                 m_rem_B(m_dc,n);
2057                 return (*this);
2058         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_rem_B (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2083         {
2084                 m_rem_B(m_dc,n);
2085                 return (*this);
2086         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_sub (\fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB\&. COPIA DE RARG
.PP
CARRY INICIAL POR DEFECTO: NULO
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE RESTA RARG A LARG DESDE IDX=1 A IDX=L-1
.PP
.nf
2252         {
2254                 dig_t cprarg{rarg};
2256                 dig_t borrow{dig_0()};
2258                 if (larg[0] >= rarg) {
2259                         larg[0] -= rarg;
2260                         borrow = dig_0();
2261                         return (larg);
2262                 }
2263                 else {
2264                         cprarg -= larg[0];
2265                         larg[0] = cprarg\&.C_B();
2266                         borrow  = dig_1();
2267                 }
2269                 for(size_t ix{1} ; ix < L ; ++ix) {
2270                         if (borrow\&.is_1()) {
2271                                 if (arg[ix]\&.is_0()) {
2272                                         arg[ix] = dig_Bm1();
2273                                         borrow  = dig_1();
2274                                         continue;
2275                                 }
2276                                 else {
2277                                         --arg[ix];
2278                                         borrow = dig_0();
2279                                         return (arg);
2280                                 }
2281                         }
2282                 }
2283                 return (arg);
2284         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr const \fBbase_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::m_sub (\fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB\&. COPIA DE RARG
.PP
CARRY INICIAL POR DEFECTO: NULO
.PP
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG
.PP
BUCLE FOR QUE RESTA RARG A LARG DESDE IDX=1 A IDX=L-1
.PP
.nf
2280         {
2282                 dig_t cprarg{rarg};
2284                 dig_t borrow{dig_0()};
2286                 if (larg[0] >= rarg) {
2287                         larg[0] -= rarg;
2288                         borrow = dig_0();
2289                         return (larg);
2290                 }
2291                 else {
2292                         cprarg -= larg[0];
2293                         larg[0] = cprarg\&.C_B();
2294                         borrow  = dig_1();
2295                 }
2297                 for(size_t ix{1} ; ix < L ; ++ix) {
2298                         if (borrow\&.is_1()) {
2299                                 if (arg[ix]\&.is_0()) {
2300                                         arg[ix] = dig_Bm1();
2301                                         borrow  = dig_1();
2302                                         continue;
2303                                 }
2304                                 else {
2305                                         --arg[ix];
2306                                         borrow = dig_0();
2307                                         return (arg);
2308                                 }
2309                         }
2310                 }
2311                 return (arg);
2312         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::is_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mC_B ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1895         {
1896                 mC_B(m_dc);
1897                 return (*this);
1898         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::mC_B()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::mC_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mC_B ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1923         {
1924                 mC_B(m_dc);
1925                 return (*this);
1926         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::mC_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mC_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1902         {
1903                 mC_Bm1(m_dc);
1904                 return (*this);
1905         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mC_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1930         {
1931                 mC_Bm1(m_dc);
1932                 return (*this);
1933         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::mC_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mer_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2062         {
2063                 nat_reg_digs_t ret{mer_B(m_dc,n)};
2064                 return std::move(ret);
2065         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::mer_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2090         {
2091                 nat_reg_digs_t ret{mer_B(m_dc,n)};
2092                 return std::move(ret);
2093         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP Int_Type () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
931                                                             {
932                 using type_traits::maxbase();
933                 uint64_t retInt{0};
934                 uint64_t BasePowIx{1};
935                 for(size_t k{0} ; k < L ; ++k) {
936                         retInt += m_dc[k]*BasePowIx;
937                         BasePowIx *= B;
938                         if(     (k+1 < L)
939                                                 &&
940                                         ( maxbase<Int_Type>() < (retInt+(m_dc[k+1]*BasePowIx)) )        )
941                         {       return retInt; }
942                 }
943                 return retInt;
944         }
.fi
.PP
Hace referencia a \fBNumRepr::type_traits::maxbase()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP Int_Type () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
931                                                             {
932                 using type_traits::maxbase();
933                 uint64_t retInt{0};
934                 uint64_t BasePowIx{1};
935                 for(size_t k{0} ; k < L ; ++k) {
936                         retInt += m_dc[k]*BasePowIx;
937                         BasePowIx *= B;
938                         if(     (k+1 < L)
939                                                 &&
940                                         ( maxbase<Int_Type>() < (retInt+(m_dc[k+1]*BasePowIx)) )        )
941                         {       return retInt; }
942                 }
943                 return retInt;
944         }
.fi
.PP
Hace referencia a \fBNumRepr::type_traits::maxbase()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator! () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1921         {
1922                 return C_Bm1();
1923         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::operator! () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1949         {
1950                 return C_Bm1();
1951         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1402         {
1403                 return (m_dc != arg);
1404         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1430         {
1431                 return (m_dc != arg);
1432         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1306                                                                             {
1307                 return (!(larg == rarg));
1308         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1334                                                                             {
1335                 return (!(larg == rarg));
1336         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1214                                                                       {
1215                 for(size_t ix{1} ; ix < N ; ++ix)
1216                         if (m_dc[ix]\&.is_not_0())
1217                                 return true;
1218                 if (larg[0] != rarg)
1219                         return true;
1220                 return false;
1221 
1222         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1242                                                                       {
1243                 for(size_t ix{1} ; ix < N ; ++ix)
1244                         if (m_dc[ix]\&.is_not_0())
1245                                 return true;
1246                 if (larg[0] != rarg)
1247                         return true;
1248                 return false;
1249 
1250         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1410         {
1411                 return (m_dc != arg\&.const_ref_data());
1412         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator!\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1438         {
1439                 return (m_dc != arg\&.const_ref_data());
1440         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP% (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3055         {
3056                 nat_reg_digs_t ret(*this);
3057                 UINT_T retuds   = ret(0);
3058                 UINT_T retdecs  = ret(1);
3059                 UINT_T arguds   = arg(0);
3060                 UINT_T argdecs  = arg(1);
3061 
3062                 retuds  += (B*retdecs);
3063                 arguds  += (B*argdecs);
3064                 retuds  %= arguds;
3065                 retdecs  = retuds;
3066                 retdecs /= B;
3067                 retuds  %= B;
3068                 ret\&.m_dc[1]      = dig_t(retdecs);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP% (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
REMAINDER BY A DIGIT\&. 
.PP
.nf
2866                 {
.fi
.PP
Hace referencia a \fBNumRepr::fediv\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP& (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2140         {
2141                 nat_reg_digs_t ret{*this};
2142                 ret &= arg;
2143                 return std::move(ret);
2144         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP& (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2168         {
2169                 nat_reg_digs_t ret{*this};
2170                 ret &= arg;
2171                 return std::move(ret);
2172         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP&= (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2133         {
2134                 m_dc &= arg\&.const_ref_data();
2135                 return (*this);
2136         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP&= (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2161         {
2162                 m_dc &= arg\&.const_ref_data();
2163                 return (*this);
2164         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP() (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1556         {
1557                 return static_cast<Int_Type>(m_dc[idx]());
1558         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP() (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1584         {
1585                 return static_cast<Int_Type>(m_dc[idx]());
1586         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP* (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3020         {
3021                 nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP* (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3047         {
3048                 nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP* (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2841                 {
2842                         nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP*= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2963         {
2964                 nat_reg_digs_t cpthis{*this};
2965                 nat_reg_digs_t& cthis{0};
2966                 for(size_t ix{0} ; ix < N ; ++ix) {
2967                         cthis += (cpthis*arg[ix]);
2968                         cpthis <<= 1;
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP*= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2977         {
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+ (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
TO DO\&. TO DO 
.PP
.nf
3002         {
3003                 nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+ (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2316         {
2317                 return nat_reg_digs_t{add(m_dc,rarg)};
2318         }
.fi
.PP
Hace referencia a \fBNumRepr::add\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+ (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2344         {
2345                 return nat_reg_digs_t{add(m_dc,rarg)};
2346         }
.fi
.PP
Hace referencia a \fBNumRepr::add\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+ (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3029         {
3030                 nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+ (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2821        :
2822 
2823                 constexpr inline
2824                 auto operator + (dig_t arg) const noexcept
2825                 {
2826                         nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP++ ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1691         {
1692                 preincrement<false>(m_dc);
1693                 return (*this);
1694         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP++ ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1719         {
1720                 preincrement<false>(m_dc);
1721                 return (*this);
1722         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP++ (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1723         {
1724                 postincrement<false>(m_dc);
1725                 return (*this);
1726         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP++ (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1751         {
1752                 postincrement<false>(m_dc);
1753                 return (*this);
1754         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2881         {
2882                 nat_reg_digs_t & cthis = (*this);
2883                 dig_t                           carry{0};
2884                 if constexpr (N < L) {
2885                         for (size_t ix{0} ; ix < N ; ++ix) {
2886                                 dig_t&                          cthis{cthis\&.m_dc[ix]};
2887                                 const dig_t     cpthis{cthis\&.m_dc[ix]};
2888                                 const dig_t     cparg{arg[ix]};
2889                                 cthis += cparg;
2890                                 cthis += carry;
2891                                 if ((cthis < cpthis) || (cparg < cpthis))
2892                                         carry = dig_1();
2893                         }
2894                         for (size_t ix{N} ; ix < L ; ++ix) {
2895                                 dig_t&                          cthis{cthis\&.m_dc[ix]};
2896                                 const dig_t     cpthis{cthis\&.m_dc[ix]};
2897                                 cthis += carry;
2898                                 if (cthis < cpthis)
2899                                         carry = dig_1();
2900                         }
2901                 }
2902                 else {
2903                         for (size_t ix{0} ; ix < L ; ++ix) {
2904                                 dig_t&                          cthis{cthis\&.m_dc[ix]};
2905                                 const dig_t     cpthis{cthis\&.m_dc[ix]};
2906                                 const dig_t     cparg{arg[ix]};
2907                                 cthis += cparg;
2908                                 cthis += carry;
2909                                 if ((cthis < cpthis) || (cparg < cpthis))
2910                                         carry = dig_1();
2911                         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2302         {
2303                 m_add<false>(m_dc,rarg);
2304                 return (*this);
2305         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2330         {
2331                 m_add<false>(m_dc,rarg);
2332                 return (*this);
2333         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP+= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2920         {
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1927         {
1928                 return C_B();
1929         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1955         {
1956                 return C_B();
1957         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::C_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3011         {
3012                 nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2322         {
2323                 return nat_reg_digs_t{sub(m_dc,rarg)};
2324         }
.fi
.PP
Hace referencia a \fBNumRepr::sub\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2350         {
2351                 return nat_reg_digs_t{sub(m_dc,rarg)};
2352         }
.fi
.PP
Hace referencia a \fBNumRepr::sub\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
3038         {
3039                 nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr auto \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\- (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2833                 {
2834                         nat_reg_digs_t ret(*this);
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-\- ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1814         {
1815                 predecrement<false>(m_dc);
1816                 return (*this);
1817         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-\- ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1842         {
1843                 predecrement<false>(m_dc);
1844                 return (*this);
1845         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-\- (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1846         {
1847                 postdecrement<false>(m_dc);
1848                 return (*this);
1849         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-\- (int)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1874         {
1875                 postdecrement<false>(m_dc);
1876                 return (*this);
1877         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
< cparg pasa a ser el complemento a la base menos 1 de cparg
.PP
.nf
2929         {
2930                 nat_reg_digs_t & cthis{*this};
2931                 base_N_t<N> cparg{arg};
2933                         // begin
2934                         for(auto & elem_dig : cparg) {
2935                                 elem_dig = dig_t(B-1)-elem_dig;
2936                         }
2937                         dig_t                   carry{0};
2938                         for (size_t ix{0} ; ix < N ; ++ix) {
2939                                 dig_t&                          cthis{cthis\&.m_dc[ix]};
2940                                 const dig_t     cpthis{cthis\&.m_dc[ix]};
2941                                 cthis += carry;
2942                                 if (cthis < cpthis)
2943                                         carry = dig_1();
2944                         }
2945                         // end
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2309         {
2310                 m_sub<false>(m_dc,rarg);
2311                 return (*this);
2312         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-= (const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2337         {
2338                 m_sub<false>(m_dc,rarg);
2339                 return (*this);
2340         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP\-= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2954         {
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP/ (\fBdig_t\fP arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
DIVISION BY A DIGIT\&. 
.PP
.nf
2859                 {
.fi
.PP
Hace referencia a \fBNumRepr::fediv\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1450         {
1451                 return (m_dc < arg);
1452         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1478         {
1479                 return (m_dc < arg);
1480         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1342         {
1343                 constexpr size_t P{std::min(N,M)};
1344                 constexpr size_t Q{std::max(N,M)};
1345                 constexpr bool N_gt_M{N>M};
1346 
1347                 if constexpr (N != M) {
1348                         for(size_t ix{P} ; ix < Q ; ++ix) {
1349                                 if constexpr (N>M) {
1350                                         if (larg[ix]\&.is_not_0())
1351                                                 return false;
1352                                 }
1353                                 else {
1354                                         if (rarg[ix]\&.is_not_0())
1355                                                 return true;
1356                                 }
1357                         }
1358                 }
1359 
1360                 for(int32_t ix{N} ; ix > -1 ; --ix)
1361                         if (larg[ix] < rarg[ix])
1362                                 return true;
1363                 return false;
1364         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1370         {
1371                 constexpr size_t P{std::min(N,M)};
1372                 constexpr size_t Q{std::max(N,M)};
1373                 constexpr bool N_gt_M{N>M};
1374 
1375                 if constexpr (N != M) {
1376                         for(size_t ix{P} ; ix < Q ; ++ix) {
1377                                 if constexpr (N>M) {
1378                                         if (larg[ix]\&.is_not_0())
1379                                                 return false;
1380                                 }
1381                                 else {
1382                                         if (rarg[ix]\&.is_not_0())
1383                                                 return true;
1384                                 }
1385                         }
1386                 }
1387 
1388                 for(int32_t ix{N} ; ix > -1 ; --ix)
1389                         if (larg[ix] < rarg[ix])
1390                                 return true;
1391                 return false;
1392         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1239                                                                       {
1240                 for(size_t ix{1} ; ix < N ; ++ix)
1241                         if (m_dc[ix]\&.is_not_0())
1242                                 return false;
1243                 if (larg[0] >= rarg)
1244                         return false;
1245                 return true;
1246         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1267                                                                       {
1268                 for(size_t ix{1} ; ix < N ; ++ix)
1269                         if (m_dc[ix]\&.is_not_0())
1270                                 return false;
1271                 if (larg[0] >= rarg)
1272                         return false;
1273                 return true;
1274         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1458         {
1459                 return (m_dc < arg\&.const_ref_data());
1460         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP< (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1486         {
1487                 return (m_dc < arg\&.const_ref_data());
1488         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<< (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2020         {
2021                 nat_reg_digs_t cpthis{*this};
2022                 cpthis\&.ref_data() <<= n;
2023                 return std::move(cpthis);
2024         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<< (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2048         {
2049                 nat_reg_digs_t cpthis{*this};
2050                 cpthis\&.ref_data() <<= n;
2051                 return std::move(cpthis);
2052         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<<= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2028         {
2029                 m_dc <<= n;
2030                 return (*this);
2031         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<<= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2056         {
2057                 m_dc <<= n;
2058                 return (*this);
2059         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1418         {
1419                 return (m_dc <= arg);
1420         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1446         {
1447                 return (m_dc <= arg);
1448         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1378         {
1379                 return (!(larg > rarg));
1380         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1406         {
1407                 return (!(larg > rarg));
1408         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1263                                                                         {
1264                 for(size_t ix{1} ; ix < N ; ++ix)
1265                         if (m_dc[ix]\&.is_not_0())
1266                                 return false;
1267                 if (larg[0] > rarg)
1268                         return false;
1269                 else
1270                         return true;
1271         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1291                                                                         {
1292                 for(size_t ix{1} ; ix < N ; ++ix)
1293                         if (m_dc[ix]\&.is_not_0())
1294                                 return false;
1295                 if (larg[0] > rarg)
1296                         return false;
1297                 else
1298                         return true;
1299         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1426         {
1427                 return (m_dc <= arg\&.const_ref_data());
1428         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1454         {
1455                 return (m_dc <= arg\&.const_ref_data());
1456         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1497         {
1498                 if (m_dc == arg)
1499                         return std::weak_ordering::equivalent;
1500                 else if (m_dc < arg)
1501                         return std::weak_ordering::less;
1502                 else
1503                         return std::weak_ordering::greater;
1504         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::weak_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1525         {
1526                 if (m_dc == arg)
1527                         return std::weak_ordering::equivalent;
1528                 else if (m_dc < arg)
1529                         return std::weak_ordering::less;
1530                 else
1531                         return std::weak_ordering::greater;
1532         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr std::weak_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1509         {
1510                 if (m_dc > arg)
1511                         return std::weak_ordering::greater;
1512                 else if (m_dc < arg)
1513                         return std::weak_ordering::less;
1514                 else
1515                         return std::weak_ordering::equivalent;
1516         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr std::weak_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBdig_t\fP & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1537         {
1538                 if (m_dc > arg)
1539                         return std::weak_ordering::greater;
1540                 else if (m_dc < arg)
1541                         return std::weak_ordering::less;
1542                 else
1543                         return std::weak_ordering::equivalent;
1544         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1483         {
1484                 if (m_dc == arg\&.const_ref_data())
1485                         return std::strong_ordering::equal;
1486                 else if (m_dc < arg\&.const_ref_data())
1487                         return std::strong_ordering::less;
1488                 else
1489                         return std::strong_ordering::greater;
1490         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr std::strong_ordering \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP<=> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERADOR COMPARACION SPACESHIP C++20\&. 
.PP
.nf
1511         {
1512                 if (m_dc == arg\&.const_ref_data())
1513                         return std::strong_ordering::equal;
1514                 else if (m_dc < arg\&.const_ref_data())
1515                         return std::strong_ordering::less;
1516                 else
1517                         return std::strong_ordering::greater;
1518         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. 
.PP
.nf
475         {
476                 if (&(this->m_dc)!=(&arg))
477                         move_arg_N<N>(std::move(arg));
478                 return (*this);
479         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBbase_N_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T\&. 
.PP
.nf
475         {
476                 if (&(this->m_dc)!=(&arg))
477                         move_arg_N<N>(std::move(arg));
478                 return (*this);
479         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. 
.PP
.nf
464         {
465                 if (&(this->m_dc)!=(&arg))
466                         copy_arg_N<N>(arg);
467                 return (*this);
468         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T\&. 
.PP
.nf
464         {
465                 if (&(this->m_dc)!=(&arg))
466                         copy_arg_N<N>(arg);
467                 return (*this);
468         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. 
.PP
.nf
453         {
454                 if (&(this->m_dc)!=(&arg))
455                         copy_arg_N<N>(arg);
456                 return (*this);
457         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBbase_N_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA CONST \fINO\fP COPIABLE DESDE BASE_N_T\&. 
.PP
.nf
453         {
454                 if (&(this->m_dc)!=(&arg))
455                         copy_arg_N<N>(arg);
456                 return (*this);
457         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN DIGITO (CONVERSION) 
.PP
.nf
696                  {
697                 if ((&(this->m_dc[0]))!=(&arg)) {
698                         set_0();
699                         m_dc[0] = arg;
700                 }
701                 return (*this);
702         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBdig_t\fP & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN DIGITO (CONVERSION) 
.PP
.nf
696                  {
697                 if ((&(this->m_dc[0]))!=(&arg)) {
698                         set_0();
699                         m_dc[0] = arg;
700                 }
701                 return (*this);
702         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. 
.PP
.nf
486         {
487                 if (this != &arg)
488                         (*this) = arg\&.const_ref_data();
489                 return (*this);
490         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. 
.PP
.nf
508         {
509                 if (this != &arg)
510                         (*this) = arg\&.const_ref_data();
511                 return (*this);
512         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR\&. 
.PP
.nf
486         {
487                 if (this != &arg)
488                         (*this) = arg\&.const_ref_data();
489                 return (*this);
490         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (const \fBnat_reg_N_digs_t\fP< N > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR COPIA EN LA QUE \fINO\fP SE PUEDE COPIAR\&. 
.PP
.nf
508         {
509                 if (this != &arg)
510                         (*this) = arg\&.const_ref_data();
511                 return (*this);
512         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (Int_Type arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) 
.PP
.nf
735                                                                              {
736                 assign(m_dc,arg);
737                 return (*this);
738         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::assign()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<type_traits::integral_c Int_Type> constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (Int_Type arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) 
.PP
.nf
735                                                                              {
736                 assign(m_dc,arg);
737                 return (*this);
738         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::assign()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR MOVIMIENTO\&. 
.PP
.nf
497         {
498                 if (this != &arg)
499                         (*this) = std::move(*(arg\&.data()));
500                 return (*this);
501         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP= (\fBnat_reg_N_digs_t\fP< N > && arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION ASIGNACION POR MOVIMIENTO\&. 
.PP
.nf
497         {
498                 if (this != &arg)
499                         (*this) = std::move(*(arg\&.data()));
500                 return (*this);
501         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1386         {
1387                 return (m_dc == arg);
1388         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1414         {
1415                 return (m_dc == arg);
1416         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
COMPARACIONES ENTRE BASE_N_T Y BASE_N_T HETEROGENEOS EN GENERAL EN FORMA BASE_N_T<N> @ BASE_N_T<M> STATIC 
.PP
.nf
1280         {
1281                 constexpr size_t P{std::min(N,M)};
1282                 constexpr size_t Q{std::max(N,M)};
1283                 constexpr bool N_gt_M{N>M};
1284 
1285                 if constexpr (N!=M) {
1286                         for (size_t ix{P} ix < Q ; ++ix) {
1287                                 if constexpr (N_gt_M) {
1288                                         if (larg[ix]\&.is_not_0())
1289                                                 return false;
1290                                 }
1291                                 else {
1292                                         if (rarg[ix]\&.is_not_0())
1293                                                 return false;
1294                                 }
1295                         }
1296                 }
1297                 for(size_t ix{0} ; ix < P ; ++ix)
1298                         if (larg[ix] != rarg[ix])
1299                                 return false;
1300                 return true;
1301         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"
COMPARACIONES ENTRE BASE_N_T Y BASE_N_T HETEROGENEOS EN GENERAL EN FORMA BASE_N_T<N> @ BASE_N_T<M> STATIC 
.PP
.nf
1308         {
1309                 constexpr size_t P{std::min(N,M)};
1310                 constexpr size_t Q{std::max(N,M)};
1311                 constexpr bool N_gt_M{N>M};
1312 
1313                 if constexpr (N!=M) {
1314                         for (size_t ix{P} ix < Q ; ++ix) {
1315                                 if constexpr (N_gt_M) {
1316                                         if (larg[ix]\&.is_not_0())
1317                                                 return false;
1318                                 }
1319                                 else {
1320                                         if (rarg[ix]\&.is_not_0())
1321                                                 return false;
1322                                 }
1323                         }
1324                 }
1325                 for(size_t ix{0} ; ix < P ; ++ix)
1326                         if (larg[ix] != rarg[ix])
1327                                 return false;
1328                 return true;
1329         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"
COMPARACIONES ENTRE BASE_N_T Y DIG_T EN FORMA BASE_N_T<N> @ DIG_T STATIC 
.PP
.nf
1202                                                                       {
1203                 if (larg[0] != rarg)
1204                         return false;
1205                 for(size_t ix{1} ; ix < N ; ++ix)
1206                         if (m_dc[ix]\&.is_not_0())
1207                                 return false;
1208                 return true;
1209         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"
COMPARACIONES ENTRE BASE_N_T Y DIG_T EN FORMA BASE_N_T<N> @ DIG_T STATIC 
.PP
.nf
1230                                                                       {
1231                 if (larg[0] != rarg)
1232                         return false;
1233                 for(size_t ix{1} ; ix < N ; ++ix)
1234                         if (m_dc[ix]\&.is_not_0())
1235                                 return false;
1236                 return true;
1237         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1394         {
1395                 return (m_dc == arg\&.const_ref_data());
1396         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP== (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1422         {
1423                 return (m_dc == arg\&.const_ref_data());
1424         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1466         {
1467                 return (m_dc > arg);
1468         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1494         {
1495                 return (m_dc > arg);
1496         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1314         {
1315                 constexpr size_t P{std::min(N,M)};
1316                 constexpr size_t Q{std::max(N,M)};
1317                 constexpr bool N_gt_M{N>M};
1318 
1319                 if constexpr (N != M) {
1320                         for(size_t ix{P} ; ix < Q ; ++ix) {
1321                                 if constexpr (N>M) {
1322                                         if (larg[ix]\&.is_not_0())
1323                                                 return true;
1324                                 }
1325                                 else {
1326                                         if (rarg[ix]\&.is_not_0())
1327                                                 return false;
1328                                 }
1329                         }
1330                 }
1331 
1332                 for(int32_t ix{N} ; ix > -1 ; --ix)
1333                         if (larg[ix] > rarg[ix])
1334                                 return true;
1335                 return false;
1336         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1342         {
1343                 constexpr size_t P{std::min(N,M)};
1344                 constexpr size_t Q{std::max(N,M)};
1345                 constexpr bool N_gt_M{N>M};
1346 
1347                 if constexpr (N != M) {
1348                         for(size_t ix{P} ; ix < Q ; ++ix) {
1349                                 if constexpr (N>M) {
1350                                         if (larg[ix]\&.is_not_0())
1351                                                 return true;
1352                                 }
1353                                 else {
1354                                         if (rarg[ix]\&.is_not_0())
1355                                                 return false;
1356                                 }
1357                         }
1358                 }
1359 
1360                 for(int32_t ix{N} ; ix > -1 ; --ix)
1361                         if (larg[ix] > rarg[ix])
1362                                 return true;
1363                 return false;
1364         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1227                                                                      {
1228                 for(size_t ix{1} ; ix < N ; ++ix)
1229                         if (m_dc[ix]\&.is_not_0())
1230                                 return true;
1231                 if (larg[0] > rarg)
1232                         return true;
1233                 return false;
1234         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1255                                                                      {
1256                 for(size_t ix{1} ; ix < N ; ++ix)
1257                         if (m_dc[ix]\&.is_not_0())
1258                                 return true;
1259                 if (larg[0] > rarg)
1260                         return true;
1261                 return false;
1262         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1474         {
1475                 return (m_dc > arg\&.const_ref_data());
1476         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP> (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1502         {
1503                 return (m_dc > arg\&.const_ref_data());
1504         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1434         {
1435                 return (m_dc >= arg);
1436         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBbase_N_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1462         {
1463                 return (m_dc >= arg);
1464         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1370         {
1371                 return (!(larg < rarg));
1372         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP M> 
.br
requires ((N>0)&&(M>0))static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBbase_N_t\fP< N > & larg, const \fBbase_N_t\fP< M > & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1398         {
1399                 return (!(larg < rarg));
1400         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1251                                                                        {
1252                 for(size_t ix{1} ; ix < N ; ++ix)
1253                         if (m_dc[ix]\&.is_not_0())
1254                                 return true;
1255                 if (larg[0] >= rarg)
1256                         return true;
1257                 return false;
1258         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)static constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBbase_N_t\fP< N > & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP"

.PP
.nf
1279                                                                        {
1280                 for(size_t ix{1} ; ix < N ; ++ix)
1281                         if (m_dc[ix]\&.is_not_0())
1282                                 return true;
1283                 if (larg[0] >= rarg)
1284                         return true;
1285                 return false;
1286         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1442         {
1443                 return (m_dc >= arg\&.const_ref_data());
1444         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>0)constexpr bool \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>= (const \fBnat_reg_N_digs_t\fP< N > & arg) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1470         {
1471                 return (m_dc >= arg\&.const_ref_data());
1472         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::const_ref_data()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>> (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2035         {
2036                 return std::move(nat_reg_digs_t{*this}\&.ref_data() >>= n);
2037         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>> (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2063         {
2064                 return std::move(nat_reg_digs_t{*this}\&.ref_data() >>= n);
2065         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>>= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2041         {
2042                 m_dc >>= n;
2043                 return (*this);
2044         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP>>= (\fBsize_t\fP n)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2069         {
2070                 m_dc >>= n;
2071                 return (*this);
2072         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP[] (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1544         {
1545                 return (m_dc[idx]);
1546         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP[] (\fBsize_t\fP idx) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1572         {
1573                 return (m_dc[idx]);
1574         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP[] (\fBsize_t\fP idx)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1550         {
1551                 return (m_dc[idx]);
1552         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBdig_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP[] (\fBsize_t\fP idx)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1578         {
1579                 return (m_dc[idx]);
1580         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP| (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2125         {
2126                 nat_reg_digs_t ret{*this};
2127                 ret |= arg;
2128                 return std::move(ret);
2129         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP| (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2153         {
2154                 nat_reg_digs_t ret{*this};
2155                 ret |= arg;
2156                 return std::move(ret);
2157         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP|= (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2118         {
2119                 m_dc |= arg\&.const_ref_data();
2120                 return (*this);
2121         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr const \fBnat_reg_digs_t\fP & \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >\fB::operator\fP|= (const \fBnat_reg_digs_t\fP< UINT_T, B, L > & arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2146         {
2147                 m_dc |= arg\&.const_ref_data();
2148                 return (*this);
2149         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::put (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1537         {
1538                 m_dc[I] = arg;
1539                 return (m_dc[I]);
1540         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP I> 
.br
requires ((I<L)&&(I>=0))constexpr \fBdig_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::put (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
1565         {
1566                 m_dc[I] = arg;
1567                 return (m_dc[I]);
1568         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
FUNCIONES INMEDIATAS QUE NOS DAN CONSTANTES DEL TIPO DE LA ACTUAL CLASE SE HACE CREANDO UNA VARIABLE RVALUE TEMPORAL CON LA FUNCION HOMOLOGA PARA BASE_T 
.PP
.nf
182                                              {
183                 return nat_reg_digs_t{regd_base_0()};
184         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_0()\fP\&.
.PP
Referenciado por \fBNumRepr::operator>>()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
FUNCIONES INMEDIATAS QUE NOS DAN CONSTANTES DEL TIPO DE LA ACTUAL CLASE SE HACE CREANDO UNA VARIABLE RVALUE TEMPORAL CON LA FUNCION HOMOLOGA PARA BASE_T 
.PP
.nf
182                                              {
183                 return nat_reg_digs_t{regd_base_0()};
184         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
186                                                      {
187                 return nat_reg_digs_t{regd_base_1()};
188         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
186                                                      {
187                 return nat_reg_digs_t{regd_base_1()};
188         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
194                                                          {
195                 return nat_reg_digs_t{regd_base_B()};
196         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
194                                                          {
195                 return nat_reg_digs_t{regd_base_B()};
196         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL 
.PP
.nf
155                                       {
156                 return base_t{regd_base_N_0<L>()};
157         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL 
.PP
.nf
155                                       {
156                 return base_t{regd_base_N_0<L>()};
157         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
159                                        {
160                 return base_t{regd_base_N_1<L>()};
161         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
159                                        {
160                 return base_t{regd_base_N_1<L>()};
161         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
167                                        {
168                 return base_t{regd_base_N_B<L>()};
169         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
167                                        {
168                 return base_t{regd_base_N_B<L>()};
169         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
163                                          {
164                 return base_t{regd_base_N_Bm1<L>()};
165         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
163                                          {
164                 return base_t{regd_base_N_Bm1<L>()};
165         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL 
.PP
.nf
99                                                     {
100                 base_N_t<N> ret{};
101                 for(auto& dig : ret) {
102                         dig = dig_0();
103                 }
104                 return ret;
105         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"
PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL 
.PP
.nf
99                                                     {
100                 base_N_t<N> ret;
101                 for(auto& dig : ret) {
102                         dig = dig_0();
103                 }
104                 return ret;
105         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
109                                                             {
110                 base_N_t<N> ret{regd_base_N_0<N>()};
111                 ret[0] = dig_1();
112                 return ret;
113         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
109                                                             {
110                 base_N_t<N> ret{regd_base_N_0<N>()};
111                 ret[0] = dig_1();
112                 return ret;
113         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
125                                                                  {
126                 base_N_t<N> ret{regd_base_N_0<N>()};
127                 ret[1] = dig_1();
128                 return ret;
129         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
125                                                                  {
126                 base_N_t<N> ret{regd_base_N_0<N>()};
127                 ret[1] = dig_1();
128                 return ret;
129         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
117                                                             {
118                 base_N_t<N> ret{regd_base_N_0<N>()};
119                 ret[0] = dig_Bm1();
120                 return ret;
121         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N> 
.br
requires (N>=0)static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
117                                                             {
118                 base_N_t<N> ret{regd_base_N_0<N>()};
119                 ret[0] = dig_Bm1();
120                 return ret;
121         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
133                                                          {
134                 base_N_t<N> ret{regd_base_N_0<N>()};
135                 ret[n] = dig_1();
136                 return ret;
137         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
133                                                          {
134                 base_N_t<N> ret{regd_base_N_0<N>()};
135                 ret[n] = dig_1();
136                 return ret;
137         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
141                                                                 {
142                 base_N_t<N> ret{};
143                 for(size_t ix{0} ; ix < n ; ++ix) {
144                         ret[ix] = dig_Bm1();
145                 }
146                 for(size_t ix{n} ; ix < N ; ++ix) {
147                         ret[ix] = dig_0();
148                 }
149                 return ret;
150         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N, \fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < N))static consteval \fBbase_N_t\fP< N > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_N_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
141                                                                 {
142                 base_N_t<N> ret{};
143                 for(size_t ix{0} ; ix < n ; ++ix) {
144                         ret[ix] = dig_Bm1();
145                 }
146                 for(size_t ix{n} ; ix < N ; ++ix) {
147                         ret[ix] = dig_0();
148                 }
149                 return ret;
150         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
171                                                  {
172                 return base_t{regd_base_N_pow_n_B<L>()};
173         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_pow_n_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
171                                                  {
172                 return base_t{regd_base_N_pow_n_B<L>()};
173         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
175                                                 {
176                 return base_t{regd_base_N_pow_n_B_m1<L>()};
177         }
.fi
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_pow_n_B_m1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_base_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
175                                                 {
176                 return base_t{regd_base_N_pow_n_B_m1<L>()};
177         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
190                                                      {
191                 return nat_reg_digs_t{regd_base_Bm1()};
192         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
190                                                      {
191                 return nat_reg_digs_t{regd_base_Bm1()};
192         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
200                                                          {
201                 return nat_reg_digs_t{regd_base_pow_n_B()};
202         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_pow_n_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
200                                                          {
201                 return nat_reg_digs_t{regd_base_pow_n_B()};
202         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_pow_n_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
206                                                                 {
207                 return nat_reg_digs_t{regd_base_pow_n_B_m1()};
208         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_pow_n_B_m1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regd_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
206                                                                 {
207                 return nat_reg_digs_t{regd_base_pow_n_B_m1()};
208         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regd_base_pow_n_B_m1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
ARRAYS DE ENTEROS (CONSTANTES EN TIEMPO DE COMPILACION INMEDIATAS) 
.PP
.nf
211                                                                                         {
212                 reg_ints_t<L> ret{};
213                 for(auto& digint : ret) {
214                         digint = dig_0()();
215                 }
216                 return ret;
217         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_1()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_B()\fP, \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_pow_n_B()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
ARRAYS DE ENTEROS (CONSTANTES EN TIEMPO DE COMPILACION INMEDIATAS) 
.PP
.nf
211                                                                                         {
212                 reg_ints_t<L> ret{};
213                 for(auto& digint : ret) {
214                         digint = dig_0()();
215                 }
216                 return ret;
217         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
220                                                                                         {
221                 reg_ints_t<L> ret{regi_0()};
222                 ret[0] = dig_1()();
223                 return ret;
224         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
220                                                                                         {
221                 reg_ints_t<L> ret{regi_0()};
222                 ret[0] = dig_1()();
223                 return ret;
224         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
234                                                                                   {
235                 reg_ints_t<L> ret{regi_0()};
236                 ret[1] = dig_1()();
237                 return ret;
238         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
234                                                                                   {
235                 reg_ints_t<L> ret{regi_0()};
236                 ret[1] = dig_1()();
237                 return ret;
238         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
227                                                                                         {
228                 reg_ints_t<L> ret{regi_0()};
229                 ret[0] = dig_Bm1()();
230                 return ret;
231         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
227                                                                                         {
228                 reg_ints_t<L> ret{regi_0()};
229                 ret[0] = dig_Bm1()();
230                 return ret;
231         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_Bm1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
243                                                                         {
244                 reg_ints_t<L> ret{regi_0()};
245                 ret[n] = dig_1()();
246                 return ret;
247         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_pow_n_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
243                                                                         {
244                 reg_ints_t<L> ret{regi_0()};
245                 ret[n] = dig_1()();
246                 return ret;
247         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::dig_1()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::regi_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
252                                                                 {
253                 reg_ints_t<L> ret{};
254                 for(size_t ix{0} ; ix < n ; ++ix) {
255                         ret[ix] = dig_t(B-1)();
256                 }
257                 for(size_t ix{n} ; ix < L ; ++ix) {
258                         ret[ix] = dig_t(0)();
259                 }
260                 return ret;
261         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP n> 
.br
requires ((n>=0)&&(n < L))static consteval \fBreg_ints_t\fP< L > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::regi_pow_n_B_m1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
252                                                                 {
253                 reg_ints_t<L> ret{};
254                 for(size_t ix{0} ; ix < n ; ++ix) {
255                         ret[ix] = dig_t(B-1)();
256                 }
257                 for(size_t ix{n} ; ix < L ; ++ix) {
258                         ret[ix] = dig_t(0)();
259                 }
260                 return ret;
261         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::rem_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2048         {
2049                 nat_reg_digs_t ret{rem_B(m_dc,n)};
2050                 return std::move(ret);
2051         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr \fBnat_reg_digs_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::rem_B (\fBsize_t\fP n) const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2076         {
2077                 nat_reg_digs_t ret{rem_B(m_dc,n)};
2078                 return std::move(ret);
2079         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. 
.PP
.nf
652                               {
653                 set_0(m_dc);
654         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_0()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::operator=()\fP y \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T\&. 
.PP
.nf
652                               {
653                 set_0(m_dc);
654         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_0()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. 
.PP
.nf
658                                 {
659                 set_Bm1(m_dc);
660         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_Bm1()\fP\&.
.PP
Referenciado por \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T\&. 
.PP
.nf
658                                 {
659                 set_Bm1(m_dc);
660         }
.fi
.PP
Hace referencia a \fBNumRepr::nat_reg_digs_t< UINT_T, B, L >::set_Bm1()\fP\&.
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_dig (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. 
.PP
.nf
664                                          {
665                 set_dig(m_dc,arg);
666         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_dig (\fBdig_t\fP arg)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T\&. 
.PP
.nf
664                                          {
665                 set_dig(m_dc,arg);
666         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
673                                        {
674                 set_interval_0<N_i,N_pf>(m_dc);
675         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_0 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
673                                        {
674                 set_interval_0<N_i,N_pf>(m_dc);
675         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
681                                          {
682                 set_interval_Bm1<N_i,N_pf>(m_dc);
683         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_Bm1 ()\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
681                                          {
682                 set_interval_Bm1<N_i,N_pf>(m_dc);
683         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_dig (\fBdig_t\fP dig)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
689                                                   {
690                 set_interval_0<N_i,N_pf>(m_dc,dig);
691         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP N_i, \fBsize_t\fP N_pf> 
.br
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::set_interval_dig (\fBdig_t\fP dig)\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T\&. 
.PP
.nf
689                                                   {
690                 set_interval_0<N_i,N_pf>(m_dc,dig);
691         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sub (const \fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2294         {
2295                 return m_sub<false>(larg,rarg);
2296         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static constexpr \fBbase_t\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sub (const \fBbase_t\fP & larg, const \fBdig_t\fP & rarg)\fC [inline]\fP, \fC [static]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
2322         {
2323                 return m_sub<false>(larg,rarg);
2324         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::subrepr () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
920         {
921                 return subregister<L,ibegin,iend>(m_dc);
922         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> template<\fBsize_t\fP ibegin, \fBsize_t\fP iend> 
.br
requires ((iend <= L)&&(ibegin < iend))constexpr \fBnat_reg_N_digs_t\fP< iend\-ibegin > \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::subrepr () const\fC [inline]\fP, \fC [constexpr]\fP, \fC [noexcept]\fP"

.PP
.nf
920         {
921                 return subregister<L,ibegin,iend>(m_dc);
922         }
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
84         {return dig_t::sui_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
84         {return dig_t::sui_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
86         {return dig_t::sui_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
86         {return dig_t::sui_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
90         {return dig_t::sui_B();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
90         {return dig_t::sui_B();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
88         {return dig_t::sui_B()-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
88         {return dig_t::sui_B()-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_Bp1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
92         {return dig_t::sui_B()+1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval \fBSIG_UINT_T\fP \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::sui_Bp1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
92         {return dig_t::sui_B()+1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
72         {return dig_t::ui_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_0 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
72         {return dig_t::ui_0();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
74         {return dig_t::ui_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
74         {return dig_t::ui_1();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
78         {return B;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_B ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
78         {return B;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
76         {return B-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_Bm1 ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
76         {return B-1;}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
82         {return dig_t::ui_max();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_max ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
82         {return dig_t::ui_max();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
80         {return dig_t::ui_submax();}
.fi
.SS "template<allowable_base_type_c UINT_T, UINT_T B, \fBsize_t\fP L> static consteval UINT_T \fBNumRepr::nat_reg_digs_t\fP< UINT_T, B, L >::ui_submax ()\fC [inline]\fP, \fC [static]\fP, \fC [noexcept]\fP"

.PP
.nf
80         {return dig_t::ui_submax();}
.fi


.SH "Autor"
.PP 
Generado automáticamente por Doxygen para NumericRepresentations del código fuente\&.
