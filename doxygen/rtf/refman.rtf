{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment NumericRepresentations }NumericRepresentations}
{\comment Generado por doxygen 1.9.6.}
{\creatim \yr2023\mo1\dy2\hr18\min19\sec24}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt NumericRepresentations}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Versi\'F3n \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Lunes, 2 de Enero de 2023 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Tabla de contenidos\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Indice de namespaces\par \pard\plain 
{\tc \v Indice de namespaces}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de 'namespaces'\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de los 'namespaces', con una breve descripci\'F3n:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b details} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_functions} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::lex} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABUB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Concept Index\par \pard\plain 
{\tc \v Concept Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Concepts\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all concepts with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b NumRepr::type_traits::arith_integral_c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TYPE_TRAITS AND CONCEPTS })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::arith_natural_c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::char_type_c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::integral_c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::signed_integral_c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR SIGNED INTEGRAL TYPES })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::uint_type_for_radix_c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES VALID FOR THE RADIX })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::unsigned_integral_c} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::all_are_the_same_type_c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::there_is_one_or_more_c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Indice jer\'E1rquico\par \pard\plain 
{\tc \v Indice jer\'E1rquico}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Jerarqu\'EDa de la clase\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Esta lista de herencias esta ordenada aproximadamente por orden alfab\'E9tico:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::array
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
NumRepr::reg_digs_t< UINT_T, B, L >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
NumRepr::nat_reg_digs_t< UINT_T, B, L >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
base_num_t
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
int_num_t< UINT_T, B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
nat_num_t< UINT_T, B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
basic_string
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
NumRepr::base_num_t< UINT_T, B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
details::cp_delete< aT, T, B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_delete< 0u >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_delete< 1u >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_delete< 2u >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_new< aT, T, num_vars, B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_new< 0u >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_new< 1u >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_new< 2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
details::cp_new< aT, T, std::numeric_limits< uchint >::max()>\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::dig_t< UINT_T, B >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::for_each_same_type< Head_t, Tail_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::for_each_same_type< Head_t >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
func_refvar_t< aT, T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
func_refvar_t< INT **, INT *, INT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
func_refvar_t< UINT **, UINT *, UINT >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::local_void_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::pack2array< Ts >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::pack2tuple< Ts >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::pow_B_to_E_t< Base, Exp >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::pow_B_to_E_t< Base, 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::pow_B_to_E_t< Base, 1 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::pow_B_to_E_t< Base, 2 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, oper >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, oper, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\'CDndice de clases\par \pard\plain 
{\tc \v \'CDndice de clases}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de clases\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de las clases, estructuras, uniones e interfaces con una breve descripci\'F3n:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::base_num_t< UINT_T, B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_delete< aT, T, B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_delete< 0u >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_delete< 1u >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_delete< 2u >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_new< aT, T, num_vars, B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_new< 0u >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_new< 1u >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_new< 2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b details::cp_new< aT, T, std::numeric_limits< uchint >::max()>} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::dig_t< UINT_T, B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::for_each_same_type< Head_t, Tail_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::for_each_same_type< Head_t >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b func_refvar_t< aT, T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b func_refvar_t< INT **, INT *, INT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b func_refvar_t< UINT **, UINT *, UINT >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b int_num_t< UINT_T, B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::local_void_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nat_num_t< UINT_T, B >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::nat_reg_digs_t< UINT_T, B, L >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::pack2array< Ts >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::pack2tuple< Ts >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::pow_B_to_E_t< Base, Exp >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA ANTIGUA PERO SEGURA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::pow_B_to_E_t< Base, 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::pow_B_to_E_t< Base, 1 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::pow_B_to_E_t< Base, 2 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::reg_digs_t< UINT_T, B, L >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> register_of_digits_t\{\}; })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, oper >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Auxiliary types for digit type and its operations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, oper, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TEMPLATE GENERAL })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == BEGININTOBJ_CT })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == ENDINTOBJ_CT-1 })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Indice de archivos\par \pard\plain 
{\tc \v Indice de archivos}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Lista de archivos\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Lista de todos los archivos con descripciones breves:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b auxiliary_functions.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b auxiliary_types.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b base_num_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b basic_types.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b dig_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b int_num_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b int_reg_digs_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b lexer_parser.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b memory_handler.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nat_num_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nat_rat_fixed_reg_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nat_rat_num_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b nat_reg_digs_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b pruebas_dig_t.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b rat_fixed_reg_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b rat_num_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b reg_digs_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b test_dig_t.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b utilities.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documentaci\'F3n de namespaces\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace details\par \pard\plain 
{\tc\tcl2 \v details}
{\xe \v details}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_delete}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_delete< 0u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_delete< 1u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_delete< 2u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_new}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_new< 0u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_new< 1u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b cp_new< 2 >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr\par \pard\plain 
{\tc\tcl2 \v NumRepr}
{\xe \v NumRepr}
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b auxiliary_functions}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b auxiliary_types}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b lex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b type_traits}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b base_num_t}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b dig_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nat_rat_fixed_reg_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b nat_reg_digs_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b reg_digs_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> register_of_digits_t\{\};. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b chint_t} = char\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NUEVOS NOMBRES PARA LOS ENTEROS O PARECIDOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b schint_t} = signed char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ssint_t} = signed short int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sint_t} = signed int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b slint_t} = signed long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sllint_t} = signed long long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uchint_t} = unsigned char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b usint_t} = unsigned short int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uint_t} = unsigned int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ulint_t} = unsigned long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ullint_t} = unsigned long long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uint128_t} = __uint128_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sint128_t} = __int128_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b size_t} = std::size_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sint8_t} = std::int8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sint16_t} = std::int16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sint32_t} = std::int32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b sint64_t} = std::int64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b int8_t} = std::int8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b int16_t} = std::int16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b int32_t} = std::int32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b int64_t} = std::int64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b fast8_t} = std::int_fast8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b fast16_t} = std::int_fast16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b fast32_t} = std::int_fast32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b fast64_t} = std::int_fast64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b least8_t} = std::int_least8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b least16_t} = std::int_least16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b least32_t} = std::int_least32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b least64_t} = std::int_least64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uint8_t} = std::uint8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uint16_t} = std::uint16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uint32_t} = std::uint32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uint64_t} = std::uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ufast8_t} = std::uint_fast8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ufast16_t} = std::uint_fast16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ufast32_t} = std::uint_fast32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b ufast64_t} = std::uint_fast64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uleast8_t} = std::uint_least8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uleast16_t} = std::uint_least16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uleast32_t} = std::uint_least32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uleast64_t} = std::uint_least64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b intmax_t} = std::intmax_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uintmax_t} = std::uintmax_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b uint128_t} B> using {\b digit_t} = {\b dig_t}< {\b type_traits::TypeFromIntNumber_t}< static_cast< {\b uint128_t} >(B)>, static_cast< {\b type_traits::TypeFromIntNumber_t}< static_cast< {\b uint128_t} >(B)> >(static_cast< {\b uint128_t} >(B)) >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o ... }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b uint128_t} B, {\b size_t} L> using {\b register_of_digits_t} = {\b reg_digs_t}< {\b type_traits::TypeFromIntNumber_t}< B >, static_cast< {\b type_traits::TypeFromIntNumber_t}< B > >(B), L >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b uint128_t} B, {\b size_t} L> using {\b register_digs_t} = {\b reg_digs_t}< {\b TypeFromIntNumber_t}< static_cast< {\b uint128_t} >(B)>, static_cast< {\b TypeFromIntNumber_t}< static_cast< {\b uint128_t} >(B)> >(static_cast< {\b uint128_t} >(B)), L >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeraciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b sign_e} : bool \{ {\b vminus} = true
, {\b vplus} = false
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b sign_funct_e} : char \{ {\b vzero} = 0
, {\b vminus} = -1
, {\b vplus} = +1
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
INTRODUCIDO. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b dig_format_e} : unsigned char \{ {\b BINnat} =0
, {\b BCDnat} =1
, {\b BCDexc3} =2
, {\b BCDaitk} =3
, {\b johnson_n} =4
, {\b biquinario} =5
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b num_type_e} : unsigned char \{ {\b natural} =0
, {\b entero} =1
, {\b racional} =2
, {\b real} =3
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A INTRODUCIR. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b nat_num_format_e} : bool \{ {\b natural} =false
, {\b exc_n} =true
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
YA INTRODUCIDO, PERO NO EXPLICITAMENTE NI COMPLETAMENTE. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b int_num_format_e} : unsigned char \{ {\b int_CB} =0
, {\b int_CBm1} =1
, {\b int_MS} =2
, {\b int_EXC_n} =3
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO NATURAL. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b rat_num_format_e} : unsigned char \{ {\b pair_num_den} =0
, {\b fxd_pt} =1
, {\b flt_pt} =2
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN C_B YA QUEDA EN MS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b binop_e} \{ {\b add}
, {\b sub}
, {\b mult}
, {\b div}
, {\b rem}
, {\b fediv}
, {\b other}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b sign_e} {\b Char2Sign} (char ch) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::arith_integral_c IntT> constexpr {\b sign_e} {\b Int2Sign} (IntT nu) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::arith_integral_c IntT> constexpr {\b sign_funct_e} {\b Int2SignFunct} (IntT nu) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::arith_natural_c NatIntT> constexpr {\b sign_funct_e} {\b Nat2SignFunct} (NatIntT nu) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T , usint B> constexpr ullint {\b pot_max_base_B_en_Int_T} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T , ullint B> constexpr ullint {\b num_digs_max_base_B_en_Int_T} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T , ullint B> constexpr ullint {\b max_base_B_en_Int_T} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T, B>())consteval UINT_T {\b ui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T, B>())consteval {\b dig_t}< UINT_T, B > {\b dig_max} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> digito_t\{\};. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> \par
requires ({\b type_traits::suitable_base}<UINT_T,Base>())std::istream & {\b operator>>} (std::istream &is, {\b dig_t}< UINT_T, Base > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> \par
requires ({\b type_traits::suitable_base}<UINT_T,Base>())std::ostream & {\b operator<<} (std::ostream &os, {\b dig_t}< UINT_T, Base > arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Length> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>()&&(Length > 0))std::istream & {\b operator>>} (std::istream &is, pfx_rat_reg_digs_t< Int_Type, Base, Length > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Long> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>())std::ostream & {\b operator<<} (std::ostream &os, const pfx_rat_reg_digs_t< Int_Type, Base, Long > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} LE> bool {\b is_nat_reg_digs_type_id} (std::string in)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACIONES PARA NAT_REG_DIGS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} LE> std::string {\b to_nat_reg_digs_type_string} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} LE> {\b size_t} {\b size_of_nat_reg_digs_type_string_idT} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, {\b size_t} Length> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>()&&(Length > 0))std::istream & {\b operator>>} (std::istream &is, {\b nat_reg_digs_t}< Int_Type, Base, Length > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, {\b size_t} Long> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>())std::ostream & {\b operator<<} (std::ostream &os, const {\b nat_reg_digs_t}< Int_Type, Base, Long > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} N> \par
requires (N>0)constexpr {\b reg_digs_t}< UInt_t, B, N > {\b concat} (const {\b reg_digs_t}< UInt_t, B, N > &larg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} N, {\b size_t} M> \par
requires ((N>0)&&(M>0))constexpr {\b reg_digs_t}< UInt_t, B, N+M > {\b concat} (const {\b reg_digs_t}< UInt_t, B, N > &larg, const {\b reg_digs_t}< UInt_t, B, M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} N> \par
requires (N > 0)constexpr {\b reg_digs_t}< UInt_t, B, N+1 > {\b concat} (const {\b reg_digs_t}< UInt_t, B, N > &larg, {\b dig_t}< UInt_t, B > rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} M> \par
requires (M > 0)constexpr {\b reg_digs_t}< UInt_t, B, 1+M > {\b concat} ({\b dig_t}< UInt_t, B > larg, const {\b reg_digs_t}< UInt_t, B, M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B> constexpr {\b reg_digs_t}< UInt_t, B, 1 > {\b concat} ({\b dig_t}< UInt_t, B > larg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1> CONCAT(DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B> constexpr {\b reg_digs_t}< UInt_t, B, 2 > {\b concat} ({\b dig_t}< UInt_t, B > larg, {\b dig_t}< UInt_t, B > rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, typename T0 , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}<UInt_t,B>>)&&...) && (std::is_same_v<T0,{\b dig_t}<UInt_t,B>>) )constexpr {\b reg_digs_t}< UInt_t, B, 1+(sizeof ...(Ts))> {\b concat} (T0 dig0, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} N, typename T , typename ... Ts> \par
requires (((std::is_same_v<Ts,{\b dig_t}<UInt_t,B>>)&&...)&&(std::is_same_v<T,{\b dig_t}<UInt_t,B>>)&&(N>0))constexpr {\b reg_digs_t}< UInt_t, B, N+1+(sizeof ...(Ts))> {\b concat} ({\b reg_digs_t}< UInt_t, B, N > larg, T dig, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} M, typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}<UInt_t,B>>)&&...) && (std::is_same_v<T,{\b dig_t}<UInt_t,B>>) && (M>0) )constexpr {\b reg_digs_t}< UInt_t, B, M+1+(sizeof ...(Ts))> {\b concat} (T dig, Ts ... dig_pack, {\b reg_digs_t}< UInt_t, B, M > rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, {\b size_t} N, {\b size_t} ... N_pack> \par
requires ((N>0)&&((N_pack>0)&&...))constexpr {\b reg_digs_t}< UInt_t, B, N+(...+(N_pack))> {\b concat} ({\b reg_digs_t}< UInt_t, B, N > larg, {\b reg_digs_t}< UInt_t, B, N_pack > ... rarg_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b operator<<} (const {\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & {\b operator<<=} ({\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & {\b operator>>=} ({\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b operator>>} (const {\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b rem_B} (const {\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & {\b m_rem_B} ({\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b mer_B} (const {\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & {\b m_mer_B} ({\b reg_digs_t}< UINT_T, B, N > &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & {\b operator|=} ({\b reg_digs_t}< UINT_T, B, N > &larg, const {\b reg_digs_t}< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b operator|} (const {\b reg_digs_t}< UINT_T, B, N > &larg, const {\b reg_digs_t}< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & {\b operator&=} ({\b reg_digs_t}< UINT_T, B, N > &larg, const {\b reg_digs_t}< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b operator&} ({\b reg_digs_t}< UINT_T, B, N > &larg, const {\b reg_digs_t}< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N> constexpr {\b reg_digs_t}< UINT_T, B, N > {\b m_incr} ({\b reg_digs_t}< UINT_T, B, N > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO 31/12/2022. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> constexpr {\b dig_t}< UINT_T, B > {\b m_sum_digs_carryin1} ({\b dig_t}< UINT_T, B > &left, {\b dig_t}< UINT_T, B > right) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> constexpr {\b dig_t}< UINT_T, B > {\b m_sum_digs_carryin0} ({\b dig_t}< UINT_T, B > &left, {\b dig_t}< UINT_T, B > right) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N> constexpr {\b dig_t}< UINT_T, B > {\b m_sum} ({\b reg_digs_t}< UINT_T, B, N > &larg, const {\b reg_digs_t}< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N> \par
requires (N>1)constexpr {\b reg_digs_t}< UINT_T, B, N > {\b aprox_units_divB} (const {\b reg_digs_t}< UINT_T, B, N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< PRECONDITIONS : ARG != 0 AND ARG != 1 > }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N, {\b size_t} n> \par
requires ((n > 0) && (n < N) && (N > 1))constexpr {\b reg_digs_t}< UINT_T, B, N > {\b aprox_units_divB_n} (const {\b reg_digs_t}< UINT_T, B, N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N> \par
requires (N > 0)constexpr std::array< {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >, 2 > {\b aprox_coc_rem} (const {\b reg_digs_t}< UINT_T, B, N > &{\b rem}, const {\b reg_digs_t}< UINT_T, B, N > &dsor) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N> \par
requires (N > 0)constexpr std::array< {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >, 2 > {\b aprox_coc_rem} (const {\b reg_digs_t}< UINT_T, B, N > &{\b rem}, const {\b reg_digs_t}< UINT_T, B, N > &dsor, {\b type_traits::sig_UInt_for_UInt_t}< UINT_T > coc_calculado, {\b type_traits::sig_UInt_for_UInt_t}< UINT_T > rem_calculado) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, {\b size_t} N, {\b size_t} M> \par
requires (N > 0)&&(M > 0)constexpr std::array< {\b reg_digs_t}< UINT_T, B, std::max(N, M)>, 2 > {\b fediv} (const {\b reg_digs_t}< UINT_T, B, N > &larg, const {\b reg_digs_t}< UINT_T, B, M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b get_digit_token} (std::istream &is, {\b dig_t}< UINT_T, B > &dig_value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN DIGITO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c T, T B> bool {\b get_radix_token} (std::istream &is)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c T, T B, {\b size_t} L> bool {\b get_digit_loop_token} (std::istream &is, {\b reg_digs_t}< T, B, L > &value) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c T, T B, {\b size_t} L> bool {\b read} (std::istream &is, {\b reg_digs_t}< T, B, L > &value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> digito_t\{\};. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_Type , Int_Type Base, {\b size_t} Length> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>()&&(Length > 0))std::istream & {\b operator>>} (std::istream &is, {\b reg_digs_t}< Int_Type, Base, Length > &arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DE ISTREAM Y OSTREAM CON LOS OPERADORES DE DESPLAZAMEINTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_Type , Int_Type Base, {\b size_t} Long> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>())std::ostream & {\b operator<<} (std::ostream &os, const {\b reg_digs_t}< Int_Type, Base, Long > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_constr_UINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_constr_SINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_constr_defecto_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_constr_copia_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_constr_movimiento_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_assign_UINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_assign_SINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_assign_copia_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_assign_movimiento_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_preincrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_postincrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_predecrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_postdecrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_add_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_add_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_substract_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_substract_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_mult_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_mult_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_ediv_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_ediv_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_erem_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_erem_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_add} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_add_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_substract} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_substract_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_multiply} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_multiply_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_edivision} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_edivision_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_C_B} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_operator_C_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_prop_C_B_eq_inv_C_B} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_prop_C_Bm1_eq_inv_C_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_prop_C_B_minus_1_eq_C_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_unary_operator_minus} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void {\b display_unary_operator_neg} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'typedefs'\par
\pard\plain 
{\xe \v chint_t\:NumRepr}
{\xe \v NumRepr\:chint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::chint_t} = typedef char}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NUEVOS NOMBRES PARA LOS ENTEROS O PARECIDOS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 58} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v digit_t\:NumRepr}
{\xe \v NumRepr\:digit_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint128_t} B> using {\b NumRepr::digit_t} = typedef {\b dig_t}< {\b TypeFromIntNumber_t}<static_cast<{\b uint128_t}>(B)>, static_cast<{\b TypeFromIntNumber_t}<static_cast<{\b uint128_t}>(B)> >(static_cast<{\b uint128_t}>(B)) >}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o ... }}\par
{
Definici\'F3n en la l\'EDnea {\b 1494} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v fast16_t\:NumRepr}
{\xe \v NumRepr\:fast16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::fast16_t} = typedef std::int_fast16_t}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 81} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v fast32_t\:NumRepr}
{\xe \v NumRepr\:fast32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::fast32_t} = typedef std::int_fast32_t}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 82} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v fast64_t\:NumRepr}
{\xe \v NumRepr\:fast64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::fast64_t} = typedef std::int_fast64_t}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 83} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v fast8_t\:NumRepr}
{\xe \v NumRepr\:fast8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::fast8_t} = typedef std::int_fast8_t}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 80} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v int16_t\:NumRepr}
{\xe \v NumRepr\:int16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::int16_t} = typedef std::int16_t}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 77} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v int32_t\:NumRepr}
{\xe \v NumRepr\:int32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::int32_t} = typedef std::int32_t}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v int64_t\:NumRepr}
{\xe \v NumRepr\:int64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::int64_t} = typedef std::int64_t}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 79} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v int8_t\:NumRepr}
{\xe \v NumRepr\:int8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::int8_t} = typedef std::int8_t}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 76} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v intmax_t\:NumRepr}
{\xe \v NumRepr\:intmax_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::intmax_t} = typedef std::intmax_t}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 104} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v least16_t\:NumRepr}
{\xe \v NumRepr\:least16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::least16_t} = typedef std::int_least16_t}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 85} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v least32_t\:NumRepr}
{\xe \v NumRepr\:least32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::least32_t} = typedef std::int_least32_t}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 86} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v least64_t\:NumRepr}
{\xe \v NumRepr\:least64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::least64_t} = typedef std::int_least64_t}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 87} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v least8_t\:NumRepr}
{\xe \v NumRepr\:least8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::least8_t} = typedef std::int_least8_t}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 84} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v register_digs_t\:NumRepr}
{\xe \v NumRepr\:register_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint128_t} B, {\b size_t} L> using {\b NumRepr::register_digs_t} = typedef {\b reg_digs_t}< {\b TypeFromIntNumber_t}<static_cast<{\b uint128_t}>(B)>, static_cast<{\b TypeFromIntNumber_t}<static_cast<{\b uint128_t}>(B)> >(static_cast<{\b uint128_t}>(B)), L >}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2434} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v register_of_digits_t\:NumRepr}
{\xe \v NumRepr\:register_of_digits_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b uint128_t} B, {\b size_t} L> using {\b NumRepr::register_of_digits_t} = typedef {\b reg_digs_t}< {\b type_traits::TypeFromIntNumber_t}<B>, static_cast<{\b type_traits::TypeFromIntNumber_t}<B> >(B), L >}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1576} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v schint_t\:NumRepr}
{\xe \v NumRepr\:schint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::schint_t} = typedef signed char}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 59} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sint128_t\:NumRepr}
{\xe \v NumRepr\:sint128_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sint128_t} = typedef __int128_t}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 70} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sint16_t\:NumRepr}
{\xe \v NumRepr\:sint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sint16_t} = typedef std::int16_t}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 73} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sint32_t\:NumRepr}
{\xe \v NumRepr\:sint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sint32_t} = typedef std::int32_t}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 74} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sint64_t\:NumRepr}
{\xe \v NumRepr\:sint64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sint64_t} = typedef std::int64_t}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 75} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sint8_t\:NumRepr}
{\xe \v NumRepr\:sint8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sint8_t} = typedef std::int8_t}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 72} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sint_t\:NumRepr}
{\xe \v NumRepr\:sint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sint_t} = typedef signed int}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 61} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v size_t\:NumRepr}
{\xe \v NumRepr\:size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::size_t} = typedef std::size_t}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 71} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v slint_t\:NumRepr}
{\xe \v NumRepr\:slint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::slint_t} = typedef signed long int}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 62} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sllint_t\:NumRepr}
{\xe \v NumRepr\:sllint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::sllint_t} = typedef signed long long int}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 63} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ssint_t\:NumRepr}
{\xe \v NumRepr\:ssint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ssint_t} = typedef signed short int}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 60} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uchint_t\:NumRepr}
{\xe \v NumRepr\:uchint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uchint_t} = typedef unsigned char}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 64} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ufast16_t\:NumRepr}
{\xe \v NumRepr\:ufast16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ufast16_t} = typedef std::uint_fast16_t}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 94} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ufast32_t\:NumRepr}
{\xe \v NumRepr\:ufast32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ufast32_t} = typedef std::uint_fast32_t}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 95} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ufast64_t\:NumRepr}
{\xe \v NumRepr\:ufast64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ufast64_t} = typedef std::uint_fast64_t}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 96} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ufast8_t\:NumRepr}
{\xe \v NumRepr\:ufast8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ufast8_t} = typedef std::uint_fast8_t}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 93} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint128_t\:NumRepr}
{\xe \v NumRepr\:uint128_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uint128_t} = typedef __uint128_t}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 69} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint16_t\:NumRepr}
{\xe \v NumRepr\:uint16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uint16_t} = typedef std::uint16_t}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 90} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint32_t\:NumRepr}
{\xe \v NumRepr\:uint32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uint32_t} = typedef std::uint32_t}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 91} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint64_t\:NumRepr}
{\xe \v NumRepr\:uint64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uint64_t} = typedef std::uint64_t}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 92} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint8_t\:NumRepr}
{\xe \v NumRepr\:uint8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uint8_t} = typedef std::uint8_t}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 89} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_t\:NumRepr}
{\xe \v NumRepr\:uint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uint_t} = typedef unsigned int}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 66} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uintmax_t\:NumRepr}
{\xe \v NumRepr\:uintmax_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uintmax_t} = typedef std::uintmax_t}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 105} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uleast16_t\:NumRepr}
{\xe \v NumRepr\:uleast16_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uleast16_t} = typedef std::uint_least16_t}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 98} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uleast32_t\:NumRepr}
{\xe \v NumRepr\:uleast32_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uleast32_t} = typedef std::uint_least32_t}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 99} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uleast64_t\:NumRepr}
{\xe \v NumRepr\:uleast64_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uleast64_t} = typedef std::uint_least64_t}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 100} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uleast8_t\:NumRepr}
{\xe \v NumRepr\:uleast8_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::uleast8_t} = typedef std::uint_least8_t}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 97} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ulint_t\:NumRepr}
{\xe \v NumRepr\:ulint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ulint_t} = typedef unsigned long int}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 67} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ullint_t\:NumRepr}
{\xe \v NumRepr\:ullint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::ullint_t} = typedef unsigned long long int}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 68} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v usint_t\:NumRepr}
{\xe \v NumRepr\:usint_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::usint_t} = typedef unsigned short int}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 65} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las enumeraciones\par
\pard\plain 
{\xe \v binop_e\:NumRepr}
{\xe \v NumRepr\:binop_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::binop_e}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v add\:NumRepr}
{\xe \v NumRepr\:add}
{\qr add{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\cell }{\cell }{\row }
{\xe \v sub\:NumRepr}
{\xe \v NumRepr\:sub}
{\qr sub{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
\cell }{\cell }{\row }
{\xe \v mult\:NumRepr}
{\xe \v NumRepr\:mult}
{\qr mult{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
\cell }{\cell }{\row }
{\xe \v div\:NumRepr}
{\xe \v NumRepr\:div}
{\qr div{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
\cell }{\cell }{\row }
{\xe \v rem\:NumRepr}
{\xe \v NumRepr\:rem}
{\qr rem{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
\cell }{\cell }{\row }
{\xe \v fediv\:NumRepr}
{\xe \v NumRepr\:fediv}
{\qr fediv{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
\cell }{\cell }{\row }
{\xe \v other\:NumRepr}
{\xe \v NumRepr\:other}
{\qr other{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 32} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v dig_format_e\:NumRepr}
{\xe \v NumRepr\:dig_format_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::dig_format_e} : unsigned char{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v BINnat\:NumRepr}
{\xe \v NumRepr\:BINnat}
{\qr BINnat{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
\cell }{\cell }{\row }
{\xe \v BCDnat\:NumRepr}
{\xe \v NumRepr\:BCDnat}
{\qr BCDnat{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
\cell }{\cell }{\row }
{\xe \v BCDexc3\:NumRepr}
{\xe \v NumRepr\:BCDexc3}
{\qr BCDexc3{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
\cell }{\cell }{\row }
{\xe \v BCDaitk\:NumRepr}
{\xe \v NumRepr\:BCDaitk}
{\qr BCDaitk{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
\cell }{\cell }{\row }
{\xe \v johnson_n\:NumRepr}
{\xe \v NumRepr\:johnson_n}
{\qr johnson_n{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
\cell }{\cell }{\row }
{\xe \v biquinario\:NumRepr}
{\xe \v NumRepr\:biquinario}
{\qr biquinario{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 17} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v int_num_format_e\:NumRepr}
{\xe \v NumRepr\:int_num_format_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::int_num_format_e} : unsigned char{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO NATURAL. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v int_CB\:NumRepr}
{\xe \v NumRepr\:int_CB}
{\qr int_CB{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
\cell }{\cell }{\row }
{\xe \v int_CBm1\:NumRepr}
{\xe \v NumRepr\:int_CBm1}
{\qr int_CBm1{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
\cell }{\cell }{\row }
{\xe \v int_MS\:NumRepr}
{\xe \v NumRepr\:int_MS}
{\qr int_MS{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
\cell }{\cell }{\row }
{\xe \v int_EXC_n\:NumRepr}
{\xe \v NumRepr\:int_EXC_n}
{\qr int_EXC_n{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 25} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v nat_num_format_e\:NumRepr}
{\xe \v NumRepr\:nat_num_format_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::nat_num_format_e} : bool{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
YA INTRODUCIDO, PERO NO EXPLICITAMENTE NI COMPLETAMENTE. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v natural\:NumRepr}
{\xe \v NumRepr\:natural}
{\qr natural{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
\cell }{\cell }{\row }
{\xe \v exc_n\:NumRepr}
{\xe \v NumRepr\:exc_n}
{\qr exc_n{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 22} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v num_type_e\:NumRepr}
{\xe \v NumRepr\:num_type_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::num_type_e} : unsigned char{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A INTRODUCIR. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v natural\:NumRepr}
{\xe \v NumRepr\:natural}
{\qr natural{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
\cell }{\cell }{\row }
{\xe \v entero\:NumRepr}
{\xe \v NumRepr\:entero}
{\qr entero{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
\cell }{\cell }{\row }
{\xe \v racional\:NumRepr}
{\xe \v NumRepr\:racional}
{\qr racional{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
\cell }{\cell }{\row }
{\xe \v real\:NumRepr}
{\xe \v NumRepr\:real}
{\qr real{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v rat_num_format_e\:NumRepr}
{\xe \v NumRepr\:rat_num_format_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::rat_num_format_e} : unsigned char{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN C_B YA QUEDA EN MS. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v pair_num_den\:NumRepr}
{\xe \v NumRepr\:pair_num_den}
{\qr pair_num_den{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
\cell }{\cell }{\row }
{\xe \v fxd_pt\:NumRepr}
{\xe \v NumRepr\:fxd_pt}
{\qr fxd_pt{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
\cell }{\cell }{\row }
{\xe \v flt_pt\:NumRepr}
{\xe \v NumRepr\:flt_pt}
{\qr flt_pt{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 28} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v sign_e\:NumRepr}
{\xe \v NumRepr\:sign_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::sign_e} : bool{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v vminus\:NumRepr}
{\xe \v NumRepr\:vminus}
{\qr vminus{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
\cell }{\cell }{\row }
{\xe \v vplus\:NumRepr}
{\xe \v NumRepr\:vplus}
{\qr vplus{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 15} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v sign_funct_e\:NumRepr}
{\xe \v NumRepr\:sign_funct_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::sign_funct_e} : char{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
INTRODUCIDO. }}\par
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v vzero\:NumRepr}
{\xe \v NumRepr\:vzero}
{\qr vzero{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
\cell }{\cell }{\row }
{\xe \v vminus\:NumRepr}
{\xe \v NumRepr\:vminus}
{\qr vminus{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
\cell }{\cell }{\row }
{\xe \v vplus\:NumRepr}
{\xe \v NumRepr\:vplus}
{\qr vplus{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v aprox_coc_rem\:NumRepr}
{\xe \v NumRepr\:aprox_coc_rem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N> \par
requires (N > 0)constexpr std::array< {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >, 2 > NumRepr::aprox_coc_rem (const {\b reg_digs_t}< UINT_T, B, N > &  {\i rem}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i dsor}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
std::array<SIG_UINT_T,2>\{\}[0] == COC std::array<SIG_UINT_T,2>\{\}[1] == REM PRECONDICION DSOR != 0 Y DSOR != 1 FUNCION DE RECURSION PARA LA DIVISION SOBRECARGA DE LA ANTERIOR PARA LA RECURSION QUE NO SEA EL PRIMER CASO \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CASO EXACTO\par
SIZE(DIVISOR) == 1 DIGITO !=0 !=1\par
SIZE(DIVISOR) >= 2 2545/278 o mayores\par
CORRECTO EN COC\par
NOS HEMOS PASADO EN EL COC\par
NOS HEMOS QUEDADO CORTOS EN EL COC rem_aprox + dsor_uint <= rem\par
}{
Definici\'F3n en la l\'EDnea {\b 2044} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v aprox_coc_rem\:NumRepr}
{\xe \v NumRepr\:aprox_coc_rem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N> \par
requires (N > 0)constexpr std::array< {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >, 2 > NumRepr::aprox_coc_rem (const {\b reg_digs_t}< UINT_T, B, N > &  {\i rem}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i dsor}, {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >  {\i coc_calculado}, {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >  {\i rem_calculado}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
std::array<SIG_UINT_T,2>\{\}[0] == COC std::array<SIG_UINT_T,2>\{\}[1] == REM PRECONDICION DSOR != 0 Y DSOR != 1 \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SUPONEMOS QUE REM TIENE TAMANO 1 o 2\par
DSOR YA REDUCIDO TIENE TAMANO 1\par
SIZE(DIVISOR) == 1 DIGITO !=0 !=1\par
CORRECTO EN COC\par
NOS HEMOS PASADO EN EL COC\par
NOS HEMOS QUEDADO CORTOS EN EL COC rem_aprox + dsor_uint <= rem\par
24/7\par
SIZE(DIVISOR) >= 2 2545/278 o mayores\par
CORRECTO EN COC\par
NOS HEMOS PASADO EN EL COC\par
NOS HEMOS QUEDADO CORTOS EN EL COC rem_aprox + dsor_uint <= rem\par
}{
Definici\'F3n en la l\'EDnea {\b 2123} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v aprox_units_divB\:NumRepr}
{\xe \v NumRepr\:aprox_units_divB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N> \par
requires (N>1)constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::aprox_units_divB (const {\b reg_digs_t}< UINT_T, B, N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< PRECONDITIONS : ARG != 0 AND ARG != 1 > }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCIONES DE IMPLEMENTACION DE LA DIVISION ENTRE DOS REGISTROS DE DIGITOS BEGIN POSTCONDICION RET[N-1] == (DIG_1() | DIG_0()) POSTCONDICION RET[N-1] == DIG_1() => RET[N-2,0] == REGD_N_0() HAY QUE VER SI ES POTENCIA DE B : is_any_B_pow \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CASO EN QUE LA LONGITUD PERMANECE 999 ; 998 ; 997 ; 996 099,9 ; 099,8 ; 099,7 ; 099,6 100 ; 100 ; 100 ; 100\par
CPARG == Bm1 Bm1 Bm1 ... Bm1 Bm1 Bm1 d0<B/2\par
CPARG == Bm1 dnm2 dnm3 ... d3 d2 d1 d0\par
}{
Definici\'F3n en la l\'EDnea {\b 1981} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a59c4987f35abcca7f49e248841dbdda7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a59c4987f35abcca7f49e248841dbdda7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v aprox_units_divB_n\:NumRepr}
{\xe \v NumRepr\:aprox_units_divB_n}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N, {\b size_t} n> \par
requires ((n > 0) && (n < N) && (N > 1))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::aprox_units_divB_n (const {\b reg_digs_t}< UINT_T, B, N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DE RECURSION PARA LA DIVISION APROX_COC_REM APROXIMA REMAINDER A 2 DIGITOS Y DIVISOR A 1 DIGITO \par
}{
Definici\'F3n en la l\'EDnea {\b 2021} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_ae65c8d3561b59553ca3379f80f42af08_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_ae65c8d3561b59553ca3379f80f42af08_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Char2Sign\:NumRepr}
{\xe \v NumRepr\:Char2Sign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr {\b sign_e} NumRepr::Char2Sign (char  {\i ch}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 9} del archivo {\b auxiliary_functions.hpp}.}\par
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} N> \par
requires (N>0)constexpr {\b reg_digs_t}< UInt_t, B, N > NumRepr::concat (const {\b reg_digs_t}< UInt_t, B, N > &  {\i larg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) STATIC BASE_N_T<1> CONCAT(DIG_T) STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) STATIC BASE_N_T<SIZEOF...(DIG_PACK)> CONCAT(DIG_T...DIG_PACK) VARIADIC PACK \par
}{
Definici\'F3n en la l\'EDnea {\b 1595} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a6f762ec285d399a1aba905239740d424_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a6f762ec285d399a1aba905239740d424_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} N, {\b size_t} M> \par
requires ((N>0)&&(M>0))constexpr {\b reg_digs_t}< UInt_t, B, N+M > NumRepr::concat (const {\b reg_digs_t}< UInt_t, B, N > &  {\i larg}, const {\b reg_digs_t}< UInt_t, B, M > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1604} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a164d8860f3a0813504ee30c88c7bcab0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} N> \par
requires (N > 0)constexpr {\b reg_digs_t}< UInt_t, B, N+1 > NumRepr::concat (const {\b reg_digs_t}< UInt_t, B, N > &  {\i larg}, {\b dig_t}< UInt_t, B >  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1620} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_afb9644c35a4bfb14155cb38894940e10_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B> constexpr {\b reg_digs_t}< UInt_t, B, 1 > NumRepr::concat ({\b dig_t}< UInt_t, B >  {\i larg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1> CONCAT(DIG_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1649} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a90dce0ccc34796d52120a70c0abe2fb3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} M> \par
requires (M > 0)constexpr {\b reg_digs_t}< UInt_t, B, 1+M > NumRepr::concat ({\b dig_t}< UInt_t, B >  {\i larg}, const {\b reg_digs_t}< UInt_t, B, M > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1635} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a991ca8bb9c18feb0b5e776550b7ad703_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B> constexpr {\b reg_digs_t}< UInt_t, B, 2 > NumRepr::concat ({\b dig_t}< UInt_t, B >  {\i larg}, {\b dig_t}< UInt_t, B >  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1655} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a064a18e22bc1be2b2a8b4bd9b8bfcafb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} N, {\b size_t} ... N_pack> \par
requires ((N>0)&&((N_pack>0)&&...))constexpr {\b reg_digs_t}< UInt_t, B, N+(...+(N_pack))> NumRepr::concat ({\b reg_digs_t}< UInt_t, B, N >  {\i larg}, {\b reg_digs_t}< UInt_t, B, N_pack > ...  {\i rarg_pack}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<SIZE_T N,SIZE_T ... N_PACK> CONCAT(BASE_N_T<N> LARG,BASE_N_T<N_PACK> ... RARG_PACK) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1713} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_af76d4c574256a8ae2913dd960c035d9a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} N, typename T , typename ... Ts> \par
requires (((std::is_same_v<Ts,{\b dig_t}<UInt_t,B>>)&&...)&&(std::is_same_v<T,{\b dig_t}<UInt_t,B>>)&&(N>0))constexpr {\b reg_digs_t}< UInt_t, B, N+1+(sizeof ...(Ts))> NumRepr::concat ({\b reg_digs_t}< UInt_t, B, N >  {\i larg}, T  {\i dig}, Ts ...  {\i dig_pack}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+1+(SIZEOF...(DIG_PACK))> CONCAT(BASE_N_T<N>,DIG_T,DIG_T ... DIG_PACK) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1682} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a0706a8207d9326e70eb68286a809eac0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} M, typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}<UInt_t,B>>)&&...) && (std::is_same_v<T,{\b dig_t}<UInt_t,B>>) && (M>0) )constexpr {\b reg_digs_t}< UInt_t, B, M+1+(sizeof ...(Ts))> NumRepr::concat (T  {\i dig}, Ts ...  {\i dig_pack}, {\b reg_digs_t}< UInt_t, B, M >  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<M+1+(SIZEOF...(DIG_PACK))> CONCAT(DIG_T,DIG_T ... DIG_PACK,BASE_N_T<M>) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1699} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a4725158490aa07256f8ba8b9bb7179e4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr}
{\xe \v NumRepr\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, typename T0 , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}<UInt_t,B>>)&&...) && (std::is_same_v<T0,{\b dig_t}<UInt_t,B>>) )constexpr {\b reg_digs_t}< UInt_t, B, 1+(sizeof ...(Ts))> NumRepr::concat (T0  {\i dig0}, Ts ...  {\i dig_pack}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<SIZEOF...(DIG_PACK)> CONCAT(DIG_T,DIG_T ... DIG_PACK) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1671} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_ad235de59c6fb0e337d7d1974999b7c90_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_max\:NumRepr}
{\xe \v NumRepr\:dig_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T, B>())consteval {\b dig_t}< UINT_T, B > NumRepr::dig_max (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> digito_t\{\};. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1488} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a46e6abf96f0de3f606c367f6217adfc5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v display_constr_copia_dig_t\:NumRepr}
{\xe \v NumRepr\:display_constr_copia_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_constr_copia_dig_t ()}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 66} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_constr_defecto_dig_t\:NumRepr}
{\xe \v NumRepr\:display_constr_defecto_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_constr_defecto_dig_t ()}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 51} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_constr_movimiento_dig_t\:NumRepr}
{\xe \v NumRepr\:display_constr_movimiento_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_constr_movimiento_dig_t ()}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 87} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_constr_SINT_dig_t\:NumRepr}
{\xe \v NumRepr\:display_constr_SINT_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_constr_SINT_dig_t ()}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 28} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_constr_UINT_dig_t\:NumRepr}
{\xe \v NumRepr\:display_constr_UINT_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_constr_UINT_dig_t ()}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 10} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_add\:NumRepr}
{\xe \v NumRepr\:display_operator_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_add ()}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 770} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_add_assign\:NumRepr}
{\xe \v NumRepr\:display_operator_add_assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_add_assign ()}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 309} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_add_assign_uint\:NumRepr}
{\xe \v NumRepr\:display_operator_add_assign_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_add_assign_uint ()}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 348} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_add_int\:NumRepr}
{\xe \v NumRepr\:display_operator_add_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_add_int ()}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 812} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_assign_copia_dig_t\:NumRepr}
{\xe \v NumRepr\:display_operator_assign_copia_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_assign_copia_dig_t ()}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 151} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_assign_movimiento_dig_t\:NumRepr}
{\xe \v NumRepr\:display_operator_assign_movimiento_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_assign_movimiento_dig_t ()}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 174} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_assign_SINT_dig_t\:NumRepr}
{\xe \v NumRepr\:display_operator_assign_SINT_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_assign_SINT_dig_t ()}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 133} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_assign_UINT_dig_t\:NumRepr}
{\xe \v NumRepr\:display_operator_assign_UINT_dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_assign_UINT_dig_t ()}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 113} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_C_B\:NumRepr}
{\xe \v NumRepr\:display_operator_C_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_C_B ()}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1133} del archivo {\b test_dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a0aa113da9c3c91f1af1c073958cc12a3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v display_operator_C_Bm1\:NumRepr}
{\xe \v NumRepr\:display_operator_C_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_C_Bm1 ()}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1178} del archivo {\b test_dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a2525ee5f113018fcb89a1c8a6a28aa31_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v display_operator_ediv_assign\:NumRepr}
{\xe \v NumRepr\:display_operator_ediv_assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_ediv_assign ()}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 552} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_ediv_assign_uint\:NumRepr}
{\xe \v NumRepr\:display_operator_ediv_assign_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_ediv_assign_uint ()}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 603} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_edivision\:NumRepr}
{\xe \v NumRepr\:display_operator_edivision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_edivision ()}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1019} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_edivision_int\:NumRepr}
{\xe \v NumRepr\:display_operator_edivision_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_edivision_int ()}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1080} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_erem_assign\:NumRepr}
{\xe \v NumRepr\:display_operator_erem_assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_erem_assign ()}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 661} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_erem_assign_uint\:NumRepr}
{\xe \v NumRepr\:display_operator_erem_assign_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_erem_assign_uint ()}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 713} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_mult_assign\:NumRepr}
{\xe \v NumRepr\:display_operator_mult_assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_mult_assign ()}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 466} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_mult_assign_uint\:NumRepr}
{\xe \v NumRepr\:display_operator_mult_assign_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_mult_assign_uint ()}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 509} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_multiply\:NumRepr}
{\xe \v NumRepr\:display_operator_multiply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_multiply ()}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 936} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_multiply_int\:NumRepr}
{\xe \v NumRepr\:display_operator_multiply_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_multiply_int ()}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 978} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_postdecrement\:NumRepr}
{\xe \v NumRepr\:display_operator_postdecrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_postdecrement ()}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 281} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_postincrement\:NumRepr}
{\xe \v NumRepr\:display_operator_postincrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_postincrement ()}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 225} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_predecrement\:NumRepr}
{\xe \v NumRepr\:display_operator_predecrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_predecrement ()}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 253} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_preincrement\:NumRepr}
{\xe \v NumRepr\:display_operator_preincrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_preincrement ()}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 197} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_substract\:NumRepr}
{\xe \v NumRepr\:display_operator_substract}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_substract ()}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 853} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_substract_assign\:NumRepr}
{\xe \v NumRepr\:display_operator_substract_assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_substract_assign ()}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 380} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_substract_assign_uint\:NumRepr}
{\xe \v NumRepr\:display_operator_substract_assign_uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_substract_assign_uint ()}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 423} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_operator_substract_int\:NumRepr}
{\xe \v NumRepr\:display_operator_substract_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_operator_substract_int ()}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 895} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_prop_C_B_eq_inv_C_B\:NumRepr}
{\xe \v NumRepr\:display_prop_C_B_eq_inv_C_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_prop_C_B_eq_inv_C_B ()}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1223} del archivo {\b test_dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_aec8203e0be75e913ece973211c4b1386_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v display_prop_C_B_minus_1_eq_C_Bm1\:NumRepr}
{\xe \v NumRepr\:display_prop_C_B_minus_1_eq_C_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_prop_C_B_minus_1_eq_C_Bm1 ()}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1291} del archivo {\b test_dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_ae0fc1d1a1935c51de9fa9490f212c168_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v display_prop_C_Bm1_eq_inv_C_Bm1\:NumRepr}
{\xe \v NumRepr\:display_prop_C_Bm1_eq_inv_C_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_prop_C_Bm1_eq_inv_C_Bm1 ()}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1257} del archivo {\b test_dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_adb8c5e5fc5db353e6db6327ac4c62742_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v display_unary_operator_minus\:NumRepr}
{\xe \v NumRepr\:display_unary_operator_minus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_unary_operator_minus ()}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1327} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v display_unary_operator_neg\:NumRepr}
{\xe \v NumRepr\:display_unary_operator_neg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T,B>())void NumRepr::display_unary_operator_neg ()}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1372} del archivo {\b test_dig_t.hpp}.}\par
}
{\xe \v fediv\:NumRepr}
{\xe \v NumRepr\:fediv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N, {\b size_t} M> \par
requires (N > 0)&&(M > 0)constexpr std::array< {\b reg_digs_t}< UINT_T, B, std::max(N, M)>, 2 > NumRepr::fediv (const {\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, const {\b reg_digs_t}< UINT_T, B, M > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCIONES DE IMPLEMENTACION DE LA DIVISION ENTRE DOS REGISTROS DE DIGITOS \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MOST SIGNIFICANT DIGIT DEL DIVISOR [DEL NUMERO NO DEL TIPO]\par
MOST SIGNIFICANT DIGIT DEL DIVIDENDO [DEL NUMERO NO DEL TIPO]\par
else if (rem >= dsor*dig_B()) \{ este caso no se deberia de dar nunca \}\par
}{
Definici\'F3n en la l\'EDnea {\b 2205} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a1924720464e58ae5372de9b39a45d496_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a1924720464e58ae5372de9b39a45d496_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_digit_loop_token\:NumRepr}
{\xe \v NumRepr\:get_digit_loop_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c T, T B, {\b size_t} L> bool NumRepr::get_digit_loop_token (std::istream &  {\i is}, {\b reg_digs_t}< T, B, L > &  {\i value}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2375} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v get_digit_token\:NumRepr}
{\xe \v NumRepr\:get_digit_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool NumRepr::get_digit_token (std::istream &  {\i is}, {\b dig_t}< UINT_T, B > &  {\i dig_value})}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN DIGITO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 2298} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a85361eaf407fae0ec70f013c1eec25ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a85361eaf407fae0ec70f013c1eec25ad_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_radix_token\:NumRepr}
{\xe \v NumRepr\:get_radix_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c T, T B> bool NumRepr::get_radix_token (std::istream &  {\i is})}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN BASE. }}\par
{
Definici\'F3n en la l\'EDnea {\b 2370} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a4a43d171097231b9c153662a4d96d170_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a4a43d171097231b9c153662a4d96d170_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Int2Sign\:NumRepr}
{\xe \v NumRepr\:Int2Sign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::arith_integral_c IntT> constexpr {\b sign_e} NumRepr::Int2Sign (IntT  {\i nu}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b auxiliary_functions.hpp}.}\par
}
{\xe \v Int2SignFunct\:NumRepr}
{\xe \v NumRepr\:Int2SignFunct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::arith_integral_c IntT> constexpr {\b sign_funct_e} NumRepr::Int2SignFunct (IntT  {\i nu}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 29} del archivo {\b auxiliary_functions.hpp}.}\par
}
{\xe \v is_nat_reg_digs_type_id\:NumRepr}
{\xe \v NumRepr\:is_nat_reg_digs_type_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} LE> bool NumRepr::is_nat_reg_digs_type_id (std::string  {\i in})}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACIONES PARA NAT_REG_DIGS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1748} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v m_incr\:NumRepr}
{\xe \v NumRepr\:m_incr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N> constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::m_incr ({\b reg_digs_t}< UINT_T, B, N > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO 31/12/2022. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1865} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a47075bda02da4f0bcb6a4d3fd0f5b254_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a47075bda02da4f0bcb6a4d3fd0f5b254_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_mer_B\:NumRepr}
{\xe \v NumRepr\:m_mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & NumRepr::m_mer_B ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1807} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a24e1622d28f1fc5b86dac826d719cccb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a24e1622d28f1fc5b86dac826d719cccb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_rem_B\:NumRepr}
{\xe \v NumRepr\:m_rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & NumRepr::m_rem_B ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1788} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a76d56b1ce8fdf8fe9f2dad696d0793ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a76d56b1ce8fdf8fe9f2dad696d0793ad_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_sum\:NumRepr}
{\xe \v NumRepr\:m_sum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B, {\b size_t} N> constexpr {\b dig_t}< UINT_T, B > NumRepr::m_sum ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1955} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a259867ff7627eb58b940d354ed1f87e3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a259867ff7627eb58b940d354ed1f87e3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_sum_digs_carryin0\:NumRepr}
{\xe \v NumRepr\:m_sum_digs_carryin0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B> constexpr {\b dig_t}< UINT_T, B > NumRepr::m_sum_digs_carryin0 ({\b dig_t}< UINT_T, B > &  {\i left}, {\b dig_t}< UINT_T, B >  {\i right}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1934} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_ad08658a7e95e0914597309c1243ea7f0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_ad08658a7e95e0914597309c1243ea7f0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_sum_digs_carryin1\:NumRepr}
{\xe \v NumRepr\:m_sum_digs_carryin1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B> constexpr {\b dig_t}< UINT_T, B > NumRepr::m_sum_digs_carryin1 ({\b dig_t}< UINT_T, B > &  {\i left}, {\b dig_t}< UINT_T, B >  {\i right}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1906} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a7a96dff18dd75c2309445fcf46a84be6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a7a96dff18dd75c2309445fcf46a84be6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v max_base_B_en_Int_T\:NumRepr}
{\xe \v NumRepr\:max_base_B_en_Int_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Int_T , ullint B> constexpr ullint NumRepr::max_base_B_en_Int_T (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 127} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v mer_B\:NumRepr}
{\xe \v NumRepr\:mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::mer_B (const {\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1797} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a791ee564df192b445483d0088d163710_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a791ee564df192b445483d0088d163710_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Nat2SignFunct\:NumRepr}
{\xe \v NumRepr\:Nat2SignFunct}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::arith_natural_c NatIntT> constexpr {\b sign_funct_e} NumRepr::Nat2SignFunct (NatIntT  {\i nu}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b auxiliary_functions.hpp}.}\par
}
{\xe \v num_digs_max_base_B_en_Int_T\:NumRepr}
{\xe \v NumRepr\:num_digs_max_base_B_en_Int_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Int_T , ullint B> constexpr ullint NumRepr::num_digs_max_base_B_en_Int_T (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 91} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v operator&\:NumRepr}
{\xe \v NumRepr\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::operator& ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1854} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator&=\:NumRepr}
{\xe \v NumRepr\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & NumRepr::operator&= ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1841} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr}
{\xe \v NumRepr\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::operator<< (const {\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1718} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr}
{\xe \v NumRepr\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, {\b size_t} Long> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>())std::ostream & NumRepr::operator<< (std::ostream &  {\i os}, const {\b nat_reg_digs_t}< Int_Type, Base, Long > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2033} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr}
{\xe \v NumRepr\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Long> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>())std::ostream & NumRepr::operator<< (std::ostream &  {\i os}, const pfx_rat_reg_digs_t< Int_Type, Base, Long > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2429} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr}
{\xe \v NumRepr\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Int_Type , Int_Type Base, {\b size_t} Long> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>())std::ostream & NumRepr::operator<< (std::ostream &  {\i os}, const {\b reg_digs_t}< Int_Type, Base, Long > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2711} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr}
{\xe \v NumRepr\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> \par
requires ({\b type_traits::suitable_base}<UINT_T,Base>())std::ostream & NumRepr::operator<< (std::ostream &  {\i os}, {\b dig_t}< UINT_T, Base >  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1608} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator<<=\:NumRepr}
{\xe \v NumRepr\:operator<<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & NumRepr::operator<<= ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1736} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>>\:NumRepr}
{\xe \v NumRepr\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::operator>> (const {\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1768} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>>\:NumRepr}
{\xe \v NumRepr\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> \par
requires ({\b type_traits::suitable_base}<UINT_T,Base>())std::istream & NumRepr::operator>> (std::istream &  {\i is}, {\b dig_t}< UINT_T, Base > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1508} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator>>\:NumRepr}
{\xe \v NumRepr\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, {\b size_t} Length> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>()&&(Length > 0))std::istream & NumRepr::operator>> (std::istream &  {\i is}, {\b nat_reg_digs_t}< Int_Type, Base, Length > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO ESTA VERSION + VERSION CON TRATAMIENTO DE ERRORES EN RUNTIME \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN\par
TIPOS A SER UTILIZADOS EN LA FUNCI\'D3N: NOMBRE DE TIPOS CORTOS\par
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA\par
VARIABLES PARA ACCIONES EN LOS ESTADOS\par
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)\par
ESTADO ACTUAL\par
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN\par
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA\par
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA\par
}{
Definici\'F3n en la l\'EDnea {\b 1781} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_abc220e2b8550522f9cb96ecd95d172bb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>>\:NumRepr}
{\xe \v NumRepr\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Length> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>()&&(Length > 0))std::istream & NumRepr::operator>> (std::istream &  {\i is}, pfx_rat_reg_digs_t< Int_Type, Base, Length > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN\par
TIPOS A SER UTILIZADOS EN LA FUNCI\'D3N: NOMBRE DE TIPOS CORTOS\par
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA\par
VARIABLES PARA ACCIONES EN LOS ESTADOS\par
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)\par
ESTADO ACTUAL\par
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN\par
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA\par
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA\par
}{
Definici\'F3n en la l\'EDnea {\b 2177} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator>>\:NumRepr}
{\xe \v NumRepr\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Int_Type , Int_Type Base, {\b size_t} Length> \par
requires ({\b type_traits::suitable_base}<Int_Type,Base>()&&(Length > 0))std::istream & NumRepr::operator>> (std::istream &  {\i is}, {\b reg_digs_t}< Int_Type, Base, Length > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DE ISTREAM Y OSTREAM CON LOS OPERADORES DE DESPLAZAMEINTO. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STRING RECOGIDO DESDE LA ENTRADA ESTANDAR CIN\par
TIPOS A SER UTILIZADOS EN LA FUNCI\'D3N: NOMBRE DE TIPOS CORTOS\par
INDICE QUE RECORRE EL STRING RECOGIDO DE ENTRADA\par
VARIABLES PARA ACCIONES EN LOS ESTADOS\par
VARIABLE DE RETORNO (BINDED TO THE ARG BY REFERENCE)\par
ESTADO ACTUAL\par
CARACTER QUE GUARDARA EL INDICADO POR EL INDICE DEL STRING RECOGIDO DESDE CIN\par
RECOGEMOS DESDE LA ENTRADA EL STRING CON LA INFORMACION CODIFICADA\par
MAQUINA DE ESTADOS FINITOS QUE HACE EL PARSE() DE LA ENTRADA\par
}{
Definici\'F3n en la l\'EDnea {\b 2444} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>>=\:NumRepr}
{\xe \v NumRepr\:operator>>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & NumRepr::operator>>= ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1752} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator|\:NumRepr}
{\xe \v NumRepr\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::operator| (const {\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1829} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator|=\:NumRepr}
{\xe \v NumRepr\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const {\b reg_digs_t}< UINT_T, B, N > & NumRepr::operator|= ({\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, const {\b reg_digs_t}< UINT_T, B, N > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1816} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v pot_max_base_B_en_Int_T\:NumRepr}
{\xe \v NumRepr\:pot_max_base_B_en_Int_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Int_T , usint B> constexpr ullint NumRepr::pot_max_base_B_en_Int_T (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 77} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v read\:NumRepr}
{\xe \v NumRepr\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c T, T B, {\b size_t} L> bool NumRepr::read (std::istream &  {\i is}, {\b reg_digs_t}< T, B, L > &  {\i value}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> digito_t\{\};. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o ... \par
}{
Definici\'F3n en la l\'EDnea {\b 2401} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v rem_B\:NumRepr}
{\xe \v NumRepr\:rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr {\b reg_digs_t}< UINT_T, B, N > NumRepr::rem_B (const {\b reg_digs_t}< UINT_T, B, N > &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1778} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_aabd0c98823a42f27c17a1392d05111ee_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_aabd0c98823a42f27c17a1392d05111ee_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size_of_nat_reg_digs_type_string_idT\:NumRepr}
{\xe \v NumRepr\:size_of_nat_reg_digs_type_string_idT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} LE> {\b size_t} NumRepr::size_of_nat_reg_digs_type_string_idT ()}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1770} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v to_nat_reg_digs_type_string\:NumRepr}
{\xe \v NumRepr\:to_nat_reg_digs_type_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t , UInt_t B, {\b size_t} LE> std::string NumRepr::to_nat_reg_digs_type_string ()}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1766} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v ui_1\:NumRepr}
{\xe \v NumRepr\:ui_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> \par
requires ({\b type_traits::suitable_base}<UINT_T, B>())consteval UINT_T NumRepr::ui_1 (){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1484} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_a2546ea7fb1f063e87dbb450cfe5e3623_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::auxiliary_functions\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_functions}
{\xe \v NumRepr::auxiliary_functions}
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_prime} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_power_of_2} ({\b uint128_t} num) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v is_power_of_2\:NumRepr::auxiliary_functions}
{\xe \v NumRepr::auxiliary_functions\:is_power_of_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr bool NumRepr::auxiliary_functions::is_power_of_2 ({\b uint128_t}  {\i num}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 115} del archivo {\b auxiliary_functions.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1auxiliary__functions_a3ea0c809df1b14220a5fc969a28d7a8d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1auxiliary__functions_a3ea0c809df1b14220a5fc969a28d7a8d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_prime\:NumRepr::auxiliary_functions}
{\xe \v NumRepr::auxiliary_functions\:is_prime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr bool NumRepr::auxiliary_functions::is_prime ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 105} del archivo {\b auxiliary_functions.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1auxiliary__functions_a6a368b190a18264af00c59b164dc1096_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1auxiliary__functions_a6a368b190a18264af00c59b164dc1096_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::auxiliary_types\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types}
{\xe \v NumRepr::auxiliary_types}
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
auxiliary types for digit type and its operations }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t< T, binop_e::add >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t< T, binop_e::div >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t< T, binop_e::fediv >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t< T, binop_e::mult >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t< T, binop_e::rem >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b resbinop_t< T, binop_e::sub >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t< T, binop_e::add, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t< T, binop_e::div, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t< T, binop_e::fediv, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t< T, binop_e::mult, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t< T, binop_e::rem, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result_operation_t< T, binop_e::sub, N >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::detail\par \pard\plain 
{\tc\tcl2 \v NumRepr::detail}
{\xe \v NumRepr::detail}
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b ceilsqrt} ({\b size_t} n, {\b size_t} low, {\b size_t} high) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b ceilsqrt} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b find_factor} ({\b size_t} n, {\b size_t} low, {\b size_t} high) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v ceilsqrt\:NumRepr::detail}
{\xe \v NumRepr::detail\:ceilsqrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr {\b size_t} NumRepr::detail::ceilsqrt ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 70} del archivo {\b auxiliary_functions.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1detail_ad76e295a8cfd29f1f6e2a02983e4717a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ceilsqrt\:NumRepr::detail}
{\xe \v NumRepr::detail\:ceilsqrt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr {\b size_t} NumRepr::detail::ceilsqrt ({\b size_t}  {\i n}, {\b size_t}  {\i low}, {\b size_t}  {\i high}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 52} del archivo {\b auxiliary_functions.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1detail_aa138a7304b06ab664d7208956b3c0dbe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1detail_aa138a7304b06ab664d7208956b3c0dbe_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v find_factor\:NumRepr::detail}
{\xe \v NumRepr::detail\:find_factor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr bool NumRepr::detail::find_factor ({\b size_t}  {\i n}, {\b size_t}  {\i low}, {\b size_t}  {\i high}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 88} del archivo {\b auxiliary_functions.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1detail_a098c7fa0c984b9aa1e6c5e6033affc88_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1detail_a098c7fa0c984b9aa1e6c5e6033affc88_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::lex\par \pard\plain 
{\tc\tcl2 \v NumRepr::lex}
{\xe \v NumRepr::lex}
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeraciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b reglexst_e} : uint16_t \{ {\b st_00} = 0
, {\b st_01} = 1
, {\b st_02} =2
, {\b st_03} =3
, {\b st_04} = 4
, {\b st_05} = 5
, {\b st_06} = 6
, {\b st_07} = 7
, {\b st_08} =8
, {\b st_09} =9
, {\b st_10} =10
, {\b st_11} =11
, {\b st_12} =12
, {\b st_13} =13
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b sintaxerrlexst_e} : uint16_t \{ {\b st_err_00} = 256
, {\b st_err_01} = 257
, {\b st_err_02} = 258
, {\b st_err_03} = 259
, {\b st_err_04} = 260
, {\b st_err_05} = 261
, {\b st_err_06} = 262
, {\b st_err_07} = 263
, {\b st_err_08} = 264
, {\b st_err_09} = 265
, {\b st_err_10} = 266
, {\b st_err_11} = 267
, {\b st_err_12} = 268
, {\b st_err_13} = 269
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b semerrlexst_e} : uint16_t \{ {\b st_sem_00} = 4096
, {\b st_sem_01} = 4097
, {\b st_sem_02} = 4098
, {\b st_sem_03} = 4099
, {\b st_sem_04} = 4100
, {\b st_sem_05} = 4101
, {\b st_sem_06} = 4102
, {\b st_sem_07} = 4103
, {\b st_sem_08} = 4104
, {\b st_sem_09} = 4105
, {\b st_sem_10} = 4106
, {\b st_sem_11} = 4107
, {\b st_sem_12} = 4108
, {\b st_sem_13} = 4109
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b lexst_e} : uint16_t \{ {\b reg_00} = 0
, {\b reg_01} = 1
, {\b reg_02} = 2
, {\b reg_03} = 3
, {\b reg_04} = 4
, {\b reg_05} = 5
, {\b reg_06} = 6
, {\b reg_07} = 7
, {\b reg_08} = 8
, {\b reg_09} = 9
, {\b reg_10} = 10
, {\b reg_11} = 11
, {\b reg_12} = 12
, {\b reg_13} = 13
, {\b err_00} = 256
, {\b err_01} = 257
, {\b err_02} = 258
, {\b err_03} = 259
, {\b err_04} = 260
, {\b err_05} = 261
, {\b err_06} = 262
, {\b err_07} = 263
, {\b err_08} = 264
, {\b err_09} = 265
, {\b err_10} = 266
, {\b err_11} = 267
, {\b err_12} = 268
, {\b err_13} = 269
, {\b sem_00} = 4096
, {\b sem_01} = 4097
, {\b sem_02} = 4098
, {\b sem_03} = 4099
, {\b sem_04} = 4100
, {\b sem_05} = 4101
, {\b sem_06} = 4102
, {\b sem_07} = 4103
, {\b sem_08} = 4104
, {\b sem_09} = 4105
, {\b sem_10} = 4106
, {\b sem_11} = 4107
, {\b sem_12} = 4108
, {\b sem_13} = 4109
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_digit} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_t} {\b digit_value} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_valid_char} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b char_value} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_separator} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_end_of_number} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_whitespace} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_end_descriptor} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_radix_descriptor} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_sign} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b sign_e} {\b sign_value} (char)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las enumeraciones\par
\pard\plain 
{\xe \v lexst_e\:NumRepr::lex}
{\xe \v NumRepr::lex\:lexst_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::lex::lexst_e} : {\b uint16_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v reg_00\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_00}
{\qr reg_00{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
\cell }{\cell }{\row }
{\xe \v reg_01\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_01}
{\qr reg_01{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
\cell }{\cell }{\row }
{\xe \v reg_02\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_02}
{\qr reg_02{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
\cell }{\cell }{\row }
{\xe \v reg_03\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_03}
{\qr reg_03{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
\cell }{\cell }{\row }
{\xe \v reg_04\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_04}
{\qr reg_04{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
\cell }{\cell }{\row }
{\xe \v reg_05\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_05}
{\qr reg_05{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
\cell }{\cell }{\row }
{\xe \v reg_06\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_06}
{\qr reg_06{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
\cell }{\cell }{\row }
{\xe \v reg_07\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_07}
{\qr reg_07{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
\cell }{\cell }{\row }
{\xe \v reg_08\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_08}
{\qr reg_08{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
\cell }{\cell }{\row }
{\xe \v reg_09\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_09}
{\qr reg_09{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
\cell }{\cell }{\row }
{\xe \v reg_10\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_10}
{\qr reg_10{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
\cell }{\cell }{\row }
{\xe \v reg_11\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_11}
{\qr reg_11{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
\cell }{\cell }{\row }
{\xe \v reg_12\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_12}
{\qr reg_12{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
\cell }{\cell }{\row }
{\xe \v reg_13\:NumRepr::lex}
{\xe \v NumRepr::lex\:reg_13}
{\qr reg_13{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
\cell }{\cell }{\row }
{\xe \v err_00\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_00}
{\qr err_00{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
\cell }{\cell }{\row }
{\xe \v err_01\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_01}
{\qr err_01{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
\cell }{\cell }{\row }
{\xe \v err_02\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_02}
{\qr err_02{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
\cell }{\cell }{\row }
{\xe \v err_03\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_03}
{\qr err_03{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
\cell }{\cell }{\row }
{\xe \v err_04\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_04}
{\qr err_04{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
\cell }{\cell }{\row }
{\xe \v err_05\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_05}
{\qr err_05{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
\cell }{\cell }{\row }
{\xe \v err_06\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_06}
{\qr err_06{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
\cell }{\cell }{\row }
{\xe \v err_07\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_07}
{\qr err_07{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
\cell }{\cell }{\row }
{\xe \v err_08\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_08}
{\qr err_08{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
\cell }{\cell }{\row }
{\xe \v err_09\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_09}
{\qr err_09{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
\cell }{\cell }{\row }
{\xe \v err_10\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_10}
{\qr err_10{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
\cell }{\cell }{\row }
{\xe \v err_11\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_11}
{\qr err_11{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
\cell }{\cell }{\row }
{\xe \v err_12\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_12}
{\qr err_12{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
\cell }{\cell }{\row }
{\xe \v err_13\:NumRepr::lex}
{\xe \v NumRepr::lex\:err_13}
{\qr err_13{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
\cell }{\cell }{\row }
{\xe \v sem_00\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_00}
{\qr sem_00{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
\cell }{\cell }{\row }
{\xe \v sem_01\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_01}
{\qr sem_01{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
\cell }{\cell }{\row }
{\xe \v sem_02\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_02}
{\qr sem_02{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
\cell }{\cell }{\row }
{\xe \v sem_03\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_03}
{\qr sem_03{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
\cell }{\cell }{\row }
{\xe \v sem_04\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_04}
{\qr sem_04{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
\cell }{\cell }{\row }
{\xe \v sem_05\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_05}
{\qr sem_05{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
\cell }{\cell }{\row }
{\xe \v sem_06\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_06}
{\qr sem_06{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
\cell }{\cell }{\row }
{\xe \v sem_07\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_07}
{\qr sem_07{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
\cell }{\cell }{\row }
{\xe \v sem_08\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_08}
{\qr sem_08{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
\cell }{\cell }{\row }
{\xe \v sem_09\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_09}
{\qr sem_09{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
\cell }{\cell }{\row }
{\xe \v sem_10\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_10}
{\qr sem_10{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
\cell }{\cell }{\row }
{\xe \v sem_11\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_11}
{\qr sem_11{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
\cell }{\cell }{\row }
{\xe \v sem_12\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_12}
{\qr sem_12{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
\cell }{\cell }{\row }
{\xe \v sem_13\:NumRepr::lex}
{\xe \v NumRepr::lex\:sem_13}
{\qr sem_13{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v reglexst_e\:NumRepr::lex}
{\xe \v NumRepr::lex\:reglexst_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::lex::reglexst_e} : {\b uint16_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v st_00\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_00}
{\qr st_00{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
\cell }{\cell }{\row }
{\xe \v st_01\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_01}
{\qr st_01{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
\cell }{\cell }{\row }
{\xe \v st_02\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_02}
{\qr st_02{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
\cell }{\cell }{\row }
{\xe \v st_03\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_03}
{\qr st_03{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
\cell }{\cell }{\row }
{\xe \v st_04\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_04}
{\qr st_04{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
\cell }{\cell }{\row }
{\xe \v st_05\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_05}
{\qr st_05{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
\cell }{\cell }{\row }
{\xe \v st_06\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_06}
{\qr st_06{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
\cell }{\cell }{\row }
{\xe \v st_07\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_07}
{\qr st_07{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
\cell }{\cell }{\row }
{\xe \v st_08\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_08}
{\qr st_08{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
\cell }{\cell }{\row }
{\xe \v st_09\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_09}
{\qr st_09{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
\cell }{\cell }{\row }
{\xe \v st_10\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_10}
{\qr st_10{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
\cell }{\cell }{\row }
{\xe \v st_11\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_11}
{\qr st_11{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
\cell }{\cell }{\row }
{\xe \v st_12\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_12}
{\qr st_12{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
\cell }{\cell }{\row }
{\xe \v st_13\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_13}
{\qr st_13{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 8} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v semerrlexst_e\:NumRepr::lex}
{\xe \v NumRepr::lex\:semerrlexst_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::lex::semerrlexst_e} : {\b uint16_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v st_sem_00\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_00}
{\qr st_sem_00{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
\cell }{\cell }{\row }
{\xe \v st_sem_01\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_01}
{\qr st_sem_01{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
\cell }{\cell }{\row }
{\xe \v st_sem_02\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_02}
{\qr st_sem_02{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
\cell }{\cell }{\row }
{\xe \v st_sem_03\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_03}
{\qr st_sem_03{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
\cell }{\cell }{\row }
{\xe \v st_sem_04\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_04}
{\qr st_sem_04{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
\cell }{\cell }{\row }
{\xe \v st_sem_05\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_05}
{\qr st_sem_05{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
\cell }{\cell }{\row }
{\xe \v st_sem_06\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_06}
{\qr st_sem_06{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
\cell }{\cell }{\row }
{\xe \v st_sem_07\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_07}
{\qr st_sem_07{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
\cell }{\cell }{\row }
{\xe \v st_sem_08\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_08}
{\qr st_sem_08{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
\cell }{\cell }{\row }
{\xe \v st_sem_09\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_09}
{\qr st_sem_09{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
\cell }{\cell }{\row }
{\xe \v st_sem_10\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_10}
{\qr st_sem_10{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
\cell }{\cell }{\row }
{\xe \v st_sem_11\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_11}
{\qr st_sem_11{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
\cell }{\cell }{\row }
{\xe \v st_sem_12\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_12}
{\qr st_sem_12{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
\cell }{\cell }{\row }
{\xe \v st_sem_13\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_sem_13}
{\qr st_sem_13{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 20} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v sintaxerrlexst_e\:NumRepr::lex}
{\xe \v NumRepr::lex\:sintaxerrlexst_e}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b NumRepr::lex::sintaxerrlexst_e} : {\b uint16_t}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v st_err_00\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_00}
{\qr st_err_00{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
\cell }{\cell }{\row }
{\xe \v st_err_01\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_01}
{\qr st_err_01{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
\cell }{\cell }{\row }
{\xe \v st_err_02\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_02}
{\qr st_err_02{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
\cell }{\cell }{\row }
{\xe \v st_err_03\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_03}
{\qr st_err_03{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
\cell }{\cell }{\row }
{\xe \v st_err_04\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_04}
{\qr st_err_04{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
\cell }{\cell }{\row }
{\xe \v st_err_05\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_05}
{\qr st_err_05{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
\cell }{\cell }{\row }
{\xe \v st_err_06\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_06}
{\qr st_err_06{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
\cell }{\cell }{\row }
{\xe \v st_err_07\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_07}
{\qr st_err_07{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
\cell }{\cell }{\row }
{\xe \v st_err_08\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_08}
{\qr st_err_08{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
\cell }{\cell }{\row }
{\xe \v st_err_09\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_09}
{\qr st_err_09{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
\cell }{\cell }{\row }
{\xe \v st_err_10\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_10}
{\qr st_err_10{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
\cell }{\cell }{\row }
{\xe \v st_err_11\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_11}
{\qr st_err_11{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
\cell }{\cell }{\row }
{\xe \v st_err_12\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_12}
{\qr st_err_12{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
\cell }{\cell }{\row }
{\xe \v st_err_13\:NumRepr::lex}
{\xe \v NumRepr::lex\:st_err_13}
{\qr st_err_13{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 13} del archivo {\b lexer_parser.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v char_value\:NumRepr::lex}
{\xe \v NumRepr::lex\:char_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::char_value (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 88} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v digit_value\:NumRepr::lex}
{\xe \v NumRepr::lex\:digit_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_t} NumRepr::lex::digit_value (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b lexer_parser.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1lex_af9280f97b4b77ecd1014186f30d34cd3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_digit\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_digit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_digit (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 73} del archivo {\b lexer_parser.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1lex_a74058f0e6bd43ed220a8a1b497b32c84_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_end_descriptor\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_end_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_end_descriptor (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 113} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v is_end_of_number\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_end_of_number}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_end_of_number (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 103} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v is_radix_descriptor\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_radix_descriptor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_radix_descriptor (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 118} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v is_separator\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_separator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_separator (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 98} del archivo {\b lexer_parser.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1lex_ae1025f30c522d63347afa67829bd7216_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_sign\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_sign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_sign (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 123} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v is_valid_char\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_valid_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_valid_char (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 83} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v is_whitespace\:NumRepr::lex}
{\xe \v NumRepr::lex\:is_whitespace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool NumRepr::lex::is_whitespace (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 108} del archivo {\b lexer_parser.hpp}.}\par
}
{\xe \v sign_value\:NumRepr::lex}
{\xe \v NumRepr::lex\:sign_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b sign_e} NumRepr::lex::sign_value (char  {\i in})}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 128} del archivo {\b lexer_parser.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits}
{\xe \v NumRepr::type_traits}
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ugly_details_for_greater_suitable_type_deduction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ugly_details_for_suitable_type_deduction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ugly_details_sig_SInt_for_UInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ugly_details_SInt_for_SInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ugly_details_UInt_for_SInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ugly_details_UInt_for_UInt}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concepts\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b arith_integral_c}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TYPE_TRAITS AND CONCEPTS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b arith_natural_c}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b char_type_c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b uint_type_for_radix_c}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES VALID FOR THE RADIX. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b unsigned_integral_c}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b signed_integral_c}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR SIGNED INTEGRAL TYPES. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b integral_c}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t > using {\b sig_UInt_for_UInt_t} = typename {\b ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< UInt_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t > using {\b sig_SInt_for_UInt_t} = typename {\b ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< UInt_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_t > using {\b sig_UInt_for_SInt_t} = typename {\b ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< Int_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SInt_t > using {\b sig_SInt_for_SInt_t} = typename {\b ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< SInt_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b ullint_t} Radix> using {\b TypeFromIntNumber_t} = typename {\b UIntTypeForRadix}< decltype(Radix), Radix >::UIntType\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<integral_c IntType, IntType Radix> using {\b GreaterTypeFromIntNumber_t} = typename {\b UIntTypeForRadixContainsMultResult}< decltype(Radix), Radix >::UIntType\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b clear_ccad} (char *, {\b usint_t})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<template< {\b uchint_t} B > class T, {\b uchint_t} B> constexpr const char * {\b devCadenaC} (T< B > arg, std::size_t long_ccad=64) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr char * {\b clear_ccad} (char *cad_c, std::size_t long_de_cad_c) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr unsigned long long {\b atoull} (char *text) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b maxbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b submaxbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b minbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b subminbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b monobase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b nobase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b maxdigit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b submaxdigit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b digit_0} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b digit_1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b base_2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> consteval bool {\b base_geqt_2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> consteval bool {\b base_leqt_max} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> consteval bool {\b suitable_base} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b middle_max} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b sqrt_max} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<char_type_c CharT> constexpr CharT {\b nullchar} \{CharT('\\0')\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > constexpr bool {\b is_uint_type_for_radix_v} = std::is_unsigned_v<UINT_T> && (! std::is_same_v<UINT_T,{\b uint128_t}>)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > constexpr bool {\b is_unsigned_type_v}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SINT_T > constexpr bool {\b is_signed_type_v} = std::is_signed_v<SINT_T>\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES SIGNED. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename INT_TYPE > constexpr bool {\b is_integral_type_v} = std::is_integral_v<INT_TYPE>\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO ES INTEGRAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b eq_sz_v} = (sizeof(T) == sizeof(S))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADORES DE COMPARACION DE CAPACIDAD DE INTEGERS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b gt_sz_v} = (sizeof(T) > sizeof(S))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b lt_sz_v} = (sizeof(T) < sizeof(S))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b ge_sz_v} = {\b gt_sz_v}<T,S>||{\b eq_sz_v}<T,S>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b le_sz_v} = {\b lt_sz_v}<T,S>||{\b eq_sz_v}<T,S>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'typedefs'\par
\pard\plain 
{\xe \v GreaterTypeFromIntNumber_t\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:GreaterTypeFromIntNumber_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c IntType, IntType Radix> using {\b NumRepr::type_traits::GreaterTypeFromIntNumber_t} = typedef typename {\b UIntTypeForRadixContainsMultResult}<decltype(Radix),Radix>::UIntType}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 671} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sig_SInt_for_SInt_t\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:sig_SInt_for_SInt_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SInt_t > using {\b NumRepr::type_traits::sig_SInt_for_SInt_t} = typedef typename {\b ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}<SInt_t>::type}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAFUNCIONES PARA DAR CON LOS MAXIMOS NUMEROS QUE CABEN EN UN TIPO Y SIMILARES \par
}{
Definici\'F3n en la l\'EDnea {\b 472} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sig_SInt_for_UInt_t\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:sig_SInt_for_UInt_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t > using {\b NumRepr::type_traits::sig_SInt_for_UInt_t} = typedef typename {\b ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}<UInt_t>::type}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAFUNCION : DA EL SIGUIENTE TIPO NATURAL PARA EL ACTUAL TIPO ENTERO POR ESPECIALIZACION EXPLICITA \par
}{
Definici\'F3n en la l\'EDnea {\b 363} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sig_UInt_for_SInt_t\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:sig_UInt_for_SInt_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Int_t > using {\b NumRepr::type_traits::sig_UInt_for_SInt_t} = typedef typename {\b ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}<Int_t>::type}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAFUNCION : DA EL SIGUIENTE TIPO ENTERO PARA EL ACTUAL TIPO ENTERO POR ESPECIALIZACION EXPLICITA \par
}{
Definici\'F3n en la l\'EDnea {\b 401} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sig_UInt_for_UInt_t\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:sig_UInt_for_UInt_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt_t > using {\b NumRepr::type_traits::sig_UInt_for_UInt_t} = typedef typename {\b ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}<UInt_t>::type}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAFUNCION : DA EL SIGUIENTE TIPO ENTERO PARA EL ACTUAL TIPO NATURAL POR ESPECIALIZACION EXPLICITA \par
}{
Definici\'F3n en la l\'EDnea {\b 288} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v TypeFromIntNumber_t\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:TypeFromIntNumber_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b ullint_t} Radix> using {\b NumRepr::type_traits::TypeFromIntNumber_t} = typedef typename {\b UIntTypeForRadix}<decltype(Radix),Radix>::UIntType}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QUEREMOS FABRICAR LA METAFUNCION TypeFromIntNumberLTSqrtMaxOfType_t<numero> QUE DEVUELVA EL TIPO ENTERO SIN SIGNO MAS PEQUENO PARA EL NUMERO numero TAL QUE SQRT(TYPE::MAX())>=B-1 \par
}{
Definici\'F3n en la l\'EDnea {\b 620} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v atoull\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:atoull}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr unsigned long long NumRepr::type_traits::atoull (char *  {\i text}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 156} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v base_2\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:base_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::base_2 ()}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 528} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v base_geqt_2\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:base_geqt_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B> consteval bool NumRepr::type_traits::base_geqt_2 ()}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 533} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v base_leqt_max\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:base_leqt_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B> consteval bool NumRepr::type_traits::base_leqt_max ()}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 538} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v clear_ccad\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:clear_ccad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * NumRepr::type_traits::clear_ccad (char * , {\b usint_t} )}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1type__traits_a167f2f4507b6f1cbc6fd15d365570c1f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v clear_ccad\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:clear_ccad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr char * NumRepr::type_traits::clear_ccad (char *  {\i cad_c}, std::size_t  {\i long_de_cad_c}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 149} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v devCadenaC\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:devCadenaC}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<template< {\b uchint_t} B > class T, {\b uchint_t} B> constexpr const char * NumRepr::type_traits::devCadenaC (T< B >  {\i arg}, std::size_t  {\i long_ccad} = {\f2 64}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 132} del archivo {\b basic_types.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1type__traits_a88d9d80805fd8fe7d5662340a7e92344_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v digit_0\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:digit_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::digit_0 ()}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 518} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v digit_1\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:digit_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::digit_1 ()}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 523} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v maxbase\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:maxbase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::maxbase ()}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 478} del archivo {\b basic_types.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1type__traits_a4f0f4b9cd9964b406c8299bcbd74f506_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v maxdigit\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:maxdigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::maxdigit ()}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 508} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v middle_max\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:middle_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::middle_max ()}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 548} del archivo {\b basic_types.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1type__traits_ab7aafe6bcb405d5c200145181755984f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v minbase\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:minbase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::minbase ()}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 488} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v monobase\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:monobase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::monobase ()}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 498} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v nobase\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:nobase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::nobase ()}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 503} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v sqrt_max\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:sqrt_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::sqrt_max ()}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
QUEREMOS FABRICAR LA METAFUNCION TypeFromIntNumber_t<numero_sin_signo> QUE DEVUELVA EL TIPO ENTERO SIN SIGNO MAS PEQUENO PARA EL NUMERO numero_sin_signo \par
}{
Definici\'F3n en la l\'EDnea {\b 557} del archivo {\b basic_types.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespace_num_repr_1_1type__traits_a9c68ad4f3469998252d88633edf8e908_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v submaxbase\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:submaxbase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::submaxbase ()}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 483} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v submaxdigit\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:submaxdigit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::submaxdigit ()}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 513} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v subminbase\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:subminbase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > consteval UINT_T NumRepr::type_traits::subminbase ()}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 493} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v suitable_base\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:suitable_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T , UINT_T B> consteval bool NumRepr::type_traits::suitable_base ()}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 543} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las variables\par
\pard\plain 
{\xe \v eq_sz_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:eq_sz_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename S > constexpr bool NumRepr::type_traits::eq_sz_v = (sizeof(T) == sizeof(S)){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADORES DE COMPARACION DE CAPACIDAD DE INTEGERS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 206} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v ge_sz_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:ge_sz_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename S > constexpr bool NumRepr::type_traits::ge_sz_v = {\b gt_sz_v}<T,S>||{\b eq_sz_v}<T,S>{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 212} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v gt_sz_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:gt_sz_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename S > constexpr bool NumRepr::type_traits::gt_sz_v = (sizeof(T) > sizeof(S)){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 208} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v is_integral_type_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:is_integral_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename INT_TYPE > constexpr bool NumRepr::type_traits::is_integral_type_v = std::is_integral_v<INT_TYPE>{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO ES INTEGRAL. }}\par
{
Definici\'F3n en la l\'EDnea {\b 199} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v is_signed_type_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:is_signed_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SINT_T > constexpr bool NumRepr::type_traits::is_signed_type_v = std::is_signed_v<SINT_T>{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES SIGNED. }}\par
{
Definici\'F3n en la l\'EDnea {\b 192} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v is_uint_type_for_radix_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:is_uint_type_for_radix_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > constexpr bool NumRepr::type_traits::is_uint_type_for_radix_v = std::is_unsigned_v<UINT_T> && (! std::is_same_v<UINT_T,{\b uint128_t}>){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"CLASS" TYPE TYPE DEFINITION template<typename              int_type,int_type base> class digito<int_type,base> \{\}; CONCEPT TYPE TYPE DEFINITION template<allowable_base_type_c int_type,int_type base> class digito<int_type,base> \{\}; METAOPERADOR QUE NOS DA LA ADECUACION DE UN TIPO PARA SER BASE DE UN SISTEMA DE NUMERACION VALE CUALQUIER TIPO UNSIGNED INTEGRAL QUE NO SEA EL MAYOR CONSIDERADO AQUI EL MAYOR CONSIDERADO ES UINT128_T \par
}{
Definici\'F3n en la l\'EDnea {\b 175} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v is_unsigned_type_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:is_unsigned_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UINT_T > constexpr bool NumRepr::type_traits::is_unsigned_type_v{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
                        is_uint_type_for_radix_v<UINT_T>        || std::is_same_v<UINT_T,uint128_t>\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES UNSIGNED VALEN LOS QUE VALEN PARA RADIX MAS LOS TIPO MAS GRANDES POR LO TANTO UINT128_T SE CONSIDERA UN UNSIGNED INTEGRAL TYPE \par
}{
Definici\'F3n en la l\'EDnea {\b 184} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v le_sz_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:le_sz_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename S > constexpr bool NumRepr::type_traits::le_sz_v = {\b lt_sz_v}<T,S>||{\b eq_sz_v}<T,S>{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAFUNCION : DA EL SIGUIENTE TIPO NATURAL PARA EL ACTUAL TIPO NATURAL POR ESPECIALIZACION EXPLICITA \par
}{
Definici\'F3n en la l\'EDnea {\b 214} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v lt_sz_v\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:lt_sz_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename S > constexpr bool NumRepr::type_traits::lt_sz_v = (sizeof(T) < sizeof(S)){\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 210} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v nullchar\:NumRepr::type_traits}
{\xe \v NumRepr::type_traits\:nullchar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<char_type_c CharT> constexpr CharT NumRepr::type_traits::nullchar \{CharT('\\0')\}{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 126} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction}
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UIntTypeForRadixContainsMultResult}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UIntTypeForRadixContainsMultResult< T, Radix >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits::ugly_details_for_suitable_type_deduction\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction}
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UIntTypeForRadix}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b UIntTypeForRadix< T, Radix >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits::ugly_details_sig_SInt_for_UInt\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt}
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_UInt_t}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_UInt_t< uchint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_UInt_t< uint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_UInt_t< ulint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_UInt_t< ullint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_UInt_t< usint_t >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits::ugly_details_SInt_for_SInt\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt}
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_SInt_t}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_SInt_t< schint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_SInt_t< sint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_SInt_t< slint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_SInt_t< sllint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_SInt_for_SInt_t< ssint_t >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits::ugly_details_UInt_for_SInt\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt}
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t< schint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t< sint128_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t< sint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t< slint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t< sllint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_SInt_t< ssint_t >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace NumRepr::type_traits::ugly_details_UInt_for_UInt\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt}
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_UInt_t}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_UInt_t< uchint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_UInt_t< uint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_UInt_t< ulint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_UInt_t< ullint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b __sig_UInt_for_UInt_t< usint_t >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace utilities\par \pard\plain 
{\tc\tcl2 \v utilities}
{\xe \v utilities}
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b special}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b for_each_same_type}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b for_each_same_type< Head_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b local_void_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pack2array}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pack2tuple}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concepts\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b all_are_the_same_type_c}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b there_is_one_or_more_c}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T> using {\b uintspair} = typename std::array< UINT_T, 2 >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T, UINT_T B> using {\b uintspairlist} = typename std::array< {\b uintspair}< UINT_T >, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T, UINT_T B> using {\b uintspairtbl} = typename std::array< {\b uintspairlist}< UINT_T, B >, B >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class... Ts> \par
requires ( all_are_the_same_type_c<Ts...> && there_is_one_or_more_c<Ts...> )void {\b assign_with_order} (auto &dest, const Ts &... args) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'typedefs'\par
\pard\plain 
{\xe \v uintspair\:utilities}
{\xe \v utilities\:uintspair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T> using {\b utilities::uintspair} = typedef typename std::array<UINT_T,2>}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 10} del archivo {\b utilities.hpp}.}\par
}
{\xe \v uintspairlist\:utilities}
{\xe \v utilities\:uintspairlist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T, UINT_T B> using {\b utilities::uintspairlist} = typedef typename std::array<{\b uintspair}<UINT_T>,B>}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 12} del archivo {\b utilities.hpp}.}\par
}
{\xe \v uintspairtbl\:utilities}
{\xe \v utilities\:uintspairtbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T, UINT_T B> using {\b utilities::uintspairtbl} = typedef typename std::array<{\b uintspairlist}<UINT_T,B>,B>}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 14} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v assign_with_order\:utilities}
{\xe \v utilities\:assign_with_order}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class... Ts> \par
requires ( all_are_the_same_type_c<Ts...> && there_is_one_or_more_c<Ts...> )void utilities::assign_with_order (auto &  {\i dest}, const Ts &...  {\i args}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 160} del archivo {\b utilities.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceutilities_a0f549ca7e224442069f979e4beaaab88_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Namespace utilities::special\par \pard\plain 
{\tc\tcl2 \v utilities::special}
{\xe \v utilities::special}
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pow_B_to_E_t}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA ANTIGUA PERO SEGURA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pow_B_to_E_t< Base, 0 >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pow_B_to_E_t< Base, 1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b pow_B_to_E_t< Base, 2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_builder_t}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TEMPLATE GENERAL. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == BEGININTOBJ_CT. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == ENDINTOBJ_CT-1. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b tuple_user_constructor_t}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::usint_t} B, {\b NumRepr::usint_t} L> consteval {\b NumRepr::uint128_t} {\b Base_pow_to_Size} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA SENCILLA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t start, std::size_t Base, std::size_t ... Is, template< std::size_t, std::size_t > typename Funct_tt, typename ... Ts> constexpr void {\b ctf_helper} (std::index_sequence< Is... >, std::tuple< Ts... > const &t) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t start, std::size_t end, std::size_t Base, template< typename, std::size_t, std::size_t > typename Funct_tt, typename ... Ts> constexpr void {\b ct_for} (std::tuple< Ts... > const &t) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<auto B, auto L, typename A > constexpr {\b NumRepr::uint128_t} {\b conversion_to_int} (const A &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONVERSION DE REGISTRO DE DIGITOS A ENTERO EN TIEMPO DE COMPILACION. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp> constexpr {\b NumRepr::uint128_t} {\b Pow_B2L_v} = {\b pow_B_to_E_t}<Base,Exp>::value\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr auto {\b tuple_constr_v}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
LA LLAMADA "REAL" ES {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid             assign_with_order(dest,args...);\par
}
 donde los "args" son de tipo "Ts" (que es uno solo, todos iguales entre si) \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v Base_pow_to_Size\:utilities::special}
{\xe \v utilities::special\:Base_pow_to_Size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} B, {\b NumRepr::usint_t} L> consteval {\b NumRepr::uint128_t} utilities::special::Base_pow_to_Size (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA SENCILLA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. }}\par
{
Definici\'F3n en la l\'EDnea {\b 179} del archivo {\b utilities.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceutilities_1_1special_a3645f9215c31596f25430e9c722eef17_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceutilities_1_1special_a3645f9215c31596f25430e9c722eef17_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v conversion_to_int\:utilities::special}
{\xe \v utilities::special\:conversion_to_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<auto B, auto L, typename A > constexpr {\b NumRepr::uint128_t} utilities::special::conversion_to_int (const A &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONVERSION DE REGISTRO DE DIGITOS A ENTERO EN TIEMPO DE COMPILACION. }}\par
{
Definici\'F3n en la l\'EDnea {\b 382} del archivo {\b utilities.hpp}.}\par
}
{\xe \v ct_for\:utilities::special}
{\xe \v utilities::special\:ct_for}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t start, std::size_t end, std::size_t Base, template< typename, std::size_t, std::size_t > typename Funct_tt, typename ... Ts> constexpr void utilities::special::ct_for (std::tuple< Ts... > const &  {\i t}){\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 374} del archivo {\b utilities.hpp}.}\par
}
{\xe \v ctf_helper\:utilities::special}
{\xe \v utilities::special\:ctf_helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t start, std::size_t Base, std::size_t ... Is, template< std::size_t, std::size_t > typename Funct_tt, typename ... Ts> constexpr void utilities::special::ctf_helper (std::index_sequence< Is... > , std::tuple< Ts... > const &  {\i t}){\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 355} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las variables\par
\pard\plain 
{\xe \v Pow_B2L_v\:utilities::special}
{\xe \v utilities::special\:Pow_B2L_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp> constexpr {\b NumRepr::uint128_t} utilities::special::Pow_B2L_v = {\b pow_B_to_E_t}<Base,Exp>::value{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 218} del archivo {\b utilities.hpp}.}\par
}
{\xe \v tuple_constr_v\:utilities::special}
{\xe \v utilities::special\:tuple_constr_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr auto utilities::special::tuple_constr_v{\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
        tuple_user_constructor_t<\par
                        BeginIntObj_ct,\par
                        EndIntObj_ct,\par
                        Base,\par
                        Funct_tt\par
        >::build()\par
}
{
Definici\'F3n en la l\'EDnea {\b 336} del archivo {\b utilities.hpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Concept Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::arith_integral_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::arith_integral_c}
{\xe \v NumRepr::type_traits::arith_integral_c}
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TYPE_TRAITS AND CONCEPTS. }}\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} IntT>\par
{\cf17 concept }NumRepr::type_traits::arith_integral_c =        std::is_arithmetic_v<IntT>      &&\par
                            std::is_integral_v<IntT>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TYPE_TRAITS AND CONCEPTS. \par
}{
Definici\'F3n en la l\'EDnea {\b 110} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::arith_natural_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::arith_natural_c}
{\xe \v NumRepr::type_traits::arith_natural_c}
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} NatIntT>\par
{\cf17 concept }NumRepr::type_traits::arith_natural_c =    std::is_arithmetic_v<NatIntT>   &&\par
                                                                                                                std::is_unsigned_v<NatIntT>     &&\par
                                                                                                                std::is_integral_v<NatIntT>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 114} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::char_type_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::char_type_c}
{\xe \v NumRepr::type_traits::char_type_c}
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} CharT>\par
{\cf17 concept }NumRepr::type_traits::char_type_c =  std::is_same_v<CharT,char>                                                 ||\par
                                                                                        std::is_same_v<CharT,signed char>               ||\par
                                                                                        std::is_same_v<CharT,unsigned char>     ||\par
                                                                                        std::is_same_v<CharT,wchar_t>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 119} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::integral_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::integral_c}
{\xe \v NumRepr::type_traits::integral_c}
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} INT_T>\par
{\cf17 concept }NumRepr::type_traits::integral_c =  is_integral_type_v<INT_T>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 202} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::signed_integral_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::signed_integral_c}
{\xe \v NumRepr::type_traits::signed_integral_c}
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR SIGNED INTEGRAL TYPES. }}\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} SINT_T>\par
{\cf17 concept }NumRepr::type_traits::signed_integral_c =  is_signed_type_v<SINT_T>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR SIGNED INTEGRAL TYPES. \par
}{
Definici\'F3n en la l\'EDnea {\b 195} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::uint_type_for_radix_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::uint_type_for_radix_c}
{\xe \v NumRepr::type_traits::uint_type_for_radix_c}
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES VALID FOR THE RADIX. }}\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} UINT_T>\par
{\cf17 concept }NumRepr::type_traits::uint_type_for_radix_c =  is_uint_type_for_radix_v<UINT_T>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES VALID FOR THE RADIX. \par
}{
Definici\'F3n en la l\'EDnea {\b 178} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NumRepr::type_traits::unsigned_integral_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::unsigned_integral_c}
{\xe \v NumRepr::type_traits::unsigned_integral_c}
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES. }}\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename} UINT_T>\par
{\cf17 concept }NumRepr::type_traits::unsigned_integral_c =  is_unsigned_type_v<UINT_T>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES. \par
}{
Definici\'F3n en la l\'EDnea {\b 188} del archivo {\b basic_types.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utilities::all_are_the_same_type_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v utilities::all_are_the_same_type_c}
{\xe \v utilities::all_are_the_same_type_c}
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename}... Ts>\par
{\cf17 concept }utilities::all_are_the_same_type_c =  {\cf17 requires}(Ts...) \{\par
        for_each_same_type<Ts...>::are_same_type_v;\par
\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 92} del archivo {\b utilities.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utilities::there_is_one_or_more_c Concept Reference\par \pard\plain 
{\tc\tcl2 \v utilities::there_is_one_or_more_c}
{\xe \v utilities::there_is_one_or_more_c}
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concept definition\par
\pard\plain 
{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid {\cf17 template}<{\cf17 typename}... Ts>\par
{\cf17 concept }utilities::there_is_one_or_more_c =  {\cf17 requires}(Ts...) \{\par
        (({\cf17 sizeof}...(Ts))>0);\par
\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 97} del archivo {\b utilities.hpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documentaci\'F3n de las clases{\tc \v Documentaci\'F3n de las clases}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >}
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename SInt>\par
struct NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 409} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SInt > using {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< SInt >::type =  void}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 410} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >}
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b signed_gt_signed_v}< {\b ssint_t} >, {\b ssint_t}, typename {\b __sig_SInt_for_SInt_t}< {\b ssint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SINT_T > static constexpr bool {\b signed_gt_signed_v} = {\b gt_sz_v}<SINT_T,{\b schint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 456} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b schint_t} >::type =  std::conditional_t< {\b signed_gt_signed_v}<{\b ssint_t}>, {\b ssint_t}, typename {\b __sig_SInt_for_SInt_t}<{\b ssint_t}>::type >}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 460} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v signed_gt_signed_v\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >\:signed_gt_signed_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SINT_T > constexpr bool {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b schint_t} >::signed_gt_signed_v = {\b gt_sz_v}<SINT_T,{\b schint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 458} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >}
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b signed_gt_signed_v}< {\b slint_t} >, {\b slint_t}, typename {\b __sig_SInt_for_SInt_t}< {\b slint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SINT_T > static constexpr bool {\b signed_gt_signed_v} = {\b gt_sz_v}<SINT_T,{\b sint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 430} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b sint_t} >::type =  std::conditional_t< {\b signed_gt_signed_v}<{\b slint_t}>, {\b slint_t}, typename {\b __sig_SInt_for_SInt_t}<{\b slint_t}>::type >}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 434} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v signed_gt_signed_v\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >\:signed_gt_signed_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SINT_T > constexpr bool {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b sint_t} >::signed_gt_signed_v = {\b gt_sz_v}<SINT_T,{\b sint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 432} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >}
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b signed_gt_signed_v}< {\b sllint_t} >, {\b sllint_t}, typename {\b __sig_SInt_for_SInt_t}< {\b sllint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<signed_integral_c SINT_T> static constexpr bool {\b signed_gt_signed_v} = {\b gt_sz_v}<SINT_T,{\b slint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 417} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b slint_t} >::type =  std::conditional_t< {\b signed_gt_signed_v}<{\b sllint_t}>, {\b sllint_t}, typename {\b __sig_SInt_for_SInt_t}<{\b sllint_t}>::type >}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 421} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v signed_gt_signed_v\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >\:signed_gt_signed_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<signed_integral_c SINT_T> constexpr bool {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b slint_t} >::signed_gt_signed_v = {\b gt_sz_v}<SINT_T,{\b slint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 419} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >}
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b sint128_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 413} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b sllint_t} >::type =  {\b sint128_t}}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 414} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >}
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b signed_gt_signed_v}< {\b sint_t} >, {\b sint_t}, typename {\b __sig_SInt_for_SInt_t}< {\b sint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SINT_T > static constexpr bool {\b signed_gt_signed_v} = {\b gt_sz_v}<SINT_T,{\b ssint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 443} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b ssint_t} >::type =  std::conditional_t< {\b signed_gt_signed_v}<{\b sint_t}>, {\b sint_t}, typename {\b __sig_SInt_for_SInt_t}<{\b sint_t}>::type >}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 447} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v signed_gt_signed_v\:NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >}
{\xe \v NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >\:signed_gt_signed_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SINT_T > constexpr bool {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t}< {\b ssint_t} >::signed_gt_signed_v = {\b gt_sz_v}<SINT_T,{\b ssint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 445} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >}
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename UInt>\par
struct NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 295} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename UInt > using {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< UInt >::type =  void}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 296} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >}
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b int_type_gt_this_type_v}< {\b ssint_t} >, {\b ssint_t}, typename {\b __sig_SInt_for_UInt_t}< {\b usint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename int_type > static constexpr bool {\b int_type_gt_this_type_v} = {\b gt_sz_v}<int_type,{\b uchint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 345} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b uchint_t} >::type =  std::conditional_t< {\b int_type_gt_this_type_v}<{\b ssint_t}>, {\b ssint_t}, typename {\b __sig_SInt_for_UInt_t}<{\b usint_t}>::type >}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 350} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v int_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >\:int_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename int_type > constexpr bool {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b uchint_t} >::int_type_gt_this_type_v = {\b gt_sz_v}<int_type,{\b uchint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 348} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >}
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b int_type_gt_this_type_v}< {\b slint_t} >, {\b slint_t}, typename {\b __sig_SInt_for_UInt_t}< {\b ulint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename int_type > static constexpr bool {\b int_type_gt_this_type_v} = {\b gt_sz_v}<int_type,{\b uint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 317} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b uint_t} >::type =  std::conditional_t< {\b int_type_gt_this_type_v}<{\b slint_t}>, {\b slint_t}, typename {\b __sig_SInt_for_UInt_t}<{\b ulint_t}>::type >}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 322} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v int_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >\:int_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename int_type > constexpr bool {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b uint_t} >::int_type_gt_this_type_v = {\b gt_sz_v}<int_type,{\b uint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 320} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >}
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b int_type_gt_this_type_v}< {\b sllint_t} >, {\b sllint_t}, typename {\b __sig_SInt_for_UInt_t}< {\b ullint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename int_type > static constexpr bool {\b int_type_gt_this_type_v} = {\b gt_sz_v}<int_type,{\b ulint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 303} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b ulint_t} >::type =  std::conditional_t< {\b int_type_gt_this_type_v}<{\b sllint_t}>, {\b sllint_t}, typename {\b __sig_SInt_for_UInt_t}<{\b ullint_t}>::type >}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 308} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v int_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >\:int_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename int_type > constexpr bool {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b ulint_t} >::int_type_gt_this_type_v = {\b gt_sz_v}<int_type,{\b ulint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 306} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >}
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b sint128_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 299} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b ullint_t} >::type =  {\b sint128_t}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 300} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >}
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b int_type_gt_this_type_v}< {\b sint_t} >, {\b sint_t}, typename {\b __sig_SInt_for_UInt_t}< {\b uint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename int_type > static constexpr bool {\b int_type_gt_this_type_v} = {\b gt_sz_v}<int_type,{\b usint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 331} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b usint_t} >::type =  std::conditional_t< {\b int_type_gt_this_type_v}<{\b sint_t}>, {\b sint_t}, typename {\b __sig_SInt_for_UInt_t}<{\b uint_t}>::type >}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 336} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v int_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >}
{\xe \v NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >\:int_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename int_type > constexpr bool {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t}< {\b usint_t} >::int_type_gt_this_type_v = {\b gt_sz_v}<int_type,{\b usint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 334} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >}
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename SInt>\par
struct NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 370} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename SInt > using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< SInt >::type =  void}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 371} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >}
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b uchint_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 378} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< {\b schint_t} >::type =  {\b uchint_t}}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 379} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >}
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b uint128_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 374} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< {\b sint128_t} >::type =  {\b uint128_t}}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 375} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >}
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b uint_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 386} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< {\b sint_t} >::type =  {\b uint_t}}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 387} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >}
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b ulint_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 390} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< {\b slint_t} >::type =  {\b ulint_t}}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 391} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >}
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b ullint_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 394} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< {\b sllint_t} >::type =  {\b ullint_t}}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 395} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >}
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b usint_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 382} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t}< {\b ssint_t} >::type =  {\b usint_t}}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 383} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >}
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<unsigned_integral_c UInt_t>\par
struct NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 220} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned_integral_c UInt_t> using {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< UInt_t >::type =  void}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 220} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >}
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b uint_type_gt_this_type_v}< {\b usint_t} >, {\b usint_t}, typename {\b __sig_UInt_for_UInt_t}< {\b usint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned_integral_c uint_type> static constexpr bool {\b uint_type_gt_this_type_v} = {\b gt_sz_v}<uint_type,{\b uchint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 270} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b uchint_t} >::type =  std::conditional_t< {\b uint_type_gt_this_type_v}<{\b usint_t}>, {\b usint_t}, typename {\b __sig_UInt_for_UInt_t}<{\b usint_t}>::type >}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 275} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v uint_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >\:uint_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned_integral_c uint_type> constexpr bool {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b uchint_t} >::uint_type_gt_this_type_v = {\b gt_sz_v}<uint_type,{\b uchint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 273} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >}
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b uint_type_gt_this_type_v}< {\b ulint_t} >, {\b ulint_t}, typename {\b __sig_UInt_for_UInt_t}< {\b ulint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned_integral_c uint_type> static constexpr bool {\b uint_type_gt_this_type_v} = {\b gt_sz_v}<uint_type,{\b uint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 242} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b uint_t} >::type =  std::conditional_t< {\b uint_type_gt_this_type_v}<{\b ulint_t}>, {\b ulint_t}, typename {\b __sig_UInt_for_UInt_t}<{\b ulint_t}>::type >}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 247} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v uint_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >\:uint_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned_integral_c uint_type> constexpr bool {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b uint_t} >::uint_type_gt_this_type_v = {\b gt_sz_v}<uint_type,{\b uint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 245} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >}
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = typename std::conditional_t< {\b uint_type_gt_this_type_v}< {\b ullint_t} >, {\b ullint_t}, typename {\b __sig_UInt_for_UInt_t}< {\b ullint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned_integral_c uint_type> static constexpr bool {\b uint_type_gt_this_type_v} = {\b gt_sz_v}<uint_type,{\b ulint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 227} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b ulint_t} >::type =  typename std::conditional_t< {\b uint_type_gt_this_type_v}<{\b ullint_t}>, {\b ullint_t}, typename {\b __sig_UInt_for_UInt_t}<{\b ullint_t}>::type >}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 232} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v uint_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >\:uint_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned_integral_c uint_type> constexpr bool {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b ulint_t} >::uint_type_gt_this_type_v = {\b gt_sz_v}<uint_type,{\b ulint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 230} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >}
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b uint128_t}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 223} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b ullint_t} >::type =  {\b uint128_t}}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 224} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >}
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::conditional_t< {\b uint_type_gt_this_type_v}< {\b uint_t} >, {\b uint_t}, typename {\b __sig_UInt_for_UInt_t}< {\b uint_t} >::type >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned_integral_c uint_type> static constexpr bool {\b uint_type_gt_this_type_v} = {\b gt_sz_v}<uint_type,{\b usint_t}>\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 256} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b usint_t} >::type =  std::conditional_t< {\b uint_type_gt_this_type_v}<{\b uint_t}>, {\b uint_t}, typename {\b __sig_UInt_for_UInt_t}<{\b uint_t}>::type >}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 261} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v uint_type_gt_this_type_v\:NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >}
{\xe \v NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >\:uint_type_gt_this_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<unsigned_integral_c uint_type> constexpr bool {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t}< {\b usint_t} >::uint_type_gt_this_type_v = {\b gt_sz_v}<uint_type,{\b usint_t}>{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 259} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::base_num_t< UINT_T, B >\par \pard\plain 
{\tc\tcl2 \v NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >}
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
\par
{
{\f2 #include <base_num_t.hpp>}}\par
Diagrama de herencias de NumRepr::base_num_t< UINT_T, B >{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1base__num__t__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Diagrama de colaboraci\'F3n para NumRepr::base_num_t< UINT_T, B >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1base__num__t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b dig_t} = {\b dig_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_t} = basic_string< {\b dig_t} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b str_iterator} = typename base_t::iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b c_str_iterator} = typename base_t::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b r_str_iterator} = typename base_t::reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b cr_str_iterator} = typename base_t::const_reverse_iterator\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b resize} ({\b size_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator[]} (ullint arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator[]} (ullint arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b clear} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b push_back} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b insert} ({\b size_t} pos, {\b size_t} tam, {\b dig_t} parg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr num_basic_t {\b substr} ({\b size_t} pos, {\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b push_front} ({\b dig_t} parg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b str_iterator} {\b begin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b c_str_iterator} {\b end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b r_str_iterator} {\b rbegin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b cr_str_iterator} {\b rend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b erase} ({\b size_t} pos, {\b size_t} tam) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const num_basic_t & {\b operator&=} (const num_basic_t &arg) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B>\par
requires ({\b type_traits::suitable_base}<UINT_T,B>())\par
struct NumRepr::base_num_t< UINT_T, B >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 10} del archivo {\b base_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v base_t\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:base_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::base_num_t}< UINT_T, B >::base_t =  basic_string<{\b dig_t}>}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 13} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v c_str_iterator\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:c_str_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::base_num_t}< UINT_T, B >::c_str_iterator =  typename base_t::const_iterator}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 15} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v cr_str_iterator\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:cr_str_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::base_num_t}< UINT_T, B >::cr_str_iterator =  typename base_t::const_reverse_iterator}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 17} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v dig_t\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::base_num_t}< UINT_T, B >::dig_t =  {\b dig_t}<UINT_T,B>}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 12} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v r_str_iterator\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:r_str_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::base_num_t}< UINT_T, B >::r_str_iterator =  typename base_t::reverse_iterator}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v str_iterator\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:str_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::base_num_t}< UINT_T, B >::str_iterator =  typename base_t::iterator}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 14} del archivo {\b base_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v begin\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b str_iterator} {\b NumRepr::base_num_t}< UINT_T, B >::begin (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 51} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v clear\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::base_num_t}< UINT_T, B >::clear (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 33} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v end\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b c_str_iterator} {\b NumRepr::base_num_t}< UINT_T, B >::end () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 54} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v erase\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::base_num_t}< UINT_T, B >::erase ({\b size_t}  {\i pos}, {\b size_t}  {\i tam}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 63} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v insert\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::base_num_t}< UINT_T, B >::insert ({\b size_t}  {\i pos}, {\b size_t}  {\i tam}, {\b dig_t}  {\i parg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 39} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v operator&=\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr const num_basic_t & {\b NumRepr::base_num_t}< UINT_T, B >::operator&= (const num_basic_t &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 67} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v operator[]\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::base_num_t}< UINT_T, B >::operator[] (ullint  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 25} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v operator[]\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} & {\b NumRepr::base_num_t}< UINT_T, B >::operator[] (ullint  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 29} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v push_back\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::base_num_t}< UINT_T, B >::push_back ({\b dig_t}  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 36} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v push_front\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:push_front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::base_num_t}< UINT_T, B >::push_front ({\b dig_t}  {\i parg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 48} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v rbegin\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b r_str_iterator} {\b NumRepr::base_num_t}< UINT_T, B >::rbegin (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 57} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v rend\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b cr_str_iterator} {\b NumRepr::base_num_t}< UINT_T, B >::rend () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 60} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v resize\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::base_num_t}< UINT_T, B >::resize ({\b size_t}  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 22} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v size\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b size_t} {\b NumRepr::base_num_t}< UINT_T, B >::size () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b base_num_t.hpp}.}\par
}
{\xe \v substr\:NumRepr::base_num_t< UINT_T, B >}
{\xe \v NumRepr::base_num_t< UINT_T, B >\:substr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> constexpr num_basic_t {\b NumRepr::base_num_t}< UINT_T, B >::substr ({\b size_t}  {\i pos}, {\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 43} del archivo {\b base_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_num_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_delete< aT, T, B >\par \pard\plain 
{\tc\tcl2 \v details::cp_delete< aT, T, B >}
{\xe \v details::cp_delete< aT, T, B >}
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b destruye_lista_de_variables} (aT *var_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, uchint B>\par
struct details::cp_delete< aT, T, B >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v destruye_lista_de_variables\:details::cp_delete< aT, T, B >}
{\xe \v details::cp_delete< aT, T, B >\:destruye_lista_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, uchint B> static void {\b details::cp_delete}< aT, T, B >::destruye_lista_de_variables (aT *  {\i var_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 80} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__delete_ae7256e3961b6516f37d144d7f2f521ff_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator()\:details::cp_delete< aT, T, B >}
{\xe \v details::cp_delete< aT, T, B >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, uchint B> void {\b details::cp_delete}< aT, T, B >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 84} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__delete_abd0cf2f40295b124e6ecbb55ca06948c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_delete< 0u >\par \pard\plain 
{\tc\tcl2 \v details::cp_delete< 0u >}
{\xe \v details::cp_delete< 0u >}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, usint num_vars>\par
struct details::cp_delete< 0u >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 126} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v operator()\:details::cp_delete< 0u >}
{\xe \v details::cp_delete< 0u >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> void {\b details::cp_delete}< 0u >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 127} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_delete< 1u >\par \pard\plain 
{\tc\tcl2 \v details::cp_delete< 1u >}
{\xe \v details::cp_delete< 1u >}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T>\par
struct details::cp_delete< 1u >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 117} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v operator()\:details::cp_delete< 1u >}
{\xe \v details::cp_delete< 1u >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> void {\b details::cp_delete}< 1u >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 118} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_delete< 2u >\par \pard\plain 
{\tc\tcl2 \v details::cp_delete< 2u >}
{\xe \v details::cp_delete< 2u >}
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b contruye_lista_de_variables} (aT *var_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T>\par
struct details::cp_delete< 2u >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 104} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v contruye_lista_de_variables\:details::cp_delete< 2u >}
{\xe \v details::cp_delete< 2u >\:contruye_lista_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> static void {\b details::cp_delete}< 2u >::contruye_lista_de_variables (aT *  {\i var_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 106} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__delete_3_012u_01_4_af61c966e76e35fbff5fb4f1acda07538_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator()\:details::cp_delete< 2u >}
{\xe \v details::cp_delete< 2u >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> void {\b details::cp_delete}< 2u >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 110} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>\par \pard\plain 
{\tc\tcl2 \v details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>}
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b contruye_lista_de_variables} (aT *var_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T>\par
struct details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 91} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v contruye_lista_de_variables\:details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>\:contruye_lista_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> static void {\b details::cp_delete}< aT, T, std::numeric_limits< uchint >::max()>::contruye_lista_de_variables (aT *  {\i var_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 93} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v operator()\:details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_delete< aT, T, std::numeric_limits< uchint >::max()>\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> void {\b details::cp_delete}< aT, T, std::numeric_limits< uchint >::max()>::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 97} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__delete_3_01a_t_00_01_t_00_01std_1_1numeric__limits_3_01uchint_01_4_1_1max_07_08_4_a6403d0c85e272cb3cbfdad6fcd6b1feb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_new< aT, T, num_vars, B >\par \pard\plain 
{\tc\tcl2 \v details::cp_new< aT, T, num_vars, B >}
{\xe \v details::cp_new< aT, T, num_vars, B >}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static aT * {\b contruye_lista_de_variables} (aT *var_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, usint num_vars, uchint B>\par
struct details::cp_new< aT, T, num_vars, B >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v contruye_lista_de_variables\:details::cp_new< aT, T, num_vars, B >}
{\xe \v details::cp_new< aT, T, num_vars, B >\:contruye_lista_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars, uchint B> static aT * {\b details::cp_new}< aT, T, num_vars, B >::contruye_lista_de_variables (aT *  {\i var_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 18} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__new_a479edf9fda80c05ef9a9be9eec8e5c3a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator()\:details::cp_new< aT, T, num_vars, B >}
{\xe \v details::cp_new< aT, T, num_vars, B >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars, uchint B> void {\b details::cp_new}< aT, T, num_vars, B >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 23} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__new_a674103f596ac614f876144d95625fa23_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_new< 0u >\par \pard\plain 
{\tc\tcl2 \v details::cp_new< 0u >}
{\xe \v details::cp_new< 0u >}
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, usint num_vars>\par
struct details::cp_new< 0u >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 71} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v operator()\:details::cp_new< 0u >}
{\xe \v details::cp_new< 0u >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> void {\b details::cp_new}< 0u >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 72} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_new< 1u >\par \pard\plain 
{\tc\tcl2 \v details::cp_new< 1u >}
{\xe \v details::cp_new< 1u >}
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, usint num_vars>\par
struct details::cp_new< 1u >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 63} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v operator()\:details::cp_new< 1u >}
{\xe \v details::cp_new< 1u >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> void {\b details::cp_new}< 1u >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 64} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_new< 2 >\par \pard\plain 
{\tc\tcl2 \v details::cp_new< 2 >}
{\xe \v details::cp_new< 2 >}
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static aT * {\b contruye_lista_de_variables} (aT *var_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, usint num_vars>\par
struct details::cp_new< 2 >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 49} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v contruye_lista_de_variables\:details::cp_new< 2 >}
{\xe \v details::cp_new< 2 >\:contruye_lista_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> static aT * {\b details::cp_new}< 2 >::contruye_lista_de_variables (aT *  {\i var_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 51} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v operator()\:details::cp_new< 2 >}
{\xe \v details::cp_new< 2 >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> void {\b details::cp_new}< 2 >::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 56} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__new_3_012_01_4_a4145679ff55c1f6202e6afb9cde4cddf_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura details::cp_new< aT, T, std::numeric_limits< uchint >::max()>\par \pard\plain 
{\tc\tcl2 \v details::cp_new< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_new< aT, T, std::numeric_limits< uchint >::max()>}
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (aT **var_list_list)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static aT ** {\b contruye_lista_de_listas_de_variables} (aT **var_list_list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static aT * {\b contruye_lista_de_variables} (aT *var_list)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T, usint num_vars>\par
struct details::cp_new< aT, T, std::numeric_limits< uchint >::max()>\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 30} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v contruye_lista_de_listas_de_variables\:details::cp_new< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_new< aT, T, std::numeric_limits< uchint >::max()>\:contruye_lista_de_listas_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> static aT ** {\b details::cp_new}< aT, T, std::numeric_limits< uchint >::max()>::contruye_lista_de_listas_de_variables (aT **  {\i var_list_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 32} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v contruye_lista_de_variables\:details::cp_new< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_new< aT, T, std::numeric_limits< uchint >::max()>\:contruye_lista_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> static aT * {\b details::cp_new}< aT, T, std::numeric_limits< uchint >::max()>::contruye_lista_de_variables (aT *  {\i var_list}){\f2 [inline]}, {\f2 [static]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 36} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v operator()\:details::cp_new< aT, T, std::numeric_limits< uchint >::max()>}
{\xe \v details::cp_new< aT, T, std::numeric_limits< uchint >::max()>\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> void {\b details::cp_new}< aT, T, std::numeric_limits< uchint >::max()>::operator() (aT **  {\i var_list_list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structdetails_1_1cp__new_3_01a_t_00_01_t_00_01std_1_1numeric__limits_3_01uchint_01_4_1_1max_07_08_4_a364f5a172ed5a1d98e1847df4caade8f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::dig_t< UINT_T, B >\par \pard\plain 
{\tc\tcl2 \v NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >}
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
\par
{
{\f2 #include <dig_t.hpp>}}\par
Diagrama de colaboraci\'F3n para NumRepr::dig_t< UINT_T, B >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_UINT_T} = {\b sig_UInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_SINT_T} = {\b sig_SInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uintspair} = std::array< UINT_T, 2 >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b digspair} = std::array< {\b dig_t}, 2 >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uintspairlist} = std::array< {\b uintspair}, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b uintspairtbl} = std::array< {\b uintspairlist}, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op> using {\b resbinop_t} = {\b auxiliary_types::resbinop_t}< {\b dig_t}, op >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b operator UINT_T} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const UINT_T & {\b get} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b operator SIG_UINT_T} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b operator SIG_SINT_T} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr UINT_T {\b operator()} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_Bm2} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
consteval {\b dig_t} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr {\b dig_t} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} (const {\b dig_t} &) noexcept=default\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA POR REFERENCIA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} ({\b dig_t} &&) noexcept=default\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR MOVIMIENTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b operator=} (const Int_t &a) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN INT_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator=} (const {\b dig_t} &) noexcept=default\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN DIG_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator=} ({\b dig_t} &&) noexcept=default\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DEL OPERATOR=() MEDIANTE MOVIMIENTO DESDE UN DIG_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_unit} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_0_divisor} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b mult_inv} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator&} (const {\b dig_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator&=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator|} (const {\b dig_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator|=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UIntType> constexpr const {\b dig_t} & {\b operator^=} (UIntType exp) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UIntType> constexpr {\b dig_t} {\b operator^} (UIntType exp) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator==} ({\b dig_t} a) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator!=} ({\b dig_t} a) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator>=} ({\b dig_t} a) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator>} ({\b dig_t} a) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator<=} ({\b dig_t} a) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator<} ({\b dig_t} a) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::strong_ordering {\b operator<=>} ({\b dig_t} rhs) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr bool {\b operator==} (Int_t rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr std::weak_ordering {\b operator<=>} (Int_t rhs) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator+=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b operator+=} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator-=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b operator-=} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator*=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b operator*=} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator/=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b operator/=} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator%=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b operator%=} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator++} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator++} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator--} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator--} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator+} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator-} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator*} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator/} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator%} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b operator+} (Int_type arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b operator-} (Int_type arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b operator*} (Int_type arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b operator/} (Int_type arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b operator%} (Int_type arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator!} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN BASE B, B-1-m_d ES EL COMPL_Bm1(m_d) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator-} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN BASE B, B-m_d ES EL COMPL_B(m_d) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b C_Bm1} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"C_Bm1" es identico a "operator!()" }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b C_B} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"C_B" es identico a "operator-()" }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b mC_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b mC_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_0} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_0or1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_0} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_0or1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bm1orBm2} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_Bm1orBm2} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bm2} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_Bm2} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_not_maxormin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_maxormin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_far_maxormin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_near_maxormin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::string {\b to_string} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b get_type_template_string_id_token} (std::istream &is) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<UINT_T n, UINT_T m> \par
requires ((n<B)&&(m<B))static consteval {\b uintspair} {\b mult} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval bool {\b is_prime} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_max} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_submax} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_Bm2} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_max} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_submax} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_Bm2} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_max} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_submax} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_max} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b ssi_submax} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b ssi_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b ssi_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_t> static constexpr UINT_T {\b normaliza} (Int_t arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b sum_carry} ({\b dig_t} arg_1, {\b dig_t} arg_2) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b is_type_template_string_id} (std::string in) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
el parser/lexer del {\b dig_t} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::string {\b to_type_template_string_id} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b size_t} {\b size_of_type_template_string_id} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b get_digit_token} (std::istream &is, UINT_T &uint_value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN DIGITO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b get_radix_token} (std::istream &is)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b read} (std::istream &is, {\b dig_t} &value) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::string {\b num_to_string} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TIENE QUE DEVOLVER STD::STRING. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::string {\b radix_str} () noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
UINT_T {\b m_d}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B>\par
requires (suitable_base<UINT_T,B>())\par
struct NumRepr::dig_t< UINT_T, B >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< WRAPPER PARA UN TIPO UINT_T QUE UNSIGNED_INTEGRAL_T<UINT_T> SE SOBRECARGAN LOS OPERADORES ARITMETICOS PARA ARITMETICA MODULAR DIG_T = SUMA Y MULTIPLICACION CIRCULAR (MODULAR CON MOD B) \par
}{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b dig_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v digspair\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:digspair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::dig_t}< UINT_T, B >::digspair =  std::array<{\b dig_t},2>}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 29} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v resbinop_t\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:resbinop_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<{\b binop_e} op> using {\b NumRepr::dig_t}< UINT_T, B >::resbinop_t =  {\b auxiliary_types::resbinop_t}<{\b dig_t},op>}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : CONSTRUCCION DE LAS TABLAS DE MULTIPLICAR ESTATICAS PARA TODA LA CLASE \par
}{
Definici\'F3n en la l\'EDnea {\b 34} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v SIG_SINT_T\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:SIG_SINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::dig_t}< UINT_T, B >::SIG_SINT_T =  {\b sig_SInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 26} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v SIG_UINT_T\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:SIG_UINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::dig_t}< UINT_T, B >::SIG_UINT_T =  {\b sig_UInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 24} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v uintspair\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:uintspair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::dig_t}< UINT_T, B >::uintspair =  std::array<UINT_T,2>}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 28} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v uintspairlist\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:uintspairlist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::dig_t}< UINT_T, B >::uintspairlist =  std::array<{\b uintspair},B>}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 30} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v uintspairtbl\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:uintspairtbl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> using {\b NumRepr::dig_t}< UINT_T, B >::uintspairtbl =  std::array<{\b uintspairlist},B>}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 31} del archivo {\b dig_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v dig_t\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> consteval {\b NumRepr::dig_t}< UINT_T, B >::dig_t (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< CONSTRUCTORES CONSTRUCTOR POR DEFECTO NORMALIZA ES UNA FUNCION QUE BASICAMENTE SI ENTRA 1524 DEVUELVE 1524B TENIENDO EN CUENTA TIPOS Y SIGNOS \par
}{
Definici\'F3n en la l\'EDnea {\b 213} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v dig_t\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr {\b NumRepr::dig_t}< UINT_T, B >::dig_t (Int_t  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR A PARTIR DE UN ENTERO ARG ARG EQUIV ARG+Z*B DONDE Z ES UN ENTERO EN m_d SOLO QUEREMOS QUE HAYA UN NUMERO ENTRE 0 Y B-1 INCLUSIVES \par
}{
Definici\'F3n en la l\'EDnea {\b 290} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v dig_t\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b NumRepr::dig_t}< UINT_T, B >::dig_t (const {\b dig_t}< UINT_T, B > & ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA POR REFERENCIA. }}\par
}
{\xe \v dig_t\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b NumRepr::dig_t}< UINT_T, B >::dig_t ({\b dig_t}< UINT_T, B > && ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR MOVIMIENTO. }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v C_B\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:C_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::C_B () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"C_B" es identico a "operator-()" }}\par
{
Definici\'F3n en la l\'EDnea {\b 962} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a946d999d39a25dda024a06800ac57f70_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v C_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:C_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::C_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"C_Bm1" es identico a "operator!()" }}\par
{
Definici\'F3n en la l\'EDnea {\b 956} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a3d6a5c0e1d8a4719d58a476cfb68c960_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::dig_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 160} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_ac6a8ff5406dd59f782f096ea7f2d2da3_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::dig_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 161} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a1dc126ef160231a2c2a87a30fdda731c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::dig_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 158} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a85fa7ae1435069ddd1b87658c97a5856_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_Bm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::dig_Bm2 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 159} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a326196de3bd9537e5c23df66440b8a56_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_max\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::dig_max (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 156} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a4295924ee3603c94ef1f1c7d83976be8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_submax\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:dig_submax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::dig_submax (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 157} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a2f8231e5cfedba8aaef0a404ca8df5d5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const UINT_T & {\b NumRepr::dig_t}< UINT_T, B >::get () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 121} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v get_digit_token\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:get_digit_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::get_digit_token (std::istream &  {\i is}, UINT_T &  {\i uint_value}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN DIGITO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1313} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a7eaaf1b30f1b962c539ec833fa5b3c5f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_radix_token\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:get_radix_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static bool {\b NumRepr::dig_t}< UINT_T, B >::get_radix_token (std::istream &  {\i is}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN BASE. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1378} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a256f1cc8420ff589031fef99193a1b52_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get_type_template_string_id_token\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:get_type_template_string_id_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> bool {\b NumRepr::dig_t}< UINT_T, B >::get_type_template_string_id_token (std::istream &  {\i is}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION GENERICA QUE CONSIGUE EL TOKEN TYPE PARA LA OBTENCION DEL OBJETO CORRESPONDIENTE POR TECLADO \par
}{
Definici\'F3n en la l\'EDnea {\b 1183} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_aac7bbe0123608fe9eef2c9ef75b082f6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_0 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dig_t<uchint,7> a,b,c; a = 5; b = 2; c = 0; !a == 1 is TRUE a.C_Bm1() == 1 is TRUE !b == 4 is TRUE b.C_Bm1() == 4 is TRUE !c == 6 is TRUE c.C_Bm1() == 6 is TRUE -a == 2 is TRUE a.C_B() == 2 is TRUE -b == 5 is TRUE b.C_B() == 5 is TRUE -c == 0 is TRUE c.C_B() == 0 is TRUE a.mC_Bm1() == 1 is TRUE a == 1 is TRUE b.mC_Bm1() == 4 is TRUE b == 4 is TRUE c.mC_Bm1() == 6 is TRUE c == 6 is TRUE a.mC_B() == 2 is TRUE a == 2 is TRUE b.mC_B() == 5 is TRUE b == 5 is TRUE c.mC_B() == 0 is TRUE c == 0 is TRUE \par
}{
Definici\'F3n en la l\'EDnea {\b 1013} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_0_divisor\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_0_divisor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_0_divisor () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 362} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a48f6d7f54f227eaf337438fccd8b9ff4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_0or1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_0or1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_0or1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1025} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a3097efc035d69810593924081fe87698_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1019} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_ac906122dd220e44ed6762896888b8e4c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1049} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_Bm1orBm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_Bm1orBm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_Bm1orBm2 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1061} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_Bm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_Bm2 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1073} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_far_maxormin\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_far_maxormin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_far_maxormin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1097} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_maxormin\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_maxormin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_maxormin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1091} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_near_maxormin\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_near_maxormin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_near_maxormin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1108} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_not_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_0 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1037} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_not_0or1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_0or1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_0or1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1043} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_not_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1031} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a3f3fbeaf6b33d1715bbd18a32c9d786b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_not_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1055} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_not_Bm1orBm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_Bm1orBm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_Bm1orBm2 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1067} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_not_Bm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_Bm2 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1079} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_not_maxormin\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_not_maxormin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_not_maxormin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1085} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_prime\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_prime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval bool {\b NumRepr::dig_t}< UINT_T, B >::is_prime (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 152} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a2e4a2d001d8b4a6e97639da50e33d3cb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_type_template_string_id\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_type_template_string_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_type_template_string_id (std::string  {\i in}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
el parser/lexer del {\b dig_t} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funciones de ayuda para \par
}{
Definici\'F3n en la l\'EDnea {\b 1162} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v is_unit\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:is_unit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::is_unit () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
a y b son digitos; a = std::move(b); a es identico a b; en b puede no queda nada; \par
}{
Definici\'F3n en la l\'EDnea {\b 338} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_aecc930e8cb3dbc3ede5beeff11ef77ee_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_B\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:mC_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::mC_B (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 981} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v mC_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:mC_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::mC_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 974} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v mult\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:mult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<UINT_T n, UINT_T m> \par
requires ((n<B)&&(m<B))static consteval {\b uintspair} {\b NumRepr::dig_t}< UINT_T, B >::mult (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v mult_inv\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:mult_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::mult_inv () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 385} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_aa62606aacfd127f2670db23a727e1689_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v normaliza\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:normaliza}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> static constexpr UINT_T {\b NumRepr::dig_t}< UINT_T, B >::normaliza (Int_t  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 219} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v num_to_string\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:num_to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr std::string {\b NumRepr::dig_t}< UINT_T, B >::num_to_string () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TIENE QUE DEVOLVER STD::STRING. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1127} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator SIG_SINT_T\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator SIG_SINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b NumRepr::dig_t}< UINT_T, B >::operator {\b SIG_SINT_T} () const{\f2 [inline]}, {\f2 [explicit]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 129} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator SIG_UINT_T\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator SIG_UINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b NumRepr::dig_t}< UINT_T, B >::operator {\b SIG_UINT_T} () const{\f2 [inline]}, {\f2 [explicit]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 125} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator UINT_T\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator UINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b NumRepr::dig_t}< UINT_T, B >::operator UINT_T () const{\f2 [inline]}, {\f2 [explicit]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PARA B=3 2*2 1 COMIENZAN POR 2 B-2 PARA B=4 2*2 2*3 3*4 3 COMIENZAN POR 2 B-2, 3 B-3 PARA B=5 2*2 2*3 2*4 3*3 3*4 4*4 6 COMIENZAN POR 2 B-2, 3 B-3, 4 B-4 PARA B=6 2*2 2*3 2*4 2*5 3*3 3*4 3*5 4*4 4*5 5*5 10 COMIENZAN POR 2 B-2, 3 B-3, 4 B-4, 5 B-5 PARA B=r 2*2 2*(2+1) ... 2*(r-1) r-1 r COMIENZAN POR 2 B-2, 3 B-3, 4 B-4, 5 B-1, ... , r-1 B-r+1 3*3 ... 3*(r-1) r-2 ... (r-1)*(r-1) r-(r-1) {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
 (r-2)r-(r-1)*r/2 + 1 = [2(r-2)-((r-2)+1)]r/2 + 1 = ((r-3)r + 2)/2 = (r^2 - 3r + 2) / 2 \par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
a r^2 + b r + c
\par}
{\tc\tcl3 \v a r^2 + b r + c}
1 = a 9 + b 3 + c 3 = a 16 + b 4 + c \par}
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
6 = a 25 + b 5 + c
\par}
{\tc\tcl3 \v 6 = a 25 + b 5 + c}
1 = a 9 + b 3 + c 2 = a 7 + b 1 \par}
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
5 = a 16 + b 2
\par}
{\tc\tcl3 \v 5 = a 16 + b 2}
1 = a 9 + b 3 + c 2 = a 7 + b \par}
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
1 = a  2
\par}
{\tc\tcl3 \v 1 = a  2}
c = 2/2 b = -3/2 \par}
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
a =  1/2
\par}
{\tc\tcl3 \v a =  1/2}
SIZE = (B^2 - 3B + 2)/2 2+3+4+...+B-1 = 1+2+3+4+...+B-1 - 1 = (B-1)B/2 - 2(B-1)/2 = (B^2 - B - 2B +2)/2 = =(B^2-3B+2)/2\par
FALTARIA HACER SOLO PARA BASES MAYORES QUE 2 CODE NEW USING TYPES : using pair_map = std::pair<uintspair,uintspair>; CODE MULTTABLE: static consteval std::array<pair_map,(B^2 - 3B + 2)/2> multtable\{make_multtables()\}; CODE FOR MAKE_MULTTABLES(): static consteval std::array<pair_map,(B^2 - 3B + 2)/2> make_multtables() noexcept \{ std::array<pair_map,(B^2 - 3B + 2)/2> ret; /// ESTO QUE SIGUE HABRIA QUE HACERLO POR UNROOLING LOOP EN COMPILE TIME /// YA QUE IDX E IDY NO SON CONSTANTES EN TIEMPO DE COMPILACION /// LO MEJOR ES HACERLO EN UNA CLASE TEMPLATE POR RECURSION for(size_t idx\{2\} ; idx < B ; ++idx) \{ for(size_t idy\{idx\} ; idy < B ; ++idy) \{ make_pair(make_array(idx,idy),{\b mult<idx,idy>()}); \} \} \} \par}
}{
Definici\'F3n en la l\'EDnea {\b 117} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator!\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator! () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN BASE B, B-1-m_d ES EL COMPL_Bm1(m_d) }}\par
{
Definici\'F3n en la l\'EDnea {\b 944} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator!=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >{\b ::operator!}= ({\b dig_t}< UINT_T, B >  {\i a}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 575} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator%\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator% ({\b dig_t}< UINT_T, B >  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 877} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator%\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator% (Int_type  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 926} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator%=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator%=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator%= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 785} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator%=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator%=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator%= (Int_t  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 793} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator&\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator& (const {\b dig_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEVOLVER EL MENOR: ANDBITWISE NO TIENE POSIBILIDAD DE ERROR \par
}{
Definici\'F3n en la l\'EDnea {\b 485} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator&=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator&= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEVOLVER EL MENOR HABIENDOLO ASIGNADO ANDBITWISE AND ASSIGN NO TIENE POSIBILIDAD DE ERROR \par
}{
Definici\'F3n en la l\'EDnea {\b 494} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator()\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr UINT_T {\b NumRepr::dig_t}< UINT_T, B >::operator() () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 133} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator*\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator* ({\b dig_t}< UINT_T, B >  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 861} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator*\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator* (Int_type  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 905} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator*=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator*= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 703} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator*=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator*= (Int_t  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 719} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator+\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator+ ({\b dig_t}< UINT_T, B >  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 845} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator+\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator+ (Int_type  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 886} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator++\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator++ (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tengo serias dudas que la division y el resto euclideo tengan cabida entre los operadores aritmeticos de un tipo {\b dig_t} DUDA SATISFECHA: TIENEN CABIDA PORQUE EL INVERSO MULTIPLICATIVO ETC. SOLO NOS SIRVE SI ESTUVIERAMOS CONSTRUYENDO NUMEROS DE UN ANILLO FINITO \par
}{
Definici\'F3n en la l\'EDnea {\b 812} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_aaa1f4b500974e6fd56e680e03f29b2c2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator++ (int ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 819} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator+=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator+= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 637} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator+=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator+= (Int_t  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 659} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator- () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN BASE B, B-m_d ES EL COMPL_B(m_d) }}\par
{
Definici\'F3n en la l\'EDnea {\b 950} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator- ({\b dig_t}< UINT_T, B >  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 853} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator- (Int_type  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 895} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator--\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator-- (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 825} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a760f7426a2aa1c3633499eb30faa47bc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator-- (int ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 832} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator-=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator-= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 681} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator-=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator-= (Int_t  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 692} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator/\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator/ ({\b dig_t}< UINT_T, B >  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 869} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator/\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_type> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator/ (Int_type  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 915} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator/=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator/= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 768} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator/=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator/= (Int_t  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 776} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator<\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::operator< ({\b dig_t}< UINT_T, B >  {\i a}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 583} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator<=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::operator<= ({\b dig_t}< UINT_T, B >  {\i a}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 581} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator<=>\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr std::strong_ordering {\b NumRepr::dig_t}< UINT_T, B >::operator<=> ({\b dig_t}< UINT_T, B >  {\i rhs}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SI COMPARAMOS O HACEMOS UNA OPERACION CON UN INT_T SIEMPRE SERA DIG_T @ INT_T -> DIG_T Y NUNCA INT_T @ DIG_T -> ANY_TYPE METODO PROPIO DE C++20 \par
}{
Definici\'F3n en la l\'EDnea {\b 589} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator<=>\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr std::weak_ordering {\b NumRepr::dig_t}< UINT_T, B >::operator<=> (Int_t  {\i rhs}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METODO PROPIO DE C++20 ESTABLECEMOS UN ORDEN PARCIAL SOBRE LOS ENTEROS SI a b EN Z ESTANDO EN ESTE AMBITO DE BASE B SI a mod B = b mod B \par
}{
Definici\'F3n en la l\'EDnea {\b 619} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator= (const {\b dig_t}< UINT_T, B > & ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN DIG_T. }}\par
}
{\xe \v operator=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator= (const Int_t &  {\i a}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DEL OPERATOR=() MEDIANTE REFERENCIA CTE DESDE UN INT_T. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PODEMOS PASAR ARGUMENTOS POR COPIA, REFERENCIA (PUNTEROS) Y MOVIMIENTO COPIA : COPIA EL ARGUMENTO LITERALMENTE PARA PASARLO: EL ORIGINAL INTACTO REFERENCIA: COPIA LA DIRECCION DEL ARGUMENTO (SI ES CONST EL COMPILADOR NO TE DEJA COMPILAR SI LO CAMBIAS) MOVIMIENTO: SI EL ARGUMETO NO SE VA A UTILIZAR MAS SE LE PASA LA PROPIEDAD A LA FUNCION \par
}{
Definici\'F3n en la l\'EDnea {\b 314} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator= ({\b dig_t}< UINT_T, B > && ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DEL OPERATOR=() MEDIANTE MOVIMIENTO DESDE UN DIG_T. }}\par
}
{\xe \v operator==\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::operator== ({\b dig_t}< UINT_T, B >  {\i a}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 573} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator==\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::integral_c Int_t> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::operator== (Int_t  {\i rhs}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 604} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator>\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::operator> ({\b dig_t}< UINT_T, B >  {\i a}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 579} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator>=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr bool {\b NumRepr::dig_t}< UINT_T, B >::operator>= ({\b dig_t}< UINT_T, B >  {\i a}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 577} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator^\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator^}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UIntType> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator^ (UIntType  {\i exp}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 559} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator^=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator^=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UIntType> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator^= (UIntType  {\i exp}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 532} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator|\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::operator| (const {\b dig_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEVOLVER EL MAYOR ORBITWISE NO TIENE POSIBILIDAD DE ERROR \par
}{
Definici\'F3n en la l\'EDnea {\b 505} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v operator|=\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr const {\b dig_t} & {\b NumRepr::dig_t}< UINT_T, B >::operator|= ({\b dig_t}< UINT_T, B >  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEVOLVER EL MAYOR HABIENDOLO ASIGNADO ORBITWISE AND ASSIGN NO TIENE POSIBILIDAD DE ERROR \par
}{
Definici\'F3n en la l\'EDnea {\b 514} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v radix_str\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:radix_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr std::string {\b NumRepr::dig_t}< UINT_T, B >::radix_str (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1138} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v read\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static bool {\b NumRepr::dig_t}< UINT_T, B >::read (std::istream &  {\i is}, {\b dig_t}< UINT_T, B > &  {\i value}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1457} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a4b2689884533f42678398c144b127910_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:set_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::dig_t}< UINT_T, B >::set_0 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
dig_t<uchint,10> digito\{4\}; digito() devuelve un 4 de tipo uchint \par
}{
Definici\'F3n en la l\'EDnea {\b 138} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v set_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:set_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::dig_t}< UINT_T, B >::set_1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 141} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v set_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:set_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::dig_t}< UINT_T, B >::set_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 144} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v set_Bm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:set_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr void {\b NumRepr::dig_t}< UINT_T, B >::set_Bm2 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 147} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v size_of_type_template_string_id\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:size_of_type_template_string_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr {\b size_t} {\b NumRepr::dig_t}< UINT_T, B >::size_of_type_template_string_id (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1177} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v ssi_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ssi_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::ssi_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 195} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a287219a289b34f6f682e318b3ca1f92c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ssi_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::ssi_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 198} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_af8eebfebac403516d028ecce97b98d63_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_B\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ssi_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_SINT_T} {\b NumRepr::dig_t}< UINT_T, B >::ssi_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 186} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_ae5704d076a53f9416a1b943df75b9179_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_max\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ssi_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_SINT_T} {\b NumRepr::dig_t}< UINT_T, B >::ssi_max (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 189} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v ssi_submax\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ssi_submax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::ssi_submax (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 192} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v sui_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:sui_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::sui_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 179} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_aeb3cb9d0b23b1c211dff853083a6fe83_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:sui_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::sui_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 182} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a43a4e505e240a8f1ad75f5ad5f8d1353_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_B\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:sui_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::sui_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 170} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a815d56d548d1572c87630f311d8b49e9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_max\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:sui_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::sui_max (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 173} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v sui_submax\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:sui_submax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval {\b SIG_UINT_T} {\b NumRepr::dig_t}< UINT_T, B >::sui_submax (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 176} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v sum_carry\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:sum_carry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr {\b dig_t} {\b NumRepr::dig_t}< UINT_T, B >::sum_carry ({\b dig_t}< UINT_T, B >  {\i arg_1}, {\b dig_t}< UINT_T, B >  {\i arg_2}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 413} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v to_string\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> constexpr std::string {\b NumRepr::dig_t}< UINT_T, B >::to_string () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1149} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v to_type_template_string_id\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:to_type_template_string_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static constexpr std::string {\b NumRepr::dig_t}< UINT_T, B >::to_type_template_string_id (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1173} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v ui_0\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ui_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T {\b NumRepr::dig_t}< UINT_T, B >::ui_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 167} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a76b5c675bb32de9c1803da4dd804d8e4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ui_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T {\b NumRepr::dig_t}< UINT_T, B >::ui_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 168} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a7abd8bcb3f0bd6b749488dfad8e56da5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_Bm1\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ui_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T {\b NumRepr::dig_t}< UINT_T, B >::ui_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 165} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a7cdf0d9df3dedb75f66d4d7eda2e2da5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_Bm2\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ui_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T {\b NumRepr::dig_t}< UINT_T, B >::ui_Bm2 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 166} del archivo {\b dig_t.hpp}.}\par
}
{\xe \v ui_max\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ui_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T {\b NumRepr::dig_t}< UINT_T, B >::ui_max (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 163} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a91e737faa7255b8706deb3220ceaa336_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_submax\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:ui_submax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> static consteval UINT_T {\b NumRepr::dig_t}< UINT_T, B >::ui_submax (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 164} del archivo {\b dig_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1dig__t_a73c90f6b9bab2442e884cc30b0af258f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v m_d\:NumRepr::dig_t< UINT_T, B >}
{\xe \v NumRepr::dig_t< UINT_T, B >\:m_d}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B> UINT_T {\b NumRepr::dig_t}< UINT_T, B >::m_d{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 21} del archivo {\b dig_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::for_each_same_type< Head_t, Tail_t >\par \pard\plain 
{\tc\tcl2 \v utilities::for_each_same_type< Head_t, Tail_t >}
{\xe \v utilities::for_each_same_type< Head_t, Tail_t >}
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b second_t} = std::tuple_element< 0, std::tuple< Tail_t... > >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b are_same_type_v}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Head_t, class... Tail_t>\par
struct utilities::for_each_same_type< Head_t, Tail_t >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 77} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v second_t\:utilities::for_each_same_type< Head_t, Tail_t >}
{\xe \v utilities::for_each_same_type< Head_t, Tail_t >\:second_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Head_t , class... Tail_t> using {\b utilities::for_each_same_type}< Head_t, Tail_t >::second_t =  std::tuple_element<0,std::tuple<Tail_t...> >::type}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v are_same_type_v\:utilities::for_each_same_type< Head_t, Tail_t >}
{\xe \v utilities::for_each_same_type< Head_t, Tail_t >\:are_same_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Head_t , class... Tail_t> constexpr bool {\b utilities::for_each_same_type}< Head_t, Tail_t >::are_same_type_v{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = (\par
        (std::is_same_v<Head_t,second_t>)\par
                &&      (for_each_same_type<Tail_t...>::are_same_type_v)\par
        )\par
}
{
Definici\'F3n en la l\'EDnea {\b 80} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::for_each_same_type< Head_t >\par \pard\plain 
{\tc\tcl2 \v utilities::for_each_same_type< Head_t >}
{\xe \v utilities::for_each_same_type< Head_t >}
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr bool {\b are_same_type_v} = true\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class Head_t>\par
struct utilities::for_each_same_type< Head_t >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 87} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v are_same_type_v\:utilities::for_each_same_type< Head_t >}
{\xe \v utilities::for_each_same_type< Head_t >\:are_same_type_v}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class Head_t > constexpr bool {\b utilities::for_each_same_type}< Head_t >::are_same_type_v = true{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 88} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Clase func_refvar_t< aT, T >\par \pard\plain 
{\tc\tcl2 \v func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b func_refvar_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~func_refvar_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b borra_var} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existe_lugar_de_base} (uchint Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b este_nombre_ya_ha_sido_declarado} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint B> T< B > {\b get} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint B> bool {\b operator()} (string nombre, string lhs)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insert} (string nombre, uchint base, uchint var_base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b func_refvar_t} (const {\b func_refvar_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b escribe_var} (string nombre, uchint base, uchint var_base)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< vector< bool > > {\b mapmem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b par_dir_t} > {\b mapvd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
aT ** {\b matd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< uint > {\b cuentavars}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename aT, template< uchint > class T>\par
class func_refvar_t< aT, T >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 182} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v func_refvar_t\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> {\b func_refvar_t}< aT, T >{\b ::func_refvar_t} (const {\b func_refvar_t}< aT, T > & ){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v func_refvar_t\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> {\b func_refvar_t}< aT, T >{\b ::func_refvar_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 218} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v ~func_refvar_t\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:~func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> {\b func_refvar_t}< aT, T >::~{\b func_refvar_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 233} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v borra_var\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:borra_var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> void {\b func_refvar_t}< aT, T >::borra_var (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 255} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v escribe_var\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:escribe_var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> bool {\b func_refvar_t}< aT, T >::escribe_var (string  {\i nombre}, uchint  {\i base}, uchint  {\i var_base}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 241} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_a08d5234094405d8ca9a77408516b59b7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v este_nombre_ya_ha_sido_declarado\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:este_nombre_ya_ha_sido_declarado}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> bool {\b func_refvar_t}< aT, T >::este_nombre_ya_ha_sido_declarado (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 278} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_aef030a35222c267cfa2f81ed9e5b12d7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v existe_lugar_de_base\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:existe_lugar_de_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> bool {\b func_refvar_t}< aT, T >::existe_lugar_de_base (uchint  {\i Base}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 269} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v get\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> template<const uchint B> T< B > {\b func_refvar_t}< aT, T >::get (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 290} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v insert\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> bool {\b func_refvar_t}< aT, T >::insert (string  {\i nombre}, uchint  {\i base}, uchint  {\i var_base}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 193} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_a8d13da8d11451ddb2c520124b5820ad5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator()\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> template<const uchint B> bool {\b func_refvar_t}< aT, T >::operator() (string  {\i nombre}, string  {\i lhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 296} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_a9127c1c5b54819300d13a4f46fbb3610_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v cuentavars\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:cuentavars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> vector<uint> {\b func_refvar_t}< aT, T >::cuentavars{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 188} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v mapmem\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:mapmem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> vector< vector<bool> > {\b func_refvar_t}< aT, T >::mapmem{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 185} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v mapvd\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:mapvd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> map< string , {\b par_dir_t} > {\b func_refvar_t}< aT, T >::mapvd{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 186} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v matd\:func_refvar_t< aT, T >}
{\xe \v func_refvar_t< aT, T >\:matd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> aT** {\b func_refvar_t}< aT, T >::matd{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 187} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta clase fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Clase func_refvar_t< INT **, INT *, INT >\par \pard\plain 
{\tc\tcl2 \v func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b func_refvar_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~func_refvar_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b borra_var} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existe_lugar_de_base} (uchint Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b este_nombre_ya_ha_sido_declarado} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INT} {\b get} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (string nombre, string lhs)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insert} (string nombre, uchint base, uchint var_base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b func_refvar_t} (const {\b func_refvar_t} &)=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b escribe_var} (string nombre, uchint base, uchint var_base)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< vector< bool > > {\b mapmem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b par_dir_t} > {\b mapvd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b INT} ** {\b matd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< uint > {\b cuentavars}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 305} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v func_refvar_t\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >{\b ::func_refvar_t} (const {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} > & ){\f2 [private]}, {\f2 [delete]}}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v func_refvar_t\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >{\b ::func_refvar_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 341} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v ~func_refvar_t\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:~func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::~{\b func_refvar_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 356} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v borra_var\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:borra_var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::borra_var (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 378} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v escribe_var\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:escribe_var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::escribe_var (string  {\i nombre}, uchint  {\i base}, uchint  {\i var_base}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 364} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_3_01_i_n_t_01_5_5_00_01_i_n_t_01_5_00_01_i_n_t_01_4_a26e278a1187a2bfff79fdb0d25458a0e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v este_nombre_ya_ha_sido_declarado\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:este_nombre_ya_ha_sido_declarado}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::este_nombre_ya_ha_sido_declarado (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 401} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v existe_lugar_de_base\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:existe_lugar_de_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::existe_lugar_de_base (uchint  {\i Base}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 392} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v get\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b INT} {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::get (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 412} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v insert\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::insert (string  {\i nombre}, uchint  {\i base}, uchint  {\i var_base}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 316} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v operator()\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::operator() (string  {\i nombre}, string  {\i lhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 417} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_3_01_i_n_t_01_5_5_00_01_i_n_t_01_5_00_01_i_n_t_01_4_ab63d213a5e7e754c772965fc5375c267_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v cuentavars\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:cuentavars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<uint> {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::cuentavars{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 311} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v mapmem\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:mapmem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< vector<bool> > {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::mapmem{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 308} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v mapvd\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:mapvd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map< string , {\b par_dir_t} > {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::mapvd{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 309} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v matd\:func_refvar_t< INT **, INT *, INT >}
{\xe \v func_refvar_t< INT **, INT *, INT >\:matd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b INT}** {\b func_refvar_t}< {\b INT} **, {\b INT} *, {\b INT} >::matd{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 310} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta clase fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Clase func_refvar_t< UINT **, UINT *, UINT >\par \pard\plain 
{\tc\tcl2 \v func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
\par
{
{\f2 #include <memory_handler.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b func_refvar_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~func_refvar_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b borra_var} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b existe_lugar_de_base} (uchint Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b este_nombre_ya_ha_sido_declarado} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint B> {\b UINT} {\b get} (string nombre)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (string nombre, string lhs)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insert} (string nombre, uchint base, uchint var_base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b func_refvar_t} (const {\b func_refvar_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b escribe_var} (string nombre, uchint base, uchint var_base)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< vector< bool > > {\b mapmem}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b par_dir_t} > {\b mapvd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UINT} ** {\b matd}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< uint > {\b cuentavars}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definici\'F3n en la l\'EDnea {\b 426} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v func_refvar_t\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >{\b ::func_refvar_t} (const {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} > & ){\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v func_refvar_t\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >{\b ::func_refvar_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 462} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v ~func_refvar_t\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:~func_refvar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::~{\b func_refvar_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 477} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v borra_var\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:borra_var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::borra_var (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 499} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v escribe_var\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:escribe_var}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::escribe_var (string  {\i nombre}, uchint  {\i base}, uchint  {\i var_base}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 485} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_3_01_u_i_n_t_01_5_5_00_01_u_i_n_t_01_5_00_01_u_i_n_t_01_4_ab30717bd4db90f33fb095fff35ccc851_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v este_nombre_ya_ha_sido_declarado\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:este_nombre_ya_ha_sido_declarado}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::este_nombre_ya_ha_sido_declarado (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 522} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v existe_lugar_de_base\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:existe_lugar_de_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::existe_lugar_de_base (uchint  {\i Base}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 513} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v get\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<const uchint B> {\b UINT} {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::get (string  {\i nombre}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 534} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v insert\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::insert (string  {\i nombre}, uchint  {\i base}, uchint  {\i var_base}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 437} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v operator()\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::operator() (string  {\i nombre}, string  {\i lhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 540} del archivo {\b memory_handler.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classfunc__refvar__t_3_01_u_i_n_t_01_5_5_00_01_u_i_n_t_01_5_00_01_u_i_n_t_01_4_ab11b5bb2dc5a6f6bc98d43c9bac6e7df_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v cuentavars\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:cuentavars}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<uint> {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::cuentavars{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 432} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v mapmem\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:mapmem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector< vector<bool> > {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::mapmem{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 429} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v mapvd\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:mapvd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map< string , {\b par_dir_t} > {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::mapvd{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 430} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v matd\:func_refvar_t< UINT **, UINT *, UINT >}
{\xe \v func_refvar_t< UINT **, UINT *, UINT >\:matd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UINT}** {\b func_refvar_t}< {\b UINT} **, {\b UINT} *, {\b UINT} >::matd{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 431} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta clase fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b memory_handler.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura int_num_t< UINT_T, B >\par \pard\plain 
{\tc\tcl2 \v int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
\par
{
{\f2 #include <int_num_t.hpp>}}\par
Diagrama de herencias de int_num_t< UINT_T, B >{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Diagrama de colaboraci\'F3n para int_num_t< UINT_T, B >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} (size_t arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_front} (dig_t< B > parg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (dig_t< B > arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator&=} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (const num_int &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (const string &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} ({\b dig} a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} ({\b dig} a1, {\b dig} a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} ({\b dig} a2, {\b dig} a1, {\b dig} a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (const std::vector< {\b dig} > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (const std::list< {\b dig} > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (sign_e s, {\b dig} a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (sign_e s, {\b dig} a1, {\b dig} a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (sign_e s, {\b dig} a2, {\b dig} a1, {\b dig} a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (sign_e s, const std::vector< {\b dig} > &arg, {\b forma_t} argforma={\b noraw})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (sign_e s, const std::list< {\b dig} > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} ({\b spardigs} a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} ({\b pardigs} a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (sign_e s, {\b pardigs} a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} (uchint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T > {\b num_int} (Int_T a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const {\b num_int} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const num_uint< B > &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const pardigs_t< B > &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const spardigs_t< B > &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const dig_t< B > &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T > const {\b num_int} & {\b operator=} (Int_T a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const std::vector< {\b dig} > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator=} (const std::list< {\b dig} > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b ceros_a_la_izqda} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b unos_a_la_izqda} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ceros_a_la_drcha} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b unos_a_la_drcha} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b filled_of_all_digits_are_Bm1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b filled_of_all_digits_are_0} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b digs_no_significativos} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b digs_fracc_no_significativos} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b Bm1_a_la_izqda} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b Bm1_a_la_drcha} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator+} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator-} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator*} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator/} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator%} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator*} ({\b pardigs} a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator+} ({\b dig} arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator-} ({\b dig} arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator*} ({\b dig} a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator+=} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator-=} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator*=} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator/=} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator%=} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator*=} ({\b pardigs} a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator+=} ({\b dig} arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator-=} ({\b dig} arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator*=} ({\b dig} arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator-} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b mC_B} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b mC_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b abs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b absp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b divB} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig} {\b remB} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b divBp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig} {\b remBp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b div2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig} {\b rem2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b div2p} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig} {\b rem2p} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig} {\b remBm1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pair< {\b num_int}, {\b num_int} > {\b EuclidDiv} (const {\b num_int} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pair< {\b num_int}, const {\b num_int} & > {\b EuclidDivP} (const {\b num_int} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator++} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} {\b operator++} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b operator--} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} {\b operator--} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b reduce} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b reduce} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b num_int} & {\b reduce_fracc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} {\b reduce_fracc} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef dig_t< B > {\b dig}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_basic_t< B > {\b num_basic}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef basic_string< dig_t< B > > {\b nbstr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef nbstr::iterator {\b striterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef nbstr::reverse_iterator {\b rstriterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef nbstr::const_iterator {\b cstriterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef nbstr::const_reverse_iterator {\b crstriterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_basic::iterator {\b b_iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_basic::reverse_iterator {\b b_riterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_basic::const_iterator {\b b_citerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_basic::const_reverse_iterator {\b b_criterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_int::iterator {\b iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_int::reverse_iterator {\b riterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_int::const_iterator {\b citerator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef num_int::const_reverse_iterator {\b criterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef n2digs_t< B > {\b n2digs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef pardigs_t< B > {\b pardigs}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef spardigs_t< B > {\b spardigs}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mC_B_incondicionado} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} & {\b insert} (size_t pos1, const dig_t< B > chardig)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} & {\b insert} (size_t pos1, size_t n, dig_t< B > c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b num_int} & {\b erase} (size_t pos, size_t npos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b erase} ({\b iterator} first, {\b iterator} last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b div_gen_step} (const {\b num_int} &dvsor, {\b num_int} &rem, {\b num_int} &coc, usint &ndig) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b divp_gen_step} (const {\b num_int} &dvsor, {\b num_int} &rem, {\b num_int} &coc, usint &ndig)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b div_uno} ({\b num_int} &rem, {\b num_int} &dvndo, {\b num_int} &dvsor, const usint long_dvndo, const usint long_dvsor) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sign_e {\b signo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b spardigs} {\b aux}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Amigas\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint Base> istream & {\b operator>>} (istream &is, {\b num_int}< Base > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint Base> ostream & {\b operator<<} (ostream &os, {\b num_int}< Base > arg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B>\par
struct int_num_t< UINT_T, B >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 13} del archivo {\b int_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v b_citerator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:b_citerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_basic::const_iterator {\b int_num_t}< UINT_T, B >::b_citerator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 24} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v b_criterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:b_criterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_basic::const_reverse_iterator {\b int_num_t}< UINT_T, B >::b_criterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 25} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v b_iterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:b_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_basic::iterator {\b int_num_t}< UINT_T, B >::b_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 22} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v b_riterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:b_riterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_basic::reverse_iterator {\b int_num_t}< UINT_T, B >::b_riterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 23} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v citerator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:citerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_int::const_iterator {\b int_num_t}< UINT_T, B >::citerator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 28} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v criterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:criterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_int::const_reverse_iterator {\b int_num_t}< UINT_T, B >::criterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 29} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v crstriterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:crstriterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef nbstr::const_reverse_iterator {\b int_num_t}< UINT_T, B >::crstriterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 21} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v cstriterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:cstriterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef nbstr::const_iterator {\b int_num_t}< UINT_T, B >::cstriterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 20} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v dig\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef dig_t<B> {\b int_num_t}< UINT_T, B >::dig{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 15} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v iterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_int::iterator {\b int_num_t}< UINT_T, B >::iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 26} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v n2digs\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:n2digs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef n2digs_t<B> {\b int_num_t}< UINT_T, B >::n2digs{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 30} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v nbstr\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:nbstr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef basic_string< dig_t<B> > {\b int_num_t}< UINT_T, B >::nbstr{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 17} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v num_basic\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_basic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_basic_t<B> {\b int_num_t}< UINT_T, B >::num_basic{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v pardigs\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:pardigs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef pardigs_t<B> {\b int_num_t}< UINT_T, B >::pardigs{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 31} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v riterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:riterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef num_int::reverse_iterator {\b int_num_t}< UINT_T, B >::riterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v rstriterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:rstriterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef nbstr::reverse_iterator {\b int_num_t}< UINT_T, B >::rstriterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v spardigs\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:spardigs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef spardigs_t<B> {\b int_num_t}< UINT_T, B >::spardigs{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 32} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v striterator\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:striterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> typedef nbstr::iterator {\b int_num_t}< UINT_T, B >::striterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 18} del archivo {\b int_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v abs\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:abs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::abs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1601} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a94f6a0a608614642522b2d8fff91aff0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a94f6a0a608614642522b2d8fff91aff0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v absp\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:absp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::absp (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1610} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acf8be3251610cf7365b5a7ae48dfa001_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acf8be3251610cf7365b5a7ae48dfa001_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Bm1_a_la_drcha\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:Bm1_a_la_drcha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b int_num_t}< UINT_T, B >::Bm1_a_la_drcha () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 627} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aec4ca498212a838867d18a5cd246aa6f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v Bm1_a_la_izqda\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:Bm1_a_la_izqda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b int_num_t}< UINT_T, B >::Bm1_a_la_izqda () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 613} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acbbb77c55849e7b5b26a162c90acf32d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ceros_a_la_drcha\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:ceros_a_la_drcha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> size_t {\b int_num_t}< UINT_T, B >::ceros_a_la_drcha () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 545} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ae09c19efabf27eb9caf36f33f0f380dd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ae09c19efabf27eb9caf36f33f0f380dd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ceros_a_la_izqda\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:ceros_a_la_izqda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b int_num_t}< UINT_T, B >::ceros_a_la_izqda () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 511} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aae2d5fd1815a61a2aadc21c151a34e6b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v digs_fracc_no_significativos\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:digs_fracc_no_significativos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b int_num_t}< UINT_T, B >::digs_fracc_no_significativos () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 607} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a4bf7f711400d921df1c0d05cbe3c9d3d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v digs_no_significativos\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:digs_no_significativos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b int_num_t}< UINT_T, B >::digs_no_significativos () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 592} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a55203f0d36573721c63de3837f8d416e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a55203f0d36573721c63de3837f8d416e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div2\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:div2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::div2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1660} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a066a49e72fc5bde03a85fdd2fa693973_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div2p\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:div2p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::div2p (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1725} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a11d24d94e5768ecceb341991ab7203a9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div_gen_step\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:div_gen_step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::div_gen_step (const {\b num_int} &  {\i dvsor}, {\b num_int} &  {\i rem}, {\b num_int} &  {\i coc}, usint &  {\i ndig}) const{\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1842} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a3619197b79f1e76bb5e8d68a3589ca18_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a3619197b79f1e76bb5e8d68a3589ca18_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div_uno\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:div_uno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::div_uno ({\b num_int} &  {\i rem}, {\b num_int} &  {\i dvndo}, {\b num_int} &  {\i dvsor}, const usint  {\i long_dvndo}, const usint  {\i long_dvsor}) const{\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1960} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a7624f41bff8f97efed07f84e8986318a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a7624f41bff8f97efed07f84e8986318a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v divB\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:divB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::divB () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1624} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aba3e9122269d8c60f598be8416397ba2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v divBp\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:divBp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::divBp (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1642} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ad1ba25e7c16f7c3bc032c36646f00f68_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v divp_gen_step\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:divp_gen_step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::divp_gen_step (const {\b num_int} &  {\i dvsor}, {\b num_int} &  {\i rem}, {\b num_int} &  {\i coc}, usint &  {\i ndig}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1898} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a7d73047f3c1ea68966184cd4c94ea923_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v erase\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b iterator} {\b int_num_t}< UINT_T, B >::erase ({\b iterator}  {\i first}, {\b iterator}  {\i last}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 121} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a5f18e6ddfb5af69f7a9ce7e1ad9dd3be_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v erase\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} & {\b int_num_t}< UINT_T, B >::erase (size_t  {\i pos}, size_t  {\i npos}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 106} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aecf8974d7f0c66b12d913b4861bcf810_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v EuclidDiv\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:EuclidDiv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> pair< {\b num_int}, {\b num_int} > {\b int_num_t}< UINT_T, B >::EuclidDiv (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2079} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a4b7bc7c10c03f0560b724614e4e4278f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v EuclidDivP\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:EuclidDivP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> pair< {\b num_int}, const {\b num_int} & > {\b int_num_t}< UINT_T, B >::EuclidDivP (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2126} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a4e1b2b56ffe5f4d8f0cf2b31fee922fc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v filled_of_all_digits_are_0\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:filled_of_all_digits_are_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::filled_of_all_digits_are_0 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 584} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ab074dd2e3e7b88588a25d371dc2c1636_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v filled_of_all_digits_are_Bm1\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:filled_of_all_digits_are_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::filled_of_all_digits_are_Bm1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 576} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ac789d6752f2a0d51e6e3304c66529716_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v insert\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} & {\b int_num_t}< UINT_T, B >::insert (size_t  {\i pos1}, const dig_t< B >  {\i chardig}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 87} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a11b6351c5930abb31689f4daf7792e17_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v insert\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} & {\b int_num_t}< UINT_T, B >::insert (size_t  {\i pos1}, size_t  {\i n}, dig_t< B >  {\i c}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 92} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v mC_B\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:mC_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::mC_B (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1555} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a3a812ddf5e23511d20f4b40f0a1d119e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a3a812ddf5e23511d20f4b40f0a1d119e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_B_incondicionado\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:mC_B_incondicionado}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::mC_B_incondicionado (){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 51} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ab9f2744f11a4b917487a0ab8793d93dc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_Bm1\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:mC_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::mC_Bm1 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1582} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ac325668599524297888380a9239225cb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ac325668599524297888380a9239225cb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 133} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ae209e7a115353db1633459a602d24e0b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 316} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a9f278fa0d5a6b8c1bcfdb8c6532715e9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (const num_int &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 141} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_afe238bb5556c227702fa86b5d0fc0085_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (const std::list< {\b dig} > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 217} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a7ce1c5264e0c3a3c44ab70b7c6150523_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (const std::vector< {\b dig} > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 207} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a486388fb8875a29054c71c3dd5f1ca06_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (const string &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 152} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_afab6608baa9f5d4cd58703aaf9a7ee32_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int ({\b dig}  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 178} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_adbe31357255b5c039d22ff0dbe48afc2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int ({\b dig}  {\i a1}, {\b dig}  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 186} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_afd31333558c0bb1fac3d7a3333dc5cff_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int ({\b dig}  {\i a2}, {\b dig}  {\i a1}, {\b dig}  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 196} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a8244d16e71dd32fc028ceae5bd163ec1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<typename Int_T > {\b int_num_t}< UINT_T, B >::num_int (Int_T  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 333} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aa828975d8442bd5ec18f43f4f42e2b83_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int ({\b pardigs}  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 296} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a5227f809c7e7b23f61318a82ece3ee94_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (sign_e  {\i s}, const std::list< {\b dig} > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 274} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a658b09d4b3089d07319e898c91139994_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (sign_e  {\i s}, const std::vector< {\b dig} > &  {\i arg}, {\b forma_t}  {\i argforma} = {\f2 {\b noraw}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 263} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ac181f6b5e9a48b847383bd068994760f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (sign_e  {\i s}, {\b dig}  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 228} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a670bc907a69ae9886a4a157616eb59ca_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (sign_e  {\i s}, {\b dig}  {\i a1}, {\b dig}  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 239} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aaf3ce8859b4934b0f2ff857045947aa5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (sign_e  {\i s}, {\b dig}  {\i a2}, {\b dig}  {\i a1}, {\b dig}  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 250} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a10e5e0316befc37645141fc22b769528_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (sign_e  {\i s}, {\b pardigs}  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 306} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a48068ebe04d7903949d4e0072ee498c5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int ({\b spardigs}  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 286} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ae067d8dffb3fb8963894dfca8173b4c4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v num_int\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:num_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b int_num_t}< UINT_T, B >::num_int (uchint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 324} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aa4b349b6871e2d8e2b3b4bd004bc31d7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1534} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a2f3c3db7d5472decaeb8ef735f01541e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >{\b ::operator!}= (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 663} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a0fa45dac193d9e3ccf9dcbd3a0f0a6bd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator%\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator% (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 978} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a958e81879bcf27742be664eaf019a125_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator%=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator%=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator%= (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1343} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aff9076398c6852dc5249e2ab6dfa5500_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator&=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator&= (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 98} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v operator*\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator* (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 912} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ae1144a6001a66b5fecad8debf5454bc2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator* ({\b dig}  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1161} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ac16f8bd1c9be289861368780674163d0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator* ({\b pardigs}  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1035} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a4041caab018eb58e56fb521bf68df70f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator*= (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1275} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ab4f61bc56098580779f5fb4f8d52cf44_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator*= ({\b dig}  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1475} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a15fd56ca4bfffa62e6896bb3e0c8720c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator*= ({\b pardigs}  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1394} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aaf1452877f71e57336b8faa91dd1e776_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator+ (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 799} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a1fa5a610a675322a17233b696994276a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator+ ({\b dig}  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1068} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a9d17a82f0441ed16b2c59ec506d66a04_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator++ (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2196} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_affa4d6ff03dfb310a7b6bda3ecc1eb7a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} {\b int_num_t}< UINT_T, B >::operator++ (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2235} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a1edf8c750b0cc6f7494ac5ce0a88f720_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator+= (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1189} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_adac8cb6ab4d43634b44059a0d7a21dc4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator+= ({\b dig}  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1427} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a82d829e8d83d2300d289a51744b256ca_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator- () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1505} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a8baef8b2dde5755813320416f58699df_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator- (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 855} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_abf1ec8aeeadefe6195d33e62435eca37_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator- ({\b dig}  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1125} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a8530f1cbf642af939f70b37e142e5f55_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator-- (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2274} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a0f0b3db6587b441868f2cccb2f4b014c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} {\b int_num_t}< UINT_T, B >::operator-- (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2330} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aaaae8b092ad0edcf7bb36b11c22f81f7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator-= (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1232} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_adcde21a88cbb4b810259e675944e1ec8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator-= ({\b dig}  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1450} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a7f13a2a6f67cf120d694d6c390d07572_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator/\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::operator/ (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 931} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acc818e68d0ebebc9ee1a14c0a9506328_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator/=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator/= (const {\b num_int} &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1295} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a6087d5c5da71405c13e8e818a8cac6b0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::operator< (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 765} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a6212907f79ef713205e6d09e5e340f2c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::operator<= (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 708} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a8a80c22f65c390355de7421e1ddd7d54_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const dig_t< B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 424} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a8cdc61cc457f067863755a8627f7b19b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const {\b num_int} &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 372} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aeeedd95e69e5f62662b060823b3bded7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const num_uint< B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 384} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a9acb58f0efc3566801617544f7cf0f34_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const pardigs_t< B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 396} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a88f785ba180ab05fc888f0e239edd220_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const spardigs_t< B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 410} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a27c84cf65ec38b837a61ba034fe4904e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const std::list< {\b dig} > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 490} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acbcdc8b8891a1038bd87be6cb7a4078e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (const std::vector< {\b dig} > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 478} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_adc2df3abaaff6ae0a4bc37ff90a0ad10_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<typename Int_T > const {\b num_int} & {\b int_num_t}< UINT_T, B >::operator= (Int_T  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 437} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a8d92e34d54ec97b31d037d46ee06a780_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator==\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::operator== (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 647} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a3f6da26847b75caa02c9969f51702de8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::operator> (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 736} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acb4f8554bc619a61d768b8b7467ddf46_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>=\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b int_num_t}< UINT_T, B >::operator>= (const {\b num_int} &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 680} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_acec6fb387e79e65f37e779ffb18d8730_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v push_back\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::push_back (dig_t< B >  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 83} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a6575701ad34d79f67738bdef51c92a2d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v push_front\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:push_front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::push_front (dig_t< B >  {\i parg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v reduce\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:reduce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::reduce (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2393} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a399984c0c867c6e3a5b15aaed4e1d465_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a399984c0c867c6e3a5b15aaed4e1d465_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:reduce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::reduce () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2402} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a6798bee749c9972bd4440497ff48d9d1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce_fracc\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:reduce_fracc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b num_int} & {\b int_num_t}< UINT_T, B >::reduce_fracc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2411} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a80b19146b3ea979dd1f6a431b7a061fe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce_fracc\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:reduce_fracc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b num_int} {\b int_num_t}< UINT_T, B >::reduce_fracc () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2419} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a77eb337c0667017330ac2c49c694fef8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rem2\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:rem2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig} {\b int_num_t}< UINT_T, B >::rem2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1703} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_aeb24d35b97a122413d6ae886f55d59e7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rem2p\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:rem2p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig} {\b int_num_t}< UINT_T, B >::rem2p (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1769} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ad5ba09cfe05ae18fbcb505b0e92b1745_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remB\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:remB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig} {\b int_num_t}< UINT_T, B >::remB () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1635} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a4d4b2c2c862d358a897074e2afe9c298_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remBm1\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:remBm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig} {\b int_num_t}< UINT_T, B >::remBm1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1805} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a7536efd30cc24248602b3083295a782c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remBp\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:remBp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig} {\b int_num_t}< UINT_T, B >::remBp (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1653} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_ae37121ea60fbd75600561e3bbef77194_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resize\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b int_num_t}< UINT_T, B >::resize (size_t  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 73} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v size\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> size_t {\b int_num_t}< UINT_T, B >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 46} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a489e24fd874f049d247539eb02416338_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v unos_a_la_drcha\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:unos_a_la_drcha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> size_t {\b int_num_t}< UINT_T, B >::unos_a_la_drcha () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 561} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a9ffbfe2524e6104557827b766b800890_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v unos_a_la_izqda\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:unos_a_la_izqda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b int_num_t}< UINT_T, B >::unos_a_la_izqda () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 528} del archivo {\b int_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structint__num__t_a0f7c7d803d12ead8126beb05485022c3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones relacionadas y clases amigas\par
\pard\plain 
{\xe \v operator<<\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<const uchint Base> ostream & operator<< (ostream &  {\i os}, {\b num_int}< Base >  {\i arg}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2544} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v operator>>\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<const uchint Base> istream & operator>> (istream &  {\i is}, {\b num_int}< Base > &  {\i arg}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2437} del archivo {\b int_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v aux\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:aux}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b spardigs} {\b int_num_t}< UINT_T, B >::aux{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 38} del archivo {\b int_num_t.hpp}.}\par
}
{\xe \v signo\:int_num_t< UINT_T, B >}
{\xe \v int_num_t< UINT_T, B >\:signo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> sign_e {\b int_num_t}< UINT_T, B >::signo{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 37} del archivo {\b int_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b int_num_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la Estructura utilities::local_void_t\par \pard\plain 
{\tc\tcl2 \v utilities::local_void_t}
{\xe \v utilities::local_void_t}
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
\par
{
{\f2 #include <utilities.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EXAMPLE pack2tuple<int,std::string,double>; // tipo {\b pack2tuple<int,std::string,double>::tuple_type} == std::tuple<int,std::string,double>; // tupla using mi_tupla = {\b pack2tuple<int,std::string,double>::tuple_type}; pack_size() devuelve 3 mi_tupla(2,"xyz",3.14159) devuelve la tupla \{2,"xyz",3.14159\} // por copia o por movimiento elem_type<0> es int elem_type<1> es std::string elem_type<2> es double get<0>(2,"xyz",3.14159) == 2; get<1>(2,"xyz",3.14159) == "xyz"; get<2>(2,"xyz",3.14159) == 3.14159; tuple_obj == mi_tupla(2,"xyz",3.14159) == \{2,"xyz",3.14159\} head of tuple_obj is \{2\} tail of tuple_obj is \{"xyz",3.14159\} BEGIN: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES \par
}{
Definici\'F3n en la l\'EDnea {\b 74} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Clase nat_num_t< UINT_T, B >\par \pard\plain 
{\tc\tcl2 \v nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
\par
{
{\f2 #include <nat_num_t.hpp>}}\par
Diagrama de herencias de nat_num_t< UINT_T, B >{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Diagrama de colaboraci\'F3n para nat_num_t< UINT_T, B >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_front} ({\b dig_t} parg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t} {\b operator[]} (uint arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t} & {\b operator[]} (uint arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} ({\b dig_t} arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b striterator} {\b begin} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b cstriterator} {\b end} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (const {\b nat_num_t} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} & {\b operator=} ({\b nat_num_t} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const {\b nat_num_t} &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const string &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (const string &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator string} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (dig a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (const dig &a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const dig &a1, const dig &a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const dig &a2, const dig &a1, const dig &a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const vector< dig > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (const vector< dig > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator vector< dig >} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const pardigs &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (const pardigs &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (const n2digs &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (const n2digs &a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (char ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (uchint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (uchint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (usint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (usint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (uint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (uint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (ulint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (ulint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} (ullint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator=} (ullint a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator uint} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator usint} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator uchint} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator ulint} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator ullint} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} & {\b operator=} (dig a0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b ceros_a_la_izqda} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b ceros_a_la_drcha} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b digs_no_significativos} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
usint {\b digs_fracc_no_significativos} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator+} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator-} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator*} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator/} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator%} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator*} (pardigs a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator+} (dig arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator-} (dig arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator*} (dig a) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator+=} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator-=} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator*=} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b substr} (size_t pos, size_t n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator/=} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator%=} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator*=} (pardigs a)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator+=} (dig arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator-=} (dig arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator*=} (dig arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator-} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b minus} (size_t sz) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator!} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b mC_B} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b mC_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b abs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b m_abs} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b divB} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dig {\b remB} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b m_divB} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dig {\b m_remB} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b div2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dig {\b rem2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b m_div2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dig {\b m_rem2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
dig {\b remBm1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pardigs {\b g_aux} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b p_aux} (pardigs arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b es_cero} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b no_es_cero} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pair< {\b nat_num_t}, {\b nat_num_t} > {\b EuclidDiv} (const {\b nat_num_t} &arg) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pair< {\b nat_num_t}, const {\b nat_num_t} & > {\b m_EuclidDiv} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator++} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator++} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator--} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b operator--} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b reduce} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b reduce} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b reduce_fracc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} {\b reduce_fracc} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b dig_t} = {\b dig_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_num_t} = {\b base_num_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b nbstr} = basic_string< dig >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b striterator} = typename nbstr::iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b rstriterator} = typename nbstr::reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b cstriterator} = typename nbstr::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b crstriterator} = typename nbstr::const_reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b b_iterator} = typename {\b base_num_t}< UINT_T, B >{\b ::iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b b_riterator} = typename {\b base_num_t}< UINT_T, B >::reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b b_citerator} = typename {\b base_num_t}< UINT_T, B >::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b b_criterator} = typename {\b base_num_t}< UINT_T, B >::const_reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator} = typename {\b nat_num_t}< UINT_T, B >::iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b riterator} = typename {\b nat_num_t}< UINT_T, B >::reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b citerator} = typename {\b nat_num_t}< UINT_T, B >::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b criterator} = typename {\b nat_num_t}< UINT_T, B >::const_reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B, size_t N> using {\b base_N_t} = std::array< {\b dig_t}< UINT_T, B >, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b base_t} = {\b nat_reg_N_digs_t}< UINT_T, B, 2 >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B, size_t N> using {\b nat_reg_N_digs_t} = {\b nat_reg_N_digs_t}< UINT_T, B, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_reg_digs_t} = {\b nat_reg_N_digs_t}< UINT_T, B, 2 >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B, size_t N> using {\b int_reg_N_digs_t} = {\b int_reg_N_digs_t}< UINT_T, B, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b int_reg_digs_t} = {\b int_reg_N_digs_t}< UINT_T, B, 2 >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} (size_t arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} & {\b insert} (size_t pos1, const {\b dig_t} chardig)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} & {\b insert} (size_t pos1, size_t n, {\b dig_t} c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b nat_num_t} & {\b operator&=} (const {\b nat_num_t} &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t} & {\b erase} (size_t pos, size_t npos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b erase} ({\b iterator} first, {\b iterator} last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b div_gen_step} (const {\b nat_num_t} &dvsor, {\b nat_num_t} &rem, {\b nat_num_t} &coc, usint &ndig) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b div_uno} ({\b nat_num_t} &rem, {\b nat_num_t} &dvndo, {\b nat_num_t} &dvsor, const usint szndo, const usint szsor) const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
pardigs {\b aux}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B>\par
class nat_num_t< UINT_T, B >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 9} del archivo {\b nat_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v b_citerator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:b_citerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::b_citerator =  typename {\b base_num_t}<UINT_T,B>::const_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 20} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v b_criterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:b_criterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::b_criterator =  typename {\b base_num_t}<UINT_T,B>::const_reverse_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 21} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v b_iterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:b_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::b_iterator =  typename {\b base_num_t}<UINT_T,B>{\b ::iterator}{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 18} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v b_riterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:b_riterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::b_riterator =  typename {\b base_num_t}<UINT_T,B>::reverse_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v base_N_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:base_N_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UINT_T, UINT_T B, size_t N> using {\b nat_num_t}< UINT_T, B >::base_N_t =  std::array<{\b dig_t}<UINT_T,B>,N>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v base_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:base_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::base_num_t =  {\b base_num_t}<UINT_T,B>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 12} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v base_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:base_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::base_t =  {\b nat_reg_N_digs_t}<UINT_T,B,2>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 29} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v citerator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:citerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::citerator =  typename {\b nat_num_t}<UINT_T,B>::const_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 24} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v criterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:criterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::criterator =  typename {\b nat_num_t}<UINT_T,B>::const_reverse_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 25} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v crstriterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:crstriterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::crstriterator =  typename nbstr::const_reverse_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 17} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v cstriterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:cstriterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::cstriterator =  typename nbstr::const_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v dig_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::dig_t =  {\b dig_t}<UINT_T,B>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 11} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v int_reg_digs_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:int_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::int_reg_digs_t =  {\b int_reg_N_digs_t}<UINT_T,B,2>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 37} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v int_reg_N_digs_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:int_reg_N_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UINT_T, UINT_T B, size_t N> using {\b nat_num_t}< UINT_T, B >::int_reg_N_digs_t =  {\b int_reg_N_digs_t}<UINT_T,B,N>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 35} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v iterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::iterator =  typename {\b nat_num_t}<UINT_T,B>::iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 22} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v nat_reg_digs_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::nat_reg_digs_t =  {\b nat_reg_N_digs_t}<UINT_T,B,2>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 33} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v nat_reg_N_digs_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_reg_N_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> template<type_traits::unsigned_integral_c UINT_T, UINT_T B, size_t N> using {\b nat_num_t}< UINT_T, B >::nat_reg_N_digs_t =  {\b nat_reg_N_digs_t}<UINT_T,B,N>{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 31} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v nbstr\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nbstr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::nbstr =  basic_string< dig >{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 13} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v riterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:riterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::riterator =  typename {\b nat_num_t}<UINT_T,B>::reverse_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 23} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v rstriterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:rstriterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::rstriterator =  typename nbstr::reverse_iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 15} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v striterator\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:striterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> using {\b nat_num_t}< UINT_T, B >::striterator =  typename nbstr::iterator{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 14} del archivo {\b nat_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 137} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a8f8bdd2355aab6b9b24f4c87cd68f5b7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a8f8bdd2355aab6b9b24f4c87cd68f5b7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const {\b nat_num_t}< UINT_T, B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 170} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a37024fe6aa82e7f7632fa2f119d91982_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const string &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 180} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a737bea5377c0328d03ed2f2c04846728_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (dig  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 210} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2792cc35c69126ae0115fe112182d762_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const dig &  {\i a1}, const dig &  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 227} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a20f6fcd2f30abb396511bb70ba9c35b3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const dig &  {\i a2}, const dig &  {\i a1}, const dig &  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 237} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2c25534d9a33ac153f49e32c0149966a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const vector< dig > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 248} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a573146d0cf8ab1ee7be2b8f89c809bc3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const pardigs &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 277} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a277242d2fb62602840bdbc6667ac4128_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (const n2digs &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 298} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_af381f51d860dcc728349d4d9f26156e7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 319} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ae368fad784e2833106b9aedc5d495f43_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (uchint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 336} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aaf28ada68877888aff9f4ba5d6ea8bb7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (usint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 353} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a61184e641a296ac9d663239efde22c51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (uint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 386} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_acf2fb4fd450dd14e499ae466251ee1c5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (ulint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 419} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a9c219e22a3aac137e12fe5a164163d8a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_num_t\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:nat_num_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >{\b ::nat_num_t} (ullint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 450} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_af6687d67225efbc841f16e8a2255028a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v abs\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:abs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::abs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1393} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a5884ef039a920a6cd34409885551d33a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v begin\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b striterator} {\b nat_num_t}< UINT_T, B >::begin (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 126} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ad6d4ad46b1d326930b2e635c8c0df004_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ceros_a_la_drcha\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:ceros_a_la_drcha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> size_t {\b nat_num_t}< UINT_T, B >::ceros_a_la_drcha () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 579} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a386e6f8d5f8b23ea4ac327c3f3a33d61_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a386e6f8d5f8b23ea4ac327c3f3a33d61_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ceros_a_la_izqda\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:ceros_a_la_izqda}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b nat_num_t}< UINT_T, B >::ceros_a_la_izqda () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 566} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2a7eae79a48f9b29a40c9103cfac72d7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2a7eae79a48f9b29a40c9103cfac72d7_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v clear\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 116} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a296e66bafb159169f28cab2ef1357f14_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v digs_fracc_no_significativos\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:digs_fracc_no_significativos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b nat_num_t}< UINT_T, B >::digs_fracc_no_significativos () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 599} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a5a50025c599c9230b0ad18badc673e37_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a5a50025c599c9230b0ad18badc673e37_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v digs_no_significativos\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:digs_no_significativos}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> usint {\b nat_num_t}< UINT_T, B >::digs_no_significativos () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 594} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a14b63725918fba3ba1f731c3cda4b6ca_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a14b63725918fba3ba1f731c3cda4b6ca_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div2\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:div2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::div2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1437} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a3a404549ae4f05cafef5d6ceec3a6646_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div_gen_step\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:div_gen_step}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::div_gen_step (const {\b nat_num_t}< UINT_T, B > &  {\i dvsor}, {\b nat_num_t}< UINT_T, B > &  {\i rem}, {\b nat_num_t}< UINT_T, B > &  {\i coc}, usint &  {\i ndig}) const{\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1608} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_acc621fe7875d86c5f40aff5d56d832be_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_acc621fe7875d86c5f40aff5d56d832be_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v div_uno\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:div_uno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::div_uno ({\b nat_num_t}< UINT_T, B > &  {\i rem}, {\b nat_num_t}< UINT_T, B > &  {\i dvndo}, {\b nat_num_t}< UINT_T, B > &  {\i dvsor}, const usint  {\i szndo}, const usint  {\i szsor}) const{\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1682} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a04fa0b36ad6a16241746cb207c649b52_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a04fa0b36ad6a16241746cb207c649b52_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v divB\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:divB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::divB () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1408} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aad12fc5939f569965b9694292906194c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v end\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b cstriterator} {\b nat_num_t}< UINT_T, B >::end () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 131} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ac8a00bffa131db2a558d6131214bc481_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v erase\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b iterator} {\b nat_num_t}< UINT_T, B >::erase ({\b iterator}  {\i first}, {\b iterator}  {\i last}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 97} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_abc3e8d570ef7c084de22f1976d146b21_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v erase\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::erase (size_t  {\i pos}, size_t  {\i npos}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 85} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aee94eee48b8f2ca712b2f5b08d1b75ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aee94eee48b8f2ca712b2f5b08d1b75ad_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v es_cero\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:es_cero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::es_cero () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1666} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ab713b283652383fab4623d66b4fef0fa_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ab713b283652383fab4623d66b4fef0fa_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v EuclidDiv\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:EuclidDiv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> pair< {\b nat_num_t}, {\b nat_num_t} > {\b nat_num_t}< UINT_T, B >::EuclidDiv (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1745} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a86fb8e79d86da172cc7adff7632ac725_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v g_aux\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:g_aux}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> pardigs {\b nat_num_t}< UINT_T, B >::g_aux () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1590} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v insert\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::insert (size_t  {\i pos1}, const {\b dig_t}  {\i chardig}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 66} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a6eaaba593cfaccac8940e3dafada5dda_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v insert\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::insert (size_t  {\i pos1}, size_t  {\i n}, {\b dig_t}  {\i c}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 71} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v m_abs\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:m_abs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::m_abs (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1397} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ae76e097322e6374c6aa5cb54b3ce7d3b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_div2\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:m_div2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::m_div2 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1499} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_affad1b46b9de15da174a01644271785f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_divB\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:m_divB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::m_divB (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1423} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_af92fae6d437e61b258bb0fa3987b91b6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_EuclidDiv\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:m_EuclidDiv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> pair< {\b nat_num_t}, const {\b nat_num_t} & > {\b nat_num_t}< UINT_T, B >::m_EuclidDiv (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1789} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a33fdda0e7d67cc2f9a9c90ea001e8c2b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_rem2\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:m_rem2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> dig {\b nat_num_t}< UINT_T, B >::m_rem2 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1541} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_afef2a039b484e1a1147959e96e07be7a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_remB\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:m_remB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> dig {\b nat_num_t}< UINT_T, B >::m_remB (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1431} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a7f59276202f957a0027f1784f88bc617_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_B\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:mC_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::mC_B (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1343} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa042059e50f3008d12e430fdebcc323f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_Bm1\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:mC_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::mC_Bm1 (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1376} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ac276fad3a3947175a55b2b9e990ae231_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v minus\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:minus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::minus (size_t  {\i sz}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1273} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a07b25245f1119449ee9171ab2ea85de6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a07b25245f1119449ee9171ab2ea85de6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v no_es_cero\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:no_es_cero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::no_es_cero () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1674} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a455685c25d4a39e136784fddf68b9a51_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator string\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator string () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 200} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator uchint\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator uchint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator uchint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 509} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a344d5169b4e8601fd3b3c7b32ea7a2ef_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator uint\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator uint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator uint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 481} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a491e17555be2492eedcb5788b8a9a271_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator ulint\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator ulint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator ulint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 523} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_abe95f2899f69106cd62ca8d576d546e3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator ullint\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator ullint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator ullint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 537} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a541e1b883b4bdab9c1fceac15fa2ce4c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator usint\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator usint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator usint () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 495} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a9c55fd75b20e9196e5f798c6d311f745_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator vector< dig >\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator vector< dig >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t}< UINT_T, B >::operator vector< dig > () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 267} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a017ccdb8add749e869c3e35cd4d32f9d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator! () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1324} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2a5a33dec1079928b211d2dc47e6d85f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >{\b ::operator!}= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 626} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aae8bc6d1fe862b06f1c203822dc0000e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator%\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator% (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 849} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a9d9cdb7e6209d001ab8e4ffa3450cb33_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator%=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator%=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator%= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1134} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aebfeb312e837e0bc29834fe3d9b7343b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator&=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator&= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 77} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator*\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator* (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 768} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a0f5643bd0b8c549e71abd522d58c7e7e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator* (dig  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 957} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a76505954b863accc7f84837c3b8052e4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator* (pardigs  {\i a}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 863} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ac1c32096ec68d63711d60bcc4f519349_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator*= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1045} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ae0bbc32c65935b4cf54a154ec950fc18_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator*= (dig  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1214} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ab9a8ea8a497f47f6ac49ae79300e3f6d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator*= (pardigs  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1149} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a0a48a98ba700db925f3a1a8e98d81a65_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator+ (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 712} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ab1087d198842dd2e00e8f2961421fd50_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator+ (dig  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 897} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_af68e64787c0e62da723c30c83eb1c017_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator++ (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1844} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator++\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator++ (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1850} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator+=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator+= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 984} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a61807871c9e8e701d61e7573acd35055_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator+= (dig  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1159} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a13b9551af1acd91b6c98aa405ab9cb61_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator- () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1239} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_afc38a7f6ec3d2a9356054115973db46a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator- (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 754} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa7de2415a6824b4af279ec90aac74dd3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator- (dig  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 927} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a6c10bdb02ef2fdb24147eeaded22dac7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator-- (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1858} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator--\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator-- (int ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1864} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator-=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator-= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1031} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a0951fd96d0bf5389fd1a30aa2c19ef6a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator-= (dig  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1184} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ace3973d5269ca6fca23d993806084378_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator/\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::operator/ (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 791} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa1a1fa2bc567648fb5fd76d2a73e911e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator/=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator/=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator/= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1074} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aeecab0dc9b304ff23fb08008db79fcc1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::operator< (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 690} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a3547d805ee0109baf0d99a3b7fed8722_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::operator<= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 659} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a11c7b4b0882f65b160a8249711f51522_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (char  {\i ch}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 327} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ac6a83dbfc376fdc3e0b377493fdc03b9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (const dig &  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 218} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_affeba8ecf20f9c786e672429f62708dc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (const n2digs &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 308} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ac436862f45dd30ae542a6b05856b6aa0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (const {\b nat_num_t}< UINT_T, B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 144} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2f2bc5932044b67b90f5fba65c0fbb36_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (const pardigs &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 287} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a1a3617402f9efc65e7981876b1b31f4b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (const string &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 190} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a1764a3d69f693ffba541f6459b1fdc78_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (const vector< dig > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 257} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a60b040d5731e18546560a0f53f2de020_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (dig  {\i a0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 551} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa60ecbc15dbaba1995f1a2e29e320ce5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= ({\b nat_num_t}< UINT_T, B > &  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 157} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a1c39c1e59f7e530334e37c2945c3dfbb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (uchint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 344} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ae07d6b446d53565941f4c6b5a9bba621_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (uint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 403} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a0b245ebcaec71f2050ab8a455df0f3c0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (ulint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 434} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a7b7a8eab5e50d4c2760b116aa0f4557d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (ullint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 465} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a2e7593bf133b34db968484753889c36b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::operator= (usint  {\i a}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 369} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa68a5e36a62a4682136e992ebc6f7e83_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator==\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::operator== (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 611} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a614183168d86548bf2798bbf4b240186_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::operator> (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 674} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ad154f114e569b1143e6e35e6dbf18668_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>=\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b nat_num_t}< UINT_T, B >::operator>= (const {\b nat_num_t}< UINT_T, B > &  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 642} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa7250f4e5c2c12501bb86b2845ddf633_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig_t} & {\b nat_num_t}< UINT_T, B >::operator[] (uint  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 111} del archivo {\b nat_num_t.hpp}.}\par
}
{\xe \v operator[]\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b dig_t} {\b nat_num_t}< UINT_T, B >::operator[] (uint  {\i arg}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 107} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a7a67b73e05ec602a2fd57d34201ad36c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v p_aux\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:p_aux}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::p_aux (pardigs  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1594} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a05f88959b68523c08a10f864e73a6fc6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v push_back\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::push_back ({\b dig_t}  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 121} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aef1019272164e14682dc667e158afa53_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v push_front\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:push_front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::push_front ({\b dig_t}  {\i parg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 60} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aa0ced0babafe7e7e98b393c63d0c06d9_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:reduce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::reduce (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1877} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a5a1e29dfd320bf08016a2f0227621f0d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a5a1e29dfd320bf08016a2f0227621f0d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:reduce}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::reduce () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1895} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a41cdaedbdc7e91c90a7c1d7b2acc1d41_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce_fracc\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:reduce_fracc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> const {\b nat_num_t} & {\b nat_num_t}< UINT_T, B >::reduce_fracc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1914} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a52b809b6182fe1ae3ceb43114ce7a0dc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a52b809b6182fe1ae3ceb43114ce7a0dc_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v reduce_fracc\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:reduce_fracc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::reduce_fracc () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1932} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ac510280c74ecea2c6685cb083d559f97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rem2\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:rem2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> dig {\b nat_num_t}< UINT_T, B >::rem2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1479} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ae56a8fb7a652c7bb033757d7e5f1c8e9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remB\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:remB}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> dig {\b nat_num_t}< UINT_T, B >::remB () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1417} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_aed8fccba120976b462162f62991f68e4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v remBm1\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:remBm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> dig {\b nat_num_t}< UINT_T, B >::remBm1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1561} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ab352e91cb85a60cc2ec06082f59dca99_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v resize\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> void {\b nat_num_t}< UINT_T, B >::resize (size_t  {\i arg}){\f2 [inline]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 54} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_ae1fc4c5d1d054bd60ef55126814268cd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v size\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> size_t {\b nat_num_t}< UINT_T, B >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 49} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a3f420ff49cf6b55ef38936b2035a4071_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v substr\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:substr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> {\b nat_num_t} {\b nat_num_t}< UINT_T, B >::substr (size_t  {\i pos}, size_t  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1068} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classnat__num__t_a04b3864005da7d30b79ebdb0b4529bcc_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v aux\:nat_num_t< UINT_T, B >}
{\xe \v nat_num_t< UINT_T, B >\:aux}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> pardigs {\b nat_num_t}< UINT_T, B >::aux{\f2 [private]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b nat_num_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta clase fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_num_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\par \pard\plain 
{\tc\tcl2 \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
\par
{
{\f2 #include <nat_rat_fixed_reg_t.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b dig_t} = {\b dig_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> using {\b base_NEXNF_t} = std::array< {\b dig_t}< UINT_T, B >, NE+NF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_t} = {\b base_NEXNF_t}< LE, LF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> using {\b pfx_rat_reg_NExNF_digs_t} = {\b pfx_rat_reg_digs_t}< UINT_T, B, NE, NF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_UINT_T} = typename {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_SINT_T} = typename {\b type_traits::sig_SInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> using {\b nat_reg_NExNF_digs_t} = {\b nat_reg_digs_t}< UINT_T, B, NE+NF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b nat_reg_digs_t} = {\b nat_reg_digs_t}< UINT_T, B, LE+LF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> using {\b reg_ints_t} = typename std::array< UINT_T, NE+NF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> using {\b reg_suints_t} = typename std::array< {\b SIG_UINT_T}, NE+NF >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> using {\b reg_ssints_t} = typename std::array< {\b SIG_SINT_T}, NE+NF >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} (const std::initializer_list< {\b dig_t} > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b pfx_rat_reg_digs_t} (const Ts &... args) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)void {\b copy_arg_N} (const {\b base_NEXNF_t}< NE, NF > &arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N> \par
requires (N>0)void {\b move_arg_N} (base_N_t< NE, NF > &&arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N> \par
requires (N>0)constexpr {\b pfx_rat_reg_digs_t} (const base_NExNF_t< NE, NF > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N> \par
requires (N>0)constexpr {\b pfx_rat_reg_digs_t} (const base_NExNF_t< NE, NF > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c ... Ints_type> constexpr {\b pfx_rat_reg_digs_t} (Ints_type ... dig_pow_i) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} ({\b nat_reg_NExNF_digs_t}< NE, NF > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} & {\b operator=} ({\b nat_reg_NExNF_digs_t}< NE, NF > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} & {\b operator=} ({\b nat_reg_NExNF_digs_t}< NE, NF > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr const {\b pfx_rat_reg_digs_t} & {\b operator=} (const nat_reg_N_digs_t< NE, NF > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA EN LA QUE {\i NO}  SE PUEDE MODIFICAR EL ARGUMENTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} & {\b operator=} (const {\b base_NEXNF_t}< NE, NF > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA DESDE BASE_N_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} & {\b operator=} (const {\b dig_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr {\b pfx_rat_reg_digs_t} & {\b operator=} (Int_Type arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b concat} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr reg_N_digs_t< LE+LF+1 > {\b concat} (const {\b dig_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b concat_inv} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr reg_N_digs_t< LE+LF+1 > {\b concat_inv} (const {\b dig_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b concat} ({\b nat_reg_NExNF_digs_t}< NE, NF > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr reg_N_digs_t< LE+LF+1 > {\b concat} ({\b dig_t} &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b concat_inv} ({\b nat_reg_NExNF_digs_t}< NE, NF > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr reg_N_digs_t< LE+LF+1 > {\b concat_inv} ({\b dig_t} &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t ibegin, std::size_t iend> \par
requires ((iend-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b subreg_digs} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t ibegin, std::size_t iend> \par
requires ((iend-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b rev_subreg_digs} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t ibegin, std::size_t iend> \par
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend-ibegin > {\b subreg_digs_pe} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t ibegin, std::size_t iend> \par
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend-ibegin > {\b rev_subreg_digs_pe} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t ibegin, std::size_t iend> \par
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b subreg_digs_pf} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t ibegin, std::size_t iend> \par
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b rev_subreg_digs_pf} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr Int_Type {\b IntPart} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator==} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator==} (const {\b pfx_rat_reg_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator!=} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator!=} (const {\b pfx_rat_reg_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator<=} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator<=} (const {\b pfx_rat_reg_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator>=} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator>=} (const {\b pfx_rat_reg_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator<} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator<} (const {\b pfx_rat_reg_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b operator>} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr std::weak_ordering {\b operator<=>} (const {\b nat_reg_NExNF_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr std::strong_ordering {\b operator<=>} (const {\b pfx_rat_reg_digs_t}< NE, NF > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t I> \par
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr const {\b dig_t} & {\b get} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t I> \par
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void {\b put} (const {\b dig_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t I> \par
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void {\b put} ({\b dig_t} &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator[]} (std::int32_t idx) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator[]} (std::int32_t idx) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr UINT_T {\b operator()} (std::int32_t idx) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator++} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator++} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator--} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator--} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b mC_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b mC_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b C_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b C_B} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator!} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator-} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator+=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator-=} ({\b dig_t} arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b mult} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b add} ({\b dig_t} arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
'@' = '+' }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b subst} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator+} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator-} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator*} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator<<} (std::size_t n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator<<=} (std::size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator>>} (std::size_t n) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DIVIDE BY THE BASE B (/10_B) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator>>=} (std::size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b rem_B} (std::size_t n) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS >> >>= << <<=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b m_rem_B} (std::size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator|=} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : OPERATORS | & |= &=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator|} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator&=} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator&} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::pair< {\b dig_t}, {\b pfx_rat_reg_digs_t} > {\b operator+} (const {\b pfx_rat_reg_digs_t} &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS | & |= &=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::pair< {\b dig_t}, {\b pfx_rat_reg_digs_t} > {\b operator-} (const {\b pfx_rat_reg_digs_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b operator*} (const {\b pfx_rat_reg_digs_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator+} (const {\b base_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator-} (const {\b base_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b pfx_rat_reg_digs_t} {\b operator*} (const {\b base_t} &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator+=} (const {\b base_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator-=} (const {\b base_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator*=} (const {\b base_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator+=} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator-=} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b pfx_rat_reg_digs_t} & {\b operator*=} (const {\b pfx_rat_reg_digs_t} &arg) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b dig_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b dig_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b dig_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b dig_max} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b dig_Bm2} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b dig_t} {\b dig_submax} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr UINT_T {\b ui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr UINT_T {\b ui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr UINT_T {\b ui_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b SIG_UINT_T} {\b sui_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b SIG_UINT_T} {\b sui_Bp1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr UINT_T {\b ui_submax} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr UINT_T {\b ui_max} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b pfx_rat_reg_digs_t} {\b regd_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b pfx_rat_reg_digs_t} {\b regd_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b pfx_rat_reg_digs_t} {\b regd_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b pfx_rat_reg_digs_t} {\b regd_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b pfx_rat_reg_digs_t} {\b regd_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b pfx_rat_reg_digs_t} {\b regd_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_ints_t}< LE+LF > {\b regi_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ARRAYS DE ENTEROS QUE SON DE AYUDA. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_ints_t}< LE+LF > {\b regi_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_ints_t}< LE+LF > {\b regi_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_ints_t}< LE+LF > {\b regi_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b reg_ints_t}< LE+LF > {\b regi_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b reg_ints_t}< LE+LF > {\b regi_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c ... Ints_type> \par
requires ((sizeof...(Ints_type))<=L)static constexpr {\b base_t} {\b normalize} (Ints_type ... digits_pow_i) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::size_t {\b cuenta_0s_desde_IZDA} (const {\b reg_ints_t}< LE+LF > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::size_t {\b cuenta_0s_desde_DRCHA} (const {\b reg_ints_t}< LE+LF > &arg) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} {\b m_dc}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF>\par
requires ({\b type_traits::suitable_base}<UINT_T,B>() && (LE>0))\par
struct NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 12} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v base_NEXNF_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:base_NEXNF_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::base_NEXNF_t =  std::array<{\b dig_t}<UINT_T,B>,NE+NF>}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 15} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v base_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:base_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::base_t =  {\b base_NEXNF_t}<LE,LF>}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v dig_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_t =  {\b dig_t}<UINT_T,B>}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 13} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::nat_reg_digs_t =  {\b nat_reg_digs_t}<UINT_T,B,LE+LF>}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 24} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v nat_reg_NExNF_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:nat_reg_NExNF_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::nat_reg_NExNF_digs_t =  {\b nat_reg_digs_t}<UINT_T,B,NE+NF>}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 23} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_NExNF_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_NExNF_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_NExNF_digs_t =  {\b pfx_rat_reg_digs_t}<UINT_T,B,NE,NF>}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v reg_ints_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:reg_ints_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::reg_ints_t =  typename std::array<UINT_T,NE+NF>}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v reg_ssints_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:reg_ssints_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::reg_ssints_t =  typename std::array<{\b SIG_SINT_T},NE+NF>}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 33} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v reg_suints_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:reg_suints_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::reg_suints_t =  typename std::array<{\b SIG_UINT_T},NE+NF>}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 30} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v SIG_SINT_T\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:SIG_SINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::SIG_SINT_T =  typename {\b type_traits::sig_SInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 21} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v SIG_UINT_T\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:SIG_UINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> using {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::SIG_UINT_T =  typename {\b type_traits::sig_UInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 20} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v add\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::add ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
'@' = '+' }}\par
{
Definici\'F3n en la l\'EDnea {\b 1455} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a747abd2210ae2c492b36f277931a8cb6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v C_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:C_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::C_B () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1238} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_adf28ede7d87f952b85ee2e6f13bddd99_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v C_Bm1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:C_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::C_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1229} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a27966e1e6701d534293e7f258e53457b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat (const {\b dig_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCAT : CONCATENACION pfx_rat_reg_digs_t<23,7> var1\{ {\b dig_t(1)}, {\b dig_t(2)}, {\b dig_t(3)}, {\b dig_t(4)}, {\b dig_t(5)}, {\b dig_t(6)}, {\b dig_t(7)} \}; dig_t<23> var2\{22\}; var1.concat(var2) == nat#1:2:3:4:5:6:7:20#B23 \par
}{
Definici\'F3n en la l\'EDnea {\b 452} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a72cce26eea1af99400f760bb683df57f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMACION DE UN REG_M_DIGS_T<M> DESDE EL THIS REG_DIGS_T (L) Y REG_N_DIGS_T<N> EN SUS DOS FORMAS: (*THIS)SEGUIDO(ARG) Y (ARG)SEGUIDO(*THIS) : OPERACIONES DE CONCATENACION A SU VEZ PUEDEN SER POR COPIA Y POR MOVIMIENTO CONCAT : CONCATENACION pfx_rat_reg_digs_t<23,7> var1\{ {\b dig_t(1)}, {\b dig_t(2)}, {\b dig_t(3)}, {\b dig_t(4)}, {\b dig_t(5)}, {\b dig_t(6)}, {\b dig_t(7)} \} pfx_rat_reg_digs_t<23,3> var2\{ {\b dig_t(22)}, {\b dig_t(21)}, {\b dig_t(20)} \} var1.concat(var2) == nat#1:2:3:4:5:6:7:22:21:20#B23 \par
}{
Definici\'F3n en la l\'EDnea {\b 433} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a8c7d7fb0e6776dd78e993e5fc8fbf8e4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat ({\b dig_t} &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 508} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a4ea2b34d7a64b91d20a547769fe4c4d5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat ({\b nat_reg_NExNF_digs_t}< NE, NF > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 494} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a5b16b680b8c906452330a8201e3f9966_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat_inv\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat_inv (const {\b dig_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 480} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad13f4ece8bd16d01902c852ada645087_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat_inv\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat_inv (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 466} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a12229e5a534c8c6f2e4075031ae7ef6c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat_inv\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr reg_N_digs_t< LE+LF+1 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat_inv ({\b dig_t} &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 535} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a9350d24557721d0a2d25a87b3d993183_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v concat_inv\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:concat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b nat_reg_NExNF_digs_t}< LE+NE, LF+NF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::concat_inv ({\b nat_reg_NExNF_digs_t}< NE, NF > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 521} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a9f346d0bbdf300ba36b0b9622a0c2004_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v copy_arg_N\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:copy_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)void {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::copy_arg_N (const {\b base_NEXNF_t}< NE, NF > &  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DELEGADA PARA COPIA DE UN ARRAY DE DISTINTO TAMANO O TAMANO CUALQUIERA "N" INTERNO \par
}{
Definici\'F3n en la l\'EDnea {\b 175} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_acf99b1745ac9ee699102236d1a2a79dc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cuenta_0s_desde_DRCHA\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:cuenta_0s_desde_DRCHA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr std::size_t {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::cuenta_0s_desde_DRCHA (const {\b reg_ints_t}< LE+LF > &  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1911} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v cuenta_0s_desde_IZDA\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:cuenta_0s_desde_IZDA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr std::size_t {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::cuenta_0s_desde_IZDA (const {\b reg_ints_t}< LE+LF > &  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1896} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v dig_0\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b dig_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 37} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a235bc4a9ae726bbf7c7d5933d9a62b2e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a235bc4a9ae726bbf7c7d5933d9a62b2e_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b dig_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 38} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a960faa8c0828a9a6680526e7a9bfbc59_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a960faa8c0828a9a6680526e7a9bfbc59_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_Bm1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b dig_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 39} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a487d6b76d2e1cb0c18afaf54288e6029_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a487d6b76d2e1cb0c18afaf54288e6029_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_Bm2\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b dig_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_Bm2 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a18ae64dc889b84eea4ca989e9563651a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_max\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b dig_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_max (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 40} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_aee17574658ad0e66f3ee133d9f554833_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_submax\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:dig_submax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b dig_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::dig_submax (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 42} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a67e6e0e59887f528524c4b54e6ba5a2a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v get\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t I> \par
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr const {\b dig_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::get () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t A\{\}; I en [LE-1,-LF] A.get<LE-1>() [devuelve el digito de peso B^(LE-1)] .......... A.get<2>() [devuelve el digito de peso B^2] A.get<1>() [devuelve el digito de peso B^1] A.get<0>() [devuelve el digito de peso (B^0)==1] A.get<-1>() [devuelve el digito de peso B^-1] A.get<-2>() [devuelve el digito de peso B^-2] ........... A.get<-LF>() [devuelve el digito de peso B^-LF] MSB == MSB_E == LE-1 LSB_E == LF MSB_F == LF-1 LSB_F == 0 == LSB \par
}{
Definici\'F3n en la l\'EDnea {\b 1090} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v IntPart\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:IntPart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c Int_Type> constexpr Int_Type {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::IntPart () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 633} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v m_rem_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:m_rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::m_rem_B (std::size_t  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1710} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a073f393cf63e0e2ee6c651748c35aa05_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:mC_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::mC_B (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1209} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a43181180eabb8e8ea937db4ba2d7718d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_Bm1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:mC_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::mC_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1199} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a82fea75187699b7f253e7a0b76f84816_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v move_arg_N\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:move_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t N> \par
requires (N>0)void {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::move_arg_N (base_N_t< NE, NF > &&  {\i arg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DELEGADA PARA MOVER DE UN ARRAY DE DISTINTO TAMANO O TAMANO CUALQUIERA "N" INTERNO \par
}{
Definici\'F3n en la l\'EDnea {\b 210} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ace15a99d6b8f4b429bf385e32d9c58d8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mult\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:mult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::mult ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACIONES '@'(REG_DIGS_T,DIG_T)->STD::ARRAY<REG_DIGS_T,2> '@' = MULT \par
}{
Definici\'F3n en la l\'EDnea {\b 1373} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ae46f34abf55253a3dc0f6774678f57bc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v normalize\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:normalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c ... Ints_type> \par
requires ((sizeof...(Ints_type))<=L)static constexpr {\b base_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::normalize (Ints_type ...  {\i digits_pow_i}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DE NORMALIZACION A LA BASE B DE UN ARGUMENTOS EN UN PACK DE ENTEROS CUALQUIERA INTERNA \par
}{
Definici\'F3n en la l\'EDnea {\b 244} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a1d2effcd65514535a97572a28c992519_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a1d2effcd65514535a97572a28c992519_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator! () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1246} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a9f8d01bd90392598f683702bdff3ad45_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >{\b ::operator!}= (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t<23,12> A; A = ... pfx_rat_reg_digs_t<23,10> B; B = ... A != B => true or false \par
}{
Definici\'F3n en la l\'EDnea {\b 717} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator!=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >{\b ::operator!}= (const {\b pfx_rat_reg_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 769} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator&\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator& (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1755} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a44e11dd006b54a63e2fbf7242cf9f273_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator&=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator&= (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1746} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator()\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr UINT_T {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator() (std::int32_t  {\i idx}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1122} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator*\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator* (const {\b base_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2066} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a0240da6219232b6431dc4355cbbfe7ac_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator* (const {\b pfx_rat_reg_digs_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : DECLARACIONES E INICIALIZACIONES\par
END : DECLARACIONES E INICIALIZACIONES\par
BEGIN : OBTENEMOS TODOS LOS SUMANDOS MULTIPLICANDO POR UN DIGITO FIJO COLOCADOS CONVENIENTEMENTE\par
COLOCADOS CONVENIENTEMENTE END : OBTENEMOS TODOS LOS SUMANDOS MULTIPLICANDO POR UN DIGITO FIJO\par
BEGIN : SUMAMOS TODOS LOS SUMANDOS\par
END : SUMAMOS TODOS LOS SUMANDOS BEGIN : PREPARAMOS EL PAR DE RETORNO\par
END : PREPARAMOS EL PAR DE RETORNO\par
}{
Definici\'F3n en la l\'EDnea {\b 1835} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a589433f890f78faca137757fc3fb8459_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr auto {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator* ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1522} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_abbd54ac852f5cde9a0ec8ebe34f4ffc9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator*= (const {\b base_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2119} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a7921aacc123039a503c43bb0590a3816_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator*= (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2142} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator+\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator+ (const {\b base_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2048} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a00a90e2240080937a5bf0fbf6f6cfde1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::pair< {\b dig_t}, {\b pfx_rat_reg_digs_t} > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator+ (const {\b pfx_rat_reg_digs_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS | & |= &=. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CARRY INICIAL ES 0\par
INT_ARRAY TEMPORAL COPIA DE (*THIS) [SUMANDO 0]\par
INT_ARRAY TEMPORAL COPIA DE ARG [SUMANDO 1]\par
BUCLE FOR QUE SUMA RETINTS Y ARGINTS DESDE IDX=0 A IDX=L-1\par
GUARDAMOS EL CARRY FINAL Y RETORNAMOS LA SUMA\par
}{
Definici\'F3n en la l\'EDnea {\b 1772} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ab3cac3beb283fe928dbda805c62a0230_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr auto {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator+ ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1506} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad900c018f6bac8a884c30349154dea10_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator++ (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CARRY INICIAL ES 1\par
BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1137} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a1ad5dbda3b2a1663086f48ccddb0c07d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator++ (int ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1159} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_adacc48c5076affbe4719232ba16af6cd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator+= (const {\b base_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2101} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a268bcec2ba1b58bfca7f3c499bcb4bdd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator+= (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2128} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator+=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator+= ({\b dig_t}  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CARRY INICIAL ES 1\par
CASOS CARRY==0[ULTIMA], CARRY==1[VECES SIGUIENTES], CARRY=ARG [1A VEZ] SI ARG == 0 ENTONCES SE DEVUELVE SIN M\'C1S SI ARG == 1 ENTONCES ++CTHIS SI ARG > 1 ENTONCES 1a VEZ dig_BmArg 2a VEZ dig_Bm1 Y SIGUIENTES ULTIMA VEZ CARRY ==0\par
PRIMERA VEZ : ARG > 1 usamos dig_BmArg\par
SEGUNDA VEZ Y SIGUIENTES BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1277} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_af9fbb6e036ca9bd58675e476d43e05a9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator- () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1254} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a46c6455a1ef12adaad5d814985d9ee2c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator- (const {\b base_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2057} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_aff1f98a5fef7912f98b23032061c4d2a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::pair< {\b dig_t}, {\b pfx_rat_reg_digs_t} > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator- (const {\b pfx_rat_reg_digs_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
INICIALIZAMOS EL CARRY/BORROW A 0\par
GUARDAMOS EL COMPLEMENTO A LA BASE MENOS 1 DEL MINUENDO\par
COMPLETAMOS EL COMPLEMENTO A LA BASE SUMANDO 1 [carry_CB vale en el inicio 1]\par
SE HA COMPLETADO EL COMPLEMENTO A LA BASE\par
SUMAMOS SUMANDO_0 + C_B(SUMANDO_1)\par
}{
Definici\'F3n en la l\'EDnea {\b 1799} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a11dc06d186a7598661dcf1b8b98736a4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr auto {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator- ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1514} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a742df4d0f55dc71053ee0cd6722c227e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator-- (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CARRY INICIAL ES EL COMPLEMENTO A LA BASE DE 1\par
BUCLE FOR QUE SUMA CTHIS Y C_B(1) DESDE IDX=0 A IDX=LE+LF-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1167} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ae87bcfde3ae0324b373aef151db47020_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator-- (int ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1182} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ac59dbac090677509ad2290c8af28c5db_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator-= (const {\b base_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2110} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a2afb2e3153171736b62c2eb7a831f22c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator-= (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2135} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator-=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator-= ({\b dig_t}  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CARRY INICIAL ES 1\par
CASOS CARRY==0[ULTIMA], CARRY==1[VECES SIGUIENTES], CARRY=ARG [1A VEZ] SI ARG == 0 ENTONCES SE DEVUELVE SIN M\'C1S SI ARG == 1 ENTONCES \'96CTHIS SI ARG > 1 ENTONCES 1a VEZ dig_BmArg 2a VEZ dig_Bm1 Y SIGUIENTES ULTIMA VEZ CARRY ==0\par
PRIMERA VEZ : SUMAMOS EL COMPLEMENTO A LA BASE DE ARG\par
SEGUNDA VEZ Y SIGUIENTES BUCLE FOR QUE SUMA CTHIS Y 1 DESDE IDX=0 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1318} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a863b4585d8f4ae407912c98c9273b6d3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator< (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t<23,12> A; A = ... pfx_rat_reg_digs_t<23,10> B; B = ... A < B => true or false \par
}{
Definici\'F3n en la l\'EDnea {\b 919} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator<\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator< (const {\b pfx_rat_reg_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 973} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator<< (std::size_t  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : OPERATORS >> >>= << <<= MULTIPLY BY THE BASE B (10) \par
}{
Definici\'F3n en la l\'EDnea {\b 1632} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad44b35a08b59ad0418071711eeed448b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<<=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator<<= (std::size_t  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1647} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a197245d11816587e8bbcc82e53a94b45_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator<= (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t<23,12> A; A = ... pfx_rat_reg_digs_t<23,10> B; B = ... A <= B => true or false \par
}{
Definici\'F3n en la l\'EDnea {\b 783} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator<=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator<= (const {\b pfx_rat_reg_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 837} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator<=>\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr std::weak_ordering {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator<=> (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COMPARACION OPERADOR SPACESHIP C++20 Comparaciones con un array estandar de otra longitud La salida devuelta es greater,less,equivalent \par
}{
Definici\'F3n en la l\'EDnea {\b 1044} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a088384a64c5d34b0286cf4074929585f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=>\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr std::strong_ordering {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator<=> (const {\b pfx_rat_reg_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1058} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad4ec8b7755e10bf9fd0d152a6f73be39_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator= (const {\b base_NEXNF_t}< NE, NF > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA DESDE BASE_N_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 376} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator= (const {\b dig_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN DIGITO (CONVERSION) dig_t<13> a\{3\}; pfx_rat_reg_digs_t<13,16> A\{\}; A = a; A = nat#0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:3#B13 \par
}{
Definici\'F3n en la l\'EDnea {\b 387} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad4655dff96fd715063231961682140a8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator= (const nat_reg_N_digs_t< NE, NF > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA EN LA QUE {\i NO}  SE PUEDE MODIFICAR EL ARGUMENTO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 366} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c Int_Type> constexpr {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator= (Int_Type  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) pfx_rat_reg_digs_t<16,4> var\{\}; var = 1324; 1324/%16 = 82|12 82/%16 = 5|2 => var == nat#5:2:12#B16 \par
}{
Definici\'F3n en la l\'EDnea {\b 400} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a7a8a8164894278d64b0ec3c2534d2837_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator= ({\b nat_reg_NExNF_digs_t}< NE, NF > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR MOVIMIENTO reg_N_digs_t == std::array<dig_t,N>; pfx_rat_reg_digs_t<21,5> var\{\}; pfx_rat_reg_digs_t var2\{\}; var2 = std::move(var); var2 == antigua var; var actual no sabemos su valor; \par
}{
Definici\'F3n en la l\'EDnea {\b 356} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator= ({\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA EN LA QUE SE PUEDE COPIAR reg_N_digs_t == std::array<dig_t,N>; pfx_rat_reg_digs_t<21,5> var\{\}; pfx_rat_reg_digs_t var2\{\}; var2 = var; var2 == var \par
}{
Definici\'F3n en la l\'EDnea {\b 341} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator==\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator== (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t<23,12> A; A = ... pfx_rat_reg_digs_t<23,10> B; B = ... A == B => true or false \par
}{
Definici\'F3n en la l\'EDnea {\b 657} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator==\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator== (const {\b pfx_rat_reg_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 703} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator>\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator> (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t<23,12> A; A = ... pfx_rat_reg_digs_t<23,10> B; B = ... A > B => true or false \par
}{
Definici\'F3n en la l\'EDnea {\b 987} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator>=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator>= (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t<23,12> A; A = ... pfx_rat_reg_digs_t<23,10> B; B = ... A >= B => true or false \par
}{
Definici\'F3n en la l\'EDnea {\b 851} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator>=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr bool {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator>= (const {\b pfx_rat_reg_digs_t}< NE, NF > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 905} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v operator>>\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator>> (std::size_t  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DIVIDE BY THE BASE B (/10_B) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1664} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a2059c242611fae3bb6b65e7313bb7ff5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>>=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator>>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator>>= (std::size_t  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1679} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a04e688baa386601c21f3ad4348205ed8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b dig_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator[] (std::int32_t  {\i idx}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1108} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a02410bb4d27f15f78c3b3e6bed790547_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b dig_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator[] (std::int32_t  {\i idx}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1115} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a66bc74a435ff3ee2f48a779b285b4045_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator|\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator| (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1738} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a85a5e8fd4c769947c919010307e3aa93_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator|=\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr const {\b pfx_rat_reg_digs_t} & {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::operator|= (const {\b pfx_rat_reg_digs_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : OPERATORS | & |= &=. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REMAINDER BY THE BASE B (%10_B) END : "OPERATORS" REM_B^n AND M_REM_B^n \par
}{
Definici\'F3n en la l\'EDnea {\b 1729} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR DEFECTO pfx_rat_reg_digs_t<10,3,2> var(); var == nat#0:0:0:s:0:0#B10 \par
}{
Definici\'F3n en la l\'EDnea {\b 152} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a05f3a766ce29786655fc99812d550fa6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a05f3a766ce29786655fc99812d550fa6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t N> \par
requires (N>0)constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const base_NExNF_t< NE, NF > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS INTERNO \par
}{
Definici\'F3n en la l\'EDnea {\b 234} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t N> \par
requires (N>0)constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const base_NExNF_t< NE, NF > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA REFERENCIA DESDE UN ARRAY DE DIGITOS INTERNO \par
}{
Definici\'F3n en la l\'EDnea {\b 227} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const {\b nat_reg_NExNF_digs_t}< NE, NF > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA pfx_rat_reg_digs_t<10,3,2> var\{1,3,2,5,6\}; pfx_rat_reg_digs_t<10,3,2> var2(var); \par
}{
Definici\'F3n en la l\'EDnea {\b 322} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const std::initializer_list< {\b dig_t} > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR LISTA DE DIGITOS pfx_rat_reg_digs_t<10,3,2> var\{{\b dig_t(1)},{\b dig_t(3)},{\b dig_t(2)},{\b dig_t(5)},{\b dig_t(6)}\}; var == nat#1:3:2:s:5:6#B10 \par
}{
Definici\'F3n en la l\'EDnea {\b 158} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (const Ts &...  {\i args}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO pfx_rat_reg_digs_t<10,3,2> var({\b dig_t(1)},{\b dig_t(3)},{\b dig_t(2)},{\b dig_t(5)},{\b dig_t(6)}); var == nat#1:3:2:5:6#B10 \par
}{
Definici\'F3n en la l\'EDnea {\b 166} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<type_traits::integral_c ... Ints_type> constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t (Ints_type ...  {\i dig_pow_i}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO pfx_rat_reg_digs_t<10,3,2> var\{1,3,2,5,6\}; var == nat#1:3:2:s:5:6#B10 \par
}{
Definici\'F3n en la l\'EDnea {\b 315} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_af205ef58ee00a8d89a5504f3638d2f06_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v pfx_rat_reg_digs_t\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:pfx_rat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t NE, std::size_t NF> \par
requires (NE>0)constexpr {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::pfx_rat_reg_digs_t ({\b nat_reg_NExNF_digs_t}< NE, NF > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO pfx_rat_reg_digs_t<10,3,2> var\{1,3,2,5,6\}; pfx_rat_reg_digs_t<10,3,2> var2(std::move(var)); var queda no sabemos su valor \par
}{
Definici\'F3n en la l\'EDnea {\b 330} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v put\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t I> \par
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::put (const {\b dig_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
pfx_rat_reg_digs_t A\{\}; A.put<2>(B-1-A.get<2>()) [pone un valor en un digito por su indice] \par
}{
Definici\'F3n en la l\'EDnea {\b 1098} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v put\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:put}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t I> \par
requires ((I < LE)&&(std::abs(I) < LF+1))constexpr void {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::put ({\b dig_t} &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1104} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v regd_0\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regd_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regd_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 51} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a300ccd4144f9f2cdb9979897e14ded03_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a300ccd4144f9f2cdb9979897e14ded03_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regd_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regd_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 58} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a4d1b2577021f8594d6efa471234869e0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regd_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regd_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 68} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_afc75739252c5a40b233bd12eace8dd16_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_Bm1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regd_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regd_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 63} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad70d405111f74e96957daf7e860f0abd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_pow_n_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regd_pow_n_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regd_pow_n_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 76} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a0fd73bc1e0e7ef8d7e5cfeb2830da7a5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_pow_n_B_m1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regd_pow_n_B_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regd_pow_n_B_m1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 83} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a010c5902fd8210da63a98c1179be37a7_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regi_0\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regi_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b reg_ints_t}< LE+LF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regi_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ARRAYS DE ENTEROS QUE SON DE AYUDA. }}\par
{
Definici\'F3n en la l\'EDnea {\b 94} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a2b72b79cdc0bf99d420fa9ffc812b274_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a2b72b79cdc0bf99d420fa9ffc812b274_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regi_1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regi_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b reg_ints_t}< LE+LF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regi_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 102} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a9a2b45b2f3d26220d33285794c8128a6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regi_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regi_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b reg_ints_t}< LE+LF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regi_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 114} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a6d97e8aa88ec3d0b9f81c66de861b915_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regi_Bm1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regi_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b reg_ints_t}< LE+LF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regi_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 108} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a9c1583db7aec52231103595dc69a2a32_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regi_pow_n_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regi_pow_n_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b reg_ints_t}< LE+LF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regi_pow_n_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 122} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a993ab098e0e7070f2514b0ebd9b9162e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regi_pow_n_B_m1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:regi_pow_n_B_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::int32_t n> \par
requires ((n < LE) && (n > -(LF+1)))static constexpr {\b reg_ints_t}< LE+LF > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::regi_pow_n_B_m1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 130} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\xe \v rem_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr {\b pfx_rat_reg_digs_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::rem_B (std::size_t  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS >> >>= << <<=. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : "OPERATORS" REM_B^n AND M_REM_B^n REMAINDER BY THE BASE B (%10_B) \par
}{
Definici\'F3n en la l\'EDnea {\b 1698} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a5beb2c8c44ad830017acdac79a4e84ad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rev_subreg_digs\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:rev_subreg_digs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> \par
requires ((iend-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::rev_subreg_digs () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 562} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a206489e66bc07dd845d00c4a6ccb0bdc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rev_subreg_digs_pe\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:rev_subreg_digs_pe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> \par
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend-ibegin > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::rev_subreg_digs_pe () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 588} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a3a821c17ddc821a00db5e00b02ea7f77_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rev_subreg_digs_pf\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:rev_subreg_digs_pf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> \par
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::rev_subreg_digs_pf () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 614} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ad5adcbe25e088551ac817004a9320300_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subreg_digs\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:subreg_digs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> \par
requires ((iend-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::subreg_digs () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 549} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_aa93bfacedfc35b410d1eb6f1e74ffe55_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subreg_digs_pe\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:subreg_digs_pe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> \par
requires ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))constexpr reg_N_digs_t< iend-ibegin > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::subreg_digs_pe () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 575} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a6fa675710cb0e3a25d2b46b601516149_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subreg_digs_pf\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:subreg_digs_pf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> template<std::size_t ibegin, std::size_t iend> \par
requires ((iend < LF)&&(ibegin < iend))constexpr reg_N_digs_t< iend-ibegin > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::subreg_digs_pf () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 601} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a826d5ada30ddfb3bd85e38a3b9231ed9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subst\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:subst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> constexpr std::array< {\b pfx_rat_reg_digs_t}, 2 > {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::subst ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TO DO REPASAR '@' = '-' \par
}{
Definici\'F3n en la l\'EDnea {\b 1476} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a6551f10097dd07df063b87fc1a007fd8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_B\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:sui_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b SIG_UINT_T} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::sui_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 46} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a94e5d24230e61c14c2590893f435ef06_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_Bp1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:sui_Bp1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr {\b SIG_UINT_T} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::sui_Bp1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 47} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ab5167455e73179baf8deaccf40901063_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_0\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:ui_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::ui_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 43} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_ab9e34bb3a8d955badd3498d51d5e62f4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:ui_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::ui_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 44} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_adbeecd9a334cb9c990bca8c7878e19ea_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_Bm1\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:ui_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::ui_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 45} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_abf72096e6dd350d74f05124d4bf07e3a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_max\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:ui_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::ui_max (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 49} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a470670e3e267bb42318f77ed70a7f42d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_submax\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:ui_submax}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> static constexpr UINT_T {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::ui_submax (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 48} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__rat__fixed__reg__t_a4ca499b70aaa1d53917b468c09ad6968_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v m_dc\:NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}
{\xe \v NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >\:m_dc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B, std::size_t LE, std::size_t LF> {\b base_t} {\b NumRepr::nat_rat_fixed_reg_t}< UINT_T, B, LE, LF >::m_dc{\f2 [private]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 35} del archivo {\b nat_rat_fixed_reg_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_rat_fixed_reg_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::nat_reg_digs_t< UINT_T, B, L >\par \pard\plain 
{\tc\tcl2 \v NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
\par
{
{\f2 #include <nat_reg_digs_t.hpp>}}\par
Diagrama de herencias de NumRepr::nat_reg_digs_t< UINT_T, B, L >{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Diagrama de colaboraci\'F3n para NumRepr::nat_reg_digs_t< UINT_T, B, L >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_UINT_T} = typename {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_SINT_T} = typename {\b type_traits::sig_SInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b dig_t} = {\b dig_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> using {\b base_N_t} = {\b reg_digs_t}< UINT_T, B, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_t} = {\b base_N_t}< L >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op, {\b size_t} N> using {\b res_base_N_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b base_N_t}< N >, op, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op> using {\b res_base_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b base_t}, op, L >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> using {\b nat_reg_N_digs_t} = {\b nat_reg_digs_t}< UINT_T, B, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op, {\b size_t} N> using {\b res_N_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b nat_reg_N_digs_t}< N >, op, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op> using {\b res_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b nat_reg_digs_t}, op, L >\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Tipos p\'FAblicos heredados desde {\b NumRepr::reg_digs_t< UINT_T, B, L >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b dig_t} = {\b dig_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> using {\b base_N_t} = std::array< {\b dig_t}, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_t} = {\b base_N_t}< L >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> using {\b reg_N_digs_t} = {\b reg_digs_t}< UINT_T, B, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_UINT_T} = typename {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_SINT_T} = typename {\b type_traits::sig_SInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op, {\b size_t} N> using {\b res_base_N_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b base_N_t}< N >, op, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op> using {\b res_base_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b base_t}, op, L >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
consteval {\b nat_reg_digs_t} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR DEFECTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} (const std::initializer_list< {\b dig_t} > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR LISTA DE DIGITOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b nat_reg_digs_t} (const Ts &... args) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b base_t} *const {\b const_base_this} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b base_t} {\b base_cpy_cthis} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b base_t} & {\b base_const_ref_cthis} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b const_by_index} ({\b size_t} ix) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b cpy_by_index} ({\b size_t} ix) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr void {\b copy_arg_N} (const {\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr void {\b move_arg_N} ({\b base_N_t}< N > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr void {\b copy_arg_N} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr void {\b move_arg_N} ({\b nat_reg_N_digs_t}< N > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} (const {\b base_N_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} (const {\b base_N_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c ... Ints_type> constexpr {\b nat_reg_digs_t} (Ints_type ... dig_pow_i) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} ({\b nat_reg_N_digs_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR MOVIMIENTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator=} (const {\b base_N_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA CONST {\i NO}  COPIABLE DESDE BASE_N_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} & {\b operator=} ({\b base_N_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator=} ({\b base_N_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} & {\b operator=} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} & {\b operator=} ({\b nat_reg_N_digs_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR MOVIMIENTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator=} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA EN LA QUE {\i NO}  SE PUEDE COPIAR. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_Bm1} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_dig} ({\b dig_t} arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_Bm1} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_dig} ({\b dig_t} dig) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} & {\b operator=} (const {\b dig_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN DIGITO (CONVERSION) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr {\b nat_reg_digs_t} & {\b operator=} (Int_Type arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_N_digs_t}< N+L > {\b cat} (const {\b nat_reg_N_digs_t}< N > &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SUBREPR => SUB REPRESENTACION. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_N_digs_t}< L+1 > {\b cat} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_N_digs_t}< N+L > {\b cat_inv} (const {\b nat_reg_N_digs_t}< N > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_N_digs_t}< L+1 > {\b cat_inv} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} ibegin, {\b size_t} iend> \par
requires ((iend <= L)&&(ibegin < iend))constexpr {\b nat_reg_N_digs_t}< iend-ibegin > {\b subrepr} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr {\b operator Int_Type} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr std::strong_ordering {\b operator<=>} (const {\b nat_reg_N_digs_t}< N > &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr std::weak_ordering {\b operator<=>} (const {\b base_N_t}< N > &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::weak_ordering {\b operator<=>} (const {\b dig_t} &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b operator[]} ({\b size_t} idx) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator[]} ({\b size_t} idx) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type {\b operator()} ({\b size_t} idx) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator++} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator++} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator--} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator--} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator<<} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator<<=} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator>>} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator>>=} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b rem_B} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b m_rem_B} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b mer_B} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b m_mer_B} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator|=} (const {\b nat_reg_digs_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator|} (const {\b nat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator&=} (const {\b nat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator&} (const {\b nat_reg_digs_t} &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator+=} (const {\b dig_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b nat_reg_digs_t} & {\b operator-=} (const {\b dig_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator+} (const {\b dig_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator-} (const {\b dig_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator+} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator-} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr auto {\b operator*} ({\b dig_t} arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator/} ({\b dig_t} arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DIVISION BY A DIGIT. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator%} ({\b dig_t} arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REMAINDER BY A DIGIT. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator+=} (const {\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator+=} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator-=} (const {\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator-=} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator*=} (const {\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b operator*=} (const {\b nat_reg_N_digs_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b operator+} (const {\b base_N_t}< N > &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TO DO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b operator-} (const {\b base_N_t}< N > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b operator*} (const {\b base_N_t}< N > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b operator+} (const {\b nat_reg_N_digs_t}< N > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b operator-} (const {\b nat_reg_N_digs_t}< N > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b operator*} (const {\b nat_reg_N_digs_t}< N > &arg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b nat_reg_digs_t} {\b operator%} (const {\b nat_reg_digs_t} &arg) const noexcept\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
M\'E9todos p\'FAblicos heredados desde {\b NumRepr::reg_digs_t< UINT_T, B, L >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b base_t} *const {\b const_base_this} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de punteros a la clase base }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} * {\b base_this} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} & {\b r_base_cthis} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de referencias a la clase base }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b base_t} & {\b cr_base_cthis} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de copia de la clase base }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} {\b cp_base_cthis} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reg_digs_t} & {\b r_cthis} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de referencias de la clase actual }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b reg_digs_t} & {\b cr_cthis} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reg_digs_t} {\b cp_cthis} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de copia de la clase actual }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t} {\b cp_cthis_at} ({\b size_t} k) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devoluciones por referencias y por copia de los elementos }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t} & {\b r_cthis_at} ({\b size_t} k) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b dig_t} & {\b cr_cthis_at} ({\b size_t} k) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b begin} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
En este bloque hacemos esta clase wrapper como si fuese una clase derivada de base_t Para esto replicamos y sobrecargamos cada una de las funciones por defecto de std::array Nota: lo anterior se escribio cuando no era clase derivada sino un wrapper. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b cbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b end} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b cend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b rbegin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b crbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b rend} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b crend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b max_size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b empty} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b front} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} const & {\b front} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b back} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} const & {\b back} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b fill} (const {\b dig_t} &value) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b swap} ({\b base_t} &{\b other}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b reverse} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
consteval {\b reg_digs_t} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructores de {\b reg_digs_t}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} (const std::initializer_list< {\b dig_t} > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por lista de digitos utilizando la funci\'F3n make_base_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b reg_digs_t} (const Ts &... args) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por argumentos tipo {\b dig_t}: deduce el tipo. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} (const {\b base_t} &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE EL TIPO BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} ({\b base_t} &&rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO DESDE EL TIPO BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b reg_digs_t} (const {\b base_N_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor copia desde un array cualquiera de d\'EDgitos {\b dig_t} (usando copy_arg_N<N>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b reg_digs_t} (const {\b base_N_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por movimiento desde un array cualquiera de d\'EDgitos {\b dig_t} (usando move_arg_N<N>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c ... Ints_type> \par
requires ((sizeof...(Ints_type))==L)constexpr {\b reg_digs_t} (Ints_type ... dig_pow_i) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr const {\b reg_digs_t} & {\b operator=} (const {\b reg_N_digs_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sobrecarga del operador copia. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b reg_digs_t} & {\b operator=} ({\b reg_N_digs_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr const {\b base_t} & {\b operator=} ({\b reg_N_digs_t}< N > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} & {\b operator=} (const {\b dig_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN DIGITO (CONVERSION) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr const {\b reg_digs_t} & {\b operator=} (Int_Type arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr {\b operator Int_Type} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SE PODR\'CDA HACER PARA UINT128_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} *const {\b data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b cpy_data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator[]} ({\b size_t} ix) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Sobrecarga del const dig_t & operator[](size_t) const"> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator[]} ({\b size_t} ix) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Sobrecarga del dig_t & operator[](size_t)"> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funciones que ponen a constantes (constexpr) los objetos base_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_dig} ({\b dig_t} d) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_fill_dig} ({\b dig_t} d) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_fill_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_fill_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"Funciones que ponen a constantes(constexpr) los objetos un subintervalo
o subrango de base_t cualquiera" }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_dig} ({\b dig_t} dig) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_0} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_B} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bp1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} n> \par
requires (n<L)constexpr bool {\b is_B_pow_m1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} n> \par
requires (n<L-1)constexpr bool {\b is_B_pow} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_any_B_pow} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_filled_of_1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_filled_of_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_filled_of} ({\b dig_t} d) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} ibegin, {\b size_t} iend> \par
requires ((iend <= L)&&(ibegin < L)&&(ibegin != iend))constexpr {\b reg_N_digs_t}<(ibegin< iend)?(iend-ibegin):(ibegin-iend)> {\b subregister} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TAKE A SUBREGISTER OF A REGISTER OF DIGITS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b mC_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b mC_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b C_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b C_B} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator!} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator-} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator<<} ({\b size_t} n) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator<<=} ({\b size_t} n) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO TO DO VOY POR AQUI CON EL TEMA DE LOS CTHIS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator>>=} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator>>} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b rem_B} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b m_rem_B} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b mer_B} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b m_mer_B} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator|=} (const {\b base_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator|} (const {\b reg_digs_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator&=} (const {\b reg_digs_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator&} (const {\b reg_digs_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b int64_t} {\b index_of_MSDig} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator==} (const {\b dig_t} &rarg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COMPARACIONES ENTRE BASE_T Y DIG_T EN FORMA BASE_T @ DIG_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator!=} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator>} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator<} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator>=} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator<=} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator==} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator!=} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator>} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator<} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator>=} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator<=} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr std::strong_ordering {\b operator<=>} (const {\b reg_N_digs_t}< M > &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::weak_ordering {\b operator<=>} (const {\b dig_t} &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b nat_reg_digs_t} {\b regd_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b nat_reg_digs_t} {\b regd_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b nat_reg_digs_t} {\b regd_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b nat_reg_digs_t} {\b regd_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} n> \par
requires ((n>=0)&&(n < L))static consteval {\b nat_reg_digs_t} {\b regd_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} n> \par
requires ((n>=0)&&(n < L))static consteval {\b nat_reg_digs_t} {\b regd_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> static constexpr const {\b base_t} & {\b assign} ({\b base_t} &larg, Int_Type arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool with_result_type> static constexpr auto {\b m_add} ({\b base_t} &larg, const {\b dig_t} &rarg) noexcept -> typename std::conditional_t< with_result_type, {\b res_base_op_t}< {\b binop_e::add} >, {\b base_t} >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS | & |= &=. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr const {\b base_t} & {\b m_sub} ({\b base_t} &larg, const {\b dig_t} &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b base_t} {\b add} (const {\b base_t} &larg, const {\b dig_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b base_t} {\b sub} (const {\b base_t} &larg, const {\b dig_t} &rarg) noexcept\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos heredados desde {\b NumRepr::reg_digs_t< UINT_T, B, L >}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_Bm2} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_Bp1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_Bp1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} n> \par
requires ((n>=0)&&(n < N))static consteval {\b base_N_t}< N > {\b regd_base_N_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} n> \par
requires ((n>=0)&&(n < N))static consteval {\b base_N_t}< N > {\b regd_base_N_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IDEM QUE ANTES PERO CON LA CLASE DERIVADA, LA ACTUAL TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ints_type> \par
requires ((sizeof...(Ints_type)) == L)static constexpr {\b base_t} {\b normalize} (Ints_type ... digits_pow_i) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_digs_t} {\b cat} (const {\b reg_digs_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_DIGS_T CAT(REG_DIGS_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> static constexpr {\b reg_N_digs_t}< L+M > {\b cat} (const {\b reg_digs_t} &larg, const {\b reg_N_digs_t}< M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC <M> REG_N_DIGS_T<L+M> CAT(REG_DIGS_T,REG_N_DIGS_T<M>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< L+1 > {\b cat} (const {\b reg_digs_t} &larg, {\b dig_t} rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_DIGS_T<L+1> CAT(REG_DIGS_T,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< 1+L > {\b cat} ({\b dig_t} larg, const {\b reg_digs_t} &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REG_N_DIGS_T<1+L> CAT(DIG_T,REG_DIGS_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< 1 > {\b cat} ({\b dig_t} larg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<1> CAT(DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< 2 > {\b cat} ({\b dig_t} larg, {\b dig_t} rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<1+1> CAT(DIG_T,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T0 , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...)&& (std::is_same_v<T0,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< 1+(sizeof ...(Ts))> {\b cat} (T0 dig0, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...) && (std::is_same_v<T,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< L+1+(sizeof ...(Ts))> {\b cat} ({\b reg_digs_t} larg, T dig, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...) && (std::is_same_v<T,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< L+1+(sizeof ...(Ts))> {\b cat} (T dig, Ts ... dig_pack, {\b reg_digs_t} rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} ... N_pack> \par
requires ((N>0)&&((N_pack>0)&&...))static constexpr {\b reg_N_digs_t}< N+(...+(N_pack))> {\b cat} ({\b reg_N_digs_t}< N > larg, {\b reg_N_digs_t}< N_pack > ... rarg_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b is_type_template_string_id} (std::string in) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
el parser/lexer del {\b reg_digs_t} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b to_type_template_string_id} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b size_t} {\b size_of_type_template_string_id} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b get_type_template_string_id_token} (std::istream &is)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b base_t} *const {\b base_this} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b base_t} & {\b base_ref_cthis} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b by_index} ({\b size_t} ix) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool with_result_type> constexpr auto {\b predecrement} ({\b base_t} &arg) noexcept -> std::conditional< with_result_type, {\b res_base_op_t}< {\b binop_e::sub} >, const {\b base_t} & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool with_result_type> constexpr auto {\b postdecrement} ({\b base_t} &arg) noexcept -> std::conditional< with_result_type, {\b res_base_op_t}< {\b binop_e::sub} >, const {\b base_t} & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool with_result_type> constexpr auto {\b mult} ({\b dig_t} arg) const noexcept -> std::conditional_t< with_result_type, {\b res_base_op_t}< binop_e::mult >, const {\b base_t} & >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_0} ({\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_1} ({\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_Bm1} ({\b base_N_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_dig} ({\b base_N_t}< N > &larg, {\b dig_t} d) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_fill_dig} ({\b base_N_t}< N > &larg, {\b dig_t} d) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_fill_1} ({\b base_N_t}< N > &larg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b set_fill_Bm1} ({\b base_N_t}< N > &larg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void {\b set_interval_0} ({\b base_N_t}< N > &larg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void {\b set_interval_Bm1} ({\b base_N_t}< N > &larg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void {\b set_interval_dig} ({\b base_N_t}< N > &larg, {\b dig_t} dig) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void {\b set_interval_0} ({\b base_t} &larg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void {\b set_interval_Bm1} ({\b base_t} &larg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void {\b set_interval_dig} ({\b base_t} &larg, {\b dig_t} dig) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool with_result_type> static constexpr auto {\b preincrement} ({\b base_t} &arg) noexcept -> std::conditional_t< with_result_type, {\b res_base_op_t}< {\b binop_e::add} >, const {\b base_t} & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool with_result_type> static constexpr auto {\b postincrement} ({\b base_t} &arg) noexcept -> std::conditional< with_result_type, {\b res_base_op_t}< {\b binop_e::add} >, const {\b base_t} & >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b base_t} {\b rem_B} (const {\b base_t} &larg, {\b size_t} n) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr const {\b base_t} & {\b m_rem_B} ({\b base_t} &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b base_t} {\b mer_B} (const {\b base_t} &larg, {\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr const {\b base_t} & {\b m_mer_B} ({\b base_t} &larg, {\b size_t} n) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L>\par
requires (suitable_base<UINT_T,B>() && (L>0))\par
struct NumRepr::nat_reg_digs_t< UINT_T, B, L >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 14} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v base_N_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:base_N_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::base_N_t =  {\b reg_digs_t}<UINT_T,B,N>}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 23} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v base_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:base_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::base_t =  {\b base_N_t}<L>}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 24} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v dig_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::dig_t =  {\b dig_t}<UINT_T,B>}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 19} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v nat_reg_N_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_N_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_N_digs_t =  {\b nat_reg_digs_t}<UINT_T,B,N>}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 35} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v res_base_N_op_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:res_base_N_op_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b binop_e} op, {\b size_t} N> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::res_base_N_op_t =  typename {\b auxiliary_types::result_operation_t}<{\b base_N_t}<N>,op,N>}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v res_base_op_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:res_base_op_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b binop_e} op> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::res_base_op_t =  typename {\b auxiliary_types::result_operation_t}<{\b base_t},op,L>}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 30} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v res_N_op_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:res_N_op_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b binop_e} op, {\b size_t} N> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::res_N_op_t =  typename {\b auxiliary_types::result_operation_t}<{\b nat_reg_N_digs_t}<N>,op,N>}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 38} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v res_op_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:res_op_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b binop_e} op> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::res_op_t =  typename {\b auxiliary_types::result_operation_t}<{\b nat_reg_digs_t},op,L>}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v SIG_SINT_T\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:SIG_SINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::SIG_SINT_T =  typename {\b type_traits::sig_SInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 17} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v SIG_UINT_T\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:SIG_UINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::SIG_UINT_T =  typename {\b type_traits::sig_UInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 16} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> consteval {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR DEFECTO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 94} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a48e13b837d97d5b20e16d06fdb896453_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (const std::initializer_list< {\b dig_t} > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR LISTA DE DIGITOS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 98} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (const Ts &...  {\i args}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR ARGUMENTOS DIGITOS SIN LIMITE: DEDUCE EL TIPO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 104} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE UN ARRAY DE DIGITOS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 202} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (const {\b base_N_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 209} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c ... Ints_type> constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (Ints_type ...  {\i dig_pow_i}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE ARGUMENTOS ENTEROS SIN LIMITE : DEDUCE EL TIPO \par
}{
Definici\'F3n en la l\'EDnea {\b 217} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a56c17d76bfaf24bbe95e8cd0402367fc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA POR REFERENCIA CONSTANTE. }}\par
{
Definici\'F3n en la l\'EDnea {\b 223} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ac754667e568ecdda0033e4672fdeefd3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v nat_reg_digs_t\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:nat_reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::nat_reg_digs_t ({\b nat_reg_N_digs_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR POR MOVIMIENTO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 229} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a9487898486f71a81f5ccc6573f8709db_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v add\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b base_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::add (const {\b base_t} &  {\i larg}, const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1276} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v assign\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c Int_Type> static constexpr const {\b base_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::assign ({\b base_t} &  {\i larg}, Int_Type  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN BASE_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 491} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a02c8ea238d4e8921ae5e92d330f5bfba_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v base_const_ref_cthis\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:base_const_ref_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b base_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::base_const_ref_cthis () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 112} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a41f2c182cf6b668b25a17364f7a32ba6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a41f2c182cf6b668b25a17364f7a32ba6_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v base_cpy_cthis\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:base_cpy_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b base_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::base_cpy_cthis () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 110} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aaaef3120f842a51681f90531559efb3c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aaaef3120f842a51681f90531559efb3c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v base_ref_cthis\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:base_ref_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b base_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::base_ref_cthis (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 121} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ab28b12d87b4ba5e5f65beb35d278e51b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ab28b12d87b4ba5e5f65beb35d278e51b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v base_this\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:base_this}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b base_t} *const {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::base_this (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 119} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aeec8fdeac36f8e4f67ca475100f83ffd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v by_index\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:by_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b dig_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::by_index ({\b size_t}  {\i ix}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 123} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_abd8cc521e9af8cfb63a845d6295dfc70_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_abd8cc521e9af8cfb63a845d6295dfc70_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cat\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_N_digs_t}< N+L > {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::cat (const {\b nat_reg_N_digs_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SUBREPR => SUB REPRESENTACION. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NAT_REG_N_T<L+M> NAT_REG_T::CAT(NAT_REG_N_T<M>) NAT_REG_N_T<L+M> NAT_REG_T::CAT_INV(NAT_REG_N_T<M>) NAT_REG_N_T<L+1> NAT_REG_T::CAT(DIG_T) NAT_REG_N_T<L+1> NAT_REG_T::CAT_INV(DIG_T) \par
}{
Definici\'F3n en la l\'EDnea {\b 575} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_acf64ab106dc1e03510434256064d85ef_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cat\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_N_digs_t}< L+1 > {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::cat ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 579} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a1e54bb927680f14dbd4d180a1262bc8a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cat_inv\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:cat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_N_digs_t}< N+L > {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::cat_inv (const {\b nat_reg_N_digs_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 585} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a503c26355f8e7d254480e5bc3c0aca90_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cat_inv\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:cat_inv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_N_digs_t}< L+1 > {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::cat_inv ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 589} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a4df4d89b90103f73c6bd40a88ca103b3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v const_base_this\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:const_base_this}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b base_t} *const {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::const_base_this () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 108} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a658eb866c878e5c8fa312d190fca084b_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v const_by_index\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:const_by_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b dig_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::const_by_index ({\b size_t}  {\i ix}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 114} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aa32760e590ee36be179c1fa86566ae2a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aa32760e590ee36be179c1fa86566ae2a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v copy_arg_N\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:copy_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::copy_arg_N (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : CONSTRUCTOR COPIA/MOVIMIENTO DESDE UN ARRAY DE DIGITOS FUNCION DELEGADA PARA COPIA DE UN ARRAY DEL MISMO TAMANO O UN TAMANO CUALQUIERA "N" \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Z < W or Z == W\par
}{
Definici\'F3n en la l\'EDnea {\b 134} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a3ab8e26377b4f409fe0ec67972db7de4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v copy_arg_N\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:copy_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::copy_arg_N (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DELEGADA PARA COPIA DE UN NAT_REG_N_DIGS_T DEL MISMO TAMANO O UN TAMANO CUALQUIERA "N" \par
}{
Definici\'F3n en la l\'EDnea {\b 183} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a10794eef68bb9e67cc275c843794b89a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cpy_by_index\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:cpy_by_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::cpy_by_index ({\b size_t}  {\i ix}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 116} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a224c57f7ae2679ea9b76fd50189efdcf_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a224c57f7ae2679ea9b76fd50189efdcf_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_add\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:m_add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<bool with_result_type> static constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::m_add ({\b base_t} &  {\i larg}, const {\b dig_t} &  {\i rarg}) -> typename std::conditional_t<
			with_result_type,
				{\b res_base_op_t}<{\b binop_e::add}>,
				{\b base_t}
		>
	{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS | & |= &=. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACIONES BINARIAS CON/SIN TIPO RESULTADO OPERACIONES BINARIAS BASE_T @ DIG_T OPERATOR BASE_T += DIG_T CON NOMBRE M_ADDITION \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CARRY INICIAL POR DEFECTO\par
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG\par
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1\par
INICIALIZACION\par
NOMBRE CORTO PARA RET.RESULT_CONTENT_LOW\par
NOMBRE CORTO PARA RET.CARRY\par
NOMBRE CORTO PARA RET.GOOD_RESULT\par
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG\par
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1157} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a36d07cae3bf81e5a9b43c1cffd201d38_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_mer_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:m_mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr const {\b base_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::m_mer_B ({\b base_t} &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1032} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a3ce938b83498e57988f39a9c6a81b7f8_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_mer_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:m_mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::m_mer_B ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1091} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ad55f50be24724cc0790b2cafb3733a69_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_rem_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:m_rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr const {\b base_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::m_rem_B ({\b base_t} &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1016} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a90c4189790e4a259cc04874a752a15cb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_rem_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:m_rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::m_rem_B ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1077} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a7c50665e783bd8dd09b76af26e2d43b4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v m_sub\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:m_sub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr const {\b base_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::m_sub ({\b base_t} &  {\i larg}, const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERATOR BASE_T -= DIG_T CON NOMBRE M_SUB. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COPIA DE RARG\par
CARRY INICIAL POR DEFECTO: NULO\par
SUMA DEL PRIMER DIGITO DE LARG[0] Y RARG\par
BUCLE FOR QUE RESTA RARG A LARG DESDE IDX=1 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 1240} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a65523219739c53202de6718061c2867d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mer_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b base_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::mer_B (const {\b base_t} &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1024} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a0fa3baa8ec9c9f70898791bb47ced6b1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mer_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::mer_B ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1084} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a76502863356a962c922528a7e0de7c22_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v move_arg_N\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:move_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::move_arg_N ({\b base_N_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DELEGADA PARA MOVER DE UN ARRAY DEL MISMO TAMANO O UN TAMANO CUALQUIERA "N" \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Z < W or Z == W\par
}{
Definici\'F3n en la l\'EDnea {\b 159} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ae8944cfac1e1fd4c1e0a6be9bd5bc9f4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ae8944cfac1e1fd4c1e0a6be9bd5bc9f4_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v move_arg_N\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:move_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::move_arg_N ({\b nat_reg_N_digs_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION DELEGADA PARA MOVER DE UN NAT_REG_N_DIGS_T DEL MISMO TAMANO O UN TAMANO CUALQUIERA "N" \par
}{
Definici\'F3n en la l\'EDnea {\b 192} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a8d4656d2c0937af44d8868383da8c26d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mult\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:mult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<bool with_result_type> constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::mult ({\b dig_t}  {\i arg}) const -> std::conditional_t<
			with_result_type,
				{\b res_base_op_t}<binop_e::mult>,
				const {\b base_t} &
		>
	{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACIONES '@'(REG_DIGS_T,DIG_T)->RESULT_TYPE<'@'> '@' = MULT \par
}{
Definici\'F3n en la l\'EDnea {\b 1321} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a652e69b8eb929e7d43f3e1098ea4a093_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator Int_Type\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator Int_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c Int_Type> constexpr {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator Int_Type () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 605} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a314ac41efce60c862c67a3939c8e6c5e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator%\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator% (const {\b nat_reg_digs_t}< UINT_T, B, L > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1718} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator%\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator%}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator% ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REMAINDER BY A DIGIT. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1529} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator&\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator& (const {\b nat_reg_digs_t}< UINT_T, B, L > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1126} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator&=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator&= (const {\b nat_reg_digs_t}< UINT_T, B, L > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1119} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a2700fbcaf685ccd1d8e1aebfd71e59b2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator()\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c Int_Type = UINT_T> constexpr Int_Type {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator() ({\b size_t}  {\i idx}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 671} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a8c41105ef914ccd1caec1a993bd95601_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator*\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator* (const {\b base_N_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1683} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator*\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator* (const {\b nat_reg_N_digs_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1710} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator*\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator* ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1505} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator*=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator*= (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1626} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator*=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator*=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator*= (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1640} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator+\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+ (const {\b base_N_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TO DO. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TO DO \par
}{
Definici\'F3n en la l\'EDnea {\b 1665} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator+\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+ (const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1304} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_acff45608b5b1956e95e00d668b6f9e53_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+ (const {\b nat_reg_N_digs_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1692} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator+\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+ ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1489} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator++\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator++ (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 786} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a061cc41d3e0bcfca2f86c6f15eeeba7b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator++\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator++ (int ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 818} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ad7a7be3dd91bec57f46819f95a5bbe8c_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+= (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1544} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a4f4dcebb7aaf1dacde690b6b847e66d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+= (const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1290} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_af16da7d777f0461043ec0d7daae338b3_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator+=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator+= (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1583} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator- (const {\b base_N_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1674} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator- (const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1310} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a2d07be047b2627cdf0b309167372ceff_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator- (const {\b nat_reg_N_digs_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1701} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator- ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1497} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator--\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator-- (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 909} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aca9335419e9033518f40cccb436c13f5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator--\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator-- (int ){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 941} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aceeb01544e642ed62c0f91026d78fd41_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator-= (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< cparg pasa a ser el complemento a la base menos 1 de cparg\par
}{
Definici\'F3n en la l\'EDnea {\b 1592} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ae1fb554a49a057b8e372a7c3b661559b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator-= (const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1297} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_abcc6c82c4a4563ff93f43cdba0ea5a3d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator-=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator-= (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1617} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator/\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator/ ({\b dig_t}  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DIVISION BY A DIGIT. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1522} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator<< ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1042} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator<<=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator<<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator<<= ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1050} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a258de4665d5dad190a1f431949a57e9b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=>\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr std::weak_ordering {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator<=> (const {\b base_N_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }}\par
{
Definici\'F3n en la l\'EDnea {\b 641} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ad7426f73c780c180a0c684705e3e277a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=>\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr std::weak_ordering {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator<=> (const {\b dig_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }}\par
{
Definici\'F3n en la l\'EDnea {\b 648} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a158ee12a14cbc5dc81d1a563915b8484_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator<=>\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr std::strong_ordering {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator<=> (const {\b nat_reg_N_digs_t}< N > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }}\par
{
Definici\'F3n en la l\'EDnea {\b 632} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a760667e522ab381ea922f79a0fe37032_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= ({\b base_N_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA MOVIMIENTO DESDE BASE_N_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 258} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aab48498228625991e1b7a6efc1714d6a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= ({\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE BASE_N_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 247} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aae26e3fd0c597eb576b8a73c8a6e0921_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA CONST {\i NO}  COPIABLE DESDE BASE_N_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 236} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aba43c889c90dfbb661c06609e10393e4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= (const {\b dig_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN DIGITO (CONVERSION) }}\par
{
Definici\'F3n en la l\'EDnea {\b 479} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a38fa3f288d43c0fa115e89bf9afd6da5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA EN LA QUE SE PUEDE COPIAR. }}\par
{
Definici\'F3n en la l\'EDnea {\b 269} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a0222f0fe5e680461731101767d0d658b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= (const {\b nat_reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA EN LA QUE {\i NO}  SE PUEDE COPIAR. }}\par
{
Definici\'F3n en la l\'EDnea {\b 291} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a72f08f8b1a5fa90636429b936399920b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c Int_Type> constexpr {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= (Int_Type  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN ENTERO CONVERSION A LA BASE B DEL OBJETO ARG DE TIPO INT_TYPE \par
}{
Definici\'F3n en la l\'EDnea {\b 520} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ab1a63d715621ca9fea2c4d765155a23b_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)constexpr {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator= ({\b nat_reg_N_digs_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR MOVIMIENTO. }}\par
{
Definici\'F3n en la l\'EDnea {\b 280} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ae13d640c0fc939f463fe4db5fb58fc0a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>>\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator>> ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1057} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator>>=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator>>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator>>= ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1063} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_afdfd81c1577f21a78a883d78c69e661d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator[] ({\b size_t}  {\i idx}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 659} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a99c01e95abff85318cb5a4e6c0fba2ae_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator[]\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator[] ({\b size_t}  {\i idx}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 665} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a953e903e06ac7220399e624582ddfe1f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator|\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator| (const {\b nat_reg_digs_t}< UINT_T, B, L > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1111} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v operator|=\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b nat_reg_digs_t} & {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::operator|= (const {\b nat_reg_digs_t}< UINT_T, B, L > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : OPERATORS | & |= &= \par
}{
Definici\'F3n en la l\'EDnea {\b 1104} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ac904337e0a7ca97801a344494172e56e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v postdecrement\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:postdecrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<bool with_result_type> constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::postdecrement ({\b base_t} &  {\i arg}) -> std::conditional<
				with_result_type,
						{\b res_base_op_t}<{\b binop_e::sub}>,
						const {\b base_t}&
				>
	{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 919} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v postincrement\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:postincrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<bool with_result_type> static constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::postincrement ({\b base_t} &  {\i arg}) -> std::conditional<
					with_result_type,
							{\b res_base_op_t}<{\b binop_e::add}>,
							const {\b base_t} &
			>
	{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 796} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v predecrement\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:predecrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<bool with_result_type> constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::predecrement ({\b base_t} &  {\i arg}) -> std::conditional<
				with_result_type,
						{\b res_base_op_t}<{\b binop_e::sub}>,
						const {\b base_t}&
				>
	{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BORROW INICIAL POR DEFECTO\par
RESTA 1 A ARG EN IDX == 0\par
BUCLE FOR QUE RESTA A ARG UN 1 DESDE IDX=1 A IDX=L-1\par
CREAMOS EL RETORNO RET\par
NOMBRE CORTO PARA RET.RESULT_CONTENT_LOW\par
NOMBRE CORTO PARA RET.BORROW\par
NOMBRE CORTO PARA RET.GOOD_RESULT\par
RESTA 1 A ARG EN IDX == 0\par
BUCLE FOR QUE RESTA BORROW A ARG [DESDE 1 EN IDX=0] DESDE IDX=1 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 828} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ac67f0700240165427c4bb850d5bb08ba_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v preincrement\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:preincrement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<bool with_result_type> static constexpr auto {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::preincrement ({\b base_t} &  {\i arg}) -> std::conditional_t<
					with_result_type,
						{\b res_base_op_t}<{\b binop_e::add}>,
						const {\b base_t} &
			>
	{\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< PREINCREMENT(OBJ) == ++OBJ SOLO QUE DEVUELVE CARRY TAMBI\'C9N PREINCREMENT(OBJ) -> CONDICIONALMENTE BIEN RES_BASE_OP_T (con CARRY), BIEN BASE_T (sin CARRY) < result_content_low result_content_high carry borrow result_content_quotient result_content_remainder good_result \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
true == tipo resultado\par
CREAMOS EL RETORNO RET DE TIPO RESULTADO\par
NOMBRE CORTO PARA RET.CARRY\par
NOMBRE CORTO PARA RET.RESULT_CONTENT_LOW\par
NOMBRE CORTO PARA RET.GOOD_RESULT\par
INCREMENTO DEL PRIMER DIGITO\par
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1\par
CARRY INICIAL POR DEFECTO\par
INCREMENTO DEL PRIMER DIGITO\par
BUCLE FOR QUE SUMA ARG Y 1 DESDE IDX=1 A IDX=L-1\par
}{
Definici\'F3n en la l\'EDnea {\b 701} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a50aeb5c3fe8c0b4c63285056e36b4ae6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_0\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:regd_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::regd_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCIONES INMEDIATAS QUE NOS DAN CONSTANTES DEL TIPO DE LA ACTUAL CLASE SE HACE CREANDO UNA VARIABLE RVALUE TEMPORAL CON LA FUNCION HOMOLOGA PARA BASE_T \par
}{
Definici\'F3n en la l\'EDnea {\b 50} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a1735c9e1782d2117df23eb12a0feeda2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a1735c9e1782d2117df23eb12a0feeda2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:regd_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::regd_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 55} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a881321b54a24d12bff09e271e0a505c4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:regd_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::regd_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 65} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_adf3405e104a61285b26efab30703513f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:regd_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::regd_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 60} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_adc9a13a06dc19e25b899e7584aa2014e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_pow_n_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:regd_pow_n_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} n> \par
requires ((n>=0)&&(n < L))static consteval {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::regd_pow_n_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 72} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a054433a5c6b1119a661844bc20df43e6_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_pow_n_B_m1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:regd_pow_n_B_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} n> \par
requires ((n>=0)&&(n < L))static consteval {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::regd_pow_n_B_m1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 79} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a8a6ada1089e4ecee20e0438b6a21881e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rem_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b base_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::rem_B (const {\b base_t} &  {\i larg}, {\b size_t}  {\i n}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
BEGIN : OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MULTIPLY BY THE BASE B (10) << <<= DIVIDE BY THE BASE B (10) >> >>= REMAINDER BY THE BASE B (10) REM_B_N M_REM_B_N MULTIPLICATIVE CARRY BY THE BASE B (10) MER_B_N M_MER_B_N \par
}{
Definici\'F3n en la l\'EDnea {\b 1008} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ac252594b28a4afdacb06de94b1bbdb0d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rem_B\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b nat_reg_digs_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::rem_B ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1070} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a6647618fb6d484f4c257159dba69c370_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_0\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_0 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE LIMPIEZA A CERO DEL NAT_REG_DIGS_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 436} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ac4f2f52679334d058322e2537881b5fc_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ac4f2f52679334d058322e2537881b5fc_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_0\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_0 ({\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 301} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aa340d969b6d01c15b8181e542d3a2fef_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_1 ({\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 310} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_aa06e3a55433e98a553d0204ce642f6b8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE LIMPIEZA A B-1 DEL NAT_REG_DIGS_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 442} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a197e63e671e4306b1d6c95cf3dddf122_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a197e63e671e4306b1d6c95cf3dddf122_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_Bm1 ({\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 320} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ae15231d7a8ac742f64c352de56ad42b5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_dig\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_dig ({\b base_N_t}< N > &  {\i larg}, {\b dig_t}  {\i d}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 330} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ab5263cf1eaa919874172ed0628db64f0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ab5263cf1eaa919874172ed0628db64f0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_dig\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_dig ({\b dig_t}  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE LIMPIEZA A VALOR DIG_T DEL NAT_REG_DIGS_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 448} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a4ac89cc0daee3cbccf22a42164e99481_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_fill_1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_fill_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_fill_1 ({\b base_N_t}< N > &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 349} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v set_fill_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_fill_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_fill_Bm1 ({\b base_N_t}< N > &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 358} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v set_fill_dig\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_fill_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> \par
requires (N>0)static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_fill_dig ({\b base_N_t}< N > &  {\i larg}, {\b dig_t}  {\i d}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 340} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v set_interval_0\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_0 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_0 EN [N_0 , N_1) DEL NAT_REG_DIGS_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 457} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ad7f694c626b4b9199f0fd299a0c06f54_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_interval_0\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_0 ({\b base_N_t}< N > &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_0 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> \par
}{
Definici\'F3n en la l\'EDnea {\b 370} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_af0c7e92ac7dad132e23eebc7df96baad_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_interval_0\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_0 ({\b base_t} &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_0 DEL ARRAY DESDE [N_0 , N_1) EN BASE_T ESPECIALIZACION PARA N==L \par
}{
Definici\'F3n en la l\'EDnea {\b 404} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a5c4c51a78151c28e0d1e98e5903000bf_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_interval_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_Bm1 EN [N_0 , N_1) DEL NAT_REG_DIGS_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 465} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_af1e049ae99df1afdfaf216efa6877f77_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_interval_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_Bm1 ({\b base_N_t}< N > &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_Bm1 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> \par
}{
Definici\'F3n en la l\'EDnea {\b 381} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a2277ebda4bff6a2e0730fa1a7c9f99e8_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_interval_Bm1\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_Bm1 ({\b base_t} &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_Bm1 DEL ARRAY DESDE [N_0 , N_1) EN BASE_T ESPECIALIZACION PARA N==L \par
}{
Definici\'F3n en la l\'EDnea {\b 416} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a800522f724b87f9d645117b982454ecb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_interval_dig\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= N)&&(N>0))static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_dig ({\b base_N_t}< N > &  {\i larg}, {\b dig_t}  {\i dig}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> \par
}{
Definici\'F3n en la l\'EDnea {\b 392} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v set_interval_dig\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))static constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_dig ({\b base_t} &  {\i larg}, {\b dig_t}  {\i dig}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG DEL ARRAY DESDE [N_0 , N_1) EN BASE_T ESPECIALIZACION PARA N==L \par
}{
Definici\'F3n en la l\'EDnea {\b 428} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v set_interval_dig\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:set_interval_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::set_interval_dig ({\b dig_t}  {\i dig}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG EN [N_0 , N_1) DEL NAT_REG_DIGS_T. }}\par
{
Definici\'F3n en la l\'EDnea {\b 473} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_a5755851c821c5b1a87ab04e4bd7861a0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sub\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:sub}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b base_t} {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::sub (const {\b base_t} &  {\i larg}, const {\b dig_t} &  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1282} del archivo {\b nat_reg_digs_t.hpp}.}\par
}
{\xe \v subrepr\:NumRepr::nat_reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::nat_reg_digs_t< UINT_T, B, L >\:subrepr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} ibegin, {\b size_t} iend> \par
requires ((iend <= L)&&(ibegin < iend))constexpr {\b nat_reg_N_digs_t}< iend-ibegin > {\b NumRepr::nat_reg_digs_t}< UINT_T, B, L >::subrepr () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 595} del archivo {\b nat_reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1nat__reg__digs__t_ae0035860926f7f260553e8bce191066e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b nat_reg_digs_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::pack2array< Ts >\par \pard\plain 
{\tc\tcl2 \v utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >}
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES. }}\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b array_type} = std::array< typename {\b pack2tuple}< Ts... >{\b ::elem_type}< 0 >,(sizeof...(Ts)) >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b elem_type} = typename {\b pack2tuple}< Ts... >::elem_type< 0 >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b array_type} {\b operator()} (Ts &&...args) const noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::size_t {\b pack_size} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t J> static constexpr {\b elem_type} {\b get} (Ts &&...args) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t... I> static constexpr void {\b for_each_impl} ({\b array_type} &iarray, const Ts...args, std::index_sequence< I... >) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr void {\b for_each} ({\b array_type} &iarray, const Ts...args) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename... Ts>\par
requires (all_are_the_same_type_c<Ts...>&&there_is_one_or_more_c<Ts...>)\par
struct utilities::pack2array< Ts >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES. \par
}{
Definici\'F3n en la l\'EDnea {\b 105} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v array_type\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:array_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> using {\b utilities::pack2array}< Ts >::array_type =  std::array< typename {\b pack2tuple}<Ts...>{\b ::elem_type}<0>, (sizeof...(Ts)) >}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 106} del archivo {\b utilities.hpp}.}\par
}
{\xe \v elem_type\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:elem_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> using {\b utilities::pack2array}< Ts >::elem_type =  typename {\b pack2tuple}<Ts...>::elem_type<0>}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 119} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v for_each\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:for_each}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> static constexpr void {\b utilities::pack2array}< Ts >::for_each ({\b array_type} &  {\i iarray}, const Ts...  {\i args}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 144} del archivo {\b utilities.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structutilities_1_1pack2array_ac0a1c575813515e6ab144a2652e65832_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v for_each_impl\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:for_each_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> template<std::size_t... I> static constexpr void {\b utilities::pack2array}< Ts >::for_each_impl ({\b array_type} &  {\i iarray}, const Ts...  {\i args}, std::index_sequence< I... > ){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESTA FUNCION AUXILIAR ES NECESARIA PARA UNA POSTERIOR EXPANSION DEL PARAMETER PACK \par
}{
Definici\'F3n en la l\'EDnea {\b 133} del archivo {\b utilities.hpp}.}\par
}
{\xe \v get\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> template<std::size_t J> static constexpr {\b elem_type} {\b utilities::pack2array}< Ts >::get (Ts &&...  {\i args}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 122} del archivo {\b utilities.hpp}.}\par
}
{\xe \v operator()\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> constexpr {\b array_type} {\b utilities::pack2array}< Ts >::operator() (Ts &&...  {\i args}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 114} del archivo {\b utilities.hpp}.}\par
}
{\xe \v pack_size\:utilities::pack2array< Ts >}
{\xe \v utilities::pack2array< Ts >\:pack_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> static constexpr std::size_t {\b utilities::pack2array}< Ts >::pack_size (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 110} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::pack2tuple< Ts >\par \pard\plain 
{\tc\tcl2 \v utilities::pack2tuple< Ts >}
{\xe \v utilities::pack2tuple< Ts >}
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b tuple_type} = std::tuple< Ts... >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned K> using {\b elem_type} = typename std::tuple_element< K, {\b tuple_type} >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b tuple_type} {\b operator()} (Ts &&...args) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr unsigned {\b pack_size} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<unsigned J> static constexpr {\b elem_type}< J >::type {\b get} (Ts &&...args) noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename... Ts>\par
struct utilities::pack2tuple< Ts >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
template<class type_0, class type_1, ... , class type_Nm1> struct apilamiento_de_tipos_t \{ type_0 obj_0; type_1 obj_1; ...... ..... type_Nm1 obj_Nm1; \}; example: apilamiento_de_tipos<int,std::string,double> objeto\{1,"abc",2.98105\}; objeto.obj_0 == 1; objeto.obj_1 == "abc"; objeto.obj_Nm1 == 2.98105; A partir del estandar de C++11 template<class ...type_i> struct apilamiento_de_tipos_t \{ type_0 obj_0; // sabemos type_i pero no type_0 type_1 obj_1; // sabemos type_i pero no type_1 ...... ..... type_Nm1 obj_Nm1;// sabemos type_i pero no type_Nm1 \}; type_i es un PACK tipo std::tupla<class ... Ts>; \par
}{
Definici\'F3n en la l\'EDnea {\b 40} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v elem_type\:utilities::pack2tuple< Ts >}
{\xe \v utilities::pack2tuple< Ts >\:elem_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> template<unsigned K> using {\b utilities::pack2tuple}< Ts >::elem_type =  typename std::tuple_element<K,{\b tuple_type}>::type}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 48} del archivo {\b utilities.hpp}.}\par
}
{\xe \v tuple_type\:utilities::pack2tuple< Ts >}
{\xe \v utilities::pack2tuple< Ts >\:tuple_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> using {\b utilities::pack2tuple}< Ts >::tuple_type =  std::tuple<Ts...>}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v get\:utilities::pack2tuple< Ts >}
{\xe \v utilities::pack2tuple< Ts >\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> template<unsigned J> static constexpr {\b elem_type}< J >::type {\b utilities::pack2tuple}< Ts >::get (Ts &&...  {\i args}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 50} del archivo {\b utilities.hpp}.}\par
}
{\xe \v operator()\:utilities::pack2tuple< Ts >}
{\xe \v utilities::pack2tuple< Ts >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> constexpr {\b tuple_type} {\b utilities::pack2tuple}< Ts >::operator() (Ts &&...  {\i args}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 43} del archivo {\b utilities.hpp}.}\par
}
{\xe \v pack_size\:utilities::pack2tuple< Ts >}
{\xe \v utilities::pack2tuple< Ts >\:pack_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename... Ts> static constexpr unsigned {\b utilities::pack2tuple}< Ts >::pack_size (){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 42} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::pow_B_to_E_t< Base, Exp >\par \pard\plain 
{\tc\tcl2 \v utilities::special::pow_B_to_E_t< Base, Exp >}
{\xe \v utilities::special::pow_B_to_E_t< Base, Exp >}
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA ANTIGUA PERO SEGURA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. }}\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b base} = static_cast<{\b NumRepr::uint128_t}>(Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b exponent} = static_cast<{\b NumRepr::uint128_t}>(Exp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b value} = {\b base}*({\b pow_B_to_E_t}<{\b base},{\b exponent}-1>::value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp>\par
struct utilities::special::pow_B_to_E_t< Base, Exp >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA ANTIGUA PERO SEGURA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. \par
}{
Definici\'F3n en la l\'EDnea {\b 193} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v base\:utilities::special::pow_B_to_E_t< Base, Exp >}
{\xe \v utilities::special::pow_B_to_E_t< Base, Exp >\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, Exp >::base = static_cast<{\b NumRepr::uint128_t}>(Base){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 194} del archivo {\b utilities.hpp}.}\par
}
{\xe \v exponent\:utilities::special::pow_B_to_E_t< Base, Exp >}
{\xe \v utilities::special::pow_B_to_E_t< Base, Exp >\:exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, Exp >::exponent = static_cast<{\b NumRepr::uint128_t}>(Exp){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 195} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::pow_B_to_E_t< Base, Exp >}
{\xe \v utilities::special::pow_B_to_E_t< Base, Exp >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, Exp >::value = {\b base}*({\b pow_B_to_E_t}<{\b base},{\b exponent}-1>::value){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 196} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::pow_B_to_E_t< Base, 0 >\par \pard\plain 
{\tc\tcl2 \v utilities::special::pow_B_to_E_t< Base, 0 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 0 >}
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b base} = static_cast<{\b NumRepr::uint128_t}>(Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b exponent} = static_cast<{\b NumRepr::uint128_t}>(0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b value} = static_cast<{\b NumRepr::uint128_t}>(1)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b NumRepr::usint_t} Base>\par
struct utilities::special::pow_B_to_E_t< Base, 0 >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 211} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v base\:utilities::special::pow_B_to_E_t< Base, 0 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 0 >\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 0 >::base = static_cast<{\b NumRepr::uint128_t}>(Base){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 212} del archivo {\b utilities.hpp}.}\par
}
{\xe \v exponent\:utilities::special::pow_B_to_E_t< Base, 0 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 0 >\:exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 0 >::exponent = static_cast<{\b NumRepr::uint128_t}>(0){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 213} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::pow_B_to_E_t< Base, 0 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 0 >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 0 >::value = static_cast<{\b NumRepr::uint128_t}>(1){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 214} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::pow_B_to_E_t< Base, 1 >\par \pard\plain 
{\tc\tcl2 \v utilities::special::pow_B_to_E_t< Base, 1 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 1 >}
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b base} = static_cast<{\b NumRepr::uint128_t}>(Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b exponent} = static_cast<{\b NumRepr::uint128_t}>(1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b value} = {\b base}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b NumRepr::usint_t} Base>\par
struct utilities::special::pow_B_to_E_t< Base, 1 >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 205} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v base\:utilities::special::pow_B_to_E_t< Base, 1 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 1 >\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 1 >::base = static_cast<{\b NumRepr::uint128_t}>(Base){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 206} del archivo {\b utilities.hpp}.}\par
}
{\xe \v exponent\:utilities::special::pow_B_to_E_t< Base, 1 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 1 >\:exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 1 >::exponent = static_cast<{\b NumRepr::uint128_t}>(1){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 207} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::pow_B_to_E_t< Base, 1 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 1 >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 1 >::value = {\b base}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 208} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::pow_B_to_E_t< Base, 2 >\par \pard\plain 
{\tc\tcl2 \v utilities::special::pow_B_to_E_t< Base, 2 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 2 >}
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b base} = static_cast<{\b NumRepr::uint128_t}>(Base)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b exponent} = static_cast<{\b NumRepr::uint128_t}>(2)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b NumRepr::uint128_t} {\b value} = {\b base}*{\b base}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<{\b NumRepr::usint_t} Base>\par
struct utilities::special::pow_B_to_E_t< Base, 2 >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 199} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v base\:utilities::special::pow_B_to_E_t< Base, 2 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 2 >\:base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 2 >::base = static_cast<{\b NumRepr::uint128_t}>(Base){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 200} del archivo {\b utilities.hpp}.}\par
}
{\xe \v exponent\:utilities::special::pow_B_to_E_t< Base, 2 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 2 >\:exponent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 2 >::exponent = static_cast<{\b NumRepr::uint128_t}>(2){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 201} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::pow_B_to_E_t< Base, 2 >}
{\xe \v utilities::special::pow_B_to_E_t< Base, 2 >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::usint_t} Base> constexpr {\b NumRepr::uint128_t} {\b utilities::special::pow_B_to_E_t}< Base, 2 >::value = {\b base}*{\b base}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 202} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::reg_digs_t< UINT_T, B, L >\par \pard\plain 
{\tc\tcl2 \v NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >}
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> register_of_digits_t\{\};. }}\par
{
{\f2 #include <reg_digs_t.hpp>}}\par
Diagrama de herencias de NumRepr::reg_digs_t< UINT_T, B, L >{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Diagrama de colaboraci\'F3n para NumRepr::reg_digs_t< UINT_T, B, L >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b dig_t} = {\b dig_t}< UINT_T, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> using {\b base_N_t} = std::array< {\b dig_t}, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b base_t} = {\b base_N_t}< L >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> using {\b reg_N_digs_t} = {\b reg_digs_t}< UINT_T, B, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_UINT_T} = typename {\b type_traits::sig_UInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b SIG_SINT_T} = typename {\b type_traits::sig_SInt_for_UInt_t}< UINT_T >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op, {\b size_t} N> using {\b res_base_N_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b base_N_t}< N >, op, N >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b binop_e} op> using {\b res_base_op_t} = typename {\b auxiliary_types::result_operation_t}< {\b base_t}, op, L >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b base_t} *const {\b const_base_this} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de punteros a la clase base }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} * {\b base_this} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} & {\b r_base_cthis} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de referencias a la clase base }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b base_t} & {\b cr_base_cthis} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de copia de la clase base }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b base_t} {\b cp_base_cthis} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reg_digs_t} & {\b r_cthis} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de referencias de la clase actual }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b reg_digs_t} & {\b cr_cthis} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reg_digs_t} {\b cp_cthis} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de copia de la clase actual }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t} {\b cp_cthis_at} ({\b size_t} k) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devoluciones por referencias y por copia de los elementos }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b dig_t} & {\b r_cthis_at} ({\b size_t} k) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b dig_t} & {\b cr_cthis_at} ({\b size_t} k) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b begin} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
En este bloque hacemos esta clase wrapper como si fuese una clase derivada de base_t Para esto replicamos y sobrecargamos cada una de las funciones por defecto de std::array Nota: lo anterior se escribio cuando no era clase derivada sino un wrapper. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b cbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b end} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b cend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b rbegin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b crbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b rend} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b crend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b size_t} {\b max_size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b empty} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b front} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} const & {\b front} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} {\b back} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} const & {\b back} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b fill} (const {\b dig_t} &value) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b swap} ({\b base_t} &{\b other}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b reverse} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
consteval {\b reg_digs_t} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructores de {\b reg_digs_t}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} (const std::initializer_list< {\b dig_t} > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por lista de digitos utilizando la funci\'F3n make_base_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b reg_digs_t} (const Ts &... args) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por argumentos tipo {\b dig_t}: deduce el tipo. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} (const {\b base_t} &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE EL TIPO BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} ({\b base_t} &&rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO DESDE EL TIPO BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b reg_digs_t} (const {\b base_N_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor copia desde un array cualquiera de d\'EDgitos {\b dig_t} (usando copy_arg_N<N>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b reg_digs_t} (const {\b base_N_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por movimiento desde un array cualquiera de d\'EDgitos {\b dig_t} (usando move_arg_N<N>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c ... Ints_type> \par
requires ((sizeof...(Ints_type))==L)constexpr {\b reg_digs_t} (Ints_type ... dig_pow_i) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr const {\b reg_digs_t} & {\b operator=} (const {\b reg_N_digs_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sobrecarga del operador copia. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr {\b reg_digs_t} & {\b operator=} ({\b reg_N_digs_t}< N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr const {\b base_t} & {\b operator=} ({\b reg_N_digs_t}< N > &&arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} & {\b operator=} (const {\b dig_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN DIGITO (CONVERSION) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr const {\b reg_digs_t} & {\b operator=} (Int_Type arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::integral_c Int_Type> constexpr {\b operator Int_Type} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SE PODR\'CDA HACER PARA UINT128_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} *const {\b data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr decltype(auto) {\b cpy_data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b dig_t} & {\b operator[]} ({\b size_t} ix) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Sobrecarga del const dig_t & operator[](size_t) const"> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} & {\b operator[]} ({\b size_t} ix) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Sobrecarga del dig_t & operator[](size_t)"> }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funciones que ponen a constantes (constexpr) los objetos base_t. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_dig} ({\b dig_t} d) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_fill_dig} ({\b dig_t} d) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_fill_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr void {\b set_fill_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"Funciones que ponen a constantes(constexpr) los objetos un subintervalo
o subrango de base_t cualquiera" }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b set_interval_dig} ({\b dig_t} dig) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_0} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_B} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_Bp1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} n> \par
requires (n<L)constexpr bool {\b is_B_pow_m1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} n> \par
requires (n<L-1)constexpr bool {\b is_B_pow} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_any_B_pow} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_filled_of_1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_filled_of_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b is_filled_of} ({\b dig_t} d) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} ibegin, {\b size_t} iend> \par
requires ((iend <= L)&&(ibegin < L)&&(ibegin != iend))constexpr {\b reg_N_digs_t}<(ibegin< iend)?(iend-ibegin):(ibegin-iend)> {\b subregister} () const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TAKE A SUBREGISTER OF A REGISTER OF DIGITS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b mC_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b mC_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b C_Bm1} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b C_B} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator!} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator-} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator<<} ({\b size_t} n) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator<<=} ({\b size_t} n) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO TO DO VOY POR AQUI CON EL TEMA DE LOS CTHIS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator>>=} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator>>} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b rem_B} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b m_rem_B} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b mer_B} ({\b size_t} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b m_mer_B} ({\b size_t} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator|=} (const {\b base_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator|} (const {\b reg_digs_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr const {\b reg_digs_t} & {\b operator&=} (const {\b reg_digs_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b reg_digs_t} {\b operator&} (const {\b reg_digs_t} &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b int64_t} {\b index_of_MSDig} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator==} (const {\b dig_t} &rarg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COMPARACIONES ENTRE BASE_T Y DIG_T EN FORMA BASE_T @ DIG_T. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator!=} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator>} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator<} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator>=} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b operator<=} (const {\b dig_t} &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator==} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator!=} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator>} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator<} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator>=} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr bool {\b operator<=} (const {\b reg_N_digs_t}< M > &rarg) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> constexpr std::strong_ordering {\b operator<=>} (const {\b reg_N_digs_t}< M > &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr std::weak_ordering {\b operator<=>} (const {\b dig_t} &arg) const noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b dig_t} {\b dig_Bm2} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval UINT_T {\b ui_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_UINT_T} {\b sui_Bp1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_0} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b SIG_SINT_T} {\b ssi_Bp1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b regd_base_N_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} n> \par
requires ((n>=0)&&(n < N))static consteval {\b base_N_t}< N > {\b regd_base_N_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} n> \par
requires ((n>=0)&&(n < N))static consteval {\b base_N_t}< N > {\b regd_base_N_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b base_t} {\b regd_base_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_0} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IDEM QUE ANTES PERO CON LA CLASE DERIVADA, LA ACTUAL TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_Bm1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_pow_n_B} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval {\b reg_digs_t} {\b regd_pow_n_B_m1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ints_type> \par
requires ((sizeof...(Ints_type)) == L)static constexpr {\b base_t} {\b normalize} (Ints_type ... digits_pow_i) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_digs_t} {\b cat} (const {\b reg_digs_t} &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_DIGS_T CAT(REG_DIGS_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} M> static constexpr {\b reg_N_digs_t}< L+M > {\b cat} (const {\b reg_digs_t} &larg, const {\b reg_N_digs_t}< M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC <M> REG_N_DIGS_T<L+M> CAT(REG_DIGS_T,REG_N_DIGS_T<M>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< L+1 > {\b cat} (const {\b reg_digs_t} &larg, {\b dig_t} rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_DIGS_T<L+1> CAT(REG_DIGS_T,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< 1+L > {\b cat} ({\b dig_t} larg, const {\b reg_digs_t} &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REG_N_DIGS_T<1+L> CAT(DIG_T,REG_DIGS_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< 1 > {\b cat} ({\b dig_t} larg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<1> CAT(DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b reg_N_digs_t}< 2 > {\b cat} ({\b dig_t} larg, {\b dig_t} rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<1+1> CAT(DIG_T,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T0 , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...)&& (std::is_same_v<T0,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< 1+(sizeof ...(Ts))> {\b cat} (T0 dig0, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...) && (std::is_same_v<T,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< L+1+(sizeof ...(Ts))> {\b cat} ({\b reg_digs_t} larg, T dig, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...) && (std::is_same_v<T,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< L+1+(sizeof ...(Ts))> {\b cat} (T dig, Ts ... dig_pack, {\b reg_digs_t} rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N, {\b size_t} ... N_pack> \par
requires ((N>0)&&((N_pack>0)&&...))static constexpr {\b reg_N_digs_t}< N+(...+(N_pack))> {\b cat} ({\b reg_N_digs_t}< N > larg, {\b reg_N_digs_t}< N_pack > ... rarg_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b is_type_template_string_id} (std::string in) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
el parser/lexer del {\b reg_digs_t} }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static std::string {\b to_type_template_string_id} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b size_t} {\b size_of_type_template_string_id} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static bool {\b get_type_template_string_id_token} (std::istream &is)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr void {\b copy_arg_N} (const {\b base_N_t}< N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por Copia/Movimiento desde una sucesi\'F3n variadica de d\'EDgitos {\b dig_t}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b size_t} N> constexpr void {\b move_arg_N} ({\b base_N_t}< N > &&arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funci\'F3n miembro (delegada) para mover un objeto tipo base_t desde una referencia derecha a un array cualquiera de {\b dig_t}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr {\b dig_t} * {\b data} () noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos privados est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b base_t} {\b make_base_t} (const std::initializer_list< {\b dig_t} > &larg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcion miembro para generar un objeto tipo base_t y devolverlo desde un std::initializer_list<dig_t> }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L>\par
requires ((suitable_base<UINT_T,B>())&&(L > 0))\par
struct NumRepr::reg_digs_t< UINT_T, B, L >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> register_of_digits_t\{\};. \par
}{
Definici\'F3n en la l\'EDnea {\b 15} del archivo {\b reg_digs_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v base_N_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:base_N_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::base_N_t =  std::array<{\b dig_t},N>}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 22} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v base_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:base_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::base_t =  {\b base_N_t}<L>}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 24} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v dig_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:dig_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::dig_t =  {\b dig_t}<UINT_T,B>}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 18} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_N_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_N_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_N_digs_t =  {\b reg_digs_t}<UINT_T,B,N>}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v res_base_N_op_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:res_base_N_op_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b binop_e} op, {\b size_t} N> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::res_base_N_op_t =  typename {\b auxiliary_types::result_operation_t}<{\b base_N_t}<N>,op,N>}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 81} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v res_base_op_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:res_base_op_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b binop_e} op> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::res_base_op_t =  typename {\b auxiliary_types::result_operation_t}<{\b base_t},op,L>}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 85} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v SIG_SINT_T\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:SIG_SINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::SIG_SINT_T =  typename {\b type_traits::sig_SInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v SIG_UINT_T\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:SIG_UINT_T}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> using {\b NumRepr::reg_digs_t}< UINT_T, B, L >::SIG_UINT_T =  typename {\b type_traits::sig_UInt_for_UInt_t}<UINT_T>}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 77} del archivo {\b reg_digs_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n del constructor y destructor\par
\pard\plain 
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> consteval {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructores de {\b reg_digs_t}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por defecto (rellena de {\b dig_t(0)} todo el array) \par
}{
Definici\'F3n en la l\'EDnea {\b 323} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (const std::initializer_list< {\b dig_t} > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por lista de digitos utilizando la funci\'F3n make_base_t. }}\par
{
Definici\'F3n en la l\'EDnea {\b 370} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<typename ... Ts> \par
requires (std::is_same_v<Ts,{\b dig_t}>&&...)constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (const Ts &...  {\i args}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por argumentos tipo {\b dig_t}: deduce el tipo. }}\par
{
Definici\'F3n en la l\'EDnea {\b 379} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (const {\b base_t} &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR COPIA DESDE EL TIPO BASE. }}\par
{
Definici\'F3n en la l\'EDnea {\b 384} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t ({\b base_t} &&  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONSTRUCTOR MOVIMIENTO DESDE EL TIPO BASE. }}\par
{
Definici\'F3n en la l\'EDnea {\b 387} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor copia desde un array cualquiera de d\'EDgitos {\b dig_t} (usando copy_arg_N<N>) }}\par
{
Definici\'F3n en la l\'EDnea {\b 463} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (const {\b base_N_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por movimiento desde un array cualquiera de d\'EDgitos {\b dig_t} (usando move_arg_N<N>) }}\par
{
Definici\'F3n en la l\'EDnea {\b 472} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reg_digs_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reg_digs_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c ... Ints_type> \par
requires ((sizeof...(Ints_type))==L)constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reg_digs_t (Ints_type ...  {\i dig_pow_i}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Constructor copia desde una sucesi\'F3n de objetos enteros vari\'E1dica, normaliz\'E1ndolos"> \par
}{
Definici\'F3n en la l\'EDnea {\b 560} del archivo {\b reg_digs_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v back\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} const  & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::back () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 297} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v back\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::back (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 295} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v base_this\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:base_this}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b base_t} * {\b NumRepr::reg_digs_t}< UINT_T, B, L >::base_this (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 34} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v begin\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::begin (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
En este bloque hacemos esta clase wrapper como si fuese una clase derivada de base_t Para esto replicamos y sobrecargamos cada una de las funciones por defecto de std::array Nota: lo anterior se escribio cuando no era clase derivada sino un wrapper. }}\par
{
Definici\'F3n en la l\'EDnea {\b 267} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v C_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:C_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::C_B () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1146} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a61e3773ab1f1b47ae335e5c561ca5c6c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v C_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:C_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::C_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1142} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a2fe3516a538c7e83b6827106fd5606c2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat (const {\b reg_digs_t}< UINT_T, B, L > &  {\i arg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_DIGS_T CAT(REG_DIGS_T) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC FUNCTIONS : CONCATENATE REGISTERS AND DIGITS reg_digs_t<1> {\b cat(dig_t)} {\b reg_digs_t}<1+1> {\b cat(dig_t,dig_t)} {\b reg_digs_t} cat(reg_digs_t) <M> reg_N_digs_t<L+M> cat(reg_digs_t,reg_N_digs_t<M>) reg_N_digs_t<L+1> cat(reg_digs_t,dig_t) reg_N_digs_t<1+L> cat(dig_t,reg_digs_t) reg_N_digs_t<sizeof...(dig_pack)> cat(dig_t ... dig_pack) VARIADIC PACK \par
}{
Definici\'F3n en la l\'EDnea {\b 984} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> static constexpr {\b reg_N_digs_t}< L+M > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat (const {\b reg_digs_t}< UINT_T, B, L > &  {\i larg}, const {\b reg_N_digs_t}< M > &  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC <M> REG_N_DIGS_T<L+M> CAT(REG_DIGS_T,REG_N_DIGS_T<M>) }}\par
{
Definici\'F3n en la l\'EDnea {\b 991} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b reg_N_digs_t}< L+1 > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat (const {\b reg_digs_t}< UINT_T, B, L > &  {\i larg}, {\b dig_t}  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_DIGS_T<L+1> CAT(REG_DIGS_T,DIG_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1003} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b reg_N_digs_t}< 1 > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat ({\b dig_t}  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<1> CAT(DIG_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1025} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b reg_N_digs_t}< 1+L > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat ({\b dig_t}  {\i larg}, const {\b reg_digs_t}< UINT_T, B, L > &  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
REG_N_DIGS_T<1+L> CAT(DIG_T,REG_DIGS_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1014} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b reg_N_digs_t}< 2 > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat ({\b dig_t}  {\i larg}, {\b dig_t}  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<1+1> CAT(DIG_T,DIG_T) }}\par
{
Definici\'F3n en la l\'EDnea {\b 1030} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...) && (std::is_same_v<T,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< L+1+(sizeof ...(Ts))> {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat ({\b reg_digs_t}< UINT_T, B, L >  {\i larg}, T  {\i dig}, Ts ...  {\i dig_pack}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<L+1+(SIZEOF...(DIG_PACK))> CAT(REG_DIGS_T,DIG_T,DIG_T ... DIG_PACK) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1059} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} ... N_pack> \par
requires ((N>0)&&((N_pack>0)&&...))static constexpr {\b reg_N_digs_t}< N+(...+(N_pack))> {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat ({\b reg_N_digs_t}< N >  {\i larg}, {\b reg_N_digs_t}< N_pack > ...  {\i rarg_pack}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<SIZE_T N,SIZE_T ... N_PACK> CAT(REG_N_DIGS_T<N> LARG,
                REG_N_DIGS_T<N_PACK> ... RARG_PACK
        ) VARIADIC PACK \par
}{
Definici\'F3n en la l\'EDnea {\b 1085} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...) && (std::is_same_v<T,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< L+1+(sizeof ...(Ts))> {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat (T  {\i dig}, Ts ...  {\i dig_pack}, {\b reg_digs_t}< UINT_T, B, L >  {\i rarg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<L+1+(SIZEOF...(DIG_PACK))> CAT(DIG_T,DIG_T ... DIG_PACK,REG_DIGS_T) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1072} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cat\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<typename T0 , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,{\b dig_t}>)&&...)&& (std::is_same_v<T0,{\b dig_t}>) )static constexpr {\b reg_N_digs_t}< 1+(sizeof ...(Ts))> {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cat (T0  {\i dig0}, Ts ...  {\i dig_pack}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC REG_N_DIGS_T<SIZEOF...(DIG_PACK)> CAT(DIG_T,DIG_T ... DIG_PACK) VARIADIC \par
}{
Definici\'F3n en la l\'EDnea {\b 1046} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cbegin\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cbegin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 269} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cend\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cend () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 273} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v const_base_this\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:const_base_this}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> const {\b base_t} *const {\b NumRepr::reg_digs_t}< UINT_T, B, L >::const_base_this () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de punteros a la clase base }}\par
{
Definici\'F3n en la l\'EDnea {\b 30} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v copy_arg_N\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:copy_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::copy_arg_N (const {\b base_N_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor por Copia/Movimiento desde una sucesi\'F3n variadica de d\'EDgitos {\b dig_t}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funci\'F3n miembro (delegada) para copiar un objeto tipo base_t desde una referencia constante a un array cualquiera de {\b dig_t}\par
<function name="copy_arg_N"></function> {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i const base_N_t<N> & arg} \cell }{\cell }
{\row }
}
<returns="void">\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Z < W or Z == W\par
}{
Definici\'F3n en la l\'EDnea {\b 406} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cp_base_cthis\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cp_base_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cp_base_cthis () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 46} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cp_cthis\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cp_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cp_cthis () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de copia de la clase actual }}\par
{
Definici\'F3n en la l\'EDnea {\b 58} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cp_cthis_at\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cp_cthis_at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cp_cthis_at ({\b size_t}  {\i k}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devoluciones por referencias y por copia de los elementos }}\par
{
Definici\'F3n en la l\'EDnea {\b 62} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cpy_data\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cpy_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cpy_data () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 684} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cr_base_cthis\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cr_base_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> const {\b base_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cr_base_cthis () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de copia de la clase base }}\par
{
Definici\'F3n en la l\'EDnea {\b 42} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cr_cthis\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cr_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cr_cthis () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 54} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v cr_cthis_at\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:cr_cthis_at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> const {\b dig_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::cr_cthis_at ({\b size_t}  {\i k}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 70} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v crbegin\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:crbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::crbegin () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 277} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v crend\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:crend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::crend () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 281} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v data\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b dig_t} *const {\b NumRepr::reg_digs_t}< UINT_T, B, L >::data () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary=" sobrecarga de las funciones miembro : "> constexpr const dig_t* {\b data() const }noexcept;\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Devuelve\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definici\'F3n en la l\'EDnea {\b 679} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v data\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} * {\b NumRepr::reg_digs_t}< UINT_T, B, L >::data (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary=" sobrecarga de las funciones miembro : "> constexpr dig_t* {\b data()} noexcept;\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Devuelve\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definici\'F3n en la l\'EDnea {\b 670} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v dig_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:dig_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::dig_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 88} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a9d37af8b2ce4db142cb55a932d8fd805_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:dig_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::dig_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 90} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a3c8f7cb71f70468db3ba5ccef33bdd37_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:dig_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::dig_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 92} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a48a6ce4848e83ccea11c42c2deea38d9_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v dig_Bm2\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:dig_Bm2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::dig_Bm2 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 94} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_aae46074f8eb1e11d4856e2efc720e3b4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v empty\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::empty () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 288} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v end\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::end (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 271} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v fill\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::fill (const {\b dig_t} &  {\i value}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 300} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v front\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} const  & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::front () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 293} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v front\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::front (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 291} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v get_type_template_string_id_token\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:get_type_template_string_id_token}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::get_type_template_string_id_token (std::istream &  {\i is}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION GENERICA QUE CONSIGUE EL TOKEN TYPE PARA LA OBTENCION DEL OBJETO CORRESPONDIENTE POR TECLADO \par
}{
Definici\'F3n en la l\'EDnea {\b 1544} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v index_of_MSDig\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:index_of_MSDig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b int64_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::index_of_MSDig () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NOS DEVUELVE EL \'CDNDICE DEL D\'CDGITO NO 0 DE POTENCIA DE B MAS GRANDE NOS DEVUELVE 0 SI ES UN D\'CDGITO NO 0 NOS DEVUELVE -1 SI ES EL D\'CDGITO 0 CUALQUIER OTRO CASO NOS DAR\'C1 MAYOR QUE 0 \par
}{
Definici\'F3n en la l\'EDnea {\b 1280} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_ae61c65b1123284d829626a91335def03_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_0 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 790} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_aeeeab7c383624a617b1ea9a9b83bf43d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 803} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a2654ba7f2592f7b91f2dad311f33e683_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_any_B_pow\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_any_B_pow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_any_B_pow () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 934} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_B () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 825} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_B_pow\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_B_pow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} n> \par
requires (n<L-1)constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_B_pow () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 890} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_B_pow_m1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_B_pow_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} n> \par
requires (n<L)constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_B_pow_m1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 860} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 814} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a6142af29fa32e0fa1e0fcccf7f1493e5_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v is_Bp1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_Bp1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_Bp1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 842} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_filled_of\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_filled_of}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_filled_of ({\b dig_t}  {\i d}) const{\f2 [inline]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 965} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_filled_of_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_filled_of_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_filled_of_1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 949} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_filled_of_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_filled_of_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_filled_of_Bm1 () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 957} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v is_type_template_string_id\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:is_type_template_string_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::is_type_template_string_id (std::string  {\i in}){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
el parser/lexer del {\b reg_digs_t} }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funciones de ayuda para \par
}{
Definici\'F3n en la l\'EDnea {\b 1517} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v m_mer_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:m_mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::m_mer_B ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1237} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v m_rem_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:m_rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::m_rem_B ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1222} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v make_base_t\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:make_base_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static constexpr {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::make_base_t (const std::initializer_list< {\b dig_t} > &  {\i larg}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [private]}}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funcion miembro para generar un objeto tipo base_t y devolverlo desde un std::initializer_list<dig_t> }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<function name="make_base_t"></function> {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i const std::initializer_list<dig_t>& larg} \cell }{\cell }
{\row }
}
<returns="rarg : base_t">\par
}{
Definici\'F3n en la l\'EDnea {\b 334} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v max_size\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:max_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b size_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::max_size () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 286} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v mC_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:mC_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::mC_B (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1127} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a459dcc84f5a2ff05f229a2813eeca4eb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mC_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:mC_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::mC_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADORES ARITMETICOS {\b C_B()} {\b C_Bm1()} {\b mC_B()} {\b mC_Bm1()} {\b operator!()} {\b operator-()} \par
}{
Definici\'F3n en la l\'EDnea {\b 1119} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_aba51984e457f7e0cd28fa38c3454b38a_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_aba51984e457f7e0cd28fa38c3454b38a_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v mer_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:mer_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::mer_B ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1230} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v move_arg_N\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:move_arg_N}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::move_arg_N ({\b base_N_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [private]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funci\'F3n miembro (delegada) para mover un objeto tipo base_t desde una referencia derecha a un array cualquiera de {\b dig_t}. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<function name="copy_arg_N"></function> {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i const base_N_t<N> & arg} \cell }{\cell }
{\row }
}
<returns="void">\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Z < W or Z == W\par
}{
Definici\'F3n en la l\'EDnea {\b 435} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v normalize\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:normalize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<typename ... Ints_type> \par
requires ((sizeof...(Ints_type)) == L)static constexpr {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::normalize (Ints_type ...  {\i digits_pow_i}){\f2 [inline]}, {\f2 [static]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Funcion de normalizacion a dig_t (d\'EDgitos base B) que construye un objeto de tipo ">\par
<summary="base_t desde una sucesion variadica de enteros cualquiera">\par
<function name="normalize"></function> {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i Ints_type ... digits_pow_i} \cell }{\cell }
{\row }
}
<returns="base_t">\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< CREA UN STD_ARRAY DEL TIPO INT PASADO POR UN PACK DE ARGUMENTOS EL TAMANO ES EL DEL PACK DE ARGUMENTOS PASADO (MENOR O IGUAL QUE L)\par
< DEVUELVE EL TIPO INTERNO DE ELEMENTO DEL ARRAY ANTERIOR [UN TIPO ENTERO]\par
< DEVUELVE EL TAMANO DEL ARRAY ANTERIOR (TAMA\'D1O == L)\par
< ELIGE ENTRE CUATRO TIPOS DE ENTEROS SEGUN TENGAN SIGNO O NO Y SU TAMANO SEA MAYOR O MENOR QUE EL PROPIO DE LA BASE UINT_T TIPO PROPIO ES : UINT_T TIPO PASADO COMO ARGUMENTO ES : UNIQUE_TYPE LOS TIPOS PASADOS EN LOS ARGUMENTOS HAN DE SER IGUALES ENTRE SI PARA EL INTERROGANTE CONDICIONAL UTILIZAMOS UNSIGNED_INTEGRAL_C{\strike  PRIMERA PREGUNTA O MAS EXTERIOR IS_UNISGNED_SZ_GT_V<T,S> PREGUNTAS SEGUNDAS O MAS INTERIORES PARA ELEGIR EL TIPO APROPIADO EN CADA CASO USAMOS SIG_UINT_FOR_UINT_T<UINT_T> SIG_UINT_FOR_UINT_T<UNIQUE_TYPE> SIG_UINT_FOR_UINT_T<UINT_T> SIG_UINT_FOR_SINT_T<UNIQUE_TYPE>} \par
{\strike } \par
}{
Definici\'F3n en la l\'EDnea {\b 487} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_ab3cfc4aade78a43c2ec975477ba85912_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator Int_Type\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator Int_Type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c Int_Type> constexpr {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator Int_Type () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SE PODR\'CDA HACER PARA UINT128_T. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Algunas Conversiones \par
}{
Definici\'F3n en la l\'EDnea {\b 649} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a3ff2a749d367851189bc05a1687a0b22_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator!\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator!}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator! () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A partir de aqu\'ED no he hecho las sustituciones de const {\b reg_digs_t} & cthis\{*this\}; / {\b reg_digs_t} & cthis\{*this\}; / {\b reg_digs_t} cthis\{*this\}; Por las correspondientes funciones {\b cr_cthis()} / {\b r_cthis()} / {\b cp_cthis()} \par
}{
Definici\'F3n en la l\'EDnea {\b 1154} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator!=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >{\b ::operator!}= (const {\b dig_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1307} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator!=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >{\b ::operator!}= (const {\b reg_N_digs_t}< M > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1395} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator&\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator& (const {\b reg_digs_t}< UINT_T, B, L > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1269} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator&=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator&=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator&= (const {\b reg_digs_t}< UINT_T, B, L > &  {\i rarg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1260} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator-\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator- () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1158} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator< (const {\b dig_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1330} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator< (const {\b reg_N_digs_t}< M > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1449} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<<\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator<< ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERATORS >> >>= << <<= REM_B^n M_REM_B^n MER_B_N M_MER_B_N. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
MULTIPLY BY THE BASE B (10) << <<= DIVIDE BY THE BASE B (10) >> >>= REMAINDER BY THE BASE B (10) REM_B_N M_REM_B_N MULTIPLICATIVE CARRY BY THE BASE B (10) MER_B_N M_MER_B_N \par
}{
Definici\'F3n en la l\'EDnea {\b 1169} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<<=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator<<= ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO TO DO VOY POR AQUI CON EL TEMA DE LOS CTHIS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1182} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator<= (const {\b dig_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1352} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator<= (const {\b reg_N_digs_t}< M > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1482} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<=>\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr std::weak_ordering {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator<=> (const {\b dig_t} &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1503} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator<=>\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator<=>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr std::strong_ordering {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator<=> (const {\b reg_N_digs_t}< M > &  {\i arg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERADOR COMPARACION SPACESHIP C++20. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1490} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator= (const {\b dig_t} &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN DIGITO (CONVERSION) }}\par
{
Definici\'F3n en la l\'EDnea {\b 604} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_aa424868f7b7f2da2b989b2eb96ed1ed1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator= (const {\b reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sobrecarga del operador copia. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA CONST {\i NO}  COPIABLE DESDE REG_N_DIGS_T EN LA IZQUIERDA \par
}{
Definici\'F3n en la l\'EDnea {\b 573} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<type_traits::integral_c Int_Type> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator= (Int_Type  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION COPIA DESDE UN ENTERO (CONVERSION A LA BASE B) A UN REG_DIGS_T \par
}{
Definici\'F3n en la l\'EDnea {\b 617} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_ada84ccdb7769b08b7b91b1dae6452c09_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr const {\b base_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator= ({\b reg_N_digs_t}< N > &&  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR MOVIMIENTO DESDE REGS_N_DIGS_T EN LA QUE NO SE PUEDE COPIAR \par
}{
Definici\'F3n en la l\'EDnea {\b 595} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> constexpr {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator= ({\b reg_N_digs_t}< N > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION ASIGNACION POR COPIA REFERENCIA DESDE REG_N_DIGS_T EN LA IZQUIERDA \par
}{
Definici\'F3n en la l\'EDnea {\b 584} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator==\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator== (const {\b dig_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COMPARACIONES ENTRE BASE_T Y DIG_T EN FORMA BASE_T @ DIG_T. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DE LOS OPERADORES DE COMPARACION Y ORDEN \par
}{
Definici\'F3n en la l\'EDnea {\b 1296} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator==\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator== (const {\b reg_N_digs_t}< M > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
COMPARACIONES ENTRE REG_DIGS_T Y REG_N_DIGS_T HETEROGENEOS EN GENERAL EN FORMA REG_DIGS_T @ REG_N_DIGS_T<M> \par
}{
Definici\'F3n en la l\'EDnea {\b 1368} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator> (const {\b dig_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1319} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator> (const {\b reg_N_digs_t}< M > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1422} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator>= (const {\b dig_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1341} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} M> constexpr bool {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator>= (const {\b reg_N_digs_t}< M > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1476} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>>\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator>> ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1208} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator>>=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator>>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator>>= ({\b size_t}  {\i n}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1194} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator[]\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b dig_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator[] ({\b size_t}  {\i ix}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Sobrecarga del const dig_t & operator[](size_t) const"> }}\par
{
Definici\'F3n en la l\'EDnea {\b 690} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator[]\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b dig_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator[] ({\b size_t}  {\i ix}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
<summary="Sobrecarga del dig_t & operator[](size_t)"> }}\par
{
Definici\'F3n en la l\'EDnea {\b 696} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator|\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator|}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator| (const {\b reg_digs_t}< UINT_T, B, L > &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1253} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v operator|=\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:operator|=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr const {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::operator|= (const {\b base_t} &  {\i rarg}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1244} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v r_base_cthis\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:r_base_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b base_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::r_base_cthis (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de referencias a la clase base }}\par
{
Definici\'F3n en la l\'EDnea {\b 38} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v r_cthis\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:r_cthis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b reg_digs_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::r_cthis (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
devolucion de referencias de la clase actual }}\par
{
Definici\'F3n en la l\'EDnea {\b 50} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v r_cthis_at\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:r_cthis_at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> {\b dig_t} & {\b NumRepr::reg_digs_t}< UINT_T, B, L >::r_cthis_at ({\b size_t}  {\i k}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 66} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v rbegin\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::rbegin (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 275} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IDEM QUE ANTES PERO CON LA CLASE DERIVADA, LA ACTUAL TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }}\par
{
Definici\'F3n en la l\'EDnea {\b 230} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_ad04bdf9bcccd5c68c414b2cca9e9bc75_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 235} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a9d2524d7b34e2e1b7d98ec3a16ccac67_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 245} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a8f86da208d0c9e947caea1a283711414_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_base_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
IDEM QUE ANTES PERO CON EL TIPO BASE_T ESPECIALIZANDO AL TIPO BASE_N_T<L> DONDE BASE_T == BASE_N_T<L> TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }}\par
{
Definici\'F3n en la l\'EDnea {\b 195} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 200} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 210} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 205} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_N_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_N_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_N_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PARA EL TIPO-TEMPLATE BASE_N_T OBTENEMOS CONSTANTES INMEDIATAS TENEMOS CUIDADO DE CREAR UN RVALUE TEMPORAL. }}\par
{
Definici\'F3n en la l\'EDnea {\b 132} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_N_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_N_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_N_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 142} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_N_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_N_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_N_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 158} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_N_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_N_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N> static consteval {\b base_N_t}< N > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_N_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 150} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_N_pow_n_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_N_pow_n_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} n> \par
requires ((n>=0)&&(n < N))static consteval {\b base_N_t}< N > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_N_pow_n_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 167} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_N_pow_n_B_m1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_N_pow_n_B_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} n> \par
requires ((n>=0)&&(n < N))static consteval {\b base_N_t}< N > {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_N_pow_n_B_m1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 176} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_pow_n_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_pow_n_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_pow_n_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 215} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_base_pow_n_B_m1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_base_pow_n_B_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b base_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_base_pow_n_B_m1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 220} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v regd_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 240} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_af02f9cc5afcc26fb14077a939c26ce85_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_pow_n_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_pow_n_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_pow_n_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 250} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_af4fa7fec5b40b63434a86ee594adaed1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v regd_pow_n_B_m1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:regd_pow_n_B_m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::regd_pow_n_B_m1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 255} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a1e76f417daec0f07cb28088baec9fb29_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v rem_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:rem_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b reg_digs_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::rem_B ({\b size_t}  {\i n}) const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1215} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v rend\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr decltype(auto) {\b NumRepr::reg_digs_t}< UINT_T, B, L >::rend (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 279} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v reverse\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:reverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::reverse (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 304} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_0 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Funciones que ponen a constantes (constexpr) los objetos base_t. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros del template\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size_t} \cell }{\cell }
{\row }
}
<nontypeparam name="N"></nontypeparam> {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i this} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Devuelve\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}}{
Definici\'F3n en la l\'EDnea {\b 710} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_abc257d67bb67ef69b1a2491e58a705e1_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 714} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a6808c754c084ff40f4d106cf42c6f350_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 719} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a635891fe476a0d485b6430eb003c66ff_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v set_dig\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_dig ({\b dig_t}  {\i d}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 724} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_fill_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_fill_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_fill_1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 733} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_fill_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_fill_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_fill_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 738} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_fill_dig\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_fill_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_fill_dig ({\b dig_t}  {\i d}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 729} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_interval_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_interval_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_interval_0 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"Funciones que ponen a constantes(constexpr) los objetos un subintervalo
o subrango de base_t cualquiera" }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros del template\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size_t} \cell }{\cell }
{\row }
}
<nontypeparam name="N_i"></nontypeparam> <nontypeparam name="N_pf"></nontypeparam> {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Par\'E1metros\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i this} \cell }{\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Devuelve\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
\par
}}OPERACION DE PONER A VALOR DIG_0 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> \par
}{
Definici\'F3n en la l\'EDnea {\b 758} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_interval_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_interval_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N, {\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_interval_Bm1 (){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG_Bm1 DEL ARRAY DESDE [N_0 , N_1) EN BASE_N_T<N> \par
}{
Definici\'F3n en la l\'EDnea {\b 769} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v set_interval_dig\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:set_interval_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} N_i, {\b size_t} N_pf> \par
requires ((N_i < N_pf)&&(N_pf <= L))constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::set_interval_dig ({\b dig_t}  {\i dig}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OPERACION DE PONER A VALOR DIG DEL ARRAY DESDE [N_0 , N_1) EN BASE_T summary="Funciones comparativas con constantes tipo constexpr"> param name="this">\par
returns="bool">\par
}{
Definici\'F3n en la l\'EDnea {\b 780} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v size\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr {\b size_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::size () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 284} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v size_of_type_template_string_id\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:size_of_type_template_string_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static {\b size_t} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::size_of_type_template_string_id (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1537} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v ssi_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ssi_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_SINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ssi_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 114} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_ac1cf8584292927fea378bde2e3172fce_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ssi_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_SINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ssi_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 116} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_af598442408cf2ed05923092e2ccb7cd2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ssi_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_SINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ssi_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 120} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a80fbaa972abc3ee57f5e8561eb4e944d_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ssi_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_SINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ssi_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 118} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a5e0248eb0b0cef64dcbf5fb87823714e_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ssi_Bp1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ssi_Bp1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_SINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ssi_Bp1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 122} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_ae6d6e6d6877d2fe389cdbacbaf7a6f63_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v subregister\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:subregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> template<{\b size_t} ibegin, {\b size_t} iend> \par
requires ((iend <= L)&&(ibegin < L)&&(ibegin != iend))constexpr {\b reg_N_digs_t}<(ibegin< iend)?(iend-ibegin):(ibegin-iend)> {\b NumRepr::reg_digs_t}< UINT_T, B, L >::subregister () const{\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TAKE A SUBREGISTER OF A REGISTER OF DIGITS. }}\par
{
Definici\'F3n en la l\'EDnea {\b 1095} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v sui_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:sui_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_UINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::sui_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 104} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a869fb55d18546d9f677b47fd1dd1d8bd_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:sui_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_UINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::sui_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 106} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a80e523569503af77fdf36cada4de6700_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:sui_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_UINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::sui_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 110} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_adaa8d7c0417ae7a7e76237ba2d368ede_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:sui_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_UINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::sui_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 108} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a51dd71f63e7ccf1c92adbe3876a5eb19_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v sui_Bp1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:sui_Bp1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval {\b SIG_UINT_T} {\b NumRepr::reg_digs_t}< UINT_T, B, L >::sui_Bp1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 112} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_af47bb7bcb365e6060f836ec7d53c8565_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v swap\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> constexpr void {\b NumRepr::reg_digs_t}< UINT_T, B, L >::swap ({\b base_t} &  {\i other}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 302} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v to_type_template_string_id\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:to_type_template_string_id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static std::string {\b NumRepr::reg_digs_t}< UINT_T, B, L >::to_type_template_string_id (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1533} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v ui_0\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ui_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval UINT_T {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ui_0 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 96} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_aa6b20e53fc72fb5353a27a5db5205ea2_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ui_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval UINT_T {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ui_1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 98} del archivo {\b reg_digs_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "struct_num_repr_1_1reg__digs__t_a1ba13ed518c031c71ccd2aa99292c4f5_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v ui_B\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ui_B}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval UINT_T {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ui_B (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 102} del archivo {\b reg_digs_t.hpp}.}\par
}
{\xe \v ui_Bm1\:NumRepr::reg_digs_t< UINT_T, B, L >}
{\xe \v NumRepr::reg_digs_t< UINT_T, B, L >\:ui_Bm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<uint_type_for_radix_c UINT_T, UINT_T B, {\b size_t} L> static consteval UINT_T {\b NumRepr::reg_digs_t}< UINT_T, B, L >::ui_Bm1 (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 100} del archivo {\b reg_digs_t.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reg_digs_t.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, oper >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, oper >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, oper >}
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
auxiliary types for digit type and its operations }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b binop_e} oper>\par
struct NumRepr::auxiliary_types::resbinop_t< T, oper >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
auxiliary types for digit type and its operations \par
}{
Definici\'F3n en la l\'EDnea {\b 37} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >}
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b content}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b carry}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 40} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v carry\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >\:carry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::add} >::carry}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 42} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v content\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >\:content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::add} >::content}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 41} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >}
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b quotient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b no_div_by_0}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 65} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v no_div_by_0\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >\:no_div_by_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::div} >::no_div_by_0}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 67} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v quotient\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >\:quotient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::div} >::quotient}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 66} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >}
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b quotient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b remainder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b no_div_by_0}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 58} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v no_div_by_0\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >\:no_div_by_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::fediv} >::no_div_by_0}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 61} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v quotient\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >\:quotient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::fediv} >::quotient}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 59} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v remainder\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >\:remainder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::fediv} >::remainder}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 60} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >}
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b low_content}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b high_content}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 52} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v high_content\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >\:high_content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::mult} >::high_content}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 54} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v low_content\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >\:low_content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::mult} >::low_content}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 53} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >}
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b remainder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b no_div_by_0}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 71} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v no_div_by_0\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >\:no_div_by_0}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::rem} >::no_div_by_0}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 73} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v remainder\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >\:remainder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::rem} >::remainder}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 72} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >}
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b content}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b borrow}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 46} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v borrow\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >\:borrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::sub} >::borrow}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 48} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v content\:NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >}
{\xe \v NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >\:content}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T {\b NumRepr::auxiliary_types::resbinop_t}< T, {\b binop_e::sub} >::content}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 47} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, oper, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, oper, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, oper, N >}
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b binop_e} oper, {\b size_t} N>\par
requires (N>0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, oper, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >}
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_low}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b carry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b good_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b size_t} N>\par
requires (N > 0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 82} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v carry\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >\:carry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> T {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::add}, N >::carry}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 84} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v good_result\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >\:good_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> bool {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::add}, N >::good_result}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 85} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_low\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >\:result_content_low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::add}, N >::result_content_low}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 83} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >}
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_quotient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b good_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b size_t} N>\par
requires (N > 0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 114} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v good_result\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >\:good_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> bool {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::div}, N >::good_result}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 116} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_quotient\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >\:result_content_quotient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::div}, N >::result_content_quotient}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 115} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >}
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_quotient}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_remainder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b good_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b size_t} N>\par
requires (N > 0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 106} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v good_result\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >\:good_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> bool {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::fediv}, N >::good_result}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 109} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_quotient\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >\:result_content_quotient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::fediv}, N >::result_content_quotient}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 107} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_remainder\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >\:result_content_remainder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::fediv}, N >::result_content_remainder}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 108} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >}
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_low}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_high}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b good_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b size_t} N>\par
requires (N > 0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 98} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v good_result\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >\:good_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> bool {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::mult}, N >::good_result}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 101} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_high\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >\:result_content_high}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::mult}, N >::result_content_high}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 100} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_low\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >\:result_content_low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::mult}, N >::result_content_low}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 99} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >}
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_remainder}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b good_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b size_t} N>\par
requires (N > 0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 121} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v good_result\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >\:good_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> bool {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::rem}, N >::good_result}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 123} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_remainder\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >\:result_content_remainder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::rem}, N >::result_content_remainder}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 122} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >\par \pard\plain 
{\tc\tcl2 \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >}
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
\par
{
{\f2 #include <auxiliary_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::array< T, N > {\b result_content_low}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b borrow}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b good_result}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, {\b size_t} N>\par
requires (N > 0)\par
struct NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 90} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v borrow\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >\:borrow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> T {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::sub}, N >::borrow}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 92} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v good_result\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >\:good_result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> bool {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::sub}, N >::good_result}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 93} del archivo {\b auxiliary_types.hpp}.}\par
}
{\xe \v result_content_low\:NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >}
{\xe \v NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >\:result_content_low}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , {\b size_t} N> std::array<T,N> {\b NumRepr::auxiliary_types::result_operation_t}< T, {\b binop_e::sub}, N >::result_content_low}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 91} del archivo {\b auxiliary_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b auxiliary_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par \pard\plain 
{\tc\tcl2 \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TEMPLATE GENERAL. }}\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::int64_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval decltype(auto) {\b build} () noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b unit} = static_cast<std::int64_t>(1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b value} \{IntObj_ct\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b begin_value} \{BeginIntObj_ct\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b end_value} \{EndIntObj_ct\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt>\par
requires ((BeginIntObj_ct >= EndIntObj_ct)&&(IntObj_ct >= BeginIntObj_ct))\par
struct utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TEMPLATE GENERAL. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
OBTENER UNA TUPLA EN TIEMPO DE COMPILACION DONDE CADA POSICION ESTA INICIALIZADA PERO CON UNA LLAMADA DISTINTA A FUNCION POR CADA INDICE \par
}{
Definici\'F3n en la l\'EDnea {\b 232} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> using {\b utilities::special::tuple_builder_t}< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::type =  std::int64_t}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 234} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v build\:utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> static consteval decltype(auto) {\b utilities::special::tuple_builder_t}< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::build (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 243} del archivo {\b utilities.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structutilities_1_1special_1_1tuple__builder__t_a8e1ed3d327091c5f21f835adea83ec3f_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
Gr\'E1fico de llamadas a esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structutilities_1_1special_1_1tuple__builder__t_a8e1ed3d327091c5f21f835adea83ec3f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v begin_value\:utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:begin_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::begin_value \{BeginIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 239} del archivo {\b utilities.hpp}.}\par
}
{\xe \v end_value\:utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:end_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::end_value \{EndIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 240} del archivo {\b utilities.hpp}.}\par
}
{\xe \v unit\:utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:unit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::unit = static_cast<std::int64_t>(1){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 236} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t IntObj_ct, std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::value \{IntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 238} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par \pard\plain 
{\tc\tcl2 \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == BEGININTOBJ_CT. }}\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::int64_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval decltype(auto) {\b build} () noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b type} {\b unit} = 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b type} {\b value} \{BeginIntObj_ct\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b type} {\b begin_value} \{BeginIntObj_ct\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b type} {\b end_value} \{EndIntObj_ct\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt>\par
requires (BeginIntObj_ct <= EndIntObj_ct)\par
struct utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == BEGININTOBJ_CT. \par
}{
Definici\'F3n en la l\'EDnea {\b 287} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> using {\b utilities::special::tuple_builder_t}< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::type =  std::int64_t}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 289} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v build\:utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> static consteval decltype(auto) {\b utilities::special::tuple_builder_t}< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::build (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 298} del archivo {\b utilities.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structutilities_1_1special_1_1tuple__builder__t_3_01_begin_int_obj__ct_00_01_begin_int_obj__ct_0acf174306e1877482e57b362979e4e21_a86b75b979de0c5767a791bb4b0731793_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v begin_value\:utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:begin_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr {\b type} {\b utilities::special::tuple_builder_t}< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::begin_value \{BeginIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 294} del archivo {\b utilities.hpp}.}\par
}
{\xe \v end_value\:utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:end_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr {\b type} {\b utilities::special::tuple_builder_t}< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::end_value \{EndIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 295} del archivo {\b utilities.hpp}.}\par
}
{\xe \v unit\:utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:unit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr {\b type} {\b utilities::special::tuple_builder_t}< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::unit = 1{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 291} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr {\b type} {\b utilities::special::tuple_builder_t}< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::value \{BeginIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 293} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par \pard\plain 
{\tc\tcl2 \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == ENDINTOBJ_CT-1. }}\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = std::int64_t\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
M\'E9todos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static consteval decltype(auto) {\b build} () noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b unit} = static_cast<std::int64_t>(1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b value} \{EndIntObj_ct-{\b unit}\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b begin_value} \{BeginIntObj_ct\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr std::int64_t {\b end_value} \{EndIntObj_ct\}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt>\par
struct utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == ENDINTOBJ_CT-1. \par
}{
Definici\'F3n en la l\'EDnea {\b 261} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v type\:utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> using {\b utilities::special::tuple_builder_t}< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::type =  std::int64_t}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 263} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones miembro\par
\pard\plain 
{\xe \v build\:utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:build}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> static consteval decltype(auto) {\b utilities::special::tuple_builder_t}< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::build (){\f2 [inline]}, {\f2 [static]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 272} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v begin_value\:utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:begin_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::begin_value \{BeginIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 268} del archivo {\b utilities.hpp}.}\par
}
{\xe \v end_value\:utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:end_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::end_value \{EndIntObj_ct\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 269} del archivo {\b utilities.hpp}.}\par
}
{\xe \v unit\:utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:unit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::unit = static_cast<std::int64_t>(1){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 265} del archivo {\b utilities.hpp}.}\par
}
{\xe \v value\:utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr std::int64_t {\b utilities::special::tuple_builder_t}< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::value \{EndIntObj_ct-{\b unit}\}{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 267} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par \pard\plain 
{\tc\tcl2 \v utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
\par
{
{\f2 #include <utilities.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr auto {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt>\par
requires (BeginIntObj_ct < EndIntObj_ct)\par
struct utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 318} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v value\:utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}
{\xe \v utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr auto {\b utilities::special::tuple_user_constructor_t}< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >::value{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Valor inicial:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid =\par
                tuple_builder_t<\par
                                BeginIntObj_ct,\par
                                BeginIntObj_ct,\par
                                EndIntObj_ct,\par
                                Base,\par
                                Funct_tt\par
                >::build()\par
}
{
Definici\'F3n en la l\'EDnea {\b 319} del archivo {\b utilities.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b utilities.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, T Radix>\par
struct NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 577} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b UIntType} = std::conditional_t< {\b uint_value}<={\b uint_value_0_max}, {\b uchint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_1_max}, {\b usint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_2_max}, {\b uint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_3_max}, {\b ulint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_4_max}, {\b ullint_t}, {\b uint128_t} > > > > >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_0_max} = static_cast<{\b ullint_t}>({\b maxbase}<{\b uchint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_1_max} = static_cast<{\b ullint_t}>({\b maxbase}<{\b usint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_2_max} = static_cast<{\b ullint_t}>({\b maxbase}<{\b uint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_3_max} = static_cast<{\b ullint_t}>({\b maxbase}<{\b ulint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_4_max} = static_cast<{\b ullint_t}>({\b maxbase}<{\b ullint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value} = static_cast<{\b ullint_t}>(Radix)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<integral_c T, T Radix>\par
requires (Radix > 1)\par
struct NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINICION PARA ESPECIALIZACION TYPE_TRAITS::UINT_TYPE_FOR_RADIX FOR RADIX VALID \par
}{
Definici\'F3n en la l\'EDnea {\b 582} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v UIntType\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:UIntType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> using {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::UIntType =  std::conditional_t< {\b uint_value} <= {\b uint_value_0_max}, {\b uchint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_1_max}, {\b usint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_2_max}, {\b uint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_3_max}, {\b ulint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_4_max}, {\b ullint_t}, {\b uint128_t} > > > > >}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 589} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v uint_value\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:uint_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::uint_value = static_cast<{\b ullint_t}>(Radix){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 588} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_0_max\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:uint_value_0_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::uint_value_0_max = static_cast<{\b ullint_t}>({\b maxbase}<{\b uchint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 583} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_1_max\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:uint_value_1_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::uint_value_1_max = static_cast<{\b ullint_t}>({\b maxbase}<{\b usint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 584} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_2_max\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:uint_value_2_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::uint_value_2_max = static_cast<{\b ullint_t}>({\b maxbase}<{\b uint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 585} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_3_max\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:uint_value_3_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::uint_value_3_max = static_cast<{\b ullint_t}>({\b maxbase}<{\b ulint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 586} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_4_max\:NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >\:uint_value_4_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix}< T, Radix >::uint_value_4_max = static_cast<{\b ullint_t}>({\b maxbase}<{\b ullint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 587} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T, T Radix>\par
struct NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\par
}
\par
{
Definici\'F3n en la l\'EDnea {\b 629} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia de la plantilla de la Estructura NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\par \pard\plain 
{\tc\tcl2 \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
\par
{
{\f2 #include <basic_types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Tipos p\'FAblicos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b UIntType} = std::conditional_t< {\b uint_value}<={\b uint_value_0_max}, {\b uchint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_1_max}, {\b usint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_2_max}, {\b uint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_3_max}, {\b ulint_t}, std::conditional_t< {\b uint_value}<={\b uint_value_4_max}, {\b ullint_t}, {\b uint128_t} > > > > >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Atributos p\'FAblicos est\'E1ticos\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_0_max} = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b uchint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_1_max} = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b usint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_2_max} = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b uint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_3_max} = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b ulint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value_4_max} = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b ullint_t}>())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr {\b ullint_t} {\b uint_value} = static_cast<{\b ullint_t}>(Radix)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Descripci\'F3n detallada\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<integral_c T, T Radix>\par
requires (Radix > 1)\par
struct NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINICION PARA ESPECIALIZACION TYPE_TRAITS::UINT_TYPE_FOR_RADIX_WITH_CONTAINS_MULT_RESULT FOR RADIX VALID \par
}{
Definici\'F3n en la l\'EDnea {\b 634} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'Typedef' miembros de la clase\par
\pard\plain 
{\xe \v UIntType\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:UIntType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> using {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::UIntType =  std::conditional_t< {\b uint_value} <= {\b uint_value_0_max}, {\b uchint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_1_max}, {\b usint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_2_max}, {\b uint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_3_max}, {\b ulint_t}, std::conditional_t< {\b uint_value} <= {\b uint_value_4_max}, {\b ullint_t}, {\b uint128_t} > > > > >}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 641} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los datos miembro\par
\pard\plain 
{\xe \v uint_value\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:uint_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::uint_value = static_cast<{\b ullint_t}>(Radix){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 640} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_0_max\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:uint_value_0_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::uint_value_0_max = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b uchint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 635} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_1_max\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:uint_value_1_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::uint_value_1_max = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b usint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 636} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_2_max\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:uint_value_2_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::uint_value_2_max = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b uint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 637} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_3_max\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:uint_value_3_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::uint_value_3_max = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b ulint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 638} del archivo {\b basic_types.hpp}.}\par
}
{\xe \v uint_value_4_max\:NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}
{\xe \v NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >\:uint_value_4_max}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<integral_c T, T Radix> constexpr {\b ullint_t} {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult}< T, Radix >::uint_value_4_max = static_cast<{\b ullint_t}>({\b sqrt_max}<{\b ullint_t}>()){\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 639} del archivo {\b basic_types.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
La documentaci\'F3n para esta estructura fue generada a partir del siguiente fichero:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_types.hpp}}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documentaci\'F3n de archivos{\tc \v Documentaci\'F3n de archivos}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo auxiliary_functions.hpp\par \pard\plain 
{\tc\tcl2 \v auxiliary_functions.hpp}
{\xe \v auxiliary_functions.hpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "auxiliary_types.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para auxiliary_functions.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "auxiliary__functions_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "auxiliary__functions_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::auxiliary_functions}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr sign_e {\b NumRepr::Char2Sign} (char ch) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::arith_integral_c IntT> constexpr sign_e {\b NumRepr::Int2Sign} (IntT nu) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::arith_integral_c IntT> constexpr sign_funct_e {\b NumRepr::Int2SignFunct} (IntT nu) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::arith_natural_c NatIntT> constexpr sign_funct_e {\b NumRepr::Nat2SignFunct} (NatIntT nu) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr size_t {\b NumRepr::detail::ceilsqrt} (size_t n, size_t low, size_t high) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr size_t {\b NumRepr::detail::ceilsqrt} (size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b NumRepr::detail::find_factor} (size_t n, size_t low, size_t high) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b NumRepr::auxiliary_functions::is_prime} (size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr bool {\b NumRepr::auxiliary_functions::is_power_of_2} (uint128_t num) noexcept\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
auxiliary_functions.hpp\par \pard\plain 
{\tc\tcl2 \v auxiliary_functions.hpp}
{\xe \v auxiliary_functions.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AUXILIARY_FUNCTIONS_HPP_INCLUDED}\par
00002 {\cf21 #define AUXILIARY_FUNCTIONS_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "auxiliary_types.hpp"}\par
00005 \par
00006 {\cf17 namespace }NumRepr \{\par
00007 \par
00008 {\cf17 constexpr} {\cf17 inline}\par
00009 sign_e Char2Sign({\cf18 char} ch) {\cf17 noexcept}\par
00010 \{\par
00011         {\cf19 if} (ch <= {\cf23 ','})\par
00012                 {\cf19 return} sign_e::vplus;\par
00013         {\cf19 else}\par
00014                 {\cf19 return} sign_e::vminus;\par
00015 \}\par
00016 \par
00017 {\cf17 template}<type_traits::arith_{\cf18 int}egral_c IntT>\par
00018 {\cf17 constexpr} {\cf17 inline}\par
00019 sign_e Int2Sign (IntT nu) {\cf17 noexcept}\par
00020 \{\par
00021         {\cf19 if} (nu < 0)\par
00022                 {\cf19 return} sign_e::vminus;\par
00023         {\cf19 else}\par
00024                 {\cf19 return} sign_e::vplus;\par
00025 \}\par
00026 \par
00027 {\cf17 template}<type_traits::arith_{\cf18 int}egral_c IntT>\par
00028 {\cf17 constexpr} {\cf17 inline}\par
00029 sign_funct_e Int2SignFunct(IntT nu) {\cf17 noexcept}\par
00030 \{\par
00031         {\cf19 if} (nu < 0)\par
00032                 {\cf19 return} sign_funct_e::vminus;\par
00033         {\cf19 else} {\cf19 if} (nu > 0)\par
00034                 {\cf19 return} sign_funct_e::vplus;\par
00035         {\cf19 else}\par
00036                 {\cf19 return} sign_funct_e::vzero;\par
00037 \}\par
00038 \par
00039 {\cf17 template}<type_traits::arith_natural_c NatIntT>\par
00040 {\cf17 constexpr} {\cf17 inline}\par
00041 sign_funct_e Nat2SignFunct(NatIntT nu) {\cf17 noexcept}\par
00042 \{\par
00043         {\cf19 if} (nu==0)\par
00044                 {\cf19 return} sign_funct_e::vzero;\par
00045         {\cf19 else}\par
00046                 {\cf19 return} sign_funct_e::vplus;\par
00047 \}\par
00048 \par
00049 {\cf17 namespace }detail \{\par
00050 {\cf20 // precondition: low*low <= n, high*high > n.}\par
00051 {\cf17 constexpr} {\cf17 inline}\par
00052 {\cf18 size_t} ceilsqrt({\cf18 size_t} n,{\cf18 size_t} low,{\cf18 size_t} high) {\cf17 noexcept}\par
00053 \{\par
00054   {\cf17 const} {\cf17 auto} mid\{std::midpoint(low, high)\};\par
00055   {\cf17 const} {\cf17 auto} sqmid\{mid*mid\};\par
00056   {\cf19 return}\par
00057         (\par
00058                 (low + 1 >= high)       ?\par
00059                         high                    :\par
00060                         (sqmid == n)            ?\par
00061                                 mid                     :\par
00062                                 (sqmid <  n)            ?\par
00063                                         ceilsqrt(n, mid, high)  :\par
00064                                         ceilsqrt(n, low, mid)\par
00065         );\par
00066 \}\par
00067 \par
00068 {\cf20 // returns ceiling(sqrt(n))}\par
00069 {\cf17 constexpr} {\cf17 inline}\par
00070 {\cf18 size_t} ceilsqrt({\cf18 size_t} n) {\cf17 noexcept}\par
00071 \{\par
00072   {\cf17 const} {\cf17 auto} num_max_dig\{std::numeric_limits<std::size_t>::digits\};\par
00073   {\cf19 return}\par
00074         (\par
00075                 (n < 3) ?\par
00076                         n       :\par
00077                         ceilsqrt(\par
00078                                 n,\par
00079                                 1,\par
00080                                 std::size_t(1) << (num_max_dig / 2)\par
00081                         )\par
00082         );\par
00083 \}\par
00084 \par
00085 {\cf20 // returns true if n divisible by an odd integer in}\par
00086 {\cf20 // [2 * low + 1, 2 * high + 1).}\par
00087 {\cf17 constexpr} {\cf17 inline}\par
00088 {\cf18 bool} find_factor({\cf18 size_t} n,{\cf18 size_t} low,{\cf18 size_t} high) {\cf17 noexcept}\par
00089 \{\par
00090   {\cf17 const} {\cf17 auto} mid\{std::midpoint(low, high)\};\par
00091   {\cf19 return}\par
00092         (\par
00093                 (low + 1 >= high)                               ?\par
00094                         (n % (2 * low + 1)) == 0        :\par
00095                         (\par
00096                                 find_factor(n, low, mid)\par
00097                                 ||\par
00098                                 find_factor(n, mid, high)\par
00099                         )\par
00100         );\par
00101 \}\par
00102 \}\par
00103 {\cf17 namespace }auxiliary_functions \{\par
00104         {\cf17 constexpr} {\cf17 inline}\par
00105         {\cf18 bool} is_prime({\cf18 size_t} n) {\cf17 noexcept}\par
00106         \{\par
00107                 {\cf19 if} (n < 2)\par
00108                         {\cf19 return} {\cf17 false};\par
00109                 {\cf19 else} {\cf19 if} ((n==2)||(n==3))\par
00110                         {\cf19 return} {\cf17 true};\par
00111                 {\cf19 else}\par
00112                         {\cf19 return} (!detail::find_factor(n, 1, (detail::ceilsqrt(n) + 1) / 2));\par
00113         \}\par
00114         {\cf17 constexpr} {\cf17 inline}\par
00115         {\cf18 bool} is_power_of_2(uint128_t num) {\cf17 noexcept}\par
00116         \{\par
00117                 {\cf19 if}((num % 2) != 0)\par
00118                         {\cf19 return} {\cf17 false};\par
00119                 {\cf19 else}\par
00120                         {\cf19 return} is_power_of_2(num / 2);\par
00121         \}\par
00122 \}\par
00123 \}\par
00124 {\cf21 #endif }{\cf20 // AUXILIARY_FUNCTIONS_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo auxiliary_types.hpp\par \pard\plain 
{\tc\tcl2 \v auxiliary_types.hpp}
{\xe \v auxiliary_types.hpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "basic_types.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para auxiliary_types.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "auxiliary__types_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "auxiliary__types_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::add >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::sub >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::mult >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::fediv >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::div >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::resbinop_t< T, binop_e::rem >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::add, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::sub, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::mult, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::fediv, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::div, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::auxiliary_types::result_operation_t< T, binop_e::rem, N >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::auxiliary_types}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeraciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::sign_e} : bool \{ {\b NumRepr::vminus} = true
, {\b NumRepr::vplus} = false
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::sign_funct_e} : char \{ {\b NumRepr::vzero} = 0
, {\b NumRepr::vminus} = -1
, {\b NumRepr::vplus} = +1
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
INTRODUCIDO. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::dig_format_e} : unsigned char \{ {\b NumRepr::BINnat} =0
, {\b NumRepr::BCDnat} =1
, {\b NumRepr::BCDexc3} =2
, {\b NumRepr::BCDaitk} =3
, {\b NumRepr::johnson_n} =4
, {\b NumRepr::biquinario} =5
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::num_type_e} : unsigned char \{ {\b NumRepr::natural} =0
, {\b NumRepr::entero} =1
, {\b NumRepr::racional} =2
, {\b NumRepr::real} =3
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A INTRODUCIR. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::nat_num_format_e} : bool \{ {\b NumRepr::natural} =false
, {\b NumRepr::exc_n} =true
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
YA INTRODUCIDO, PERO NO EXPLICITAMENTE NI COMPLETAMENTE. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::int_num_format_e} : unsigned char \{ {\b NumRepr::int_CB} =0
, {\b NumRepr::int_CBm1} =1
, {\b NumRepr::int_MS} =2
, {\b NumRepr::int_EXC_n} =3
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO NATURAL. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::rat_num_format_e} : unsigned char \{ {\b NumRepr::pair_num_den} =0
, {\b NumRepr::fxd_pt} =1
, {\b NumRepr::flt_pt} =2
 \}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
EN C_B YA QUEDA EN MS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::binop_e} \{ {\b NumRepr::add}
, {\b NumRepr::sub}
, {\b NumRepr::mult}
, {\b NumRepr::div}
, {\b NumRepr::rem}
, {\b NumRepr::fediv}
, {\b NumRepr::other}
 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
auxiliary_types.hpp\par \pard\plain 
{\tc\tcl2 \v auxiliary_types.hpp}
{\xe \v auxiliary_types.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AUXILIARY_TYPES_HPP_INCLUDED}\par
00002 {\cf21 #define AUXILIARY_TYPES_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "basic_types.hpp"}\par
00005 \par
00006 {\cf17 namespace }NumRepr \{\par
00007 \par
00008 {\cf20                                         /****************************/}\par
00009                                         {\cf20 //}\par
00010                                         {\cf20 //      SIGNO}\par
00011                                         {\cf20 //}\par
00012 {\cf20                                         /****************************/}\par
00013 \par
00014 \par
00015 {\cf17 enum class} sign_e : {\cf18 bool} \{vminus = {\cf17 true},vplus = {\cf17 false}\};\par
00016 {\cf17 enum class} sign_funct_e : {\cf18 char} \{vzero = 0, vminus = -1, vplus = +1\};\par
00017 {\cf17 enum class} dig_format_e : {\cf18 unsigned} {\cf18 char} \{\par
00018         BINnat=0 , BCDnat=1 , BCDexc3=2 , BCDaitk=3 , johnson_n=4 , biquinario=5\};\par
00019 {\cf17 enum class} num_type_e : {\cf18 unsigned} {\cf18 char} \{\par
00020         natural=0  , entero=1   , racional=2 , real=3\par
00021 \}; \par
00022 {\cf17 enum class} nat_num_format_e : {\cf18 bool} \{\par
00023         natural=false  , exc_n={\cf17 true}\par
00024 \}; \par
00025 {\cf17 enum class} int_num_format_e : {\cf18 unsigned} {\cf18 char} \{\par
00026         int_CB=0 , int_CBm1=1 , int_MS=2  , int_EXC_n=3\par
00027 \};  \par
00028 {\cf17 enum class} rat_num_format_e : {\cf18 unsigned} {\cf18 char} \{\par
00029         pair_num_den=0 , fxd_pt=1 , flt_pt=2\par
00030 \};\par
00031 \par
00032 {\cf17 enum class} binop_e \{add,sub,mult,div,rem,fediv,other\};\par
00033 \par
00034 {\cf17 namespace }auxiliary_types \{\par
00036 {\cf17 template}<{\cf17 typename} T,binop_e oper>\par
00037 {\cf17 struct }resbinop_t;\par
00038 \par
00039 {\cf17 template}<{\cf17 typename} T>\par
00040 {\cf17 struct }resbinop_t<T,binop_e::add> \{\par
00041         T                                               content;\par
00042         T                                               carry;\par
00043 \};\par
00044 \par
00045 {\cf17 template}<{\cf17 typename} T>\par
00046 {\cf17 struct }resbinop_t<T,binop_e::sub> \{\par
00047         T                                               content;\par
00048         T                                               borrow;\par
00049 \};\par
00050 \par
00051 {\cf17 template}<{\cf17 typename} T>\par
00052 {\cf17 struct }resbinop_t<T,binop_e::mult> \{\par
00053         T                       low_content;\par
00054         T                       high_content;\par
00055 \};\par
00056 \par
00057 {\cf17 template}<{\cf17 typename} T>\par
00058 {\cf17 struct }resbinop_t<T,binop_e::fediv> \{\par
00059         T                       quotient;\par
00060         T                       remainder;\par
00061         {\cf18 bool}    no_div_by_0;\par
00062 \};\par
00063 \par
00064 {\cf17 template}<{\cf17 typename} T>\par
00065 {\cf17 struct }resbinop_t<T,binop_e::div> \{\par
00066         T                       quotient;\par
00067         {\cf18 bool}    no_div_by_0;\par
00068 \};\par
00069 \par
00070 {\cf17 template}<{\cf17 typename} T>\par
00071 {\cf17 struct }resbinop_t<T,binop_e::rem> \{\par
00072         T                       remainder;\par
00073         {\cf18 bool}    no_div_by_0;\par
00074 \};\par
00075 \par
00076 {\cf17 template}<{\cf17 typename} T,binop_e oper,{\cf18 size_t} N>\par
00077         {\cf17 requires} (N>0)\par
00078 {\cf17 struct} result_operation_t;\par
00079 \par
00080 {\cf17 template}<{\cf17 typename} T,{\cf18 size_t} N>\par
00081         {\cf17 requires} (N > 0)\par
00082 {\cf17 struct} result_operation_t<T,binop_e::add,N> \{\par
00083         std::array<T,N>                 result_content_low;\par
00084         T                                                                               carry;\par
00085         {\cf18 bool}                                                            good_result;\par
00086 \};\par
00087 \par
00088 {\cf17 template}<{\cf17 typename} T,{\cf18 size_t} N>\par
00089         {\cf17 requires} (N > 0)\par
00090 {\cf17 struct} result_operation_t<T,binop_e::sub,N> \{\par
00091         std::array<T,N>                 result_content_low;\par
00092         T                                                                               borrow;\par
00093         {\cf18 bool}                                                            good_result;\par
00094 \};\par
00095 \par
00096 {\cf17 template}<{\cf17 typename} T,{\cf18 size_t} N>\par
00097         {\cf17 requires} (N > 0)\par
00098 {\cf17 struct} result_operation_t<T,binop_e::mult,N> \{\par
00099         std::array<T,N>                 result_content_low;\par
00100         std::array<T,N>                 result_content_high;\par
00101         {\cf18 bool}                                                            good_result;\par
00102 \};\par
00103 \par
00104 {\cf17 template}<{\cf17 typename} T,{\cf18 size_t} N>\par
00105         {\cf17 requires} (N > 0)\par
00106 {\cf17 struct} result_operation_t<T,binop_e::fediv,N> \{\par
00107         std::array<T,N>                 result_content_quotient;\par
00108         std::array<T,N>                 result_content_remainder;\par
00109         {\cf18 bool}                                                            good_result;\par
00110 \};\par
00111 \par
00112 {\cf17 template}<{\cf17 typename} T,{\cf18 size_t} N>\par
00113         {\cf17 requires} (N > 0)\par
00114 {\cf17 struct} result_operation_t<T,binop_e::div,N> \{\par
00115         std::array<T,N>                 result_content_quotient;\par
00116         {\cf18 bool}                                                            good_result;\par
00117 \};\par
00118 \par
00119 {\cf17 template}<{\cf17 typename} T,{\cf18 size_t} N>\par
00120         {\cf17 requires} (N > 0)\par
00121 {\cf17 struct} result_operation_t<T,binop_e::rem,N> \{\par
00122         std::array<T,N>                 result_content_remainder;\par
00123         {\cf18 bool}                                                            good_result;\par
00124 \};\par
00125 \}\par
00126 \}\par
00127 \par
00128 \par
00129 {\cf21 #endif }{\cf20 // AUXILIARY_TYPES_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo base_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v base_num_t.hpp}
{\xe \v base_num_t.hpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "int_reg_digs_t.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para base_num_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "base__num__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "base__num__t_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::base_num_t< UINT_T, B >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T , usint B> constexpr ullint {\b NumRepr::pot_max_base_B_en_Int_T} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T , ullint B> constexpr ullint {\b NumRepr::num_digs_max_base_B_en_Int_T} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_T , ullint B> constexpr ullint {\b NumRepr::max_base_B_en_Int_T} () noexcept\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
base_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v base_num_t.hpp}
{\xe \v base_num_t.hpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef BASE_NUM_T_HPP_INCLUDED}\par
00002 {\cf21 #define BASE_NUM_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "int_reg_digs_t.hpp"}\par
00005 \par
00006 {\cf17 namespace }NumRepr\{\par
00007 \par
00008 {\cf17 template}<type_traits::u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B>\par
00009         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00010 {\cf17 struct} base_num_t : {\cf17 public} basic_string<dig_t<UINT_T,B>> \{\par
00011 {\cf17 public}:\par
00012         {\cf17 using   }dig_t                                   = dig_t<UINT_T,B>;\par
00013         {\cf17 using   }base_t                                  = basic_string<dig_t>;\par
00014         {\cf17 using   }str_iterator            = {\cf17 typename} base_t::iterator;\par
00015         {\cf17 using   }c_str_iterator  = {\cf17 typename} base_t::const_iterator;\par
00016         {\cf17 using   }r_str_iterator  = {\cf17 typename} base_t::reverse_iterator;\par
00017         {\cf17 using   }cr_str_iterator = {\cf17 typename} base_t::const_reverse_iterator;\par
00018 {\cf17 public}:\par
00019         {\cf17 inline} {\cf17 constexpr} {\cf18 size_t} size() const noexcept\par
00020         \{ {\cf19 return} ({\cf17 static_cast<}{\cf17 const }base_t*const{\cf17 >}({\cf17 this})->size()); \}\par
00021 \par
00022         {\cf17 inline} {\cf17 constexpr} {\cf18 void} resize({\cf18 size_t} arg) {\cf17 noexcept}\par
00023         \{       ({\cf17 static_cast<}base_t*const{\cf17 >}({\cf17 this})->resize()); \}\par
00024 \par
00025         {\cf17 inline} {\cf17 constexpr} dig_t operator[](ullint arg) {\cf17 const} {\cf17 noexcept} \{\par
00026                 {\cf19 return} ({\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this})->{\cf17 operator}[](arg));\par
00027         \}\par
00028 \par
00029         {\cf17 inline} {\cf17 constexpr} dig_t & operator[](ullint arg) {\cf17 noexcept} \{\par
00030                 {\cf19 return} ({\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->{\cf17 operator}[](arg));\par
00031         \}\par
00032 \par
00033         {\cf17 inline} {\cf17 constexpr} {\cf18 void} clear() noexcept\par
00034         \{ {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->clear(); \}\par
00035 \par
00036         {\cf17 inline} {\cf17 constexpr} {\cf18 void} push_back(dig_t arg) {\cf17 noexcept}\par
00037         \{ {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->push_back(arg);     \}\par
00038 \par
00039         {\cf17 inline} {\cf17 constexpr} {\cf18 void} insert({\cf18 size_t} pos,{\cf18 size_t} tam,dig_t parg)\par
00040         {\cf17 noexcept} \{\par
00041                 {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->insert(pos,tam,parg); \}\par
00042 \par
00043         {\cf17 inline} {\cf17 constexpr} num_basic_t substr ( {\cf18 size_t} pos , {\cf18 size_t} n ) {\cf17 const}\par
00044         {\cf17 noexcept} \{\par
00045                 {\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this})->substr(pos,n);\par
00046                 {\cf19 return} (*{\cf17 this});                                                                                                                                                                                                 \}\par
00047 \par
00048         {\cf17 inline} {\cf17 constexpr} {\cf18 void} push_front(dig_t parg) {\cf17 noexcept}\par
00049         \{       {\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this})->insert(0,1,parg);\}\par
00050 \par
00051         {\cf17 inline} {\cf17 constexpr} str_iterator begin() noexcept\par
00052         \{       {\cf19 return} {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->begin(); \}\par
00053 \par
00054         {\cf17 inline} {\cf17 constexpr} c_str_iterator end() const noexcept\par
00055         \{       {\cf19 return} {\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this})->end(); \}\par
00056 \par
00057         {\cf17 inline} {\cf17 constexpr} r_str_iterator rbegin() noexcept\par
00058         \{       {\cf19 return} {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->rbegin(); \}\par
00059 \par
00060         {\cf17 inline} {\cf17 constexpr} cr_str_iterator rend() const noexcept\par
00061         \{       {\cf19 return} {\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this})->rbegin(); \}\par
00062 \par
00063         {\cf17 inline} {\cf17 constexpr} {\cf18 void} erase({\cf18 size_t} pos,{\cf18 size_t} tam) {\cf17 noexcept}\par
00064         \{       {\cf19 return} {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this})->erase(pos,tam); \}\par
00065 \par
00066         {\cf20 // OPERADOR DE CONCATENACION}\par
00067         {\cf17 inline} {\cf17 constexpr} {\cf17 const} num_basic_t & {\cf17 operator} &=\par
00068                 ({\cf17 const} num_basic_t & arg) {\cf17 noexcept}\par
00069         \{\par
00070                 (*({\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this}))) += arg;\par
00071                 {\cf19 return} (*{\cf17 this});\par
00072         \}\par
00073 \};\par
00074 \par
00075 {\cf17 template}< {\cf17 typename} Int_T , us{\cf18 int} B >\par
00076 {\cf17 inline} {\cf17 constexpr}\par
00077 ullint pot_max_base_B_en_Int_T() noexcept \{\par
00078         {\cf17 constexpr} {\cf18 long} {\cf18 double} max = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(type_traits::maxbase<Int_T>());\par
00079         {\cf17 constexpr} {\cf18 long} {\cf18 double} max_unit = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(numeric_limits<char>::max());\par
00080         {\cf17 constexpr} {\cf18 long} {\cf18 double} nb_unit = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(1+(log(max_unit)/log(2)));\par
00081         {\cf17 constexpr} {\cf18 long} {\cf18 double} n_units_Int_T = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}({\cf17 sizeof}(Int_T));\par
00082         {\cf17 constexpr} {\cf18 long} {\cf18 double} nb_Int_T = nb_unit * n_units_Int_T;\par
00083         {\cf17 constexpr} {\cf18 long} {\cf18 double} log_2_b_B = std::log({\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(2))/std::log({\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(B));\par
00084         {\cf17 constexpr} {\cf18 long} {\cf18 double} ld_expB = (std::floor(nb_Int_T * log_2_b_B));\par
00085         {\cf20 //long double ld_potB = (floor(pow(static_cast<long double>(B),ld_expB)));}\par
00086         {\cf17 constexpr} ullint ret = {\cf17 static_cast<}ullint{\cf17 >}(ld_expB);\par
00087         {\cf19 return} ret;\par
00088 \}\par
00089 \par
00090 {\cf17 template}< {\cf17 typename} Int_T , ull{\cf18 int} B >\par
00091 {\cf17 inline} {\cf17 constexpr} ullint num_digs_max_base_B_en_Int_T() noexcept \{\par
00092         {\cf17 constexpr} {\cf18 long} {\cf18 double} max = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(numeric_limits<Int_T>::max() + 1);\par
00093         {\cf17 constexpr} {\cf18 long} {\cf18 double} max_unit = 2*{\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(numeric_limits<char>::max() + 1);\par
00094         {\cf17 constexpr} {\cf18 long} {\cf18 double} nb_unit = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}((log(max_unit)/log(2)));\par
00095         {\cf17 constexpr} {\cf18 long} {\cf18 double} n_units_Int_T = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}({\cf17 sizeof}(Int_T));\par
00096         {\cf17 constexpr} {\cf18 long} {\cf18 double} nb_Int_T = nb_unit * n_units_Int_T;\par
00097         {\cf17 constexpr} {\cf18 long} {\cf18 double} log_2_b_B = log({\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(2))/log({\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(B));\par
00098         {\cf18 long} {\cf18 double} ld_expB = (floor(nb_Int_T * log_2_b_B));\par
00099         {\cf18 long} {\cf18 double} ld_potB = (floor(pow({\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(B),ld_expB)));\par
00100         {\cf20 //bool B_es_pot_de_2 = false;}\par
00101         ullint pot_2 = 2;\par
00102         {\cf19 for} (ullint b=1 ; b < max_unit; b++) \{\par
00103                 {\cf19 if} (B==pot_2) \{\par
00104                         ld_expB+={\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(1);\par
00105                         {\cf20 //B_es_pot_de_2 = true;}\par
00106                         {\cf19 break};\par
00107                 \}\par
00108                 pot_2 *= 2;\par
00109         \}\par
00110         {\cf17 constexpr} {\cf18 long} {\cf18 double} max_pot_B_Int_T = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(pot_max_base_B_en_Int_T<Int_T,B>());\par
00111         {\cf18 long} {\cf18 double} multiplo = 1;\par
00112         ullint ind = 0;\par
00113         {\cf19 while}((multiplo < max) and (ind < B)) \{\par
00114                 multiplo = floor(multiplo  +  max_pot_B_Int_T);\par
00115                 {\cf19 if} (multiplo > max) \{\par
00116                         multiplo = floor(multiplo - max_pot_B_Int_T);\par
00117                         ullint ret = {\cf17 static_cast<}ullint{\cf17 >}(multiplo-1.0);\par
00118                         {\cf19 return} ret;\par
00119                 \}\par
00120                 ++ind;\par
00121         \}\par
00122         {\cf17 constexpr} ullint ret = ullint(ld_expB);\par
00123         {\cf19 return} ret;\par
00124 \}\par
00125 \par
00126 {\cf17 template}< {\cf17 typename} Int_T , ull{\cf18 int} B >\par
00127 {\cf17 inline} {\cf17 constexpr} ullint max_base_B_en_Int_T() noexcept \{\par
00128         {\cf17 constexpr} {\cf18 long} {\cf18 double} max = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(numeric_limits<Int_T>::max());\par
00129         {\cf17 constexpr} {\cf18 long} {\cf18 double} n_digs_base_B = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(num_digs_max_base_B_en_Int_T<Int_T,B>());\par
00130         {\cf17 constexpr} {\cf18 long} {\cf18 double} dos = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(2);\par
00131         {\cf17 constexpr} {\cf18 long} {\cf18 double} base = {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(B);\par
00132         {\cf17 constexpr} ullint ret = {\cf17 static_cast<}ullint{\cf17 >}(ceil((n_digs_base_B*log(dos))/log(base)));\par
00133         {\cf19 return} ret;\par
00134 \}\par
00135 \}\par
00136 {\cf21 #endif }{\cf20 //  BASE_NUM_T__HPP__INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo basic_types.hpp\par \pard\plain 
{\tc\tcl2 \v basic_types.hpp}
{\xe \v basic_types.hpp}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "istream"}\par
{\f2 #include <cinttypes>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <optional>}\par
{\f2 #include <compare>}\par
{\f2 #include <concepts>}\par
{\f2 #include <iostream>}\par
{\f2 #include <cstring>}\par
{\f2 #include <string>}\par
{\f2 #include <sstream>}\par
{\f2 #include <fstream>}\par
{\f2 #include <array>}\par
{\f2 #include <vector>}\par
{\f2 #include <list>}\par
{\f2 #include <map>}\par
{\f2 #include <climits>}\par
{\f2 #include <numeric>}\par
{\f2 #include <limits>}\par
{\f2 #include <cmath>}\par
{\f2 #include <iterator>}\par
{\f2 #include <functional>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para basic_types.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "basic__types_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "basic__types_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ullint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< ulint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< usint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< uchint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ullint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< ulint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< usint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< uchint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< SInt >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint128_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< schint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< ssint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< slint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< sllint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sllint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< slint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< sint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< ssint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< schint_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction::UIntTypeForRadix< T, Radix >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction::UIntTypeForRadixContainsMultResult< T, Radix >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits::ugly_details_UInt_for_UInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits::ugly_details_sig_SInt_for_UInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits::ugly_details_UInt_for_SInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits::ugly_details_SInt_for_SInt}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits::ugly_details_for_suitable_type_deduction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::type_traits::ugly_details_for_greater_suitable_type_deduction}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concepts\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::arith_integral_c}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TYPE_TRAITS AND CONCEPTS. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::arith_natural_c}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::char_type_c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::uint_type_for_radix_c}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES VALID FOR THE RADIX. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::unsigned_integral_c}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR UNSIGNED INTEGRAL TYPES. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::signed_integral_c}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONCEPT FOR SIGNED INTEGRAL TYPES. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b NumRepr::type_traits::integral_c}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::chint_t} = char\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
NUEVOS NOMBRES PARA LOS ENTEROS O PARECIDOS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::schint_t} = signed char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ssint_t} = signed short int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sint_t} = signed int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::slint_t} = signed long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sllint_t} = signed long long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uchint_t} = unsigned char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::usint_t} = unsigned short int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uint_t} = unsigned int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ulint_t} = unsigned long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ullint_t} = unsigned long long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uint128_t} = __uint128_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sint128_t} = __int128_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::size_t} = std::size_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sint8_t} = std::int8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sint16_t} = std::int16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sint32_t} = std::int32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::sint64_t} = std::int64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::int8_t} = std::int8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::int16_t} = std::int16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::int32_t} = std::int32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::int64_t} = std::int64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::fast8_t} = std::int_fast8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::fast16_t} = std::int_fast16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::fast32_t} = std::int_fast32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::fast64_t} = std::int_fast64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::least8_t} = std::int_least8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::least16_t} = std::int_least16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::least32_t} = std::int_least32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::least64_t} = std::int_least64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uint8_t} = std::uint8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uint16_t} = std::uint16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uint32_t} = std::uint32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uint64_t} = std::uint64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ufast8_t} = std::uint_fast8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ufast16_t} = std::uint_fast16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ufast32_t} = std::uint_fast32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::ufast64_t} = std::uint_fast64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uleast8_t} = std::uint_least8_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uleast16_t} = std::uint_least16_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uleast32_t} = std::uint_least32_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uleast64_t} = std::uint_least64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::intmax_t} = std::intmax_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b NumRepr::uintmax_t} = std::uintmax_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t > using {\b NumRepr::type_traits::sig_UInt_for_UInt_t} = typename ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t< UInt_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t > using {\b NumRepr::type_traits::sig_SInt_for_UInt_t} = typename ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t< UInt_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_t > using {\b NumRepr::type_traits::sig_UInt_for_SInt_t} = typename ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t< Int_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SInt_t > using {\b NumRepr::type_traits::sig_SInt_for_SInt_t} = typename ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t< SInt_t >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<ullint_t Radix> using {\b NumRepr::type_traits::TypeFromIntNumber_t} = typename UIntTypeForRadix< decltype(Radix), Radix >::UIntType\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<integral_c IntType, IntType Radix> using {\b NumRepr::type_traits::GreaterTypeFromIntNumber_t} = typename UIntTypeForRadixContainsMultResult< decltype(Radix), Radix >::UIntType\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b NumRepr::type_traits::clear_ccad} (char *, usint_t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<template< uchint_t B > class T, uchint_t B> constexpr const char * {\b NumRepr::type_traits::devCadenaC} (T< B > arg, std::size_t long_ccad=64) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr char * {\b NumRepr::type_traits::clear_ccad} (char *cad_c, std::size_t long_de_cad_c) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
constexpr unsigned long long {\b NumRepr::type_traits::atoull} (char *text) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::maxbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::submaxbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::minbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::subminbase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::monobase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::nobase} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::maxdigit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::submaxdigit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::digit_0} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::digit_1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::base_2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> consteval bool {\b NumRepr::type_traits::base_geqt_2} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> consteval bool {\b NumRepr::type_traits::base_leqt_max} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> consteval bool {\b NumRepr::type_traits::suitable_base} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::middle_max} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > consteval UINT_T {\b NumRepr::type_traits::sqrt_max} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<char_type_c CharT> constexpr CharT {\b NumRepr::type_traits::nullchar} \{CharT('\\0')\}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > constexpr bool {\b NumRepr::type_traits::is_uint_type_for_radix_v} = std::is_unsigned_v<UINT_T> && (! std::is_same_v<UINT_T,uint128_t>)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T > constexpr bool {\b NumRepr::type_traits::is_unsigned_type_v}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename SINT_T > constexpr bool {\b NumRepr::type_traits::is_signed_type_v} = std::is_signed_v<SINT_T>\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO INTEGRAL ES SIGNED. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename INT_TYPE > constexpr bool {\b NumRepr::type_traits::is_integral_type_v} = std::is_integral_v<INT_TYPE>\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADOR QUE NOS DA SI UN TIPO ES INTEGRAL. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b NumRepr::type_traits::eq_sz_v} = (sizeof(T) == sizeof(S))\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
METAOPERADORES DE COMPARACION DE CAPACIDAD DE INTEGERS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b NumRepr::type_traits::gt_sz_v} = (sizeof(T) > sizeof(S))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b NumRepr::type_traits::lt_sz_v} = (sizeof(T) < sizeof(S))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b NumRepr::type_traits::ge_sz_v} = gt_sz_v<T,S>||eq_sz_v<T,S>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename S > constexpr bool {\b NumRepr::type_traits::le_sz_v} = lt_sz_v<T,S>||eq_sz_v<T,S>\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
basic_types.hpp\par \pard\plain 
{\tc\tcl2 \v basic_types.hpp}
{\xe \v basic_types.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 // *** ADDED BY HEADER FIXUP ***}\par
00002 {\cf21 #include "istream"}\par
00003 {\cf20 // *** END ***}\par
00004 \par
00005 {\cf20 /*}\par
00006 {\cf20   A list of valid replacements is as follows:}\par
00007 {\cf20 }\par
00008 {\cf20   Use:                                                      Instead of:}\par
00009 {\cf20   <sstream>, basic_stringbuf                    <strstream>, strstreambuf}\par
00010 {\cf20   <sstream>, basic_istringstream                <strstream>, istrstream}\par
00011 {\cf20   <sstream>, basic_ostringstream                <strstream>, ostrstream}\par
00012 {\cf20   <sstream>, basic_stringstream                 <strstream>, strstream}\par
00013 {\cf20   <unordered_set>, unordered_set            <ext/hash_set>, hash_set}\par
00014 {\cf20   <unordered_set>, unordered_multiset       <ext/hash_set>, hash_multiset}\par
00015 {\cf20   <unordered_map>, unordered_map                <ext/hash_map>, hash_map}\par
00016 {\cf20   <unordered_map>, unordered_multimap       <ext/hash_map>, hash_multimap}\par
00017 {\cf20   <functional>, bind                                <functional>, binder1st}\par
00018 {\cf20   <functional>, bind                                <functional>, binder2nd}\par
00019 {\cf20   <functional>, bind                                <functional>, bind1st}\par
00020 {\cf20   <functional>, bind                                <functional>, bind2nd}\par
00021 {\cf20   <memory>, unique_ptr                          <memory>, auto_ptr}\par
00022 {\cf20 */}\par
00023 \par
00024 {\cf21 #ifndef BASIC_TYPES_HPP_INDLUDED}\par
00025 {\cf21 #define BASIC_TYPES_HPP_INDLUDED}\par
00026 \par
00027 {\cf21 #include <cinttypes>}\par
00028 \par
00029 {\cf21 #include <type_traits>}\par
00030 {\cf21 #include <optional>}\par
00031 {\cf21 #include <compare>}\par
00032 {\cf21 #include <concepts>}\par
00033 \par
00034 {\cf20 //#include <istream>}\par
00035 {\cf20 //#include <ostream>}\par
00036 {\cf21 #include <iostream>}\par
00037 {\cf21 #include <cstring>}\par
00038 {\cf21 #include <string>}\par
00039 {\cf21 #include <sstream>}\par
00040 {\cf21 #include <fstream>}\par
00041 {\cf20 //#include <fmt/format.h>}\par
00042 \par
00043 {\cf21 #include <array>}\par
00044 {\cf21 #include <vector>}\par
00045 {\cf21 #include <list>}\par
00046 {\cf21 #include <map>}\par
00047 \par
00048 {\cf21 #include <climits>}\par
00049 {\cf21 #include <numeric>}\par
00050 {\cf21 #include <limits>}\par
00051 {\cf21 #include <cmath>}\par
00052 \par
00053 {\cf21 #include <iterator>}\par
00054 {\cf21 #include <functional>}\par
00055 \par
00056 {\cf17 namespace }NumRepr \{\par
00058 {\cf17 using   }chint_t                 = char;\par
00059 {\cf17 using   }schint_t                = {\cf18 signed} char;\par
00060 {\cf17 using   }ssint_t                 = {\cf18 signed} {\cf18 short} int;\par
00061 {\cf17 using   }sint_t      = {\cf18 signed} int;\par
00062 {\cf17 using   }slint_t     = {\cf18 signed} {\cf18 long} int;\par
00063 {\cf17 using   }sllint_t                = {\cf18 signed} {\cf18 long} {\cf18 long} int;\par
00064 {\cf17 using   }uchint_t                = {\cf18 unsigned} char;\par
00065 {\cf17 using   }usint_t                 = {\cf18 unsigned} {\cf18 short} int;\par
00066 {\cf17 using   }uint_t            = {\cf18 unsigned} int;\par
00067 {\cf17 using   }ulint_t                 = {\cf18 unsigned} {\cf18 long} int;\par
00068 {\cf17 using   }ullint_t                = {\cf18 unsigned} {\cf18 long} {\cf18 long} int;\par
00069 {\cf17 using   }uint128_t       = __uint128_t;\par
00070 {\cf17 using   }sint128_t       = __int128_t;\par
00071 {\cf17 using           }size_t                  = std::size_t;\par
00072 {\cf17 using           }sint8_t                 = std::int8_t;\par
00073 {\cf17 using           }sint16_t                = std::int16_t;\par
00074 {\cf17 using           }sint32_t                = std::int32_t;\par
00075 {\cf17 using           }sint64_t                = std::int64_t;\par
00076 {\cf17 using           }int8_t                  = std::int8_t;\par
00077 {\cf17 using           }int16_t                 = std::int16_t;\par
00078 {\cf17 using           }int32_t                 = std::int32_t;\par
00079 {\cf17 using           }int64_t                 = std::int64_t;\par
00080 {\cf17 using   }fast8_t                 = std::int_fast8_t;\par
00081 {\cf17 using   }fast16_t                = std::int_fast16_t;\par
00082 {\cf17 using   }fast32_t                = std::int_fast32_t;\par
00083 {\cf17 using   }fast64_t                = std::int_fast64_t;\par
00084 {\cf17 using   }least8_t                = std::int_least8_t;\par
00085 {\cf17 using   }least16_t       = std::int_least16_t;\par
00086 {\cf17 using   }least32_t       = std::int_least32_t;\par
00087 {\cf17 using   }least64_t       = std::int_least64_t;\par
00088 {\cf20 //using         ssize_t         = std::ssize_t;}\par
00089 {\cf17 using           }uint8_t                 = std::uint8_t;\par
00090 {\cf17 using           }uint16_t                = std::uint16_t;\par
00091 {\cf17 using           }uint32_t                = std::uint32_t;\par
00092 {\cf17 using           }uint64_t                = std::uint64_t;\par
00093 {\cf17 using   }ufast8_t                = std::uint_fast8_t;\par
00094 {\cf17 using   }ufast16_t       = std::uint_fast16_t;\par
00095 {\cf17 using   }ufast32_t       = std::uint_fast32_t;\par
00096 {\cf17 using   }ufast64_t       = std::uint_fast64_t;\par
00097 {\cf17 using   }uleast8_t       = std::uint_least8_t;\par
00098 {\cf17 using   }uleast16_t      = std::uint_least16_t;\par
00099 {\cf17 using   }uleast32_t      = std::uint_least32_t;\par
00100 {\cf17 using   }uleast64_t      = std::uint_least64_t;\par
00101 {\cf20 //using         uchint8         = std::char8_t;}\par
00102 {\cf20 //using         uchint16        = std::char16_t;}\par
00103 {\cf20 //using         uchint32        = std::char32_t;}\par
00104 {\cf17 using           }intmax_t                = std::intmax_t;\par
00105 {\cf17 using           }uintmax_t               = std::uintmax_t;\par
00106 \par
00107 {\cf17 namespace }type_traits \{\par
00109 {\cf17 template}<{\cf17 typename} IntT>\par
00110 {\cf17 concept }arith_integral_c =      std::is_arithmetic_v<IntT>      &&\par
00111                             std::is_integral_v<IntT>;\par
00112 \par
00113 {\cf17 template}<{\cf17 typename} NatIntT>\par
00114 {\cf17 concept }arith_natural_c =   std::is_arithmetic_v<NatIntT>   &&\par
00115                                                                                                                 std::is_unsigned_v<NatIntT>     &&\par
00116                                                                                                                 std::is_integral_v<NatIntT>;\par
00117 \par
00118 {\cf17 template}<{\cf17 typename} CharT>\par
00119 {\cf17 concept }char_type_c = std::is_same_v<CharT,char>                                                ||\par
00120                                                                                         std::is_same_v<CharT,signed char>               ||\par
00121                                                                                         std::is_same_v<CharT,unsigned char>     ||\par
00122                                                                                         std::is_same_v<CharT,wchar_t>;\par
00123 \par
00124 {\cf17 template}<{\cf18 char}_type_c CharT>\par
00125 {\cf17 constexpr} {\cf17 inline}\par
00126 CharT  nullchar \{CharT({\cf23 '\\0'})\};\par
00127 \par
00128 {\cf18 char}* clear_ccad({\cf18 char} *,usint_t);\par
00129 \par
00130 {\cf17 template}< {\cf17 template}<uch{\cf18 int}_t B> {\cf17 class }T  , uchint_t B >\par
00131 {\cf17 inline} {\cf17 constexpr}\par
00132 {\cf17 const} {\cf18 char}* devCadenaC(T<B> arg,std::size_t long_ccad = 64) noexcept \{\par
00133         {\cf18 char}* c_cad = {\cf17 new} {\cf18 char}[long_ccad];\par
00134         c_cad = clear_ccad(c_cad,long_ccad);\par
00135         std::stringstream pre_cad;\par
00136         pre_cad << arg;\par
00137         std::string cad(pre_cad.str());\par
00138         {\cf17 const} {\cf18 size_t} longitud = cad.length();\par
00139         {\cf19 for}({\cf18 size_t} i=0;i<longitud;++i) \{\par
00140                 c_cad[i] = cad[i];\par
00141         \}\par
00142         {\cf19 for}({\cf18 size_t} i=longitud;i<long_ccad;++i) \{\par
00143                 c_cad[i] = nullchar<char>;\par
00144         \}\par
00145         {\cf19 return} c_cad;\par
00146 \}\par
00147 \par
00148 {\cf17 inline} {\cf17 constexpr}\par
00149 {\cf18 char}* clear_ccad({\cf18 char} * cad_c,std::size_t long_de_cad_c) {\cf17 noexcept} \{\par
00150         {\cf19 for}( {\cf18 size_t} I=0 ; I < long_de_cad_c ; ++I )\par
00151                 cad_c[I]=nullchar<char>;\par
00152         {\cf19 return} cad_c;\par
00153 \}\par
00154 \par
00155 {\cf17 inline} {\cf17 constexpr}\par
00156 {\cf18 unsigned} {\cf18 long} {\cf18 long} atoull({\cf18 char}* text) {\cf17 noexcept} \{\par
00157                 {\cf18 int} i=0;\par
00158                 {\cf19 while}(*text)\par
00159                 \{\par
00160                         i=(i<<3) + (i<<1) + (*text - {\cf23 '0'});\par
00161                         ++text;\par
00162                 \}\par
00163                 {\cf19 return}(i);\par
00164 \}\par
00165 \par
00170 \par
00174         {\cf17 template}<{\cf17 typename} UINT_T>       {\cf20 // variable on compile time for concept on UINT_T for BASE}\par
00175         {\cf17 constexpr} {\cf18 bool} is_uint_type_for_radix_v = std::is_unsigned_v<UINT_T> && (! std::is_same_v<UINT_T,uint128_t>);\par
00177         {\cf17 template}<{\cf17 typename} UINT_T>\par
00178         {\cf17 concept }uint_type_for_radix_c = is_uint_type_for_radix_v<UINT_T>;\par
00179 \par
00183   {\cf17 template}<{\cf17 typename} UINT_T> {\cf20 // variable on compile time for concept on UINT_T}\par
00184         {\cf17 constexpr} {\cf18 bool} is_unsigned_type_v =\par
00185                         is_uint_type_for_radix_v<UINT_T>        || std::is_same_v<UINT_T,uint128_t>;\par
00187         {\cf17 template}<{\cf17 typename} UINT_T>\par
00188         {\cf17 concept }unsigned_integral_c = is_unsigned_type_v<UINT_T>;\par
00189 \par
00191         {\cf17 template}<{\cf17 typename} SINT_T> {\cf20 // concept on SINT_T}\par
00192         {\cf17 constexpr} {\cf18 bool} is_signed_type_v = std::is_signed_v<SINT_T>;\par
00194         {\cf17 template}<{\cf17 typename} SINT_T>\par
00195         {\cf17 concept }signed_integral_c = is_signed_type_v<SINT_T>;\par
00196 \par
00198         {\cf17 template}<{\cf17 typename} INT_TYPE>\par
00199         {\cf17 inline} {\cf17 constexpr} {\cf18 bool} is_integral_type_v = std::is_integral_v<INT_TYPE>;\par
00200 \par
00201         {\cf17 template}<{\cf17 typename} INT_T>\par
00202         {\cf17 concept }integral_c = is_integral_type_v<INT_T>;\par
00203 \par
00205         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} S>\par
00206         {\cf17 constexpr} {\cf18 bool} eq_sz_v = ({\cf17 sizeof}(T) == {\cf17 sizeof}(S));\par
00207         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} S>\par
00208         {\cf17 constexpr} {\cf18 bool} gt_sz_v = ({\cf17 sizeof}(T) > {\cf17 sizeof}(S));\par
00209         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} S>\par
00210         {\cf17 constexpr} {\cf18 bool} lt_sz_v = ({\cf17 sizeof}(T) < {\cf17 sizeof}(S));\par
00211         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} S>\par
00212         {\cf17 constexpr} {\cf18 bool} ge_sz_v = gt_sz_v<T,S>||eq_sz_v<T,S>;\par
00213         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} S>\par
00214         {\cf17 constexpr} {\cf18 bool} le_sz_v = lt_sz_v<T,S>||eq_sz_v<T,S>;\par
00215 \par
00218         {\cf17 namespace }ugly_details_UInt_for_UInt \{\par
00219                 {\cf17 template}<{\cf18 unsigned}_{\cf18 int}egral_c UInt_t>\par
00220                 {\cf17 struct }__sig_UInt_for_UInt_t \{{\cf17 using }type = void;\};\par
00221 \par
00222                 {\cf17 template}<>\par
00223                 {\cf17 struct }__sig_UInt_for_UInt_t<ullint_t>\par
00224                 \{       {\cf17 using }type = uint128_t;\};\par
00225 \par
00226                 {\cf17 template}<>\par
00227                 {\cf17 struct }__sig_UInt_for_UInt_t<ulint_t>\par
00228                 \{\par
00229                         {\cf17 template}<{\cf18 unsigned}_{\cf18 int}egral_c u{\cf18 int}_type>\par
00230                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} uint_type_gt_this_type_v = gt_sz_v<uint_type,ulint_t>;\par
00231 \par
00232                         {\cf17 using }type =\par
00233                                 {\cf17 typename}\par
00234                                 std::conditional_t<\par
00235                                         uint_type_gt_this_type_v<ullint_t>,\par
00236                                                 ullint_t,\par
00237                                                 {\cf17 typename} __sig_UInt_for_UInt_t<ullint_t>::type\par
00238                                 >;\par
00239                 \};\par
00240 \par
00241                 {\cf17 template}<>\par
00242                 {\cf17 struct }__sig_UInt_for_UInt_t<uint_t>\par
00243                 \{\par
00244                         {\cf17 template}<{\cf18 unsigned}_{\cf18 int}egral_c u{\cf18 int}_type>\par
00245                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} uint_type_gt_this_type_v = gt_sz_v<uint_type,uint_t>;\par
00246 \par
00247                         {\cf17 using }type =\par
00248                                 std::conditional_t<\par
00249                                         uint_type_gt_this_type_v<ulint_t>,\par
00250                                                 ulint_t,\par
00251                                                 {\cf17 typename} __sig_UInt_for_UInt_t<ulint_t>::type\par
00252                                 >;\par
00253                 \};\par
00254 \par
00255                 {\cf17 template}<>\par
00256                 {\cf17 struct }__sig_UInt_for_UInt_t<usint_t>\par
00257                 \{\par
00258                         {\cf17 template}<{\cf18 unsigned}_{\cf18 int}egral_c u{\cf18 int}_type>\par
00259                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} uint_type_gt_this_type_v = gt_sz_v<uint_type,usint_t>;\par
00260 \par
00261                         {\cf17 using }type =\par
00262                                 std::conditional_t<\par
00263                                         uint_type_gt_this_type_v<uint_t>,\par
00264                                                 uint_t,\par
00265                                                 {\cf17 typename} __sig_UInt_for_UInt_t<uint_t>::type\par
00266                                 >;\par
00267                 \};\par
00268 \par
00269                 {\cf17 template}<>\par
00270                 {\cf17 struct }__sig_UInt_for_UInt_t<uchint_t>\par
00271                 \{\par
00272                         {\cf17 template}<{\cf18 unsigned}_{\cf18 int}egral_c u{\cf18 int}_type>\par
00273                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} uint_type_gt_this_type_v = gt_sz_v<uint_type,uchint_t>;\par
00274 \par
00275                         {\cf17 using }type =\par
00276                                 std::conditional_t<\par
00277                                         uint_type_gt_this_type_v<usint_t>,\par
00278                                                 usint_t,\par
00279                                                 {\cf17 typename} __sig_UInt_for_UInt_t<usint_t>::type\par
00280                                 >;\par
00281                 \};\par
00282 \par
00283 \par
00284         \}\par
00285 \par
00286 \par
00287         {\cf17 template}<{\cf17 typename} UInt_t>\par
00288         {\cf17 using }sig_UInt_for_UInt_t =\par
00289         {\cf17 typename} ugly_details_UInt_for_UInt::__sig_UInt_for_UInt_t<UInt_t>::type;\par
00290 \par
00293         {\cf17 namespace }ugly_details_sig_SInt_for_UInt \{\par
00294                 {\cf17 template}<{\cf17 typename} UInt>\par
00295                 {\cf17 struct }__sig_SInt_for_UInt_t\par
00296                 \{{\cf17 using }type = void;\};\par
00297 \par
00298                 {\cf17 template}<>\par
00299                 {\cf17 struct }__sig_SInt_for_UInt_t<ullint_t>\par
00300                 \{       {\cf17 using }type = sint128_t;\};\par
00301 \par
00302                 {\cf17 template}<>\par
00303                 {\cf17 struct }__sig_SInt_for_UInt_t<ulint_t>\par
00304                 \{\par
00305                         {\cf17 template}<{\cf17 typename} {\cf18 int}_type>\par
00306                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} int_type_gt_this_type_v = gt_sz_v<int_type,ulint_t>;\par
00307 \par
00308                         {\cf17 using }type =\par
00309                                 std::conditional_t<\par
00310                                         int_type_gt_this_type_v<sllint_t>,\par
00311                                                 sllint_t,\par
00312                                                 {\cf17 typename} __sig_SInt_for_UInt_t<ullint_t>::type\par
00313                                 >;\par
00314                 \};\par
00315 \par
00316                 {\cf17 template}<>\par
00317                 {\cf17 struct }__sig_SInt_for_UInt_t<uint_t>\par
00318                 \{\par
00319                         {\cf17 template}<{\cf17 typename} {\cf18 int}_type>\par
00320                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} int_type_gt_this_type_v = gt_sz_v<int_type,uint_t>;\par
00321 \par
00322                         {\cf17 using }type =\par
00323                                 std::conditional_t<\par
00324                                         int_type_gt_this_type_v<slint_t>,\par
00325                                                 slint_t,\par
00326                                                 {\cf17 typename} __sig_SInt_for_UInt_t<ulint_t>::type\par
00327                                 >;\par
00328                 \};\par
00329 \par
00330                 {\cf17 template}<>\par
00331                 {\cf17 struct }__sig_SInt_for_UInt_t<usint_t>\par
00332                 \{\par
00333                         {\cf17 template}<{\cf17 typename} {\cf18 int}_type>\par
00334                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} int_type_gt_this_type_v = gt_sz_v<int_type,usint_t>;\par
00335 \par
00336                         {\cf17 using }type =\par
00337                                 std::conditional_t<\par
00338                                         int_type_gt_this_type_v<sint_t>,\par
00339                                                 sint_t,\par
00340                                                 {\cf17 typename} __sig_SInt_for_UInt_t<uint_t>::type\par
00341                                 >;\par
00342                 \};\par
00343 \par
00344                 {\cf17 template}<>\par
00345                 {\cf17 struct }__sig_SInt_for_UInt_t<uchint_t>\par
00346                 \{\par
00347                         {\cf17 template}<{\cf17 typename} {\cf18 int}_type>\par
00348                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} int_type_gt_this_type_v = gt_sz_v<int_type,uchint_t>;\par
00349 \par
00350                         {\cf17 using }type =\par
00351                                 std::conditional_t<\par
00352                                         int_type_gt_this_type_v<ssint_t>,\par
00353                                                 ssint_t,\par
00354                                                 {\cf17 typename} __sig_SInt_for_UInt_t<usint_t>::type\par
00355                                 >;\par
00356                 \};\par
00357 \par
00358 \par
00359 \par
00360         \}\par
00361 \par
00362         {\cf17 template}<{\cf17 typename} UInt_t>\par
00363         {\cf17 using }sig_SInt_for_UInt_t =\par
00364         {\cf17 typename} ugly_details_sig_SInt_for_UInt::__sig_SInt_for_UInt_t<UInt_t>::type;\par
00365 \par
00368         {\cf17 namespace }ugly_details_UInt_for_SInt    \{\par
00369                 {\cf17 template}<{\cf17 typename} SInt>\par
00370                 {\cf17 struct }__sig_UInt_for_SInt_t\par
00371                 \{{\cf17 using }type = void;\};\par
00372 \par
00373                 {\cf17 template}<>\par
00374                 {\cf17 struct }__sig_UInt_for_SInt_t<sint128_t>\par
00375                 \{{\cf17 using }type = uint128_t;\};\par
00376 \par
00377                 {\cf17 template}<>\par
00378                 {\cf17 struct }__sig_UInt_for_SInt_t<schint_t>\par
00379                 \{{\cf17 using }type = uchint_t;\};\par
00380 \par
00381                 {\cf17 template}<>\par
00382                 {\cf17 struct }__sig_UInt_for_SInt_t<ssint_t>\par
00383                 \{{\cf17 using }type = usint_t;\};\par
00384 \par
00385                 {\cf17 template}<>\par
00386                 {\cf17 struct }__sig_UInt_for_SInt_t<sint_t>\par
00387                 \{{\cf17 using }type = uint_t;\};\par
00388 \par
00389                 {\cf17 template}<>\par
00390                 {\cf17 struct }__sig_UInt_for_SInt_t<slint_t>\par
00391                 \{{\cf17 using }type = ulint_t;\};\par
00392 \par
00393                 {\cf17 template}<>\par
00394                 {\cf17 struct }__sig_UInt_for_SInt_t<sllint_t>\par
00395                 \{{\cf17 using }type = ullint_t;\};\par
00396 \par
00397 \par
00398         \}\par
00399 \par
00400         {\cf17 template}<{\cf17 typename} Int_t>\par
00401         {\cf17 using }sig_UInt_for_SInt_t =\par
00402         {\cf17 typename} ugly_details_UInt_for_SInt::__sig_UInt_for_SInt_t<Int_t>::type;\par
00403 \par
00406         {\cf17 namespace }ugly_details_SInt_for_SInt \{\par
00407 \par
00408                 {\cf17 template}<{\cf17 typename} SInt>\par
00409                 {\cf17 struct }__sig_SInt_for_SInt_t\par
00410                 \{{\cf17 using }type = void;\};\par
00411 \par
00412                 {\cf17 template}<>\par
00413                 {\cf17 struct }__sig_SInt_for_SInt_t<sllint_t>\par
00414                 \{       {\cf17 using }type = sint128_t;\};\par
00415 \par
00416                 {\cf17 template}<>\par
00417                 {\cf17 struct }__sig_SInt_for_SInt_t<slint_t> \{\par
00418                         {\cf17 template}<{\cf18 signed}_{\cf18 int}egral_c SINT_T>\par
00419                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} signed_gt_signed_v = gt_sz_v<SINT_T,slint_t>;\par
00420 \par
00421                         {\cf17 using }type =\par
00422                                 std::conditional_t<\par
00423                                         signed_gt_signed_v<sllint_t>,\par
00424                                                 sllint_t,\par
00425                                                 {\cf17 typename} __sig_SInt_for_SInt_t<sllint_t>::type\par
00426                                 >;\par
00427                 \};\par
00428 \par
00429                 {\cf17 template}<>\par
00430                 {\cf17 struct }__sig_SInt_for_SInt_t<sint_t> \{\par
00431                         {\cf17 template}<{\cf17 typename} SINT_T>\par
00432                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} signed_gt_signed_v = gt_sz_v<SINT_T,sint_t>;\par
00433 \par
00434                         {\cf17 using }type =\par
00435                                 std::conditional_t<\par
00436                                         signed_gt_signed_v<slint_t>,\par
00437                                                 slint_t,\par
00438                                                 {\cf17 typename} __sig_SInt_for_SInt_t<slint_t>::type\par
00439                                 >;\par
00440                 \};\par
00441 \par
00442                 {\cf17 template}<>\par
00443                 {\cf17 struct }__sig_SInt_for_SInt_t<ssint_t> \{\par
00444                         {\cf17 template}<{\cf17 typename} SINT_T>\par
00445                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} signed_gt_signed_v = gt_sz_v<SINT_T,ssint_t>;\par
00446 \par
00447                         {\cf17 using }type =\par
00448                                 std::conditional_t<\par
00449                                         signed_gt_signed_v<sint_t>,\par
00450                                                 sint_t,\par
00451                                                 {\cf17 typename} __sig_SInt_for_SInt_t<sint_t>::type\par
00452                                 >;\par
00453                 \};\par
00454 \par
00455                 {\cf17 template}<>\par
00456                 {\cf17 struct }__sig_SInt_for_SInt_t<schint_t> \{\par
00457                         {\cf17 template}<{\cf17 typename} SINT_T>\par
00458                         {\cf17 static} {\cf17 inline} {\cf17 constexpr} {\cf18 bool} signed_gt_signed_v = gt_sz_v<SINT_T,schint_t>;\par
00459 \par
00460                         {\cf17 using }type =\par
00461                                 std::conditional_t<\par
00462                                         signed_gt_signed_v<ssint_t>,\par
00463                                                 ssint_t,\par
00464                                                 {\cf17 typename} __sig_SInt_for_SInt_t<ssint_t>::type\par
00465                                 >;\par
00466                 \};\par
00467 \par
00468 \par
00469         \}\par
00470 \par
00471         {\cf17 template}<{\cf17 typename} SInt_t>\par
00472         {\cf17 using }sig_SInt_for_SInt_t =\par
00473         {\cf17 typename} ugly_details_SInt_for_SInt::__sig_SInt_for_SInt_t<SInt_t>::type;\par
00474 \par
00477         {\cf17 template}<{\cf17 typename} UINT_T>\par
00478         {\cf17 consteval} UINT_T maxbase() \{\par
00479                 {\cf19 return} ({\cf17 static_cast<}UINT_T{\cf17 >}(std::numeric_limits<UINT_T>::max()));\par
00480         \}\par
00481 \par
00482         {\cf17 template}<{\cf17 typename} UINT_T>\par
00483         {\cf17 consteval} UINT_T submaxbase() \{\par
00484                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(maxbase<UINT_T>()-1);\par
00485         \}\par
00486 \par
00487         {\cf17 template}<{\cf17 typename} UINT_T>\par
00488         {\cf17 consteval} UINT_T minbase() \{\par
00489                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(2);\par
00490         \}\par
00491 \par
00492         {\cf17 template}<{\cf17 typename} UINT_T>\par
00493         {\cf17 consteval} UINT_T subminbase() \{\par
00494                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(3);\par
00495         \}\par
00496 \par
00497         {\cf17 template}<{\cf17 typename} UINT_T>\par
00498         {\cf17 consteval} UINT_T monobase() \{\par
00499                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(1);\par
00500         \}\par
00501 \par
00502         {\cf17 template}<{\cf17 typename} UINT_T>\par
00503         {\cf17 consteval} UINT_T nobase() \{\par
00504                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(0);\par
00505         \}\par
00506 \par
00507         {\cf17 template}<{\cf17 typename} UINT_T>\par
00508         {\cf17 consteval} UINT_T maxdigit() \{\par
00509                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(submaxbase<UINT_T>());\par
00510         \}\par
00511 \par
00512         {\cf17 template}<{\cf17 typename} UINT_T>\par
00513         {\cf17 consteval} UINT_T submaxdigit() \{\par
00514                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(submaxbase<UINT_T>()-1);\par
00515         \}\par
00516 \par
00517         {\cf17 template}<{\cf17 typename} UINT_T>\par
00518         {\cf17 consteval} UINT_T digit_0() \{\par
00519                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(0u);\par
00520         \}\par
00521 \par
00522         {\cf17 template}<{\cf17 typename} UINT_T>\par
00523         {\cf17 consteval} UINT_T digit_1() \{\par
00524                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(1u);\par
00525         \}\par
00526 \par
00527         {\cf17 template}<{\cf17 typename} UINT_T>\par
00528         {\cf17 consteval} UINT_T base_2() \{\par
00529                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(2u);\par
00530         \}\par
00531 \par
00532   {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B>\par
00533         {\cf17 consteval} {\cf18 bool} base_geqt_2() \{\par
00534                 {\cf19 return} (B >= base_2<UINT_T>());\par
00535         \}\par
00536 \par
00537         {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B>\par
00538         {\cf17 consteval} {\cf18 bool} base_leqt_max() \{\par
00539                 {\cf19 return} (B <= maxbase<UINT_T>());\par
00540         \}\par
00541 \par
00542         {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B>\par
00543         {\cf17 consteval} {\cf18 bool} suitable_base() \{ {\cf20 // requires on B}\par
00544                 {\cf19 return} (base_geqt_2<UINT_T,B>() && base_leqt_max<UINT_T,B>());\par
00545         \}\par
00546 \par
00547         {\cf17 template}<{\cf17 typename} UINT_T>\par
00548         {\cf17 consteval} UINT_T middle_max() \{\par
00549                 {\cf17 using }SIG_UINT_T = sig_UInt_for_UInt_t<UINT_T>;\par
00550                 {\cf17 constexpr} SIG_UINT_T maximo = maxbase<UINT_T>();\par
00551                 {\cf17 constexpr} SIG_UINT_T uno\{1\};\par
00552                 {\cf17 constexpr} SIG_UINT_T dos\{2\};\par
00553                 {\cf19 return}  {\cf17 static_cast<}UINT_T{\cf17 >}((maximo+uno)/dos);\par
00554         \}\par
00555 \par
00556         {\cf17 template}<{\cf17 typename} UINT_T>\par
00557         {\cf17 consteval} UINT_T sqrt_max() \{\par
00558                 {\cf17 using }SIG_UINT_T = sig_UInt_for_UInt_t<UINT_T>;\par
00559                 {\cf17 constexpr} SIG_UINT_T maximo\{maxbase<UINT_T>()\};\par
00560                 {\cf17 constexpr} SIG_UINT_T uno\{1\};\par
00561                 {\cf17 constexpr} SIG_UINT_T base\{maximo+uno\};\par
00562                 {\cf17 constexpr}\par
00563                         {\cf18 long} {\cf18 double} raiz_real\{\par
00564                                 std::sqrt(\par
00565                                         {\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(\par
00566                                                 {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(base)\par
00567                                         )\par
00568                                 )\par
00569                         \};\par
00570                 {\cf19 return}  {\cf17 static_cast<}UINT_T{\cf17 >}(std::floor(raiz_real));\par
00571         \}\par
00572 \par
00575         {\cf17 namespace }ugly_details_for_suitable_type_deduction \{\par
00576                 {\cf17 template}<{\cf17 typename} T, T Radix>\par
00577                 {\cf17 struct }UIntTypeForRadix;\par
00580                 {\cf17 template}<{\cf18 int}egral_c T, T Radix>\par
00581                         {\cf17 requires} (Radix > 1)\par
00582                 {\cf17 struct} UIntTypeForRadix<T, Radix> \{\par
00583                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_0_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(maxbase<uchint_t>());\par
00584                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_1_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(maxbase<usint_t>());\par
00585                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_2_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(maxbase<uint_t>());\par
00586                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_3_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(maxbase<ulint_t>());\par
00587                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_4_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(maxbase<ullint_t>());\par
00588                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value                                      = {\cf17 static_cast<}ullint_t{\cf17 >}(Radix);\par
00589                         {\cf17 using }UIntType =\par
00590                                 std::conditional_t<\par
00591                                         uint_value <= uint_value_0_max,\par
00592                                                 uchint_t,\par
00593                                                 std::conditional_t<\par
00594                                                         uint_value <= uint_value_1_max,\par
00595                                                                 usint_t,\par
00596                                                                 std::conditional_t<\par
00597                                                                         uint_value <= uint_value_2_max,\par
00598                                                                                 uint_t,\par
00599                                                                                 std::conditional_t<\par
00600                                                                                         uint_value <= uint_value_3_max,\par
00601                                                                                                 ulint_t,\par
00602                                                                                                 std::conditional_t<\par
00603                                                                                                         uint_value <= uint_value_4_max,\par
00604                                                                                                                 ullint_t,\par
00605                                                                                                                 uint128_t\par
00606                                                                                                 >\par
00607                                                                                 >\par
00608                                                                 >\par
00609                                                 >\par
00610                                 >;\par
00611                 \};\par
00612         \}\par
00613 \par
00618         {\cf17 using namespace }ugly_details_for_suitable_type_deduction;\par
00619         {\cf17 template}<ull{\cf18 int}_t Radix>\par
00620         {\cf17 using }TypeFromIntNumber_t =\par
00621                         {\cf17 typename} UIntTypeForRadix<{\cf17 decltype}(Radix),Radix>::UIntType;\par
00622 \par
00623 \par
00627         {\cf17 namespace }ugly_details_for_greater_suitable_type_deduction \{\par
00628                 {\cf17 template}<{\cf17 typename} T, T Radix>\par
00629                 {\cf17 struct }UIntTypeForRadixContainsMultResult;\par
00632                 {\cf17 template}<{\cf18 int}egral_c T, T Radix>\par
00633                         {\cf17 requires} (Radix > 1)\par
00634                 {\cf17 struct} UIntTypeForRadixContainsMultResult<T, Radix> \{\par
00635                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_0_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(sqrt_max<uchint_t>());\par
00636                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_1_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(sqrt_max<usint_t>());\par
00637                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_2_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(sqrt_max<uint_t>());\par
00638                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_3_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(sqrt_max<ulint_t>());\par
00639                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value_4_max    = {\cf17 static_cast<}ullint_t{\cf17 >}(sqrt_max<ullint_t>());\par
00640                         {\cf17 static} {\cf17 constexpr}        ullint_t                uint_value                                      = {\cf17 static_cast<}ullint_t{\cf17 >}(Radix);\par
00641                         {\cf17 using }UIntType =\par
00642                                 std::conditional_t<\par
00643                                         uint_value <= uint_value_0_max,\par
00644                                                 uchint_t,\par
00645                                                 std::conditional_t<\par
00646                                                         uint_value <= uint_value_1_max,\par
00647                                                                 usint_t,\par
00648                                                                 std::conditional_t<\par
00649                                                                         uint_value <= uint_value_2_max,\par
00650                                                                                 uint_t,\par
00651                                                                                 std::conditional_t<\par
00652                                                                                         uint_value <= uint_value_3_max,\par
00653                                                                                                 ulint_t,\par
00654                                                                                                 std::conditional_t<\par
00655                                                                                                         uint_value <= uint_value_4_max,\par
00656                                                                                                                 ullint_t,\par
00657                                                                                                                 uint128_t\par
00658                                                                                                 >\par
00659                                                                                 >\par
00660                                                                 >\par
00661                                                 >\par
00662                                 >;\par
00663                 \};\par
00664         \}\par
00669         {\cf17 using namespace }ugly_details_for_greater_suitable_type_deduction;\par
00670         {\cf17 template}<{\cf18 int}egral_c IntType, IntType Radix>\par
00671         {\cf17 using }GreaterTypeFromIntNumber_t =\par
00672         {\cf17 typename} UIntTypeForRadixContainsMultResult<{\cf17 decltype}(Radix),Radix>::UIntType;\par
00673 \}{\cf20 // END NAMESPACE TYPE_TRAITS}\par
00674 \}{\cf20 // END NAMESPACE NUMREPR}\par
00675 \par
00676 {\cf21 #endif }{\cf20 // BASIC_TYPES_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo dig_t.hpp\par \pard\plain 
{\tc\tcl2 \v dig_t.hpp}
{\xe \v dig_t.hpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "auxiliary_functions.hpp"}\par
{\f2 #include "auxiliary_types.hpp"}\par
{\f2 #include "lexer_parser.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para dig_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dig__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "dig__t_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::dig_t< UINT_T, B >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint128_t B> using {\b NumRepr::digit_t} = dig_t< type_traits::TypeFromIntNumber_t< static_cast< uint128_t >(B)>, static_cast< type_traits::TypeFromIntNumber_t< static_cast< uint128_t >(B)> >(static_cast< uint128_t >(B)) >\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOLO HAY QUE DECLARAR digit_t<2> o digit_t<10> o ... }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T, B>())consteval UINT_T {\b NumRepr::ui_1} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T, B>())consteval dig_t< UINT_T, B > {\b NumRepr::dig_max} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> digito_t\{\};. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> \par
requires (type_traits::suitable_base<UINT_T,Base>())std::istream & {\b NumRepr::operator>>} (std::istream &is, dig_t< UINT_T, Base > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c UINT_T, UINT_T Base> \par
requires (type_traits::suitable_base<UINT_T,Base>())std::ostream & {\b NumRepr::operator<<} (std::ostream &os, dig_t< UINT_T, Base > arg)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
dig_t.hpp\par \pard\plain 
{\tc\tcl2 \v dig_t.hpp}
{\xe \v dig_t.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef DIG_T_HPP_INCLUDED}\par
00002 {\cf21 #define DIG_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "auxiliary_functions.hpp"}\par
00005 {\cf21 #include "auxiliary_types.hpp"}\par
00006 {\cf21 #include "lexer_parser.hpp"}\par
00007 \par
00008 {\cf17 namespace }NumRepr \{\par
00009 {\cf17 using }type_traits::uint_type_for_radix_c;\par
00010 {\cf17 using }type_traits::suitable_base;\par
00011 {\cf17 using }type_traits::sig_UInt_for_UInt_t;\par
00012 {\cf17 using }type_traits::sig_SInt_for_UInt_t;\par
00013 {\cf17 using }type_traits::maxbase;\par
00017 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T, UINT_T B>\par
00018         {\cf17 requires} (suitable_base<UINT_T,B>())\par
00019 {\cf17 struct} dig_t \{\par
00020 {\cf17 private}:\par
00021 UINT_T m_d;\par
00022 {\cf17 public}:\par
00023         {\cf20 // SIG_UINT_T(uchint) -> usint}\par
00024         {\cf17 using }SIG_UINT_T                = sig_UInt_for_UInt_t<UINT_T>;\par
00025         {\cf20 // SIG_SINT_T(uchint) -> ssint}\par
00026         {\cf17 using }SIG_SINT_T                = sig_SInt_for_UInt_t<UINT_T>;\par
00027 \par
00028         {\cf17 using }uintspair                 = std::array<UINT_T,2>;\par
00029         {\cf17 using }digspair                  = std::array<dig_t,2>;\par
00030         {\cf17 using }uintspairlist = std::array<uintspair,B>;\par
00031         {\cf17 using }uintspairtbl      = std::array<uintspairlist,B>;\par
00032 \par
00033         {\cf17 template}<binop_e op>\par
00034         {\cf17 using }resbinop_t = auxiliary_types::resbinop_t<dig_t,op>;\par
00035 \par
00038         {\cf17 template}<UINT_T n,UINT_T m>\par
00039                 {\cf17 requires} ((n<B)&&(m<B))\par
00040         {\cf17 static} {\cf17 consteval} {\cf17 inline}\par
00041         uintspair mult()\par
00042         {\cf17 noexcept} \{\par
00043                 {\cf19 if} {\cf17 constexpr} (B > type_traits::sqrt_max<UINT_T>()) \{\par
00044                         {\cf17 constexpr} SIG_UINT_T sup_n\{n\};\par
00045                         {\cf17 constexpr} SIG_UINT_T sup_m\{m\};\par
00046                         {\cf17 constexpr} SIG_UINT_T result\{sup_n * sup_m\};\par
00047                         {\cf17 constexpr} UINT_T ret_1\{result/B\}; {\cf20 // "DECENAS"}\par
00048                         {\cf17 constexpr} UINT_T ret_0\{result%B\}; {\cf20 // "UNIDADES"}\par
00049                         {\cf17 constexpr} uintspair ret\{ret_1,ret_0\};\par
00050                         {\cf19 return} ret;\par
00051                 \} {\cf19 else} \{\par
00052                         {\cf17 constexpr} UINT_T result\{n * m\};\par
00053                         {\cf17 constexpr} UINT_T ret_1\{result/B\}; {\cf20 // "DECENAS"}\par
00054                         {\cf17 constexpr} UINT_T ret_0\{result%B\}; {\cf20 // "UNIDADES"}\par
00055                         {\cf17 constexpr} uintspair ret\{ret_1,ret_0\};\par
00056                         {\cf19 return} ret;\par
00057                 \}\par
00058         \}\par
00113 \par
00114 {\cf17 public}:\par
00115 \par
00116         {\cf17 inline} {\cf17 constexpr} {\cf17 explicit}\par
00117         {\cf17 operator} UINT_T() const\par
00118         noexcept \{ {\cf19 return} m_d; \}\par
00119 \par
00120         {\cf17 inline} {\cf17 constexpr}\par
00121         {\cf17 const} UINT_T& get() const\par
00122         noexcept \{ {\cf19 return} (m_d); \}\par
00123 \par
00124         {\cf17 inline} {\cf17 constexpr} {\cf17 explicit}\par
00125         {\cf17 operator} SIG_UINT_T() const\par
00126         noexcept \{ {\cf19 return} {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(m_d); \}\par
00127 \par
00128         {\cf17 inline} {\cf17 constexpr} {\cf17 explicit}\par
00129         {\cf17 operator} SIG_SINT_T() const\par
00130         noexcept \{ {\cf19 return} {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(m_d); \}\par
00131 \par
00132         {\cf17 inline} {\cf17 constexpr}\par
00133         UINT_T operator()() const\par
00134         noexcept \{ {\cf19 return} (m_d); \}\par
00137 \par
00138         {\cf17 constexpr} {\cf18 void} set_0() noexcept \{\par
00139                 m_d = 0;\par
00140         \}\par
00141         {\cf17 constexpr} {\cf18 void} set_1() noexcept \{\par
00142                 m_d = 1;\par
00143         \}\par
00144         {\cf17 constexpr} {\cf18 void} set_Bm1() noexcept \{\par
00145                 m_d = B-1;\par
00146         \}\par
00147         {\cf17 constexpr} {\cf18 void} set_Bm2() noexcept \{\par
00148                 m_d = B-2;\par
00149         \}\par
00150 {\cf17 public}:\par
00152         {\cf17 inline} {\cf17 static} {\cf17 consteval} {\cf18 bool} is_prime() noexcept \{\par
00153                 {\cf19 return} auxiliary_functions::is_prime({\cf17 static_cast<}std::size_t{\cf17 >}(B));\par
00154         \}\par
00156         {\cf17 inline} {\cf17 static} {\cf17 consteval} dig_t dig_max()                 noexcept \{{\cf19 return} dig_t(B-1u);\};\par
00157         {\cf17 inline} {\cf17 static} {\cf17 consteval} dig_t dig_submax()      noexcept \{{\cf19 return} dig_t(B-2u);\}\par
00158         {\cf17 inline} {\cf17 static} {\cf17 consteval} dig_t dig_Bm1()                 noexcept \{{\cf19 return} dig_t(B-1u);\}\par
00159         {\cf17 inline} {\cf17 static} {\cf17 consteval} dig_t dig_Bm2()                 noexcept \{{\cf19 return} dig_t(B-2u);\}\par
00160         {\cf17 inline} {\cf17 static} {\cf17 consteval} dig_t dig_0()                   noexcept \{{\cf19 return} dig_t();\}\par
00161         {\cf17 inline} {\cf17 static} {\cf17 consteval} dig_t dig_1()                   noexcept \{{\cf19 return} dig_t(1u);\}\par
00163         {\cf17 inline} {\cf17 static} {\cf17 consteval} UINT_T ui_max()                 noexcept \{{\cf19 return} UINT_T(B-1u);\}\par
00164         {\cf17 inline} {\cf17 static} {\cf17 consteval} UINT_T ui_submax()      noexcept \{{\cf19 return} UINT_T(B-2u);\}\par
00165         {\cf17 inline} {\cf17 static} {\cf17 consteval} UINT_T ui_Bm1()                 noexcept \{{\cf19 return} UINT_T(B-1u);\}\par
00166         {\cf17 inline} {\cf17 static} {\cf17 consteval} UINT_T ui_Bm2()                 noexcept \{{\cf19 return} UINT_T(B-2u);\}\par
00167         {\cf17 inline} {\cf17 static} {\cf17 consteval} UINT_T ui_0()                   noexcept \{{\cf19 return} UINT_T(0u);\}\par
00168         {\cf17 inline} {\cf17 static} {\cf17 consteval} UINT_T ui_1()                   noexcept \{{\cf19 return} UINT_T(1u);\}\par
00170         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_B()              noexcept        \{\par
00171                 {\cf19 return} {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(B);\par
00172         \}\par
00173         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_max()    noexcept        \{\par
00174                 {\cf19 return} {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(B-1u);\par
00175         \}\par
00176         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_submax() noexcept        \{\par
00177                 {\cf19 return} {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(B-2u);\par
00178         \}\par
00179         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_0()              noexcept        \{\par
00180                 {\cf19 return} {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(0u);\par
00181         \}\par
00182         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_1()              noexcept        \{\par
00183                 {\cf19 return} {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(1u);\par
00184         \}\par
00186         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_SINT_T ssi_B()              noexcept        \{\par
00187                 {\cf19 return} {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(B);\par
00188         \}\par
00189         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_SINT_T ssi_max()    noexcept        \{\par
00190                 {\cf19 return} {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(B-1u);\par
00191         \}\par
00192         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T ssi_submax() noexcept        \{\par
00193                 {\cf19 return} {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(B-2u);\par
00194         \}\par
00195         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T ssi_0()              noexcept        \{\par
00196                 {\cf19 return} {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(0u);\par
00197         \}\par
00198         {\cf17 inline} {\cf17 static} {\cf17 consteval} SIG_UINT_T ssi_1()              noexcept        \{\par
00199                 {\cf19 return} {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(1u);\par
00200         \}\par
00202 \par
00203 {\cf17 public}:\par
00204 {\cf20                                 /************************************/}\par
00205                                 {\cf20 /*                                                                                                                                      */}\par
00206                                 {\cf20 /*      CONSTRUIR DIGITO                                                                */}\par
00207                                 {\cf20 /*                                                                                                                                      */}\par
00208 {\cf20                                 /************************************/}\par
00209 \par
00212         {\cf17 consteval} {\cf17 inline}\par
00213         dig_t() noexcept : m_d(0u) \{\}\par
00214 \par
00217         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00218         {\cf17 constexpr} {\cf17 static} {\cf17 inline}\par
00219         UINT_T normaliza(Int_t arg)\par
00220         {\cf17 noexcept} \{\par
00221                 {\cf19 if} {\cf17 constexpr} (std::is_same_v<Int_t,UINT_T>) \{\par
00222                         {\cf19 return} (arg%B);\par
00223                 \}\par
00224                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (std::is_signed_v<Int_t>) \{\par
00225                         {\cf19 if} {\cf17 constexpr} (\par
00226                                 type_traits::maxbase<Int_t>()\par
00227                                                         >=\par
00228                                 type_traits::maxbase<SIG_SINT_T>()\par
00229                         ) \{\par
00230                                 {\cf17 constexpr} Int_t sint_0\{0\}; {\cf20 // ssi_0()}\par
00231                                 {\cf17 constexpr} Int_t sint_B\{B\}; {\cf20 // ssi_B()}\par
00232                                 Int_t cparg\{arg\};\par
00233                                 {\cf19 if} (arg<sint_0) \{\par
00234                                         Int_t coc\{(-arg)/sint_B\};\par
00235                                         coc *= sint_B;\par
00236                                         cparg += coc;\par
00237                                         {\cf19 if} (cparg<0)\par
00238                                                 cparg += sint_B;\par
00239                                         {\cf19 if} (cparg>=sint_B)\par
00240                                                 cparg -= sint_B;\par
00241                                 \}\par
00242                                 {\cf19 else} \{\par
00243                                         cparg %= sint_B;\par
00244                                 \}\par
00245                                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(cparg);\par
00246                         \}\par
00247                         {\cf19 else} \{\par
00248                                 {\cf17 constexpr} SIG_SINT_T sint_0\{0\};\par
00249                                 {\cf17 constexpr} SIG_SINT_T sint_B\{B\};\par
00250                                 SIG_SINT_T cparg\{arg\};\par
00251                                 {\cf19 if} (arg<sint_0) \{\par
00252                                         SIG_SINT_T coc\{(-arg)/sint_B\};\par
00253                                         coc *= sint_B;\par
00254                                         cparg += coc;\par
00255                                         {\cf19 if} (cparg<0)\par
00256                                                 cparg += sint_B;\par
00257                                         {\cf19 if} (cparg>=sint_B)\par
00258                                                 cparg -= sint_B;\par
00259                                 \}\par
00260                                 {\cf19 else} \{\par
00261                                         cparg %= sint_B;\par
00262                                 \}\par
00263                                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(cparg);\par
00264                         \}\par
00265                 \}\par
00266                 {\cf19 else} \{\par
00267                         {\cf19 if} {\cf17 constexpr} (maxbase<Int_t>() < maxbase<UINT_T>() ) \{\par
00268                                 {\cf17 constexpr} SIG_UINT_T uint_B\{B\};\par
00269                                 SIG_UINT_T cparg\{arg\};\par
00270                                 {\cf19 if} (arg >= uint_B) \{\par
00271                                         cparg %= uint_B;\par
00272                                 \}\par
00273                                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(cparg);\par
00274                         \}\par
00275                         {\cf19 else} \{\par
00276                                 {\cf17 constexpr} Int_t uint_B\{B\};\par
00277                                 Int_t cparg\{arg\};\par
00278                                 {\cf19 if} (arg >= uint_B) \{\par
00279                                         cparg %= uint_B;\par
00280                                 \}\par
00281                                 {\cf19 return} {\cf17 static_cast<}UINT_T{\cf17 >}(cparg);\par
00282                         \}\par
00283                 \}\par
00284         \}\par
00285 \par
00289         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00290         {\cf17 constexpr} {\cf17 inline} dig_t(Int_t arg) noexcept :\par
00291                 m_d(normaliza<Int_t>(arg))\par
00292         \{\}\par
00293 \par
00295         {\cf17 constexpr} {\cf17 inline} dig_t({\cf17 const} dig_t &) {\cf17 noexcept} = {\cf19 default};\par
00297         {\cf17 constexpr} {\cf17 inline} dig_t(dig_t &&) noexcept = default;\par
00298 \par
00304 \par
00305 {\cf20                                 /************************************/}\par
00306                                 {\cf20 /*                                                                                                                                      */}\par
00307                                 {\cf20 /*      OPERADORES DE ASIGNACION                                */}\par
00308                                 {\cf20 /*                                                                                                                                      */}\par
00309 {\cf20                                 /************************************/}\par
00310 \par
00312         template<type_traits::integral_c Int_t>\par
00313         constexpr inline\par
00314         const dig_t & operator = (const Int_t & a)\par
00315         noexcept \{\par
00316                 {\cf19 if} {\cf17 constexpr} (std::is_same_v<Int_t,UINT_T>) \{\par
00317                         {\cf19 if} (&a != &m_d) \{\par
00318                                 m_d = normaliza<Int_t>(a);\par
00319                         \}\par
00320                 \}\par
00321                 {\cf19 else} \{\par
00322                         m_d = normaliza<Int_t>(a);\par
00323                 \}\par
00324                 {\cf19 return} (*{\cf17 this});\par
00325         \}\par
00327         {\cf17 constexpr} {\cf17 inline} dig_t & operator = ({\cf17 const} dig_t &)  {\cf17 noexcept} = {\cf19 default};\par
00329         {\cf17 constexpr} {\cf17 inline} dig_t & operator = (dig_t &&) noexcept = default;\par
00333 \par
00337 \par
00338         constexpr inline {\cf18 bool} is_unit() const noexcept \{ {\cf20 // FROM FINITE RINGS}\par
00343 {\cf20 }                dig_t& cthis\{*{\cf17 this}\};\par
00344                 {\cf19 if} {\cf17 constexpr} (is_prime()) \{\par
00345                         {\cf19 if} (!is_0()) \{\par
00346                                 {\cf19 return} {\cf17 true};\par
00347                         \}\par
00348                         {\cf19 else} \{\par
00349                                 {\cf19 return} {\cf17 false};\par
00350                         \}\par
00351                 \}\par
00352                 {\cf19 else} \{\par
00353                         {\cf19 if} (is_1())\par
00354                                 {\cf19 return} {\cf17 true};\par
00355                         {\cf19 else} {\cf19 if} (std::gcd(B, m_d) != ui_1())\par
00356                                 {\cf19 return} {\cf17 false};\par
00357                         {\cf19 else}\par
00358                                 {\cf19 return} {\cf17 true};\par
00359                 \}\par
00360         \}\par
00361 \par
00362         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} is_0_divisor() const noexcept \{ {\cf20 // FROM FINITE RINGS}\par
00367 {\cf20 }                {\cf19 if} {\cf17 constexpr} (is_prime()) \{\par
00368                         {\cf19 if} (is_0()) \{\par
00369                                 {\cf19 return} {\cf17 true};\par
00370                         \}\par
00371                         {\cf19 else} \{\par
00372                                 {\cf19 return} {\cf17 false};\par
00373                         \}\par
00374                 \}\par
00375                 {\cf19 else} \{\par
00376                         {\cf19 if} (is_0())\par
00377                                 {\cf19 return} {\cf17 true};\par
00378                         {\cf19 else} {\cf19 if} (std::gcd(B,m_d)!=ui_1())\par
00379                                 {\cf19 return} {\cf17 true};\par
00380                         {\cf19 else}\par
00381                                 {\cf19 return} {\cf17 false};\par
00382                 \}\par
00383         \}\par
00384 \par
00385         {\cf17 constexpr} {\cf17 inline} dig_t mult_inv() const noexcept \{ {\cf20 // FROM FINITE RINGS}\par
00386                 {\cf19 if} (is_unit()) \{\par
00387                         dig_t& cthis\{*{\cf17 this}\};\par
00388                         {\cf19 if} (is_1()) \{\par
00389                                 {\cf19 return} dig_1();\par
00390                         \} {\cf19 else} {\cf19 if} (is_Bm1()) {\cf19 return} dig_max();\par
00391                         {\cf19 else} \{\par
00392                                 {\cf19 for} (dig_t index(2); !is_Bm1(); ++index) \{\par
00393                                         {\cf19 if} (index.is_unit()) \{\par
00394                                                 {\cf19 if} ((cthis * index).is_1()) \{\par
00395                                                         {\cf19 return} index;\par
00396                                                 \}\par
00397                                         \}\par
00398                                 \}\par
00399                         \}\par
00400                 \}\par
00401                 {\cf19 else} \{\par
00402                         {\cf19 return} dig_0();\par
00403                 \}\par
00404         \}\par
00405 \par
00406 {\cf20                                 /************************************/}\par
00407                                 {\cf20 /*                                                                                                                                      */}\par
00408                                 {\cf20 /*      FUNCIONES PARA CONOCER EL CARRY */}\par
00409                                 {\cf20 /*                                                                                                                                      */}\par
00410 {\cf20                                 /************************************/}\par
00411 \par
00412         {\cf17 inline} {\cf17 constexpr} {\cf17 static}\par
00413         dig_t sum_carry(dig_t arg_1,dig_t arg_2)\par
00414         {\cf17 noexcept} \{\par
00415                 {\cf19 if} {\cf17 constexpr} (B <= type_traits::middle_max<UINT_T>()) \{\par
00416                         {\cf19 if} {\cf17 constexpr} ((B%2) == 0) \{\par
00417                                 {\cf17 constexpr} UINT_T Bdiv2\{B/2\};\par
00418                                 {\cf19 if} ((arg_1() < Bdiv2)&&(arg_2() < Bdiv2)) \{\par
00419                                         {\cf19 return} dig_0();\par
00420                                 \} {\cf19 else} {\cf19 if} ((arg_1() >= Bdiv2)&&(arg_2() >= Bdiv2)) \{\par
00421                                         {\cf19 return} dig_1();\par
00422                                 \} {\cf19 else} {\cf19 if} ( arg_1() >= B-arg_2() ) \{\par
00423                                         {\cf19 return} dig_1();\par
00424                                 \} {\cf19 else} \{\par
00425                                         {\cf19 return} dig_0();\par
00426                                 \}\par
00427                         \} {\cf19 else} \{\par
00428                                 {\cf17 constexpr} UINT_T Bdiv2_1\{B/2\};\par
00429                                 {\cf17 constexpr} UINT_T Bdiv2_2\{(B/2)+1\};\par
00430                                 {\cf19 if} (   ((arg_1() < Bdiv2_1)&&(arg_2() < Bdiv2_2))\par
00431                                                 || ((arg_1() < Bdiv2_2)&&(arg_2() < Bdiv2_1))\par
00432                                         )       \{\par
00433                                         {\cf19 return} dig_0();\par
00434                                 \} {\cf19 else} {\cf19 if} (             ((arg_1() >= Bdiv2_1)&&(arg_2() >= Bdiv2_2))\par
00435                                                                                 ||((arg_1() >= Bdiv2_2)&&(arg_2() >= Bdiv2_1))\par
00436                                         ) \{\par
00437                                         {\cf19 return} dig_1();\par
00438                                 \} {\cf19 else} {\cf19 if} ( arg_1() >= B-arg_2() ) \{\par
00439                                         {\cf19 return} dig_1();\par
00440                                 \} {\cf19 else} \{\par
00441                                         {\cf19 return} dig_0();\par
00442                                 \}\par
00443                         \}\par
00444                 \} {\cf19 else} \{\par
00445                         {\cf19 if} {\cf17 constexpr} ((B%2) == 0) \{\par
00446                                 {\cf17 constexpr} SIG_UINT_T Bdiv2\{B/2\};\par
00447                                 {\cf19 if} ((arg_1() < Bdiv2)&&(arg_2() < Bdiv2)) \{\par
00448                                         {\cf19 return} dig_0();\par
00449                                 \} {\cf19 else} {\cf19 if} ((arg_1() >= Bdiv2)&&(arg_2() >= Bdiv2)) \{\par
00450                                         {\cf19 return} dig_1();\par
00451                                 \} {\cf19 else} {\cf19 if} ( arg_1() >= B-arg_2() ) \{\par
00452                                         {\cf19 return} dig_1();\par
00453                                 \} {\cf19 else} \{\par
00454                                         {\cf19 return} dig_0();\par
00455                                 \}\par
00456                         \} {\cf19 else} \{\par
00457                                 {\cf17 constexpr} SIG_UINT_T Bdiv2_1\{B/2\};\par
00458                                 {\cf17 constexpr} SIG_UINT_T Bdiv2_2\{(B/2)+1\};\par
00459                                 {\cf19 if} (   ((arg_1() < Bdiv2_1)&&(arg_2() < Bdiv2_2))\par
00460                                                 || ((arg_1() < Bdiv2_2)&&(arg_2() < Bdiv2_1))\par
00461                                         )       \{\par
00462                                         {\cf19 return} dig_0();\par
00463                                 \} {\cf19 else} {\cf19 if} (             ((arg_1() >= Bdiv2_1)&&(arg_2() >= Bdiv2_2))\par
00464                                                                                 ||((arg_1() >= Bdiv2_2)&&(arg_2() >= Bdiv2_1))\par
00465                                         ) \{\par
00466                                         {\cf19 return} dig_1();\par
00467                                 \} {\cf19 else} {\cf19 if} ( arg_1() >= B-arg_2() ) \{\par
00468                                         {\cf19 return} dig_1();\par
00469                                 \} {\cf19 else} \{\par
00470                                         {\cf19 return} dig_0();\par
00471                                 \}\par
00472                         \}\par
00473                 \}\par
00474         \}\par
00475 {\cf20                                 /************************************/}\par
00476                                 {\cf20 /*                                                                                                                                      */}\par
00477                                 {\cf20 /*      OPERADORES & &= | |=                                    */}\par
00478                                 {\cf20 /*  FUNCIONAN COMO MAX Y MIN                            */}\par
00479                                 {\cf20 /*                                                                                                                                      */}\par
00480 {\cf20                                 /************************************/}\par
00481 \par
00484         {\cf17 constexpr} {\cf17 inline}\par
00485         dig_t operator & ({\cf17 const} dig_t & arg) {\cf17 const}\par
00486         {\cf17 noexcept}\par
00487         \{\par
00488                 {\cf19 return} (((*{\cf17 this})<=arg)?(*{\cf17 this}):arg);\par
00489         \}\par
00490 \par
00493         {\cf17 constexpr} {\cf17 inline}\par
00494         {\cf17 const} dig_t & operator &= (dig_t arg)\par
00495         {\cf17 noexcept}\par
00496         \{\par
00497                 {\cf19 if} (arg < (*{\cf17 this}))\par
00498                         (*this) = arg;\par
00499                 {\cf19 return} (*{\cf17 this});\par
00500         \}\par
00501 \par
00504         {\cf17 constexpr} {\cf17 inline}\par
00505         dig_t operator | ({\cf17 const} dig_t & arg) {\cf17 const}\par
00506         {\cf17 noexcept}\par
00507         \{\par
00508                 {\cf19 return} (((*{\cf17 this})>=arg)?(*{\cf17 this}):arg);\par
00509         \}\par
00510 \par
00513         {\cf17 constexpr} {\cf17 inline}\par
00514         {\cf17 const} dig_t & operator |= (dig_t arg)\par
00515         {\cf17 noexcept}\par
00516         \{\par
00517                 {\cf19 if} (arg > (*{\cf17 this}))\par
00518                         (*this) = arg;\par
00519                 {\cf19 return} (*{\cf17 this});\par
00520         \}\par
00521 \par
00522 {\cf20                                 /******************************************************/}\par
00523                                 {\cf20 /*                                                                                                                                                                                                      */}\par
00524                                 {\cf20 /*      OPERADORES *^n *^=n                                                                                                                     */}\par
00525                                 {\cf20 /*  FUNCIONAN COMO Power(*,n) y n = Power(*,n)                  */}\par
00526                                 {\cf20 /*      DONDE n ES NATURAL                                                                                                                      */}\par
00527                                 {\cf20 /*                                                                                                                                                                                                      */}\par
00528 {\cf20                                 /******************************************************/}\par
00529 \par
00530         {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UIntType>\par
00531         {\cf17 constexpr} {\cf17 inline}\par
00532         {\cf17 const} dig_t & operator ^= (UIntType exp)\par
00533         {\cf17 noexcept}\par
00534         \{\par
00535                 dig_t& cthis\{*{\cf17 this}\};\par
00536                 {\cf19 if} (exp == 0) \{\par
00537                         cthis = dig_1();\par
00538                         {\cf19 return} (cthis);\par
00539                 \}\par
00540                 {\cf19 else} {\cf19 if} (exp == 1) \{\par
00541                         {\cf19 return} (cthis);\par
00542                 \}\par
00543                 {\cf19 else} {\cf19 if} (exp == 2) \{\par
00544                         cthis *= cthis;\par
00545                         {\cf19 return} (cthis);\par
00546                 \}\par
00547                 {\cf19 else} \{\par
00548                         {\cf17 const} dig_t  vthis\{*{\cf17 this}\};\par
00549                         cthis *= vthis;\par
00550                         {\cf19 for}(UIntType ix\{2\} ; ix < exp ; ++ix) \{\par
00551                                 cthis *= vthis;\par
00552                         \}\par
00553                         {\cf19 return} (cthis);\par
00554                 \}\par
00555         \}\par
00556 \par
00557         {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UIntType>\par
00558         {\cf17 constexpr} {\cf17 inline}\par
00559         dig_t operator ^ (UIntType exp) {\cf17 const}\par
00560         {\cf17 noexcept}\par
00561         \{\par
00562                 dig_t cpthis\{*{\cf17 this}\};\par
00563                 cpthis ^= exp;\par
00564                 {\cf19 return} cpthis;\par
00565         \}\par
00566 \par
00567 {\cf20                                 /****************************************/}\par
00568                                 {\cf20 /*                                                                                                      */}\par
00569                                 {\cf20 /* OPERADORES COMPARACION                                                               */}\par
00570                                 {\cf20 /*                                                                                                      */}\par
00571 {\cf20                                 /****************************************/}\par
00572 \par
00573         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} operator == (dig_t a) {\cf17 const}  {\cf17 noexcept}\par
00574                 \{{\cf19 return} ((a() == m_d)? {\cf17 true} : {\cf17 false});\}\par
00575         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} operator != (dig_t a) {\cf17 const}  {\cf17 noexcept}\par
00576                 \{{\cf19 return} ((a() != m_d)? {\cf17 true} : {\cf17 false});\}\par
00577         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} operator >= (dig_t a) {\cf17 const}  {\cf17 noexcept}\par
00578                 \{{\cf19 return} ((a() <= m_d)? {\cf17 true} : {\cf17 false});\}\par
00579         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} operator >  (dig_t a) {\cf17 const}  {\cf17 noexcept}\par
00580                 \{{\cf19 return} ((a() < m_d )? {\cf17 true} : {\cf17 false});\}\par
00581         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} operator <= (dig_t a) {\cf17 const}  {\cf17 noexcept}\par
00582                 \{{\cf19 return} ((a() >= m_d )? {\cf17 true} : {\cf17 false});\}\par
00583         {\cf17 constexpr} {\cf17 inline} {\cf18 bool} operator <  (dig_t a) {\cf17 const}  {\cf17 noexcept}\par
00584                 \{{\cf19 return} ((a() >  m_d )? {\cf17 true} : {\cf17 false});\}\par
00588         {\cf17 constexpr} {\cf17 inline}\par
00589         std::strong_ordering operator <=> (dig_t rhs) {\cf17 const}\par
00590         {\cf17 noexcept} \{\par
00591                 {\cf17 const} {\cf17 auto} lhs_d\{m_d\};\par
00592                 {\cf17 const} {\cf17 auto} rhs_d\{rhs()\};\par
00593                 {\cf19 return} (\par
00594                         (lhs_d<rhs_d)                                                                           ?\par
00595                                         std::strong_ordering::less      :\par
00596                                         ((lhs_d>rhs_d)                                                                          ?\par
00597                                                         std::strong_ordering::greater   :\par
00598                                                         std::strong_ordering::equal)\par
00599                 );\par
00600         \}\par
00601 \par
00602         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00603         {\cf17 constexpr} {\cf17 inline}\par
00604         {\cf18 bool} operator == (Int_t rhs)\par
00605         {\cf17 noexcept} \{\par
00606                 {\cf17 const} dig_t& lhs\{*{\cf17 this}\};\par
00607                 {\cf19 return}\par
00608                         (\par
00609                                 (lhs.m_d == normaliza<Int_t>(rhs))              ?\par
00610                                         {\cf17 true}                                    :\par
00611                                         {\cf17 false}\par
00612                         );\par
00613         \}\par
00617         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00618         {\cf17 constexpr} {\cf17 inline}\par
00619         std::weak_ordering operator <=> (Int_t rhs) {\cf17 const}\par
00620         {\cf17 noexcept} \{\par
00621                 {\cf17 const} dig_t& lhs\{*{\cf17 this}\};\par
00622                 {\cf17 const} UINT_T rhs_B\{normaliza<Int_t>(rhs)\};\par
00623                 {\cf19 return} ((lhs() < rhs_B)                                                                 ?\par
00624                                                 std::weak_ordering::less                                :\par
00625                                                 (lhs() > rhs_B)                                                                         ?\par
00626                                                         std::weak_ordering::greater             :\par
00627                                                         std::weak_ordering::equivalent\par
00628                 );\par
00629         \}\par
00630 \par
00631 {\cf20                                 /********************************************/}\par
00632                                 {\cf20 /*                                                                                                                                                      */}\par
00633                                 {\cf20 /*   ARITMETICOS CON ASIGNACION                                 */}\par
00634                                 {\cf20 /*                                                                                                                                                      */}\par
00635 {\cf20                                 /********************************************/}\par
00636 \par
00637         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator +=(dig_t arg)  {\cf17 noexcept}\par
00638         \{\par
00639                 dig_t & cthis\{*{\cf17 this}\};\par
00640                 {\cf19 if} {\cf17 constexpr} (B < type_traits::middle_max<UINT_T>())\par
00641                 \{\par
00642                         m_d += arg.m_d;\par
00643                         {\cf19 if}(m_d >= B)\par
00644                                 m_d -= B;\par
00645                         {\cf19 return} (cthis);\par
00646                 \}\par
00647                 {\cf19 else}\par
00648                 \{\par
00649                         SIG_UINT_T tmp\{m_d\};\par
00650                         tmp += (arg.m_d);\par
00651                         {\cf19 if}(tmp>=B)\par
00652                                 tmp -= B;\par
00653                         m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(tmp);\par
00654                         {\cf19 return} (cthis);\par
00655                 \}\par
00656         \}\par
00657 \par
00658         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00659         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator +=(Int_t arg)  {\cf17 noexcept}\par
00660         \{\par
00661                 {\cf19 if} {\cf17 constexpr} (B >= type_traits::middle_max<UINT_T>())\par
00662                 \{\par
00663                         {\cf17 const} SIG_UINT_T arg1\{normaliza<Int_t>(arg)\};\par
00664                         SIG_UINT_T arg2\{m_d\};\par
00665                         arg2+=arg1;\par
00666                         {\cf19 if} (arg2 >= {\cf17 static_cast<}Int_t{\cf17 >}(B))\par
00667                                 arg2-={\cf17 static_cast<}Int_t{\cf17 >}(B);\par
00668                         m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(arg2);\par
00669                         {\cf19 return} (*{\cf17 this});\par
00670                 \} {\cf19 else} \{\par
00671                         {\cf17 const} UINT_T arg1\{normaliza<Int_t>(arg)\};\par
00672                         UINT_T arg2\{m_d\};\par
00673                         arg2+=arg1;\par
00674                         {\cf19 if} (arg2 >= {\cf17 static_cast<}Int_t{\cf17 >}(B))\par
00675                                 arg2-={\cf17 static_cast<}Int_t{\cf17 >}(B);\par
00676                         m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(arg2);\par
00677                         {\cf19 return} (*{\cf17 this});\par
00678                 \}\par
00679         \}\par
00680 \par
00681         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator -=(dig_t arg)  {\cf17 noexcept}\par
00682         \{\par
00683                 SIG_SINT_T cp_dm\{m_d\};\par
00684                 cp_dm-=arg.m_d;\par
00685                 {\cf19 if} (cp_dm < 0)\par
00686                         cp_dm += ssi_B();\par
00687                 m_d = cp_dm;\par
00688                 {\cf19 return} (*{\cf17 this});\par
00689         \}\par
00690 \par
00691         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00692         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator -=(Int_t arg)  {\cf17 noexcept}\par
00693         \{\par
00694                 SIG_SINT_T tmp\{normaliza<Int_t>(arg)\};\par
00695                 SIG_SINT_T este\{m_d\};\par
00696                 este-=tmp;\par
00697                 {\cf19 if} (este<{\cf17 static_cast<}SIG_SINT_T{\cf17 >}(0))\par
00698                         este += ssi_B();\par
00699                 m_d = este;\par
00700                 {\cf19 return} (*{\cf17 this});\par
00701         \}\par
00702 \par
00703         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator *=(dig_t arg)  {\cf17 noexcept}\par
00704         \{\par
00705                 {\cf19 if} {\cf17 constexpr} (B < type_traits::sqrt_max<UINT_T>()) \{\par
00706                         m_d *= arg.m_d;\par
00707                         m_d %= B;\par
00708                         {\cf19 return} (*{\cf17 this});\par
00709                 \} {\cf19 else} \{\par
00710                         SIG_UINT_T tmp\{m_d\};\par
00711                         tmp *= arg.m_d;\par
00712                         tmp %= {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(B);\par
00713                         m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(tmp);\par
00714                         {\cf19 return} (*{\cf17 this});\par
00715                 \}\par
00716         \}\par
00717 \par
00718         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00719         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator *=(Int_t arg)  {\cf17 noexcept}\par
00720         \{\par
00721                 {\cf17 const} Int_t tmp\{normaliza<Int_t>(arg)\};\par
00722                 {\cf19 if} {\cf17 constexpr} (std::is_signed_v<Int_t>)\par
00723                 \{\par
00724                         {\cf19 if} {\cf17 constexpr} ({\cf17 sizeof}(Int_t)>{\cf17 sizeof}(UINT_T))\par
00725                         \{\par
00726                                 {\cf17 using }SIG2_SINT_T = type_traits::sig_SInt_for_SInt_t<Int_t>;\par
00727                                 {\cf17 const} SIG2_SINT_T norm_arg\{tmp\};\par
00728                                 SIG2_SINT_T este\{m_d\};\par
00729                                 este *= norm_arg;\par
00730                                 este %= {\cf17 static_cast<}SIG2_SINT_T{\cf17 >}(B);\par
00731                                 m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(este);\par
00732                                 {\cf19 return} (*{\cf17 this});\par
00733                         \}\par
00734                         {\cf19 else}\par
00735                         \{\par
00736                                 {\cf17 const} SIG_SINT_T norm_arg\{tmp\};\par
00737                                 SIG_SINT_T este\{m_d\};\par
00738                                 este *= norm_arg;\par
00739                                 este %= {\cf17 static_cast<}SIG_SINT_T{\cf17 >}(B);\par
00740                                 m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(este);\par
00741                                 {\cf19 return} (*{\cf17 this});\par
00742                         \}\par
00743                 \}\par
00744                 {\cf19 else}\par
00745                 \{\par
00746                         {\cf19 if} {\cf17 constexpr} ({\cf17 sizeof}(Int_t)>{\cf17 sizeof}(UINT_T))\par
00747                         \{\par
00748                                 {\cf17 using }SIG2_UINT_T = type_traits::sig_UInt_for_UInt_t<Int_t>;\par
00749                                 {\cf17 const} SIG2_UINT_T norm_arg\{tmp\};\par
00750                                 SIG2_UINT_T este\{m_d\};\par
00751                                 este *= norm_arg;\par
00752                                 este %= {\cf17 static_cast<}SIG2_UINT_T{\cf17 >}(B);\par
00753                                 m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(este);\par
00754                                 {\cf19 return} (*{\cf17 this});\par
00755                         \}\par
00756                         {\cf19 else}\par
00757                         \{\par
00758                                 {\cf17 const} SIG_UINT_T norm_arg\{tmp\};\par
00759                                 SIG_UINT_T este\{m_d\};\par
00760                                 este *= norm_arg;\par
00761                                 este %= {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(B);\par
00762                                 m_d = {\cf17 static_cast<}UINT_T{\cf17 >}(este);\par
00763                                 {\cf19 return} (*{\cf17 this});\par
00764                         \}\par
00765                 \}\par
00766         \}\par
00767 \par
00768         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator /=(dig_t arg)  {\cf17 noexcept}\par
00769         \{\par
00770                 {\cf19 if} (arg.m_d != ui_0())\par
00771                         m_d /= arg.m_d;\par
00772                 {\cf19 return} (*{\cf17 this});\par
00773         \}\par
00774 \par
00775         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00776         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator /=(Int_t arg)  {\cf17 noexcept}\par
00777         \{\par
00778                 UINT_T cparg\{normaliza<Int_t>(arg)\};\par
00779                 dig_t tmp\{cparg\};\par
00780                 {\cf19 if} (tmp != dig_0())\par
00781                         (*this)/=tmp;\par
00782                 {\cf19 return} (*{\cf17 this});\par
00783         \}\par
00784 \par
00785         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator %=(dig_t arg)  {\cf17 noexcept}\par
00786         \{\par
00787                 {\cf19 if} (arg.m_d != ui_0())\par
00788                         m_d %= arg.m_d;\par
00789                 {\cf19 return} (*{\cf17 this});\par
00790         \}\par
00791 \par
00792         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_t>\par
00793         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t & operator %=(Int_t arg)  {\cf17 noexcept}\par
00794         \{\par
00795                 dig_t cparg\{normaliza<Int_t>(arg)\};\par
00796                 {\cf19 if} (cparg != dig_0())\par
00797                         (*this)%=cparg;\par
00798                 {\cf19 return} (*{\cf17 this});\par
00799         \}\par
00804 \par
00805 {\cf20                                 /********************************/}\par
00806                                 {\cf20 /*                                                                                                      */}\par
00807                                 {\cf20 /*                PRE Y POST                                                    */}\par
00808                                 {\cf20 /*                      CIRCULARES                                                      */}\par
00809                                 {\cf20 /*                                                                                                                      */}\par
00810 {\cf20                                 /********************************/}\par
00811 \par
00812         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t& operator ++ ()  noexcept \{\par
00813                 (m_d < ui_max())        ?\par
00814                         (m_d+=ui_1())   :\par
00815                         (m_d=ui_0());\par
00816                 {\cf19 return}(*{\cf17 this});\par
00817         \}\par
00818 \par
00819         {\cf17 constexpr} {\cf17 inline} dig_t operator ++ ({\cf18 int}) {\cf17 noexcept} \{\par
00820                 dig_t ret(*{\cf17 this});\par
00821                 ++(*this);\par
00822                 {\cf19 return} ret;\par
00823         \}\par
00824 \par
00825         {\cf17 constexpr} {\cf17 inline} {\cf17 const} dig_t& operator -- ()  noexcept \{\par
00826                 m_d = (m_d > ui_0())                    ?\par
00827                                                 (m_d-ui_1())    :\par
00828                                                 (ui_max())      ;\par
00829                 {\cf19 return}(*{\cf17 this});\par
00830         \}\par
00831 \par
00832         {\cf17 constexpr} {\cf17 inline} dig_t operator -- ({\cf18 int}) {\cf17 noexcept} \{\par
00833                 dig_t ret(*{\cf17 this});\par
00834                 --(*this);\par
00835                 {\cf19 return} ret;\par
00836         \}\par
00837 \par
00838 {\cf20                                 /****************************************/}\par
00839                                 {\cf20 /*                                                                                                                                                      */}\par
00840                                 {\cf20 /*    OPERADORES ARITMETICOS                                    */}\par
00841                                 {\cf20 /*                                                                                                                                                      */}\par
00842 {\cf20                                 /****************************************/}\par
00843 \par
00844         {\cf17 constexpr} {\cf17 inline}\par
00845         dig_t operator + (dig_t arg) {\cf17 const}\par
00846         {\cf17 noexcept} \{\par
00847                 dig_t ret(*{\cf17 this});\par
00848                 ret += arg;\par
00849                 {\cf19 return} ret;\par
00850         \}\par
00851 \par
00852         {\cf17 constexpr} {\cf17 inline}\par
00853         dig_t operator - (dig_t arg) {\cf17 const}\par
00854         {\cf17 noexcept} \{\par
00855                 dig_t ret(*{\cf17 this});\par
00856                 ret -= arg;\par
00857                 {\cf19 return} ret;\par
00858         \}\par
00859 \par
00860         {\cf17 constexpr} {\cf17 inline}\par
00861         dig_t operator * (dig_t arg) {\cf17 const}\par
00862         {\cf17 noexcept} \{\par
00863                 dig_t ret(*{\cf17 this});\par
00864                 ret *= arg;\par
00865                 {\cf19 return} ret;\par
00866         \}\par
00867 \par
00868         {\cf17 constexpr} {\cf17 inline}\par
00869         dig_t operator / (dig_t arg) {\cf17 const}\par
00870         {\cf17 noexcept} \{\par
00871                 dig_t ret(*{\cf17 this});\par
00872                 ret /= arg;\par
00873                 {\cf19 return} ret;\par
00874         \}\par
00875 \par
00876         {\cf17 constexpr} {\cf17 inline}\par
00877         dig_t operator % (dig_t arg) {\cf17 const}\par
00878         {\cf17 noexcept} \{\par
00879                 dig_t ret(*{\cf17 this});\par
00880                 ret %= arg;\par
00881                 {\cf19 return} ret;\par
00882         \}\par
00883 \par
00884         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_type>\par
00885         {\cf17 constexpr} {\cf17 inline}\par
00886         dig_t operator + (Int_type arg) {\cf17 const}\par
00887         {\cf17 noexcept} \{\par
00888                 dig_t ret(*{\cf17 this});\par
00889                 ret += normaliza<Int_type>(arg);\par
00890                 {\cf19 return} ret;\par
00891         \}\par
00892 \par
00893         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_type>\par
00894         {\cf17 constexpr} {\cf17 inline}\par
00895         dig_t operator - (Int_type arg) {\cf17 const}\par
00896         {\cf17 noexcept} \{\par
00897                 dig_t ret(*{\cf17 this});\par
00898                 {\cf17 const} dig_t tmp(normaliza<Int_type>(arg));\par
00899                 ret -= tmp;\par
00900                 {\cf19 return} ret;\par
00901         \}\par
00902 \par
00903         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_type>\par
00904         {\cf17 constexpr} {\cf17 inline}\par
00905         dig_t operator * (Int_type arg) {\cf17 const}\par
00906         {\cf17 noexcept} \{\par
00907                 dig_t ret(*{\cf17 this});\par
00908                 {\cf17 const} dig_t tmp(normaliza<Int_type>(arg));\par
00909                 ret *= tmp;\par
00910                 {\cf19 return} ret;\par
00911         \}\par
00912 \par
00913         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_type>\par
00914         {\cf17 constexpr} {\cf17 inline}\par
00915         dig_t operator / (Int_type arg) {\cf17 const}\par
00916         {\cf17 noexcept} \{\par
00917                 dig_t ret(*{\cf17 this});\par
00918                 {\cf17 const} dig_t cparg(normaliza<Int_type>(arg));\par
00919                 {\cf19 if} (cparg != dig_0())\par
00920                         ret /= cparg;\par
00921                 {\cf19 return} ret;\par
00922         \}\par
00923 \par
00924         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_type>\par
00925         {\cf17 constexpr} {\cf17 inline}\par
00926         dig_t operator % (Int_type arg) {\cf17 const}\par
00927         {\cf17 noexcept} \{\par
00928                 dig_t ret(*{\cf17 this});\par
00929                 {\cf17 const} dig_t cparg(normaliza<Int_type>(arg));\par
00930                 {\cf19 if} (cparg != dig_0())\par
00931                         ret %= cparg;\par
00932                 {\cf19 return} ret;\par
00933         \}\par
00934 \par
00935 {\cf20                                 /****************************************/}\par
00936                                 {\cf20 /*                                                                                                                                                      */}\par
00937                                 {\cf20 /*           COMPLEMENTO BASE                                                   */}\par
00938                                 {\cf20 /*            Y BASE MENOS 1                                                            */}\par
00939                                 {\cf20 /*                                                                                                                                                      */}\par
00940 {\cf20                                 /****************************************/}\par
00941 \par
00943         {\cf17 constexpr} {\cf17 inline}\par
00944         dig_t operator ! () const\par
00945         noexcept \{\par
00946                         {\cf19 return} dig_t(ui_max()-m_d);\par
00947         \}\par
00949         {\cf17 constexpr} {\cf17 inline}\par
00950         dig_t operator - () const\par
00951         noexcept \{\par
00952                         {\cf19 return} dig_t((m_d==0)?0:(B-m_d));\par
00953         \}\par
00954 \par
00955         {\cf17 constexpr} {\cf17 inline}   \par
00956         dig_t C_Bm1 () const\par
00957         noexcept \{\par
00958                         {\cf19 return} dig_t(ui_max()-m_d);\par
00959         \}\par
00960 \par
00961         {\cf17 constexpr} {\cf17 inline}  \par
00962         dig_t C_B () const\par
00963         noexcept \{\par
00964                         {\cf19 return} dig_t((m_d==0)?0:(B-m_d));\par
00965         \}\par
00966 \par
00967 {\cf20                                 /****************************************************/}\par
00968                                 {\cf20 /*                                                                                                                                                                                      */}\par
00969                                 {\cf20 /*    MODIFICADORES COMPLEMENTO                                                                 */}\par
00970                                 {\cf20 /*                                                                                                                                                                                      */}\par
00971 {\cf20                                 /****************************************************/}\par
00972 \par
00973         {\cf17 constexpr} {\cf17 inline}\par
00974         {\cf17 const} dig_t & mC_Bm1 ()\par
00975         noexcept \{\par
00976                 m_d=(ui_max()-m_d);\par
00977                 {\cf19 return} (*{\cf17 this});\par
00978         \}\par
00979 \par
00980         {\cf17 constexpr} {\cf17 inline}\par
00981         {\cf17 const} dig_t & mC_B ()\par
00982         noexcept \{\par
00983                 (m_d==0)                                                ?\par
00984                         (m_d)                                                   :\par
00985                         (m_d=(B-m_d));\par
00986                 {\cf19 return} (*{\cf17 this});\par
00987         \}\par
00988 \par
01005 \par
01006 {\cf20                                 /**********************************/}\par
01007                                 {\cf20 /*                                */}\par
01008                                 {\cf20 /*      NULO Y MAXIMO                   */}\par
01009                                 {\cf20 /*                                */}\par
01010 {\cf20                                 /**********************************/}\par
01011 \par
01012         {\cf17 constexpr} {\cf17 inline}\par
01013         {\cf18 bool} is_0 () const\par
01014         noexcept \{\par
01015                 {\cf19 return} (m_d == ui_0());\par
01016         \}\par
01017 \par
01018         {\cf17 constexpr} {\cf17 inline}\par
01019         {\cf18 bool} is_1 () const\par
01020         noexcept \{\par
01021                 {\cf19 return} (m_d == ui_1());\par
01022         \}\par
01023 \par
01024         {\cf17 constexpr} {\cf17 inline}\par
01025         {\cf18 bool} is_0or1 () const\par
01026         noexcept \{\par
01027                 {\cf19 return} ((m_d == ui_0())||(m_d == ui_1()));\par
01028         \}\par
01029 \par
01030         {\cf17 constexpr} {\cf17 inline}\par
01031         {\cf18 bool} is_not_1 () const\par
01032         noexcept \{\par
01033                 {\cf19 return} (m_d != ui_1());\par
01034         \}\par
01035 \par
01036         {\cf17 constexpr} {\cf17 inline}\par
01037         {\cf18 bool} is_not_0 () const\par
01038         noexcept \{\par
01039                 {\cf19 return} (m_d != ui_0());\par
01040         \}\par
01041 \par
01042         {\cf17 constexpr} {\cf17 inline}\par
01043         {\cf18 bool} is_not_0or1 () const\par
01044         noexcept \{\par
01045                 {\cf19 return} ( ! is_0or1() );\par
01046         \}\par
01047 \par
01048         {\cf17 constexpr} {\cf17 inline}\par
01049         {\cf18 bool} is_Bm1 () const\par
01050         noexcept \{\par
01051                 {\cf19 return} (m_d == ui_Bm1());\par
01052         \}\par
01053 \par
01054         {\cf17 constexpr} {\cf17 inline}\par
01055         {\cf18 bool} is_not_Bm1 () const\par
01056         noexcept \{\par
01057                 {\cf19 return} (m_d != ui_Bm1());\par
01058         \}\par
01059 \par
01060         {\cf17 constexpr} {\cf17 inline}\par
01061         {\cf18 bool} is_Bm1orBm2() const\par
01062         noexcept \{\par
01063                 {\cf19 return} (is_Bm1() || is_Bm2());\par
01064         \}\par
01065 \par
01066         {\cf17 constexpr} {\cf17 inline}\par
01067         {\cf18 bool} is_not_Bm1orBm2() const\par
01068         noexcept \{\par
01069                 {\cf19 return} (is_not_Bm1() && is_not_Bm2());\par
01070         \}\par
01071 \par
01072         {\cf17 constexpr} {\cf17 inline}\par
01073         {\cf18 bool} is_Bm2() const\par
01074         noexcept \{\par
01075                 {\cf19 return} (m_d == ui_Bm2());\par
01076         \}\par
01077 \par
01078         {\cf17 constexpr} {\cf17 inline}\par
01079         {\cf18 bool} is_not_Bm2() const\par
01080         noexcept \{\par
01081                 {\cf19 return} (m_d != ui_Bm2());\par
01082         \}\par
01083 \par
01084         {\cf17 constexpr} {\cf17 inline}\par
01085         {\cf18 bool} is_not_maxormin() const\par
01086         noexcept \{\par
01087                 {\cf19 return} (is_not_0() && is_not_Bm1());\par
01088         \}\par
01089 \par
01090         {\cf17 constexpr} {\cf17 inline}\par
01091         {\cf18 bool} is_maxormin() const\par
01092         noexcept \{\par
01093                 {\cf19 return} (is_0() || is_Bm1());\par
01094         \}\par
01095 \par
01096         {\cf17 constexpr} {\cf17 inline}\par
01097         {\cf18 bool} is_far_maxormin() const\par
01098         noexcept \{\par
01099                 {\cf19 if} {\cf17 constexpr} (B == 2u) \{\par
01100                         {\cf19 return} {\cf17 false};\par
01101                 \}\par
01102                 {\cf19 else} \{\par
01103                         {\cf19 return} (is_not_0() && is_not_Bm1() && is_not_1() && is_not_Bm2());\par
01104                 \}\par
01105         \}\par
01106 \par
01107         {\cf17 constexpr} {\cf17 inline}\par
01108         {\cf18 bool} is_near_maxormin() const\par
01109         noexcept \{\par
01110                 {\cf19 if} {\cf17 constexpr} (B == 2u) \{\par
01111                         {\cf19 return} {\cf17 true};\par
01112                 \}\par
01113                 {\cf19 else} \{\par
01114                         {\cf19 return} (is_0() || is_Bm1() || is_1() || is_Bm2());\par
01115                 \}\par
01116         \}\par
01117 \par
01118 {\cf20                                 /********************************/}\par
01119                                 {\cf20 /*                                                              */}\par
01120                                 {\cf20 /*           VARIOS CASTS                       */}\par
01121                                 {\cf20 /*                                                              */}\par
01122 {\cf20                                 /********************************/}\par
01123 \par
01125 {\cf17 private}:\par
01126         {\cf17 constexpr} {\cf17 inline}\par
01127         std::string num_to_string() const\par
01128         noexcept\par
01129         \{\par
01130                 {\cf17 const} std::int64_t data_member = {\cf17 static_cast<}std::int64_t{\cf17 >}(this->m_d);\par
01131                 std::ostringstream fmtr_obj;\par
01132                 fmtr_obj << data_member;\par
01133                 {\cf17 const} std::string ret\{fmtr_obj.str()\};\par
01134                 {\cf19 return} ret;\par
01135         \}\par
01136 \par
01137         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01138         std::string radix_str()\par
01139         noexcept\par
01140         \{\par
01141                 {\cf17 constexpr} std::int64_t radix = {\cf17 static_cast<}std::int64_t{\cf17 >}(B);\par
01142                 std::ostringstream fmtr_obj;\par
01143                 fmtr_obj << radix;\par
01144                 {\cf17 const} std::string ret\{{\cf22 "B"}+fmtr_obj.str()\};\par
01145                 {\cf19 return} ret;\par
01146         \}\par
01147 {\cf17 public}:\par
01148         {\cf17 constexpr} {\cf17 inline}\par
01149         std::string to_string() const\par
01150         noexcept\par
01151         \{\par
01152                 {\cf17 const} std::string num\{this->num_to_string()\};\par
01153                 {\cf17 const} std::string ret\{{\cf22 "dig#"}+num+{\cf22 "#"}+radix_str()\};\par
01154                 {\cf19 return} ret;\par
01155         \}\par
01156 \par
01157 \par
01160 \par
01161   {\cf17 static} {\cf17 constexpr}\par
01162   {\cf18 bool} is_type_template_string_id(std::string in) {\cf17 noexcept} \{\par
01163     {\cf19 return}      (\par
01164       (in == {\cf22 "dig_t"})||\par
01165                         (in == {\cf22 "dig_"})||\par
01166                         (in == {\cf22 "dig"})||\par
01167       (in == {\cf22 "di"})||\par
01168       (in == {\cf22 "d"})\par
01169     );\par
01170   \}\par
01171 \par
01172   {\cf17 static} {\cf17 constexpr}\par
01173   std::string to_type_template_string_id() noexcept\par
01174   \{     {\cf19 return} std::string\{{\cf22 "digs_t"}\};   \}\par
01175 \par
01176   {\cf17 static} {\cf17 constexpr}\par
01177   {\cf18 size_t} size_of_type_template_string_id() noexcept\par
01178   \{     {\cf19 return} (to_type_template_string_id()).size();   \}\par
01179 \par
01180 \par
01183   {\cf18 bool} get_type_template_string_id_token(std::istream& is)\par
01184   {\cf17 noexcept} \{\par
01185         {\cf18 char} input_char\{{\cf23 '\\0'}\};\par
01186     std::string old_input_string\{{\cf22 ""}\};\par
01187     std::string new_input_string\{{\cf22 ""}\};\par
01188     {\cf18 size_t} index\{ 0 \};\par
01189     {\cf19 while}({\cf17 true}) \{\par
01190       is >> input_char;\par
01191       new_input_string += input_char;\par
01192       {\cf19 if} (is_type_template_string_id(new_input_string)) \{\par
01193         old_input_string = new_input_string;\par
01194       \}\par
01195       {\cf19 else} \{\par
01196         std::cerr << {\cf22 "Has cometido un error, tenias que escribir "}\par
01197         << {\cf22 "\\" "} << to_type_template_string_id()\par
01198         << {\cf22 " \\"  y has escrito "}\par
01199         << new_input_string << std::endl;\par
01200         std::cerr << {\cf22 "Considera que has escrito "}\par
01201         << old_input_string\par
01202         << {\cf22 " y continua escribiendo a partir de ahi"};\par
01203         new_input_string = old_input_string;\par
01204       \}\par
01205 \par
01206       {\cf19 if} (new_input_string==to_type_template_string_id())\par
01207         {\cf19 return} {\cf17 true};\par
01208       {\cf19 else}\par
01209         {\cf19 return} {\cf17 false};\par
01210     \}\par
01211   \}\par
01212 \par
01213 {\cf20 //  /// FUNCION QUE CONSIGUE EL TOKEN PUNTO FIJO}\par
01214 {\cf20 //  bool get_fixed_point_token(std::istream& is,std::ostream& errs)}\par
01215 {\cf20 //  \{}\par
01216 {\cf20 //    std::string old_input_string\{""\};}\par
01217 {\cf20 //    std::string new_input_string\{""\};}\par
01218 {\cf20 //    size_t index\{0\};}\par
01219 {\cf20 //    char input_char = nullchar<char>;}\par
01220 {\cf20 //    while(true) \{}\par
01221 {\cf20 //      is >> input_char;}\par
01222 {\cf20 //      if ((index==0)&&(is_separator(input_char))) \{}\par
01223 {\cf20 //        new_input_string += input_char;}\par
01224 {\cf20 //        old_input_string = new_input_string;}\par
01225 {\cf20 //        ++index;}\par
01226 {\cf20 //      \}}\par
01227 {\cf20 //      else if ((index == 0)&&(! is_separator(input_char))) \{}\par
01228 {\cf20 //        errs << "Has cometido un error, tenias que escribir "}\par
01229 {\cf20 //        << "\\" " << '#'       << " \\"  y has escrito "}\par
01230 {\cf20 //        << new_input_string << std::endl;}\par
01231 {\cf20 //        errs << "Considera que has escrito "}\par
01232 {\cf20 //        << old_input_string}\par
01233 {\cf20 //        << " y continua escribiendo a partir de ahi";}\par
01234 {\cf20 //        new_input_string = old_input_string;}\par
01235 {\cf20 //      \}}\par
01236 {\cf20 //      else if ((index == 1)&&(input_char == '.')) \{}\par
01237 {\cf20 //        new_input_string += input_char;}\par
01238 {\cf20 //        old_input_string = new_input_string;}\par
01239 {\cf20 //      \}}\par
01240 {\cf20 //      else\{}\par
01241 {\cf20 //        errs << "Has cometido un error, tenias que escribir "}\par
01242 {\cf20 //        << " \\" " << "#."}\par
01243 {\cf20 //        << " \\"  y has escrito "}\par
01244 {\cf20 //        << new_input_string << std::endl;}\par
01245 {\cf20 //        errs << "Considera que has escrito "}\par
01246 {\cf20 //        << old_input_string}\par
01247 {\cf20 //        << " y continua escribiendo a partir de ahi";}\par
01248 {\cf20 //        new_input_string = old_input_string;}\par
01249 {\cf20 //      \}}\par
01250 {\cf20 //}\par
01251 {\cf20 //      if (new_input_string=="#.")}\par
01252 {\cf20 //        return true;}\par
01253 {\cf20 //      else}\par
01254 {\cf20 //        return false;}\par
01255 {\cf20 //    \}}\par
01256 {\cf20 //  \}}\par
01257 \par
01258 {\cf20 //  /// FUNCION QUE CONSIGUE EL TOKEN SIGNO EXPLICITO}\par
01259 {\cf20 //  bool get_explicit_sign_token(}\par
01260 {\cf20 //              std::istream& is,std::ostream& errs,sign_e& signo}\par
01261 {\cf20 //      ) \{}\par
01262 {\cf20 //    std::string old_input_string\{""\};}\par
01263 {\cf20 //    std::string new_input_string\{""\};}\par
01264 {\cf20 //    size_t index\{0\};}\par
01265 {\cf20 //    char input_char = nullchar<char>;}\par
01266 {\cf20 //    while(true) \{}\par
01267 {\cf20 //      is >> input_char;}\par
01268 {\cf20 //      if ((index==0)&&(is_separator(input_char))) \{}\par
01269 {\cf20 //        new_input_string += input_char;}\par
01270 {\cf20 //        old_input_string = new_input_string;}\par
01271 {\cf20 //        ++index;}\par
01272 {\cf20 //      \}}\par
01273 {\cf20 //      else if (}\par
01274 {\cf20 //        (index == 0)&&(! is_separator(input_char))}\par
01275 {\cf20 //      ) \{}\par
01276 {\cf20 //        errs << "Has cometido un error, tenias que escribir "}\par
01277 {\cf20 //        << " \\" " << '#' << " \\"  y has escrito "}\par
01278 {\cf20 //        << new_input_string << std::endl;}\par
01279 {\cf20 //        errs << "Considera que has escrito "}\par
01280 {\cf20 //        << old_input_string}\par
01281 {\cf20 //        << " y continua escribiendo a partir de ahi";}\par
01282 {\cf20 //        new_input_string = old_input_string;}\par
01283 {\cf20 //      \}}\par
01284 {\cf20 //      else if((index==1)&&((input_char == '+')||}\par
01285 {\cf20 //                           (input_char == '-')}\par
01286 {\cf20 //                          )                                                                                   )}\par
01287 {\cf20 //      \{}\par
01288 {\cf20 //        new_input_string += input_char;}\par
01289 {\cf20 //        old_input_string = new_input_string;}\par
01290 {\cf20 //        signo = sign_value(input_char);}\par
01291 {\cf20 //        break;}\par
01292 {\cf20 //      \}}\par
01293 {\cf20 //      else\{}\par
01294 {\cf20 //        errs << "Has cometido un error, tenias que "}\par
01295 {\cf20 //        <<" escribir \\" " << "#+ o #-" << " \\"  y has escrito "}\par
01296 {\cf20 //        << new_input_string << std::endl;}\par
01297 {\cf20 //        errs << "Considera que has escrito "}\par
01298 {\cf20 //        << old_input_string}\par
01299 {\cf20 //        << " y continua escribiendo a partir de ahi";}\par
01300 {\cf20 //        new_input_string = old_input_string;}\par
01301 {\cf20 //      \}}\par
01302 {\cf20 //}\par
01303 {\cf20 //      if( (new_input_string=="#+")||}\par
01304 {\cf20 //          (new_input_string=="#-")    )}\par
01305 {\cf20 //        return true;}\par
01306 {\cf20 //      else}\par
01307 {\cf20 //        return false;}\par
01308 {\cf20 //    \}}\par
01309 {\cf20 //  \}}\par
01310 \par
01312   {\cf17 static} {\cf17 constexpr}\par
01313   {\cf18 bool} get_digit_token(std::istream& is,UINT_T& uint_value)\par
01314   \{\par
01315     std::string old_input_string\{{\cf22 ""}\};\par
01316     std::string new_input_string\{{\cf22 ""}\};\par
01317     {\cf18 size_t} index\{0\};\par
01318     {\cf18 char} input_char = type_traits::nullchar<char>;\par
01319     uint_value = 0;\par
01320     {\cf19 while}({\cf17 true}) \{\par
01321       is >> input_char;\par
01322       {\cf19 if} ((index==0)&&(NumRepr::lex::is_separator(input_char))) \{\par
01323         new_input_string += input_char;\par
01324         old_input_string = new_input_string;\par
01325         ++index;\par
01326       \}\par
01327       {\cf19 else} {\cf19 if} ((index == 0)&&(! lex::is_separator(input_char))) \{\par
01328         std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
01329         << {\cf22 " escribir \\" "} << {\cf23 '#'} << {\cf22 " \\"  y has escrito "}\par
01330         << new_input_string << std::endl;\par
01331         std::cerr << {\cf22 "Considera que has escrito "}\par
01332         << old_input_string\par
01333         << {\cf22 " y continua escribiendo a partir de ahi"};\par
01334         new_input_string = old_input_string;\par
01335       \}\par
01336       {\cf19 else} {\cf19 if}((index>=1) && lex::is_digit(input_char)) \{\par
01337         {\cf19 if} (lex::digit_value(input_char) < B) \{\par
01338           new_input_string += input_char;\par
01339           uint_value *= B;\par
01340           uint_value += lex::digit_value(input_char);\par
01341           {\cf19 if} (uint_value < B) \{\par
01342             old_input_string = new_input_string;\par
01343             ++index;\par
01344           \}\par
01345           {\cf19 else} \{\par
01346             old_input_string = {\cf22 "#"};\par
01347             std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
01348             << {\cf22 "poner un valor menor que la base y has "}\par
01349             << {\cf22 "puesto \\" "} << uint_value << {\cf22 " \\" escrito como \\" "}\par
01350             << new_input_string << {\cf22 " \\" "} << std::endl;\par
01351             uint_value = 0;\par
01352             {\cf19 return} {\cf17 false};\par
01353           \}\par
01354         \}\par
01355         {\cf19 else} {\cf19 if}((index>=1) && ! lex::is_digit(input_char) && (input_char != {\cf23 '_'})) \{\par
01356           std::cerr << {\cf22 "El caracter "} << input_char << {\cf22 " no es valido aqui "}\par
01357           << std::endl;\par
01358           uint_value = 0;\par
01359           {\cf19 return} {\cf17 false};\par
01360         \}\par
01361       \}\par
01362       {\cf19 else} {\cf19 if}((index>1)&&(input_char == {\cf23 '_'})) \{\par
01363         {\cf19 return} {\cf17 true};\par
01364       \}\par
01365       {\cf19 else}\{\par
01366         std::cerr << {\cf22 "Has cometido un error, tenias que escribir "}\par
01367         << {\cf22 " \\" "} << {\cf22 "#digdigdig..._"}\par
01368         << {\cf22 " \\"  y has escrito "}\par
01369         << new_input_string << std::endl;\par
01370         uint_value = 0;\par
01371         {\cf19 return} {\cf17 false};\par
01372       \}\par
01373     \}\par
01374   \}\par
01375 \par
01377   {\cf17 static}\par
01378   {\cf18 bool} get_radix_token(std::istream& is)\par
01379   \{\par
01380     std::string old_input_string\{{\cf22 ""}\};\par
01381     std::string new_input_string\{{\cf22 ""}\};\par
01382     UINT_T uint_radix;\par
01383     {\cf18 size_t} index\{0\};\par
01384     {\cf18 char} input_char = type_traits::nullchar<char>;\par
01385     uint_radix = 0;\par
01386     {\cf19 while}({\cf17 true}) \{\par
01387       is >> input_char;\par
01388       {\cf19 if} ((index==0)&&(lex::is_separator(input_char))) \{\par
01389         new_input_string += input_char;\par
01390         old_input_string = new_input_string;\par
01391         ++index;\par
01392       \}\par
01393       {\cf19 else} {\cf19 if} ((index == 0)&&(! lex::is_separator(input_char))) \{\par
01394         std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
01395         << {\cf22 " escribir \\" "} << {\cf23 '#'} << {\cf22 " \\"  y has escrito "}\par
01396         << new_input_string << std::endl;\par
01397         std::cerr << {\cf22 "Considera que has escrito "}\par
01398         << old_input_string\par
01399         << {\cf22 " y continua escribiendo a partir de ahi"};\par
01400         new_input_string = old_input_string;\par
01401       \}\par
01402       {\cf19 else} {\cf19 if} ((index==1)&&((input_char=={\cf23 'b'})||(input_char=={\cf23 'B'}))) \{\par
01403         new_input_string += input_char;\par
01404         old_input_string = new_input_string;\par
01405         ++index;\par
01406       \}\par
01407       {\cf19 else} {\cf19 if} ((index == 1)&&((input_char!={\cf23 'b'})&&(input_char!={\cf23 'B'}))) \{\par
01408         std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
01409         << {\cf22 " escribir \\" "} << {\cf23 '#'} << {\cf22 " \\"  y has escrito "}\par
01410         << new_input_string << std::endl;\par
01411         std::cerr << {\cf22 "Considera que has escrito "}\par
01412         << old_input_string\par
01413         << {\cf22 " y continua escribiendo a partir de ahi"};\par
01414         new_input_string = old_input_string;\par
01415       \}\par
01416       {\cf19 else} {\cf19 if}((index>=2) && lex::is_digit(input_char)) \{\par
01417         {\cf19 if} (lex::digit_value(input_char) <= B) \{\par
01418           new_input_string += input_char;\par
01419           uint_radix *= B;\par
01420           uint_radix += lex::digit_value(input_char);\par
01421           {\cf19 if} (uint_radix <= B) \{\par
01422             old_input_string = new_input_string;\par
01423             ++index;\par
01424           \}\par
01425           {\cf19 else} \{\par
01426             old_input_string = {\cf22 "#"};\par
01427             std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
01428             << {\cf22 "poner un valor menor que la base y has "}\par
01429             << {\cf22 "puesto \\" "} << uint_radix << {\cf22 " \\" escrito como \\" "}\par
01430             << new_input_string << {\cf22 " \\" "} << std::endl;\par
01431             uint_radix = 0;\par
01432             {\cf19 return} {\cf17 false};\par
01433           \}\par
01434         \}\par
01435         {\cf19 else} {\cf19 if}((index>=3) && ! lex::is_digit(input_char) && (input_char != {\cf23 '_'})) \{\par
01436           std::cerr << {\cf22 "El caracter "} << input_char << {\cf22 " no es valido aqui "}\par
01437           << std::endl;\par
01438           uint_radix = 0;\par
01439           {\cf19 return} {\cf17 false};\par
01440         \}\par
01441       \}\par
01442       {\cf19 else} {\cf19 if}((index>2)&&(input_char == {\cf23 '_'})) \{\par
01443         {\cf19 return} {\cf17 true};\par
01444       \}\par
01445       {\cf19 else}\{\par
01446         std::cerr << {\cf22 "Has cometido un error, tenias que escribir "}\par
01447         << {\cf22 " \\" "} << {\cf22 "#Bdigdigdig..._"}\par
01448         << {\cf22 " \\"  y has escrito "}\par
01449         << new_input_string << std::endl;\par
01450         uint_radix = 0;\par
01451         {\cf19 return} {\cf17 false};\par
01452       \}\par
01453     \}\par
01454   \}\par
01455 \par
01456         {\cf17 static}\par
01457         {\cf18 bool} read(std::istream& is,dig_t& value) {\cf17 noexcept} \{\par
01458                 dig_t default_value\{\};\par
01459                 {\cf18 bool} type_token = dig_t::get_type_template_string_id_token(is);\par
01460                 {\cf19 if} (type_token) \{\par
01461                         {\cf19 if} (get_digit_token(is,value)) \{\par
01462                                 {\cf19 if} (get_radix_token(is)) \{\par
01463                                         {\cf19 return} {\cf17 true};\par
01464                                 \}\par
01465                                 {\cf19 else} \{\par
01466                                         value = default_value;\par
01467                                         {\cf19 return} {\cf17 false};\par
01468                                 \}\par
01469                         \}\par
01470                         {\cf19 else} \{\par
01471                                 value = default_value;\par
01472                                 {\cf19 return} {\cf17 false};\par
01473                         \}\par
01474                 \} {\cf19 else} \{\par
01475                         value = default_value;\par
01476                         {\cf19 return} {\cf17 false};\par
01477                 \}\par
01478         \}\par
01479 \par
01480 \};\par
01481 \par
01482 {\cf17 template}<type_traits::u{\cf18 int}_type_for_radix_c UINT_T, UINT_T B>\par
01483         {\cf17 requires} (type_traits::suitable_base<UINT_T, B>())\par
01484 {\cf17 consteval} UINT_T ui_1() {\cf17 noexcept} \{{\cf19 return} UINT_T(1u);\}\par
01485 \par
01486 {\cf17 template}<type_traits::u{\cf18 int}_type_for_radix_c UINT_T, UINT_T B>\par
01487         {\cf17 requires} (type_traits::suitable_base<UINT_T, B>())\par
01488 {\cf17 consteval} dig_t<UINT_T, B> dig_max() {\cf17 noexcept} \{\par
01489         {\cf19 return} dig_t<UINT_T, B>(B-1u);\par
01490 \}\par
01491 \par
01493 {\cf17 template}<u{\cf18 int}128_t B>\par
01494 {\cf17 using }digit_t = dig_t<\par
01495                 type_traits::TypeFromIntNumber_t<static_cast<uint128_t>(B)>,\par
01496                 {\cf17 static_cast<}type_traits::TypeFromIntNumber_t<static_cast<uint128_t>(B){\cf17 >}>({\cf17 static_cast<}uint128_t{\cf17 >}(B))\par
01497         >;\par
01499 \par
01500 {\cf20                         /************************************/}\par
01501                         {\cf20 /*                                              */}\par
01502                         {\cf20 /*         ISTREAM Y OSTREAM                                    */}\par
01503                         {\cf20 /*                                              */}\par
01504 {\cf20                         /************************************/}\par
01505 \par
01506 {\cf17 template}<type_traits::u{\cf18 int}_type_for_radix_c UINT_T,UINT_T Base>\par
01507         {\cf17 requires} (type_traits::suitable_base<UINT_T,Base>())\par
01508 std::istream & {\cf17 operator} >> (std::istream & is,dig_t<UINT_T,Base> & arg) \{\par
01509 \par
01510         {\cf17 using }SIG_UINT_T        = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
01511         {\cf17 enum} estado_e \{e0,e1,e2,e3,e4,e5,e6,e7,e8\};\par
01512 \par
01513         std::string sds;\par
01514         std::string num_dig;\par
01515         std::string num_base;\par
01516 \par
01517         estado_e est_act = e0;\par
01518         SIG_UINT_T indice = 0;\par
01519         SIG_UINT_T numero_base_recogido=0;\par
01520         UINT_T numero = 0;\par
01521 \par
01522         {\cf18 char} c;\par
01523         is >> sds;\par
01524         {\cf19 do} \{\par
01525                 c = sds[indice];\par
01526                 {\cf19 switch}(est_act) \{\par
01527                         {\cf19 case} e0 : {\cf19 if} (c=={\cf23 'd'})\{\par
01528                                         est_act = e1;\par
01529                                 \}\par
01530                                 {\cf19 break};\par
01531                         {\cf19 case} e1 : {\cf19 if} (c=={\cf23 '#'}) \{\par
01532                                         est_act = e2;\par
01533                                 \}\par
01534                                 {\cf19 else} \{\par
01535                                         est_act = e0;\par
01536                                 \}\par
01537                                 {\cf19 break};\par
01538                         {\cf19 case} e2 : {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) \{\par
01539                                         est_act = e3;\par
01540                                         num_dig.push_back(c-{\cf23 '0'});\par
01541                                 \}\par
01542                                 {\cf19 else} \{\par
01543                                         est_act = e0;\par
01544                                         num_dig.clear();\par
01545                                 \}\par
01546                                 {\cf19 break};\par
01547                         {\cf19 case} e3 : {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) num_dig.push_back(c-{\cf23 '0'});\par
01548                                           {\cf19 else} {\cf19 if} (c == {\cf23 '#'}) est_act = e4;\par
01549                                           {\cf19 else} \{\par
01550                                                 est_act=e0;\par
01551                                                 num_dig.clear();\par
01552                                           \}\par
01553                                           {\cf19 break};\par
01554                         {\cf19 case} e4 : {\cf19 if} (c == {\cf23 'B'}) est_act = e5;\par
01555                                           {\cf19 else} \{\par
01556                                                 est_act = e0;\par
01557                                                 num_dig.clear();\par
01558                                           \}\par
01559                                           {\cf19 break};\par
01560                         {\cf19 case} e5 : {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) \{\par
01561                                                 est_act = e6;\par
01562                                                 num_base.push_back(c-{\cf23 '0'});\par
01563                                           \}\par
01564                                           {\cf19 else} \{\par
01565                                                 est_act = e0;\par
01566                                                 num_dig.clear();\par
01567                                                 num_base.clear();\par
01568                                           \}\par
01569                                           {\cf19 break};\par
01570                         {\cf19 case} e6 : {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) num_base.push_back(c-{\cf23 '0'});\par
01571                                           {\cf19 else} {\cf19 if} ((c=={\cf23 ' '})||(c=={\cf23 '\\0'})) est_act = e7;\par
01572                                           {\cf19 break};\par
01573                         {\cf19 case} e7 : {\cf19 if} ((c!={\cf23 ' '})||(c!={\cf23 '\\0'}))\{\par
01574                                                 est_act = e0;\par
01575                                                 num_dig.clear();\par
01576                                                 num_base.clear();\par
01577                                                 \}\par
01578                                           {\cf19 break};\par
01579                         {\cf19 case} e8 :\par
01580                         default : {\cf19 break};\par
01581                 \}\par
01582                 ++indice;\par
01583                 {\cf19 if} (est_act==e7) \{\par
01584                         {\cf19 for} (SIG_UINT_T k=0 ; k < num_base.size() ; ++k ) \{\par
01585                                 numero_base_recogido *= 10;\par
01586                                 numero_base_recogido += num_base[k];\par
01587                         \}\par
01588                         {\cf19 if} (numero_base_recogido!=Base) \{\par
01589                                 est_act = e0;\par
01590                                 num_dig.clear();\par
01591                                 num_base.clear();\par
01592                         \}\par
01593                         {\cf19 else} est_act = e8;\par
01594                 \}\par
01595         \} {\cf19 while} (est_act!=e8);\par
01596 \par
01597         {\cf19 for} (SIG_UINT_T k=0 ; k < num_dig.size() ; ++k ) \{\par
01598                 numero *= 10;\par
01599                 numero += num_dig[k];\par
01600         \}\par
01601         numero %= Base;\par
01602         arg = dig_t<UINT_T,Base>(numero);\par
01603         {\cf19 return} is;\par
01604 \}\par
01605 \par
01606 {\cf17 template}<type_traits::u{\cf18 int}_type_for_radix_c UINT_T,UINT_T Base>\par
01607         {\cf17 requires} (type_traits::suitable_base<UINT_T,Base>())\par
01608 std::ostream & {\cf17 operator} << (std::ostream & os,dig_t<UINT_T,Base> arg)   \{\par
01609         os  << {\cf22 "d#"}\par
01610                 << {\cf17 static_cast<}std::int64_t{\cf17 >}(arg()%Base)\par
01611                 << {\cf22 "#B"}\par
01612                 << {\cf17 static_cast<}std::int64_t{\cf17 >}(Base) ;\par
01613         {\cf19 return} os;\par
01614 \}\par
01615 \par
01616 \}\par
01617 {\cf21 #endif }{\cf20 // DIG_T__HPP___INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo int_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v int_num_t.hpp}
{\xe \v int_num_t.hpp}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "dig_t.hpp"}\par
{\f2 #include "int_reg_digs_t.hpp"}\par
{\f2 #include "nat_num_t.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para int_num_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "int__num__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b int_num_t< UINT_T, B >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeraciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b forma_t} \{ {\b noraw}
, {\b raw}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las enumeraciones\par
\pard\plain 
{\xe \v forma_t\:int_num_t.hpp}
{\xe \v int_num_t.hpp\:forma_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b forma_t}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Valores de enumeraciones:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v noraw\:int_num_t.hpp}
{\xe \v int_num_t.hpp\:noraw}
{\qr noraw{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
\cell }{\cell }{\row }
{\xe \v raw\:int_num_t.hpp}
{\xe \v int_num_t.hpp\:raw}
{\qr raw{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
\cell }{\cell }{\row }
}
\par
{
Definici\'F3n en la l\'EDnea {\b 10} del archivo {\b int_num_t.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
int_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v int_num_t.hpp}
{\xe \v int_num_t.hpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef INT_NUM_T_HPP_INCLUDED}\par
00002 {\cf21 #define INT_NUM_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "dig_t.hpp"}\par
00005 {\cf21 #include "int_reg_digs_t.hpp"}\par
00006 {\cf21 #include "nat_num_t.hpp"}\par
00007 \par
00008 {\cf17 using namespace }std;\par
00009 \par
00010 {\cf17 enum} forma_t \{noraw,raw\};\par
00011 \par
00012 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00013 {\cf17 struct }int_num_t : {\cf17 protected} base_num_t<UINT_T,B> \{\par
00014     {\cf17 private}:\par
00015                 {\cf17 typedef} dig_t<B>                                                                                                            dig;\par
00016                 {\cf17 typedef} num_basic_t<B>                                                                                      num_basic;\par
00017                 {\cf17 typedef} basic_string< dig_t<B> >                                                                    nbstr;\par
00018                 {\cf17 typedef} {\cf17 typename} nbstr::iterator                                                                    striterator;\par
00019                 {\cf17 typedef} {\cf17 typename} nbstr::reverse_iterator                                                rstriterator;\par
00020                 {\cf17 typedef} {\cf17 typename} nbstr::const_iterator                                                  cstriterator;\par
00021                 {\cf17 typedef} {\cf17 typename} nbstr::const_reverse_iterator                          crstriterator;\par
00022                 {\cf17 typedef} {\cf17 typename} num_basic::iterator                                                    b_iterator;\par
00023                 {\cf17 typedef} {\cf17 typename} num_basic::reverse_iterator                            b_riterator;\par
00024                 {\cf17 typedef} {\cf17 typename} num_basic::const_iterator                                      b_citerator;\par
00025                 {\cf17 typedef} {\cf17 typename} num_basic::const_reverse_iterator              b_criterator;\par
00026                 {\cf17 typedef} {\cf17 typename} num_int::iterator                                                              iterator;\par
00027                 {\cf17 typedef} {\cf17 typename} num_int::reverse_iterator                                      riterator;\par
00028                 {\cf17 typedef} {\cf17 typename} num_int::const_iterator                                            citerator;\par
00029                 {\cf17 typedef} {\cf17 typename} num_int::const_reverse_iterator                        criterator;\par
00030                 {\cf17 typedef} n2digs_t<B>                                                                                                     n2digs;\par
00031                 {\cf17 typedef} pardigs_t<B>                                                                                                pardigs;\par
00032                 {\cf17 typedef} spardigs_t<B>                                                                                           spardigs;\par
00033 \par
00034 \par
00035 \par
00036     {\cf17 private}:\par
00037         sign_e                  signo;\par
00038         spardigs                aux;\par
00039 \par
00040 {\cf20                                                                 /*********************************/}\par
00041                                                                 {\cf20 /*                                                                          */}\par
00042                                                                 {\cf20 /*       CONSTRUCTORES          */}\par
00043                                                                 {\cf20 /*                                                                          */}\par
00044 {\cf20                                                                 /*********************************/}\par
00045 {\cf17 public}:\par
00046         {\cf17 inline} {\cf18 size_t} size(){\cf17  const }\{\par
00047                 {\cf17 const} num_basic & cthis = (*this);\par
00048                 {\cf19 return} cthis.num_basic::size();\par
00049         \}\par
00050 {\cf17 private}:\par
00051         {\cf17 inline} {\cf18 void} mC_B_incondicionado() \{\par
00052                 num_int & cthis = *{\cf17 this};\par
00053                 {\cf20 // Complementaci\'F3n a la base menos 1}\par
00054                 {\cf20 // complementar a Bm1}\par
00055                 {\cf19 for}(usint i=0; i < cthis.size() ;i++) \{\par
00056                         (cthis[i]).mC_Bm1();\par
00057                 \}\par
00058                 {\cf20 // Sumar 1}\par
00059                 aux = spardigs(vplus,0,cthis[0]);\par
00060                 aux += spardigs(vplus,0,dig(1));\par
00061                 cthis[0]=aux.g_uds();\par
00062                 aux = spardigs(vplus,0,aux.g_decs());\par
00063                 usint i = 1;\par
00064                 {\cf19 for}(;i < cthis.size(); ++i) \{\par
00065                         aux += spardigs(vplus,0,cthis[i]);\par
00066                         cthis[i]=aux.g_uds();\par
00067                         aux = spardigs(vplus,0,aux.g_decs());\par
00068 \par
00069                 \}\par
00070                 aux = spardigs();\par
00071         \}\par
00072 {\cf17 public}:\par
00073         {\cf17 inline} {\cf18 void} resize({\cf18 size_t} arg) \{\par
00074                 num_basic & cthis = (*this);\par
00075                 cthis.num_basic::resize(arg);\par
00076                 {\cf19 return};\par
00077         \}\par
00078         {\cf17 inline} {\cf18 void} push_front(dig_t<B> parg) \{\par
00079                 num_basic & cthis = (*this);\par
00080                 cthis.num_basic::push_front(parg);\par
00081                 {\cf19 return};\par
00082         \}\par
00083         {\cf17 inline} {\cf18 void} push_back(dig_t<B> arg) \{\par
00084                 this->num_basic_t<B>::push_back(arg);\par
00085         \}\par
00086 {\cf17 private}:\par
00087         {\cf17 inline} num_int& insert ( {\cf18 size_t} pos1, {\cf17 const} dig_t<B> chardig )\{\par
00088                 num_basic & cthis = (*this);\par
00089                 cthis.num_basic::insert(pos1,1,chardig);\par
00090                 {\cf19 return} (*{\cf17 this});\par
00091         \}\par
00092         {\cf17 inline} num_int& insert ( {\cf18 size_t} pos1, {\cf18 size_t} n, dig_t<B> c )\{\par
00093                 num_basic & cthis = (*this);\par
00094                 cthis.num_basic::insert(pos1,n,c);\par
00095                 {\cf19 return} (*{\cf17 this});\par
00096         \}\par
00097 {\cf17 public}:\par
00098         {\cf17 inline} {\cf17 const} num_int & operator &= ({\cf17 const} num_int & arg) \{\par
00099                 num_basic & cthis = (*this);\par
00100                 cthis+=arg;\par
00101                 {\cf19 return} (*{\cf17 this});\par
00102         \}\par
00103 {\cf17 private}:\par
00104         {\cf20 // string& erase ( size_t pos = 0, size_t n = npos );}\par
00105 \par
00106         {\cf17 inline} num_int& erase ( {\cf18 size_t} pos, {\cf18 size_t} npos )\{\par
00107                 num_int & cthis = (*this);\par
00108                 {\cf18 size_t} npos_2= npos;\par
00109                 {\cf17 const} {\cf18 size_t} sz = size();\par
00110                 {\cf19 if} ((sz == npos) and (pos == 0)) \{\par
00111                         npos_2--;\par
00112                         {\cf19 if} (signo==vplus)\par
00113                                 cthis[sz-1] = dig_t<B>(0);\par
00114                         {\cf19 else}\par
00115                                 cthis[sz-1] = dig_t<B>(B-1);\par
00116                 \}\par
00117                 cthis.num_basic::erase(pos,npos_2);\par
00118                 {\cf19 return} (*{\cf17 this});\par
00119         \}\par
00120 \par
00121         {\cf17 inline} iterator erase ( iterator first, iterator last )\{\par
00122                 num_int & cthis = (*this);\par
00123                 {\cf18 size_t} npos= last-first;\par
00124                 {\cf17 const} {\cf18 size_t} sz = size();\par
00125                 {\cf19 if} (sz == npos) \{\par
00126                         last--;\par
00127                         cthis[sz-1] = d_0<B>();\par
00128                 \}\par
00129                 {\cf19 return} num_basic::erase(first,last);\par
00130         \}\par
00131 \par
00132     {\cf17 public}:\par
00133         num_int() \{\par
00134             num_int & cthis = *{\cf17 this};\par
00135             signo=vplus;\par
00136                         aux = spardigs();\par
00137             cthis.num_basic::clear();\par
00138             cthis.num_basic::push_back(dig_t<B>(0));\par
00139         \}\par
00140 \par
00141         num_int({\cf17 const} num_int & a) \{\par
00142             num_int & cthis = *{\cf17 this};\par
00143             signo=a.signo;\par
00144             aux=a.aux;\par
00145             cthis.clear();\par
00146             cthis.resize(a.size());\par
00147             {\cf19 for} (usint k=0; k < a.size() ; ++k)\par
00148                 cthis[k]=a[k];\par
00149             cthis.reduce();\par
00150         \}\par
00151 \par
00152         num_int({\cf17 const} {\cf18 string} & a ) \{\par
00153             num_int & cthis = *{\cf17 this};\par
00154             signo=vplus;\par
00155             cthis.clear();\par
00156             cthis.resize(a.size());\par
00157                         {\cf18 unsigned} {\cf18 int} l=0;\par
00158             {\cf18 bool} Exit = {\cf17 false};\par
00159             usint k = 0;\par
00160             {\cf19 while} ((a[k]<{\cf23 '0'})||(a[k] > ({\cf18 char}(B-1)+{\cf23 '0'}))) ++k;\par
00161             {\cf19 if} (k >= a.size()) \{ num_int & cthis = *{\cf17 this};\par
00162                 cthis.resize(0);\par
00163                 Exit={\cf17 true};\par
00164             \}\par
00165             {\cf19 if} (!Exit) \{\par
00166                 {\cf19 for} ( ; (k < a.size())&&(!Exit) ; ++k) \{\par
00167                     {\cf19 if} ((a[k]>={\cf23 '0'})&&(a[k] <= (char(B-1)+{\cf23 '0'})))\par
00168                                         \{\par
00169                         cthis[l]=Char2Dig<B>(a[k]);\par
00170                                                 ++l;\par
00171                                         \}\par
00172                     {\cf19 else} Exit={\cf17 true};\par
00173                 \}\par
00174             \}\par
00175                         cthis.reduce();\par
00176         \}\par
00177 \par
00178         num_int(dig a0) \{\par
00179             num_int & cthis = *{\cf17 this};\par
00180             signo=vplus;\par
00181             cthis.clear();\par
00182             cthis.resize(1);\par
00183             cthis[0]=a0;\par
00184         \}\par
00185 \par
00186         num_int(dig a1,dig a0 ) \{\par
00187             num_int & cthis = *{\cf17 this};\par
00188             signo=vplus;\par
00189             cthis.clear();\par
00190             cthis.resize(2);\par
00191             cthis[0]=a0;\par
00192             cthis[1]=a1;\par
00193             cthis.reduce();\par
00194         \}\par
00195 \par
00196         num_int(dig a2,dig a1,dig a0) \{\par
00197             num_int & cthis = *{\cf17 this};\par
00198             signo=vplus;\par
00199             cthis.clear();\par
00200             cthis.resize(3);\par
00201             cthis[0]=a0;\par
00202             cthis[1]=a1;\par
00203             cthis[2]=a2;\par
00204             cthis.reduce();\par
00205         \}\par
00206 \par
00207         num_int({\cf17 const} std::vector<dig> & arg) \{\par
00208             num_int & cthis = *{\cf17 this};\par
00209             signo=vplus;\par
00210             cthis.clear();\par
00211             cthis.resize( arg.size() );\par
00212             {\cf19 for} ( uint ix=0; ix < arg.size() ; ++ix )\par
00213                 cthis[ix]=arg[ix];\par
00214             cthis.reduce();\par
00215         \}\par
00216 \par
00217         num_int({\cf17 const} std::list<dig> & arg) \{\par
00218             num_int & cthis = *{\cf17 this};\par
00219             signo=vplus;\par
00220             cthis.clear();\par
00221                         {\cf17 typename} list<dig>::iterator it=arg.begin();\par
00222                         {\cf17 typename} list<dig>::const_iterator itf=arg.end();\par
00223             {\cf19 for} ( ; it != itf ; ++it )\par
00224                 cthis.push_back(*it);\par
00225             cthis.reduce();\par
00226         \}\par
00227 \par
00228         num_int(sign_e s,dig a0) \{\par
00229             num_int & cthis = *{\cf17 this};\par
00230             signo=s;\par
00231             aux = spardigs(vplus,0,a0);\par
00232             cthis.clear();\par
00233             cthis.resize(1);\par
00234             cthis[0]=aux.g_uds();\par
00235                         aux = spardigs(vplus,0,0);\par
00236             cthis.reduce();\par
00237         \}\par
00238 \par
00239         num_int(sign_e s,dig a1,dig a0) \{\par
00240             num_int & cthis = *{\cf17 this};\par
00241             signo=s;\par
00242             aux = spardigs(vplus,0,0);\par
00243             cthis.clear();\par
00244             cthis.resize(2);\par
00245             cthis[0]=a0;\par
00246             cthis[1]=a1;\par
00247             cthis.reduce();\par
00248         \}\par
00249 \par
00250         num_int(sign_e s,dig a2,dig a1,dig a0)\par
00251                 \{\par
00252             num_int & cthis = *{\cf17 this};\par
00253             signo=s;\par
00254             aux = spardigs(vplus,0,0);\par
00255             cthis.clear();\par
00256             cthis.resize(3);\par
00257             cthis[0]=a0;\par
00258             cthis[1]=a1;\par
00259             cthis[2]=a2;\par
00260             cthis.reduce();\par
00261         \}\par
00262 \par
00263         num_int(sign_e s,{\cf17 const} std::vector<dig> & arg,forma_t argforma=noraw) \{\par
00264             num_int & cthis = *{\cf17 this};\par
00265             signo=s;\par
00266             cthis.clear();\par
00267             cthis.resize( arg.size() );\par
00268             {\cf19 for} ( uint ix=0; ix < arg.size() ; ++ix )\{\par
00269                 cthis[ix]=arg[ix];\par
00270                         \}\par
00271                         {\cf19 if} (argforma==noraw) cthis.reduce();\par
00272         \}\par
00273 \par
00274         num_int(sign_e s,{\cf17 const} std::list<dig> & arg) \{\par
00275             num_int & cthis = *{\cf17 this};\par
00276             signo=s;\par
00277             cthis.clear();\par
00278             cthis.resize( arg.size() );\par
00279                         {\cf17 typename} std::list<dig>::const_iterator it=arg.begin();\par
00280                         {\cf17 typename} std::list<dig>::const_iterator it_end=arg.end();\par
00281             {\cf19 for} ( ; it != it_end ; ++it )\par
00282                 cthis.push_front(*it);\par
00283             cthis.reduce();\par
00284         \}\par
00285 \par
00286         num_int(spardigs a) \{\par
00287             num_int & cthis = *{\cf17 this};\par
00288             signo=a.g_sign();\par
00289             cthis.clear();\par
00290             cthis.resize(2);\par
00291             cthis[0] = a.g_first();\par
00292             cthis[1] = a.g_second();\par
00293             cthis.reduce();\par
00294         \}\par
00295 \par
00296         num_int(pardigs a) \{\par
00297             num_int & cthis = *{\cf17 this};\par
00298             signo=vplus;\par
00299             cthis.clear();\par
00300             cthis.resize(2);\par
00301             cthis[0] = a.g_first();\par
00302             cthis[1] = a.g_second();\par
00303             cthis.reduce();\par
00304         \}\par
00305 \par
00306                 num_int(sign_e s , pardigs a) \{\par
00307             num_int & cthis = *{\cf17 this};\par
00308             cthis.signo=s;\par
00309             cthis.clear();\par
00310             cthis.resize(2);\par
00311                         cthis[0] = a.g_first();\par
00312                         cthis[1] = a.g_second();\par
00313             cthis.reduce();\par
00314         \}\par
00315 \par
00316         num_int({\cf18 char} ch) \{\par
00317             num_int & cthis = *{\cf17 this};\par
00318             cthis.clear();\par
00319             signo=vplus;\par
00320             cthis.resize(1);\par
00321             cthis[0] = Char2Dig<B>(ch);\par
00322         \}\par
00323 \par
00324         num_int(uchint a) \{\par
00325             num_int & cthis = *{\cf17 this};\par
00326             signo=vplus;\par
00327             cthis.clear();\par
00328             cthis.resize(1);\par
00329             cthis[0] = UInt2Dig<B>(a);\par
00330         \}\par
00331 \par
00332                 {\cf17 template}<{\cf17 typename} Int_T>\par
00333         num_int(Int_T a) \{\par
00334             num_int & cthis = *{\cf17 this};\par
00335             cthis.clear();\par
00336                         {\cf17 const} ullint longitud = num_digs_max_base_B_en_Int_T<Int_T,B>();\par
00337             cthis.resize(longitud);\par
00338                         uint indice = 0;\par
00339             {\cf19 if} (a>=0) \{\par
00340                                 {\cf19 for}({\cf18 int} i=0;i<longitud;i++) cthis[i]=dig(0);\par
00341                 signo=vplus;\par
00342                 ullint rem=0,coc=a;\par
00343                 {\cf19 while} (coc >= B) \{\par
00344                     rem = coc%B;\par
00345                     cthis[indice] = UInt2Dig<B>(rem);\par
00346                                         indice++;\par
00347                     coc = coc/B;\par
00348                 \}\par
00349                 rem = coc%B;\par
00350                 cthis[indice] = UInt2Dig<B>(rem);\par
00351                                 indice++;\par
00352             \}\par
00353             {\cf19 else} \{\par
00354                                 {\cf19 for}({\cf18 int} i=0;i<longitud;i++) cthis[i]=dig(B-1);\par
00355                 signo=vminus;\par
00356                 {\cf18 long} {\cf18 long} {\cf18 int} rem=0,coc=-a;\par
00357                 {\cf19 while} (coc >= B) \{\par
00358                     rem = coc%B;\par
00359                     cthis[indice] = !(Int2Dig<B>(rem));\par
00360                                         indice++;\par
00361                     coc = coc/B;\par
00362                 \}\par
00363                 cthis[indice] = !(Int2Dig<B>(coc));\par
00364                                 ++cthis;\par
00365                                 {\cf20 //cthis.signo = vplus;}\par
00366                                 {\cf20 //cthis.reduce();}\par
00367                                 cthis.signo = vminus;\par
00368             \}\par
00369                         cthis.reduce();\par
00370         \}\par
00371 \par
00372         {\cf17 const} num_int & operator = ({\cf17 const} num_int & a) \{\par
00373             num_int & cthis = *{\cf17 this};\par
00374             signo=a.signo;\par
00375             aux=a.aux;\par
00376             cthis.clear();\par
00377             cthis.resize(a.size());\par
00378             {\cf19 for} (usint k=0; k < a.size() ; ++k)\par
00379                 cthis[k]=a[k];\par
00380             cthis.reduce();\par
00381             {\cf19 return} cthis;\par
00382         \}\par
00383 \par
00384                 {\cf17 const} num_int & operator = ({\cf17 const} num_uint<B> & a) \{\par
00385             num_int & cthis = *{\cf17 this};\par
00386             signo=vplus;\par
00387             aux=vplus;\par
00388             cthis.clear();\par
00389             cthis.resize(a.size());\par
00390             {\cf19 for} (usint k=0; k < a.size() ; ++k)\par
00391                 cthis[k]=a[k];\par
00392             cthis.reduce();\par
00393             {\cf19 return} cthis;\par
00394         \}\par
00395 \par
00396         {\cf17 const} num_int & operator = ({\cf17 const} pardigs_t<B> & a) \{\par
00397             num_int & cthis = *{\cf17 this};\par
00398             signo=vplus;\par
00399             aux.p_sign(vplus);\par
00400                         aux.p_decs(0);\par
00401                         aux.p_uds(0);\par
00402             cthis.clear();\par
00403             cthis.resize(2);\par
00404             cthis[1]=a.g_decs();\par
00405             cthis[0]=a.g_uds();\par
00406             cthis.reduce();\par
00407             {\cf19 return} cthis;\par
00408         \}\par
00409 \par
00410                 {\cf17 const} num_int & operator = ({\cf17 const} spardigs_t<B> & a) \{\par
00411             num_int & cthis = *{\cf17 this};\par
00412             signo=a.signo;\par
00413             aux.p_sign(vplus);\par
00414                         aux.p_decs(0);\par
00415                         aux.p_uds(0);\par
00416             cthis.clear();\par
00417             cthis.resize(2);\par
00418             cthis[1]=a.g_decs();\par
00419             cthis[0]=a.g_uds();\par
00420             cthis.reduce();\par
00421             {\cf19 return} cthis;\par
00422         \}\par
00423 \par
00424         {\cf17 const} num_int & operator = ({\cf17 const} dig_t<B> & a) \{\par
00425             num_int & cthis = *{\cf17 this};\par
00426             signo=vplus;\par
00427             aux.p_sign(vplus);\par
00428                         aux.p_decs(0);\par
00429                         aux.p_uds(0);\par
00430             cthis.clear();\par
00431             cthis.resize(1);\par
00432             cthis[0]=a;\par
00433             {\cf19 return} cthis;\par
00434         \}\par
00435 \par
00436                 {\cf17 template}<{\cf17 typename} Int_T>\par
00437         {\cf17 const} num_int & operator = (Int_T a) \{\par
00438             num_int & cthis = *{\cf17 this};\par
00439             cthis.clear();\par
00440                         {\cf17 const} ullint longitud = num_digs_max_base_B_en_Int_T<Int_T,B>();\par
00441             cthis.resize(longitud);\par
00442                         uint indice = 0;\par
00443             {\cf19 if} (a>=0) \{\par
00444                                 {\cf19 for}({\cf18 int} i=0;i<longitud;i++) cthis[i]=dig(0);\par
00445                 signo=vplus;\par
00446                 ullint rem=0,coc=a;\par
00447                 {\cf19 while} (coc >= B) \{\par
00448                     rem = coc%B;\par
00449                     cthis[indice] = UInt2Dig<B>(rem);\par
00450                                         indice++;\par
00451                     coc = coc/B;\par
00452                 \}\par
00453                 rem = coc%B;\par
00454                 cthis[indice] = UInt2Dig<B>(rem);\par
00455                                 indice++;\par
00456             \}\par
00457             {\cf19 else} \{\par
00458                                 {\cf19 for}({\cf18 int} i=0;i<longitud;i++) cthis[i]=dig(B-1);\par
00459                 signo=vminus;\par
00460                 {\cf18 long} {\cf18 long} {\cf18 int} rem=0,coc=-a;\par
00461                 {\cf19 while} (coc >= B) \{\par
00462                     rem = coc%B;\par
00463                     cthis[indice] = Int2Dig<B>(rem);\par
00464                                         indice++;\par
00465                     coc = coc/B;\par
00466                 \}\par
00467                 cthis[indice] = Int2Dig<B>(coc);\par
00468                                 cthis.mC_B_incondicionado();\par
00469                                 cthis.signo = vplus;\par
00470                                 cthis.reduce();\par
00471                                 cthis.signo = vminus;\par
00472             \}\par
00473                         cthis.reduce();\par
00474                         {\cf19 return} cthis;\par
00475         \}\par
00476 \par
00477 \par
00478         {\cf17 const} num_int & operator = ({\cf17 const} std::vector<dig> & arg) \{\par
00479             num_int & cthis = *{\cf17 this};\par
00480             signo=vplus;\par
00481             cthis.clear();\par
00482             cthis.resize( arg.size() );\par
00483             {\cf19 for} ( uint ix=0; ix < arg.size() ; ++ix )\{\par
00484                 cthis[ix]=arg[ix];\par
00485                         \}\par
00486                         cthis.reduce();\par
00487                         {\cf19 return} cthis;\par
00488         \}\par
00489 \par
00490         {\cf17 const} num_int & operator = ({\cf17 const} std::list<dig> & arg) \{\par
00491             num_int & cthis = *{\cf17 this};\par
00492             signo=vplus;\par
00493             cthis.clear();\par
00494             cthis.resize( arg.size() );\par
00495                         {\cf17 typename} std::list<dig>::const_iterator it=arg.begin();\par
00496                         {\cf17 typename} std::list<dig>::const_iterator it_end=arg.end();\par
00497             {\cf19 for} ( ; it != it_end ; ++it )\par
00498                 cthis.push_front(*it);\par
00499             cthis.reduce();\par
00500                         {\cf19 return} cthis;\par
00501         \}\par
00502 \par
00503 \par
00504 {\cf20                                                 /***************************************/}\par
00505                                                 {\cf20 /*                                                                                       */}\par
00506                                                 {\cf20 /*  DIGITOS NO SIGNIFICATIVOS    */}\par
00507                                                 {\cf20 /*                                                                                       */}\par
00508 {\cf20                                                 /***************************************/}\par
00509 \par
00510 \par
00511 usint ceros_a_la_izqda (){\cf17  const }\{\par
00512         {\cf17 const} num_int & cthis = (*this);\par
00513         {\cf20 //digitos no significativos para n\'FAmeros positivos}\par
00514         {\cf18 bool} Exit = {\cf17 false};\par
00515         {\cf18 int} sz=0;\par
00516         {\cf17 const} {\cf18 size_t} fin= this->size();\par
00517         {\cf19 for} ( {\cf18 int} i=fin-1 ; (i >= 0) and (!Exit) ; --i) \{\par
00518                 {\cf18 bool} char_es_0 = (cthis[i]==0);\par
00519                 {\cf19 if} (char_es_0)\{\par
00520                         ++sz;\par
00521                 \}\par
00522                 {\cf19 else} Exit={\cf17 true};\par
00523         \}\par
00524         {\cf19 return} sz;\par
00525 \}\par
00526 {\cf20 //digitos no significativos para n\'FAmeros positivos}\par
00527 \par
00528 usint unos_a_la_izqda (){\cf17  const }\{\par
00529         {\cf17 const} num_int & cthis = (*this);\par
00530         {\cf20 //digitos no significativos para n\'FAmeros negativos}\par
00531         {\cf18 bool} Exit = {\cf17 false};\par
00532         {\cf18 int} sz=0;\par
00533         {\cf17 const} {\cf18 size_t} fin = cthis.size();\par
00534         {\cf19 for} ( {\cf18 int} i=fin-1 ; (i >= 0) and (!Exit) ; --i) \{\par
00535                 {\cf18 bool} char_es_max = (cthis[i]==(dig_t<B>::max_dig()));\par
00536                 {\cf19 if} (char_es_max)\{\par
00537                         ++sz;\par
00538                 \}\par
00539                 {\cf19 else} Exit={\cf17 true};\par
00540         \}\par
00541         {\cf19 return} sz;\par
00542 \}\par
00543 {\cf20 //digitos no significativos para n\'FAmeros negativos}\par
00544 \par
00545 {\cf18 size_t} ceros_a_la_drcha (){\cf17  const }\{\par
00546         {\cf20 //const num_uint & cthis = (*this);}\par
00547         {\cf18 bool} Exit = {\cf17 false};\par
00548         {\cf18 size_t} sz=0;\par
00549         {\cf17 const} {\cf18 size_t} fin=this->size();\par
00550         {\cf17 const} {\cf18 size_t} finl = fin-1;\par
00551         {\cf19 if} (this->{\cf17 operator}[](finl)==0) \{\par
00552                 {\cf19 for} ( {\cf18 int} i=finl ; (i >=0) and (!Exit) ; --i) \{\par
00553                         {\cf19 if} (this->{\cf17 operator}[](i)==0) ++sz;\par
00554                         {\cf19 else} Exit={\cf17 true};\par
00555                 \}\par
00556         \}\par
00557         {\cf19 return} sz;\par
00558 \}\par
00559 \par
00560 \par
00561 {\cf18 size_t} unos_a_la_drcha (){\cf17  const }\{\par
00562         {\cf20 //const num_uint & cthis = (*this);}\par
00563         {\cf18 bool} Exit = {\cf17 false};\par
00564         {\cf18 size_t} sz=0;\par
00565         {\cf17 const} {\cf18 size_t} fin=this->size();\par
00566         {\cf17 const} {\cf18 size_t} finl = fin-1;\par
00567         {\cf19 if} (this->{\cf17 operator}[](finl)==0) \{\par
00568                 {\cf19 for} ( {\cf18 int} i=finl ; (i >=0) and (!Exit) ; --i) \{\par
00569                         {\cf19 if} (this->{\cf17 operator}[](i)==dig_t<B>::max) ++sz;\par
00570                         {\cf19 else} Exit={\cf17 true};\par
00571                 \}\par
00572         \}\par
00573         {\cf19 return} sz;\par
00574 \}\par
00575 \par
00576 {\cf18 bool} filled_of_all_digits_are_Bm1(){\cf17  const }\{\par
00577         {\cf17 const} num_int & cthis = (*this);\par
00578         {\cf17 const} {\cf18 int} longitud = cthis.size();\par
00579         {\cf19 for}({\cf18 int} i=0;i<longitud;i++)\par
00580                 {\cf19 if} (cthis[i]!=dig(B-1)) {\cf19 return} {\cf17 false};\par
00581         {\cf19 return} {\cf17 true};\par
00582 \}\par
00583 \par
00584 {\cf18 bool} filled_of_all_digits_are_0(){\cf17  const }\{\par
00585         {\cf17 const} num_int & cthis = (*this);\par
00586         {\cf17 const} {\cf18 int} longitud = cthis.size();\par
00587         {\cf19 for}({\cf18 int} i=0;i<longitud;++i)\par
00588                 {\cf19 if} (cthis[i]!=dig(0)) {\cf19 return} {\cf17 false};\par
00589         {\cf19 return} {\cf17 true};\par
00590 \}\par
00591 \par
00592 usint digs_no_significativos (){\cf17  const }\{\par
00593         {\cf17 const} num_int & cthis = (*this);\par
00594         {\cf20 //digitos no significativos}\par
00595         usint retorno;\par
00596         {\cf20 //if ((size()<1) and (signo==vminus)) return 0;}\par
00597         {\cf19 if} (signo==vplus) \{\par
00598                 retorno = cthis.ceros_a_la_izqda();\par
00599                 {\cf19 return} retorno;\par
00600         \}\par
00601         {\cf19 else} \{\par
00602                 retorno = cthis.unos_a_la_izqda();\par
00603                 {\cf19 return} retorno;\par
00604         \}\par
00605 \}\par
00606 \par
00607 usint digs_fracc_no_significativos (){\cf17  const }\{\par
00608         {\cf20 //const num_uint & cthis = (*this);}\par
00609         {\cf20 //digitos no significativos}\par
00610         {\cf19 return} this->ceros_a_la_drcha();\par
00611 \}\par
00612                 {\cf20 //digitos no significativos para n\'FAmeros positivos fraccionaria}\par
00613         usint Bm1_a_la_izqda (){\cf17  const }\{\par
00614             num_int & cthis = *{\cf17 this};\par
00615             {\cf20 //digitos no significativos para n\'FAmeros negativos}\par
00616             {\cf18 bool} Exit = {\cf17 false};\par
00617             usint sz=0;\par
00618             usint k=(cthis.size()-1);\par
00619             {\cf19 for} ( ; (k > 0) and (!Exit) ; --k) \{\par
00620                 {\cf19 if} (cthis[k]==(B-1)) ++sz;\par
00621                 {\cf19 else} Exit={\cf17 true};\par
00622             \}\par
00623             {\cf19 if} ((k==0) and (cthis[0]==(B-1)) and (!Exit)) ++sz;\par
00624             {\cf19 return} sz;\par
00625         \}\par
00626         {\cf20 // digitos no significativos para n\'FAmeros negativo}\par
00627                 usint Bm1_a_la_drcha (){\cf17  const }\{\par
00628             num_int & cthis = *{\cf17 this};\par
00629             {\cf20 // digitos no significativos para n\'FAmeros negativos fraccionarios}\par
00630                         {\cf17 const} {\cf18 size_t} fin = cthis.size();\par
00631             {\cf18 bool} Exit = {\cf17 false};\par
00632             usint sz=0;\par
00633             usint k=0;\par
00634             {\cf19 for} ( ; (k < fin) and (!Exit) ; ++k) \{\par
00635                 {\cf19 if} (cthis[k]==(B-1)) ++sz;\par
00636                 {\cf19 else} Exit={\cf17 true};\par
00637             \}\par
00638             {\cf19 return} sz;\par
00639         \}\par
00640 \par
00641 {\cf20                                         /***********************************************/}\par
00642                                         {\cf20 /*                                                                                                      */}\par
00643                                         {\cf20 /*   OPERACIONES COMPARATIVAS           */}\par
00644                                         {\cf20 /*                                                                                                      */}\par
00645 {\cf20                                         /**********************************************/}\par
00646 \par
00647         {\cf18 bool} operator == ({\cf17 const} num_int & arg){\cf17  const }\{\par
00648             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00649             {\cf17 const} slint thisnsz = cthis.digs_no_significativos();\par
00650             {\cf17 const} slint thisvsz = cthis.size()-thisnsz;\par
00651             {\cf17 const} slint argnsz = arg.digs_no_significativos();\par
00652             {\cf17 const} slint argvsz = arg.size()-argnsz;\par
00653             {\cf19 if} ((thisvsz > argvsz)||(thisvsz < argvsz)||(signo!=arg.signo)) {\cf19 return} {\cf17 false};\par
00654             {\cf19 else} \{\par
00655                 {\cf19 for} (slint k=(thisvsz-1);k>0;--k) \{\par
00656                     {\cf19 if} (arg[k]!=cthis[k]) {\cf19 return} {\cf17 false};\par
00657                 \}\par
00658                 {\cf19 if} ((arg[0])!=(cthis[0])) {\cf19 return} {\cf17 false};\par
00659                 {\cf19 else} {\cf19 return} {\cf17 true};\par
00660             \}\par
00661         \}\par
00662 \par
00663         {\cf18 bool} operator != ({\cf17 const} num_int & arg){\cf17  const }\{\par
00664             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00665             {\cf17 const} slint thisnsz = digs_no_significativos();\par
00666             {\cf17 const} slint thisvsz = (cthis.size())-thisnsz;\par
00667             {\cf17 const} slint argnsz = arg.digs_no_significativos();\par
00668             {\cf17 const} slint argvsz = arg.size()-argnsz;\par
00669             {\cf19 if} ((thisvsz > argvsz)||(thisvsz < argvsz)||(signo!=arg.signo)) {\cf19 return} {\cf17 true};\par
00670             {\cf19 else} \{\par
00671                 {\cf19 for} (slint k=(thisvsz-1);k>0;--k)\par
00672                     {\cf19 if} (arg[k]!=cthis[k])\par
00673                         {\cf19 return} {\cf17 true};\par
00674                 {\cf19 if} (arg[0]!= cthis[0])\par
00675                     {\cf19 return} {\cf17 true};\par
00676                 {\cf19 else} {\cf19 return} {\cf17 false};\par
00677             \}\par
00678         \}\par
00679 \par
00680         {\cf18 bool} operator >= ({\cf17 const} num_int & arg){\cf17  const }\{\par
00681             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00682                         {\cf17 const} slint thissz  = cthis.size();\par
00683             {\cf17 const} slint thisnsz = ((thissz==1)?0:(cthis.digs_no_significativos()));\par
00684                         {\cf20 //cout << "J vale   " << cthis << endl;}\par
00685             {\cf17 const} slint thisvsz = thissz-thisnsz;\par
00686                         {\cf17 const} slint argsz  = arg.size();\par
00687             {\cf17 const} slint argnsz = ((argsz==1)?0:(arg.digs_no_significativos()));\par
00688                         {\cf20 //cout << "I vale   " << arg << endl;}\par
00689             {\cf17 const} slint argvsz = argsz-argnsz;\par
00690 \par
00691             {\cf19 if} ((signo == vplus)and(arg.signo == vminus)) {\cf19 return} {\cf17 true};\par
00692             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vplus)) {\cf19 return} {\cf17 false};\par
00693             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vminus))\{\par
00694                 {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 true};\par
00695                 {\cf19 else} {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 false};\par
00696             \}\par
00697                         {\cf19 else} {\cf19 if} ((signo == vplus)and(arg.signo == vplus))\{\par
00698                 {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 true};\par
00699                 {\cf19 else} {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 false};\par
00700             \}\par
00701             {\cf19 for} (slint k=(thisvsz-1);k>-1;--k) \{\par
00702                 {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 true};\par
00703                 {\cf19 else} {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 false};\par
00704             \}\par
00705             {\cf19 return} {\cf17 true};\par
00706         \}\par
00707 \par
00708         {\cf18 bool} operator <= ({\cf17 const} num_int & arg){\cf17  const }\{\par
00709             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00710                         {\cf17 const} slint thissz  = cthis.size();\par
00711             {\cf17 const} slint thisnsz = ((thissz==1)?0:(cthis.digs_no_significativos()));\par
00712                         {\cf20 //cout << "J vale   " << cthis << endl;}\par
00713             {\cf17 const} slint thisvsz = thissz-thisnsz;\par
00714                         {\cf17 const} slint argsz  = arg.size();\par
00715             {\cf17 const} slint argnsz = ((argsz==1)?0:(arg.digs_no_significativos()));\par
00716                         {\cf20 //cout << "I vale   " << arg << endl;}\par
00717             {\cf17 const} slint argvsz = argsz-argnsz;\par
00718 \par
00719             {\cf19 if} ((signo == vplus)and(arg.signo == vminus)) {\cf19 return} {\cf17 false};\par
00720             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vplus)) {\cf19 return} {\cf17 true};\par
00721             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vminus))\{\par
00722                 {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 false};\par
00723                 {\cf19 else} {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 true};\par
00724             \}\par
00725                         {\cf19 else} {\cf19 if} ((signo == vplus)and(arg.signo == vplus))\{\par
00726                 {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 false};\par
00727                 {\cf19 else} {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 true};\par
00728             \}\par
00729             {\cf19 for} (slint k=(thisvsz-1);k>-1;--k) \{\par
00730                 {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 false};\par
00731                 {\cf19 else} {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 true};\par
00732             \}\par
00733             {\cf19 return} {\cf17 true};\par
00734         \}\par
00735 \par
00736         {\cf18 bool} operator >  ({\cf17 const} num_int & arg ){\cf17  const }\{\par
00737             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00738                         {\cf17 const} slint thissz  = cthis.size();\par
00739             {\cf17 const} slint thisnsz = ((thissz==1)?0:(cthis.digs_no_significativos()));\par
00740             {\cf17 const} slint thisvsz = thissz-thisnsz;\par
00741                         {\cf17 const} slint argsz  = arg.size();\par
00742             {\cf17 const} slint argnsz = ((argsz==1)?0:(arg.digs_no_significativos()));\par
00743             {\cf17 const} slint argvsz = argsz-argnsz;\par
00744 \par
00745             {\cf19 if} ((signo == vplus)and(arg.signo == vminus)) {\cf19 return} {\cf17 true};\par
00746             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vplus)) {\cf19 return} {\cf17 false};\par
00747             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vminus))\par
00748                         \{\par
00749                 {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 true};\par
00750                 {\cf19 else} {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 false};\par
00751             \}\par
00752                         {\cf19 else} {\cf19 if} ((signo == vplus)and(arg.signo == vplus))\par
00753                         \{\par
00754                 {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 true};\par
00755                 {\cf19 else} {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 false};\par
00756             \}\par
00757                         {\cf19 for} (slint k=(thisvsz-1);k>-1;--k)\par
00758                         \{\par
00759                                 {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 true};\par
00760                                 {\cf19 else} {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 false};\par
00761                         \}\par
00762                         {\cf19 return} {\cf17 false};\par
00763                 \}\par
00764 \par
00765         {\cf18 bool} operator <  ({\cf17 const} num_int & arg){\cf17  const }\{\par
00766             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00767                         {\cf17 const} slint thissz  = cthis.size();\par
00768             {\cf17 const} slint thisnsz = ((thissz==1)?0:(cthis.digs_no_significativos()));\par
00769                         {\cf20 //cout << "J vale   " << cthis << endl;}\par
00770             {\cf17 const} slint thisvsz = thissz-thisnsz;\par
00771                         {\cf17 const} slint argsz  = arg.size();\par
00772             {\cf17 const} slint argnsz = ((argsz==1)?0:(arg.digs_no_significativos()));\par
00773                         {\cf20 //cout << "I vale   " << arg << endl;}\par
00774             {\cf17 const} slint argvsz = argsz-argnsz;\par
00775 \par
00776             {\cf19 if} ((signo == vplus)and(arg.signo == vminus)) {\cf19 return} {\cf17 false};\par
00777             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vplus)) {\cf19 return} {\cf17 true};\par
00778             {\cf19 else} {\cf19 if} ((signo == vminus)and(arg.signo == vminus))\{\par
00779                 {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 false};\par
00780                 {\cf19 else} {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 true};\par
00781             \}\par
00782                         {\cf19 else} {\cf19 if} ((signo == vplus)and(arg.signo == vplus))\{\par
00783                 {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 false};\par
00784                 {\cf19 else} {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 true};\par
00785             \}\par
00786             {\cf19 for} (slint k=(thisvsz-1);k>-1;--k) \{\par
00787                 {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 false};\par
00788                 {\cf19 else} {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 true};\par
00789             \}\par
00790             {\cf19 return} {\cf17 false};\par
00791         \}\par
00792 \par
00793 {\cf20                                         /**********************************************/}\par
00794                                         {\cf20 /*                                                                                                      */}\par
00795                                         {\cf20 /*     OPERACIONES ARITMETICAS          */}\par
00796                                         {\cf20 /*                                                                                                      */}\par
00797 {\cf20                                         /**********************************************/}\par
00798 \par
00799         num_int operator + ({\cf17 const} num_int & arg){\cf17  const }\{\par
00800             {\cf17 const} num_int & cthis = *{\cf17 this};\par
00801             num_int ret(cthis);\par
00802             ret.reduce();\par
00803             num_int cpy(arg);\par
00804             cpy.reduce();\par
00805             spardigs_t<B> tempt();\par
00806             spardigs_t<B> tempa();\par
00807             {\cf17 const} num_int* po =0;\par
00808             usint sza = arg.size();\par
00809             usint szt = ret.size();\par
00810             p_usint  pszmin=0;\par
00811             p_usint  pszmax=0;\par
00812             {\cf19 if} (sza<=szt) \{\par
00813                 pszmin = &sza;\par
00814                 pszmax = &szt;\par
00815                 po     = &ret;\par
00816             \} {\cf19 else} \{\par
00817                 pszmin = &szt;\par
00818                 pszmax = &sza;\par
00819                 po     = &cpy;\par
00820             \}\par
00821 \par
00822             usint & szmin = *pszmin;\par
00823             usint & szmax = *pszmax;\par
00824             {\cf17 const} num_int & obj = *po;\par
00825             usint k = 0;\par
00826             ret.aux = spardigs();\par
00827             {\cf19 for} ( ; k<szmin ; ++k) \{\par
00828                 tempt.p_uds(ret[k]);\par
00829                 tempa.p_uds(arg[k]);\par
00830                 tempt += tempa;\par
00831                 tempt += aux;\par
00832                 ret[k]=tempt.g_uds();\par
00833                 ret.aux=spardigs(tempt.g_sign(),\par
00834                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
00835                                  tempt.g_decs()\par
00836                                 );\par
00837             \}\par
00838             {\cf19 for} ( ; k<szmax ; ++k) \{\par
00839                 tempt.p_first(obj[k]);\par
00840                 tempt += aux;\par
00841                 ret[k]=tempt.g_first();\par
00842                 ret.aux=spardigs(tempt.g_sign(),\par
00843                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
00844                                  tempt.g_decs()\par
00845                                 );\par
00846             \}\par
00847 \par
00848             ret.push_back(ret.aux.g_uds());\par
00849             ret.push_back(ret.aux.g_decs());\par
00850             ret.signo=ret.aux.g_sign();\par
00851             ret.aux =  spardigs();\par
00852             {\cf19 return} ret;\par
00853         \}\par
00854 \par
00855         num_int operator - ({\cf17 const} num_int & arg){\cf17  const }\{\par
00856             num_int & cthis = *{\cf17 this};\par
00857             num_int ret;\par
00858             num_int cpy(-arg);\par
00859             ret.reduce();\par
00860             cpy.reduce();\par
00861             spardigs tempt();\par
00862             spardigs tempa();\par
00863             {\cf17 const} num_int* po =0;\par
00864             usint sza = arg.lst_arg.size();\par
00865             usint szt = ret.lst_arg.size();\par
00866             p_usint  pszmin=0;\par
00867             p_usint  pszmax=0;\par
00868             {\cf19 if} (sza<=szt) \{\par
00869                 pszmin = &sza;\par
00870                 pszmax = &szt;\par
00871                 po     = &ret;\par
00872             \} {\cf19 else} \{\par
00873                 pszmin = &szt;\par
00874                 pszmax = &sza;\par
00875                 po     = &cpy;\par
00876             \}\par
00877 \par
00878             usint & szmin = *pszmin;\par
00879             usint & szmax = *pszmax;\par
00880             {\cf17 const} num_int & obj = *po;\par
00881             usint k = 0;\par
00882             ret.aux = spardigs();\par
00883             {\cf19 for} ( ; k<szmin ; ++k) \{\par
00884                 tempt.p_first(ret[k]);\par
00885                 tempa.p_first(arg[k]);\par
00886                 tempt += tempa;\par
00887                 tempt += aux;\par
00888                 ret[k]=tempt.g_first();\par
00889                 ret.aux=spardigs(tempt.g_sign(),\par
00890                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
00891                                  tempt.g_second()\par
00892                                 );\par
00893             \}\par
00894             {\cf19 for} ( ; k<szmax ; ++k) \{\par
00895                 tempt.p_first(obj[k]);\par
00896                 tempt += aux;\par
00897                 ret[k]=tempt.g_first();\par
00898                 ret.aux=spardigs(tempt.g_sign(),\par
00899                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
00900                                  tempt.g_second()\par
00901                                 );\par
00902             \}\par
00903 \par
00904             ret.lst_digs.push_back(ret.aux.g_first());\par
00905             ret.lst_digs.push_back(ret.aux.g_second());\par
00906             ret.signo=ret.aux.g_sign();\par
00907             ret.aux =  spardigs();\par
00908             {\cf19 return} ret;\par
00909         \}\par
00910 \par
00911         {\cf20 // Utilizamos una funcion num_int * dig_t}\par
00912         num_int operator * ({\cf17 const} num_int & arg){\cf17  const }\{\par
00913             num_int & cthis = *{\cf17 this};\par
00914             num_int sumatemp;\par
00915             num_int multtemp;\par
00916             num_int m1(cthis.abs());\par
00917             m1.reduce();\par
00918             num_int m2(arg.abs());\par
00919             m2.reduce();\par
00920             multtemp = cthis*m2[0];\par
00921             sumatemp = multtemp;\par
00922             {\cf19 for} (usint j = 1 ; j < m2.size() ; ++j) \{\par
00923                 multtemp = cthis*m2[j]; {\cf20 // num_int * dig_t}\par
00924                 multtemp.insert(0,j,0);\par
00925                 sumatemp += multtemp;\par
00926             \}\par
00927             {\cf19 if} (signo!=arg.signo) sumatemp.mC_B();\par
00928             {\cf19 return} sumatemp;\par
00929         \}\par
00930 \par
00931         num_int operator / ({\cf17 const} num_int & arg){\cf17  const }\{\par
00932             num_int & cthis = *{\cf17 this};\par
00933             {\cf17 const} sign_e sgn_ndo = signo;\par
00934             {\cf17 const} sign_e sgn_sor = arg.signo;\par
00935             num_int dvndo_int(this->abs());\par
00936             dvndo_int.reduce();\par
00937             num_int rem(dvndo_int);\par
00938 \par
00939             num_int dvsor_int(arg.abs());\par
00940             dvsor_int.reduce();\par
00941 \par
00942             {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
00943 \par
00944             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
00945             dvsor_int.lst_digs.erase(0,cssor);{\cf20 // division por una potencia de B}\par
00946 \par
00947 \par
00948             dvsor_int.reduce();\par
00949             dvndo_int.reduce();\par
00950 \par
00951             dvndo_fra.reduce();\par
00952 \par
00953             {\cf17 const} usint longtndo  = dvndo_int.size();\par
00954             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
00955             {\cf17 const} usint longtsor  = dvsor_int.size();\par
00956             {\cf17 const} usint longsor   = longtsor;\par
00957 \par
00958             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
00959             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
00960             {\cf20 // cocientes enteros.}\par
00961             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
00962             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
00963             {\cf20 // dividendo obteniendo dvndo_fra}\par
00964 \par
00965             {\cf20 /* *}\par
00966 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
00967 {\cf20 }\par
00968 {\cf20                 rem = rem.lst_digs.insert(0,cssor,0);}\par
00969 {\cf20                 rem += dvndo_fra;}\par
00970 {\cf20             * */}\par
00971             {\cf19 if} (sgn_ndo!=sgn_sor) dvndo_int.mC_B();\par
00972             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
00973             {\cf20 // acomodar el formato al signo de la operacion}\par
00974             {\cf20 // determinar el signo de la operacion}\par
00975             {\cf19 return} dvndo_int;\par
00976         \}\par
00977 \par
00978         num_int operator % ({\cf17 const} num_int & arg){\cf17  const }\{\par
00979             num_int & cthis = *{\cf17 this};\par
00980             num_int dvndo_int(this->abs());\par
00981             dvndo_int.reduce();\par
00982             num_int rem(dvndo_int);\par
00983 \par
00984             num_int dvsor_int(arg.abs());\par
00985             dvsor_int.reduce();\par
00986 \par
00987             {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
00988 \par
00989             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
00990             dvsor_int.lst_digs.erase(0,cssor);{\cf20 // division por una potencia de B}\par
00991 \par
00992 \par
00993             dvsor_int.reduce();\par
00994             dvndo_int.reduce();\par
00995 \par
00996             dvndo_fra.reduce();\par
00997 \par
00998             {\cf17 const} usint longtndo  = dvndo_int.size();\par
00999             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01000             {\cf17 const} usint longtsor  = dvsor_int.size();\par
01001             {\cf17 const} usint longsor   = longtsor;\par
01002 \par
01003             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01004             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01005             {\cf20 // cocientes enteros.}\par
01006             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01007             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01008             {\cf20 // dividendo obteniendo dvndo_fra}\par
01009 \par
01010             {\cf20 /* *}\par
01011 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01012 {\cf20             * */}\par
01013             rem = rem.lst_digs.insert(0,cssor,0);\par
01014             rem += dvndo_fra;\par
01015             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01016             {\cf20 // acomodar el formato al signo de la operacion}\par
01017             {\cf20 // determinar el signo de la operacion}\par
01018             {\cf19 return} rem;\par
01019         \}\par
01020 \par
01021 \par
01022                 {\cf20 //num_int operator + (spardigs) const;}\par
01023                 {\cf20 //num_int operator - (spardigs) const;}\par
01024                 {\cf20 //num_int operator * (spardigs) const;}\par
01025                 {\cf20 //num_int operator / (spardigs) const;}\par
01026                 {\cf20 //num_int operator % (spardigs) const;}\par
01027                 {\cf20 //num_int operator + (n2digs_t) const;}\par
01028                 {\cf20 //num_int operator - (n2digs_t) const;}\par
01029                 {\cf20 //num_int operator * (n2digs_t) const;}\par
01030                 {\cf20 //num_int operator / (n2digs_t) const;}\par
01031                 {\cf20 //num_int operator % (n2digs_t) const;}\par
01032                 {\cf20 //num_int operator + (pardigs) const;}\par
01033                 {\cf20 //num_int operator - (pardigs) const;}\par
01034 \par
01035         num_int operator * (pardigs a){\cf17  const }\{\par
01036             num_int & cthis = *{\cf17 this};\par
01037             pardigs             temp;\par
01038             dig                         carry=0;\par
01039             num_int             ret(*{\cf17 this});\par
01040             {\cf19 for} ( usint k=0 ; k < (cthis.size()-1) ; ++k ) \{\par
01041                 temp = cthis[k]*(a.g_first());\par
01042                 temp += carry;\par
01043                 ret[k]= temp.g_first();\par
01044                 carry=temp.g_second();\par
01045             \}\par
01046             {\cf19 if} (carry != 0)\par
01047                 ret.insert((cthis.size())-1,1,carry);\par
01048             ret.reduce();\par
01049             carry = 0;\par
01050             {\cf19 for} ( usint k=0 ; k < ((cthis.size())-1) ; ++k ) \{\par
01051                 temp = cthis[k]*(a.g_second());\par
01052                 temp += carry;\par
01053                 ret.substr(k+1,ret.size()-1)+= temp.g_first();{\cf20 //\'BF?}\par
01054                 carry=temp.g_second();\par
01055             \}\par
01056             {\cf19 if} (carry != 0)\par
01057                 ret.insert((cthis.size())-1,1,carry);\par
01058             ret.reduce();\par
01059 \par
01060             {\cf19 if} (signo==vminus) ret.mC_B();\par
01061 \par
01062             {\cf19 return} ret;\par
01063         \}\par
01064 \par
01065         {\cf20 //      num_int operator / (pardigs) const;}\par
01066         {\cf20 //      num_int operator % (pardigs) const;}\par
01067 \par
01068         num_int operator + (dig arg){\cf17  const }\{\par
01069             num_int & cthis = *{\cf17 this};\par
01070             num_int ret(*{\cf17 this});\par
01071             ret.reduce();\par
01072             spardigs tempt();\par
01073             spardigs tempa();\par
01074             {\cf17 const} num_int* po =0;\par
01075             {\cf17 const} usint sza = 1;\par
01076             usint szt = ret.lst_arg.size();\par
01077             p_usint  pszmin=0;\par
01078             p_usint  pszmax=0;\par
01079             {\cf19 if} (sza<=szt) \{\par
01080                 pszmin = &sza;\par
01081                 pszmax = &szt;\par
01082                 po     = &ret;\par
01083             \} {\cf19 else} \{\par
01084                 pszmin = &szt;\par
01085                 pszmax = &sza;\par
01086                 po     = &arg;\par
01087             \}\par
01088 \par
01089             usint & szmin = *pszmin;\par
01090             usint & szmax = *pszmax;\par
01091             {\cf17 const} num_int & obj = *po;\par
01092             usint k = 0;\par
01093             ret.aux = spardigs();\par
01094             tempt.p_first(ret[0]);\par
01095             tempa.p_first(arg);\par
01096 \par
01097             {\cf19 for} ( k=1 ; k<szmin ; ++k) \{\par
01098                 tempt.p_first(ret[k]);\par
01099                 tempt += tempa;\par
01100                 tempt += aux;\par
01101                 ret[k]=tempt.g_first();\par
01102                 ret.aux=spardigs(tempt.g_sign(),\par
01103                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
01104                                  tempt.g_second()\par
01105                                 );\par
01106             \}\par
01107             {\cf19 for} ( ; k<szmax ; ++k) \{\par
01108                 dig D = ret[k];\par
01109                 tempt.p_first(D);\par
01110                 tempt += aux;\par
01111                 ret[k]=tempt.g_first();\par
01112                 ret.aux=spardigs(tempt.g_sign(),\par
01113                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
01114                                  tempt.g_second()\par
01115                                 );\par
01116             \}\par
01117 \par
01118             ret.cthis.push_back(ret.aux.g_first());\par
01119             ret.cthis.push_back(ret.aux.g_second());\par
01120             ret.signo=ret.aux.g_sign();\par
01121             ret.aux =  spardigs();\par
01122             {\cf19 return} ret;\par
01123         \}\par
01124 \par
01125         num_int operator - (dig arg){\cf17  const }\{\par
01126             num_int & cthis = *{\cf17 this};\par
01127             num_int ret(*{\cf17 this});\par
01128             ret.reduce();\par
01129             spardigs cpy(-arg);\par
01130             spardigs tempt();\par
01131             spardigs tempa();\par
01132             usint szt = ret.lst_arg.size();\par
01133             usint k = 0;\par
01134             ret.aux = spardigs();\par
01135             tempt.p_first(ret[0]);\par
01136             tempa.p_first(arg.g_first());\par
01137             tempt += tempa;\par
01138             ret[0] =tempt.g_first();\par
01139             tempa = spardigs(vplus,0,tempt.g_second());\par
01140             tempt = spardigs(vplus,0,ret[1]);\par
01141             tempt += tempa;\par
01142             ret[1] = tempt.g_first();\par
01143 \par
01144             {\cf19 for} ( k=2 ; k < ret.lst_digs.size() ; ++k) \{\par
01145                 tempt.p_first(ret[k]);\par
01146                 tempt += aux;\par
01147                 ret[k]=tempt.g_first();\par
01148                 ret.aux=spardigs(tempt.g_sign(),\par
01149                                  ((tempt.g_sign()==vplus)?(0):(B-1)),\par
01150                                  tempt.g_second()\par
01151                                 );\par
01152             \}\par
01153 \par
01154             ret.lst_digs.push_back(ret.aux.g_first());\par
01155             ret.lst_digs.push_back(ret.aux.g_second());\par
01156             ret.signo=ret.aux.g_sign();\par
01157             ret.aux =  spardigs();\par
01158             {\cf19 return} ret;\par
01159         \}\par
01160 \par
01161         num_int operator * (dig a){\cf17  const }\{\par
01162             num_int & cthis = *{\cf17 this};\par
01163             pardigs temp;\par
01164             dig         carry=0;\par
01165             num_int ret(*{\cf17 this});\par
01166             {\cf19 if} (ret.signo==vminus) ret.mC_B();\par
01167             {\cf19 for} ( usint k=0 ; k < (cthis.size()) ; ++k ) \{\par
01168                 temp = cthis[k]*a;\par
01169                 temp += carry;\par
01170                 ret[k]= temp.g_first();\par
01171                 carry=temp.g_second();\par
01172             \}\par
01173             {\cf19 if} (carry != 0)\par
01174                 ret.insert((cthis.size())-1,1,carry);\par
01175             {\cf19 if} (ret.signo==vminus) ret.mC_B();\par
01176             {\cf19 return} ret;\par
01177         \}\par
01178 \par
01179         {\cf20 // num_int operator / (dig) const;}\par
01180         {\cf20 // num_int operator % (dig) const;}\par
01181 \par
01182 {\cf20                                         /********************************************/}\par
01183                                         {\cf20 /*                                                                                                  */}\par
01184                                         {\cf20 /*   OPERACIONES ARITMETICAS            */}\par
01185                                         {\cf20 /*           CON ASIGNACION                                     */}\par
01186                                         {\cf20 /*                                                                                                  */}\par
01187 {\cf20                                         /********************************************/}\par
01188 \par
01189         {\cf17 const} num_int & operator += ({\cf17 const} num_int &arg ) \{\par
01190             num_int & cthis = *{\cf17 this};\par
01191             this->reduce();\par
01192             num_int carg(arg.reduce());\par
01193             spardigs tempt;\par
01194             spardigs tempa;\par
01195             {\cf17 const} num_int*       po    =0;\par
01196             usint sza = carg.size();\par
01197             usint szt = cthis.size();\par
01198             p_usint pszmin=0;\par
01199             p_usint pszmax=0;\par
01200             {\cf19 if} (sza<=szt) \{\par
01201                 pszmin = &sza;\par
01202                 pszmax = &szt;\par
01203                 po     = {\cf17 this};\par
01204             \} {\cf19 else} \{\par
01205                 pszmin = &szt;\par
01206                 pszmax = &sza;\par
01207                 po     = &carg;\par
01208             \}\par
01209             {\cf17 const} num_int & obj = (*po);\par
01210             tempt.p_decs(dig_t<B>(0));\par
01211             tempa.p_decs(0);\par
01212             usint & szmin = *pszmin;\par
01213             usint & szmax = *pszmax;\par
01214             usint k = 0;\par
01215             {\cf19 for} ( ; k<szmin ; ++k ) \{\par
01216                 tempt.p_uds(cthis[k]);\par
01217                 tempa.p_uds(carg[k]);\par
01218                 tempt += tempa;\par
01219                 cthis[k]=tempt.g_uds();\par
01220             \}\par
01221             {\cf19 for} (; k<szmax ; ++k) \{\par
01222                 tempt.p_first(obj[k]);\par
01223                 tempt += (obj.aux);\par
01224                 cthis[k]=tempt.g_first();\par
01225             \}\par
01226             aux.p_first(tempt.g_second());\par
01227             aux.p_second(0);\par
01228             this->reduce();\par
01229             {\cf19 return} (*{\cf17 this});\par
01230         \}\par
01231 \par
01232         {\cf17 const} num_int & operator -= ({\cf17 const} num_int & arg) \{\par
01233             num_int & cthis = *{\cf17 this};\par
01234             this->reduce();\par
01235             num_int carg((-arg).reduce());\par
01236             spardigs tempt();\par
01237             spardigs tempa();\par
01238             {\cf17 const} num_int*       po    =0;\par
01239             usint sza = carg.size();\par
01240             usint szt = (cthis.size());\par
01241             p_usint pszmin=0;\par
01242             p_usint pszmax=0;\par
01243             {\cf19 if} (sza<=szt) \{\par
01244                 pszmin = &sza;\par
01245                 pszmax = &szt;\par
01246                 po     = {\cf17 this};\par
01247             \} {\cf19 else} \{\par
01248                 pszmin = &szt;\par
01249                 pszmax = &sza;\par
01250                 po     = &carg;\par
01251             \}\par
01252             {\cf17 const} num_int & obj = (*po);\par
01253             tempt.p_second(0);\par
01254             tempa.p_second(0);\par
01255             usint & szmin = *pszmin;\par
01256             usint & szmax = *pszmax;\par
01257             usint k = 0;\par
01258             {\cf19 for} ( ; k<szmin ; ++k) \{\par
01259                 tempt.p_first(cthis[k]);\par
01260                 tempa.p_first(carg[k]);\par
01261                 tempt += tempa;\par
01262                 cthis[k]=tempt.g_first();\par
01263             \}\par
01264             {\cf19 for} (; k<szmax ; ++k) \{\par
01265                 tempt.p_first(obj.lst_digs[k]);\par
01266                 tempt += (obj.aux);\par
01267                 cthis[k]=tempt.g_first();\par
01268             \}\par
01269             aux.p_first(tempt.g_second());\par
01270             aux.p_second(0);\par
01271             this->reduce();\par
01272             {\cf19 return} (*{\cf17 this});\par
01273         \}\par
01274 \par
01275         {\cf17 const} num_int & operator *= ({\cf17 const} num_int & arg) \{\par
01276             num_int & cthis = *{\cf17 this};\par
01277             num_int multtemp;\par
01278             {\cf17 const} sign_e sgn_ndo = signo;\par
01279             this->absp();\par
01280             this->reduce();\par
01281             num_int & m1 = (*this);\par
01282             num_int m2(arg.abs());\par
01283             m2.reduce();\par
01284 \par
01285             cthis *= m2[0];\par
01286             {\cf19 for} (usint j = 1 ; j < m2.size() ; ++j) \{\par
01287                 multtemp = m1*m2[j];\par
01288                 multtemp.insert(0,j,0);\par
01289                 cthis += multtemp;\par
01290             \}\par
01291             {\cf19 if} (sgn_ndo!=arg.signo) m1.mC_B();\par
01292             {\cf19 return} (*{\cf17 this});\par
01293         \}\par
01294 \par
01295         {\cf17 const} num_int & operator /= ({\cf17 const} num_int & arg) \{\par
01296             num_int & cthis = *{\cf17 this};\par
01297             {\cf17 const} sign_e sgn_ndo = signo;\par
01298             {\cf17 const} sign_e sgn_sor = arg.signo;\par
01299             this->absp();\par
01300             num_int & dvndo_int = *{\cf17 this};\par
01301             dvndo_int.reduce();\par
01302             num_int rem(dvndo_int);\par
01303 \par
01304             num_int dvsor_int(arg.abs());\par
01305             dvsor_int.reduce();\par
01306 \par
01307             {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
01308 \par
01309             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
01310             dvsor_int.lst_digs.erase(0,cssor);{\cf20 // division por una potencia de B}\par
01311 \par
01312 \par
01313             dvsor_int.reduce();\par
01314             dvndo_int.reduce();\par
01315 \par
01316             dvndo_fra.reduce();\par
01317 \par
01318             {\cf17 const} usint longtndo  = dvndo_int.size();\par
01319             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01320             {\cf17 const} usint longtsor  = dvsor_int.size();\par
01321             {\cf17 const} usint longsor   = longtsor;\par
01322 \par
01323             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01324             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01325             {\cf20 // cocientes enteros.}\par
01326             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01327             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01328             {\cf20 // dividendo obteniendo dvndo_fra}\par
01329 \par
01330             {\cf20 /* *}\par
01331 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01332 {\cf20 }\par
01333 {\cf20                 rem = rem.lst_digs.insert(0,cssor,0);}\par
01334 {\cf20                 rem += dvndo_fra;}\par
01335 {\cf20             * */}\par
01336             {\cf19 if} (sgn_ndo!=sgn_sor) dvndo_int.mC_B();\par
01337             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01338             {\cf20 // acomodar el formato al signo de la operacion}\par
01339             {\cf20 // determinar el signo de la operacion}\par
01340             {\cf19 return} dvndo_int;\par
01341         \}\par
01342 \par
01343         {\cf17 const} num_int & operator %= ({\cf17 const} num_int & arg) \{\par
01344             num_int & cthis = *{\cf17 this};\par
01345             (*this).absp();\par
01346             num_int & rem = *{\cf17 this};\par
01347             rem.reduce();\par
01348             num_int dvndo_int(rem);\par
01349 \par
01350             num_int dvsor_int(arg.abs());\par
01351             dvsor_int.reduce();\par
01352 \par
01353             {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
01354 \par
01355             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
01356             dvsor_int.lst_digs.erase(0,cssor);{\cf20 // division por una potencia de B}\par
01357 \par
01358 \par
01359             dvsor_int.reduce();\par
01360             dvndo_int.reduce();\par
01361 \par
01362             dvndo_fra.reduce();\par
01363 \par
01364             {\cf17 const} usint longtndo  = dvndo_int.size();\par
01365             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01366             {\cf17 const} usint longtsor  = dvsor_int.size();\par
01367             {\cf17 const} usint longsor   = longtsor;\par
01368 \par
01369             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01370             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01371             {\cf20 // cocientes enteros.}\par
01372             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01373             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01374             {\cf20 // dividendo obteniendo dvndo_fra}\par
01375 \par
01376             {\cf20 /* *}\par
01377 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01378 {\cf20             * */}\par
01379 \par
01380             rem = rem.lst_digs.insert(0,cssor,0);\par
01381             rem += dvndo_fra;\par
01382 \par
01383             {\cf19 return} rem;\par
01384         \}\par
01385 \par
01386         {\cf20 //const num_int & operator += (spardigs);}\par
01387         {\cf20 //const num_int & operator -= (spardigs);}\par
01388         {\cf20 //const num_int & operator *= (spardigs);}\par
01389         {\cf20 //const num_int & operator /= (spardigs);}\par
01390         {\cf20 //const num_int & operator %= (spardigs);}\par
01391         {\cf20 //const num_int & operator += (pardigs);}\par
01392         {\cf20 //const num_int & operator -= (pardigs);}\par
01393 \par
01394         {\cf17 const} num_int & operator *= (pardigs a) \{\par
01395             num_int & cthis = *{\cf17 this};\par
01396             pardigs             temp;\par
01397             dig                         carry = 0;\par
01398             num_int &           ret = (*this);\par
01399             {\cf19 for} ( usint k=0 ; k < cthis.size() ; ++k ) \{\par
01400                 temp = cthis[k]*(a.g_first());\par
01401                 temp += carry;\par
01402                 ret[k]= temp.g_first();\par
01403                 carry=temp.g_second();\par
01404             \}\par
01405             {\cf19 if} (carry != 0)\par
01406                 ret.insert((cthis.size())-1,1,carry);\par
01407             ret.reduce();\par
01408             carry = 0;\par
01409             {\cf19 for} ( usint k=0 ; k < ((cthis.size())-1) ; ++k ) \{\par
01410                 temp = cthis[k]*(a.g_second());\par
01411                 temp += carry;\par
01412                 ret.substr(k+1,ret.size()-1)+= temp.g_first();{\cf20 //\'BF?}\par
01413                 carry=temp.g_second();\par
01414             \}\par
01415             {\cf19 if} (carry != 0)\par
01416                 ret.insert((cthis.size())-1,1,carry);\par
01417             ret.reduce();\par
01418 \par
01419             {\cf19 if} (signo==vminus) ret.mC_B();\par
01420 \par
01421             {\cf19 return} ret;\par
01422         \}\par
01423 \par
01424         {\cf20 //const num_int & operator /= (pardigs);}\par
01425         {\cf20 //const num_int & operator %= (pardigs);}\par
01426 \par
01427         {\cf17 const} num_int & operator += (dig arg) \{\par
01428             num_int & cthis = *{\cf17 this};\par
01429             this->reduce();\par
01430             spardigs tempt();\par
01431 \par
01432             tempt.p_second(0);\par
01433             usint k = 1;\par
01434             tempt.p_first(cthis[0]);\par
01435             tempt += spardigs(arg);\par
01436             cthis[0]=tempt.g_first();\par
01437             aux = spardigs(tempt.g_second());\par
01438             {\cf19 for} (; k < cthis.size() ; ++k) \{\par
01439                 tempt.p_first(0);\par
01440                 tempt += aux;\par
01441                 cthis[k]=tempt.g_first();\par
01442                 aux = spardigs(tempt.g_second());\par
01443             \}\par
01444             aux.p_first(tempt.g_second());\par
01445             aux.p_second(0);\par
01446             this->reduce();\par
01447             {\cf19 return} (*{\cf17 this});\par
01448         \}\par
01449 \par
01450         {\cf17 const} num_int & operator -= (dig arg) \{\par
01451             num_int & cthis = *{\cf17 this};\par
01452             this->reduce();\par
01453             dig arg_CB = (dig(B-1)-arg)+dig(1);\par
01454             spardigs tempt();\par
01455 \par
01456             tempt.p_second(0);\par
01457             usint k = 1;\par
01458             tempt.p_first(cthis[0]);\par
01459             tempt += arg_CB;\par
01460             cthis[0]=tempt.g_first();\par
01461             aux = spardigs(tempt.g_second());\par
01462             {\cf19 if} (arg==0) aux += dig(B-1);\par
01463             {\cf19 for} (; k < cthis.size() ; ++k) \{\par
01464                 tempt.p_first(0);\par
01465                 tempt += aux;\par
01466                 cthis[k]=tempt.g_first();\par
01467                 aux = spardigs(tempt.g_second());\par
01468             \}\par
01469             aux.p_first(tempt.g_second());\par
01470             aux.p_second(0);\par
01471             this->reduce();\par
01472             {\cf19 return} (*{\cf17 this});\par
01473         \}\par
01474 \par
01475         {\cf17 const} num_int & operator *= (dig arg) \{\par
01476             num_int & cthis = *{\cf17 this};\par
01477             pardigs temp;\par
01478             dig         carry=0;\par
01479             sign_e  sgn = this->signo;\par
01480             this->absp();\par
01481             this->reduce();\par
01482             {\cf19 for} ( usint k=0 ; k < (cthis.size()) ; ++k ) \{\par
01483                 temp = cthis[k]*arg;\par
01484                 temp += carry;\par
01485                 cthis[k]= temp.g_first();\par
01486                 carry=temp.g_second();\par
01487             \}\par
01488             {\cf19 if} (carry != 0)\par
01489                 insert((cthis.size())-1,1,carry);\par
01490             {\cf19 if} (sgn==vminus)\par
01491                 this->mC_B();\par
01492             {\cf19 return} (*{\cf17 this});\par
01493         \}\par
01494 \par
01495         {\cf20 //      const num_int & operator /= (dig);}\par
01496         {\cf20 //      const num_int & operator %= (dig);}\par
01497 \par
01498 {\cf20                                                                 /***************************************/}\par
01499                                                                 {\cf20 /*                                                                                  */}\par
01500                                                                 {\cf20 /*   COMPLEMENTO A BASE Y       */}\par
01501                                                                 {\cf20 /*              BASE MENOS 1                            */}\par
01502                                                                 {\cf20 /*                                                                                  */}\par
01503 {\cf20                                                                 /**************************************/}\par
01504 \par
01505         num_int operator -(){\cf17  const }\{\par
01506             num_int & cthis = *{\cf17 this};\par
01507             num_int cpy(*{\cf17 this});\par
01508             cpy.reduce();\par
01509             {\cf17 const} striterator fin = cpy.end();\par
01510             striterator  it = cpy.begin();\par
01511             {\cf19 for} ( ; it != fin ; ++it )\par
01512                 (*it) = (!(*it));\par
01513 \par
01514             it = cpy.begin();\par
01515             cpy.aux = (*it)+1;\par
01516             cpy[0]=cpy.aux.g_first();\par
01517             ++it;\par
01518             {\cf19 if} ((cpy.aux.g_second())!= spardigs()) \{\par
01519                 {\cf19 for} ( ; it != fin ; ++it ) \{\par
01520                     cpy.aux.p_first(cpy.aux.g_second());\par
01521                     cpy.aux.p_second(0);\par
01522                     {\cf19 if} (cpy.aux == spardigs()) {\cf19 break};\par
01523                     cpy.aux += spardigs(*it);\par
01524                 \}\par
01525                 cpy.push_back(cpy.aux.g_first());\par
01526                 cpy.push_back(cpy.aux.g_second());\par
01527             \}\par
01528             cpy.signo = ((cpy.signo==vminus)?vplus:vminus);\par
01529             cpy.aux = spardigs();\par
01530             cpy.reduce();\par
01531             {\cf19 return} cpy;\par
01532         \}\par
01533 \par
01534         num_int operator !(){\cf17  const }\{\par
01535             num_int & cthis = *{\cf17 this};\par
01536             num_int cpy(*{\cf17 this});\par
01537             {\cf17 const} striterator fin = cpy.end();\par
01538             striterator  it = cpy.begin();\par
01539             {\cf19 for} ( ; it != fin ; ++it )\par
01540                 (*it) = (!(*it));\par
01541             cpy.signo = ((cpy.signo==vminus)?vplus:vminus);\par
01542             cpy.aux = spardigs();\par
01543             cpy.reduce();\par
01544             {\cf19 return} cpy;\par
01545         \}\par
01546 \par
01547 {\cf20                                                         /************************************/}\par
01548                                                         {\cf20 /*                                                                              */}\par
01549                                                         {\cf20 /*       MODIFICADOR                        */}\par
01550                                                         {\cf20 /*      COMPLEMENTO A BASE Y    */}\par
01551                                                         {\cf20 /*              BASE MENOS 1                        */}\par
01552                                                         {\cf20 /*                                                                              */}\par
01553 {\cf20                                                         /***********************************/}\par
01554 \par
01555         {\cf17 const} num_int & mC_B() \{\par
01556             num_int & cthis = *{\cf17 this};\par
01557             cthis.reduce();\par
01558             {\cf17 const} striterator fin = cthis.end();\par
01559             striterator  it = cthis.begin();\par
01560             {\cf19 for} ( ; it != fin ; ++it )\par
01561                 (*it) = (!(*it));\par
01562             it = cthis.begin();\par
01563             aux = (*it)+1;\par
01564             cthis[0]=aux.g_first();\par
01565             ++it;\par
01566             {\cf19 if} ((aux.g_second())!= spardigs()) \{\par
01567                 {\cf19 for} ( ; it != fin ; ++it ) \{\par
01568                     aux.p_first(aux.g_second());\par
01569                     aux.p_second(0);\par
01570                     {\cf19 if} (aux == spardigs()) {\cf19 break};\par
01571                     aux += spardigs(*it);\par
01572                 \}\par
01573                 push_back(aux.g_first());\par
01574                 push_back(aux.g_second());\par
01575             \}\par
01576             signo = ((signo==vminus)?vplus:vminus);\par
01577             aux = spardigs();\par
01578             cthis.reduce();\par
01579             {\cf19 return} cthis;\par
01580         \}\par
01581 \par
01582         {\cf17 const} num_int & mC_Bm1() \{\par
01583             num_int & cthis = *{\cf17 this};\par
01584             num_int & cpy = (*this);\par
01585             {\cf17 const} striterator fin = cpy.end();\par
01586             striterator  it = cpy.begin();\par
01587             {\cf19 for} ( ; it != fin ; ++it )\par
01588                 (*it) = (!(*it));\par
01589             cpy.signo = ((cpy.signo==vminus)?vplus:vminus);\par
01590             cpy.aux = spardigs();\par
01591             cpy.reduce();\par
01592             {\cf19 return} cpy;\par
01593         \}\par
01594 \par
01595 {\cf20                                                         /******************************/}\par
01596                                                         {\cf20 /*                                                                      */}\par
01597                                                         {\cf20 /*         ABSOLUTO                     */}\par
01598                                                         {\cf20 /*                                                                      */}\par
01599 {\cf20                                                         /******************************/}\par
01600 \par
01601         num_int abs(){\cf17  const }\{\par
01602             {\cf17 const} num_int cthis(*{\cf17 this});\par
01603             cthis.reduce();\par
01604             {\cf19 if} (signo==vminus)\par
01605                 cthis.mC_B();\par
01606             cthis.reduce();\par
01607             {\cf19 return} cthis;\par
01608         \}\par
01609 \par
01610         {\cf17 const} num_int & absp() \{\par
01611             num_int & cthis = (*this);\par
01612             cthis.reduce();\par
01613             {\cf19 if} (signo==vminus) cthis.mC_B();\par
01614             cthis.reduce();\par
01615             {\cf19 return} cthis;\par
01616         \}\par
01617 \par
01618 {\cf20                                                                         /***********************************/}\par
01619                                                                         {\cf20 /*                                                                              */}\par
01620                                                                         {\cf20 /*  DIVIDIR ENTRE BASE O 2      */}\par
01621                                                                         {\cf20 /*                                                                              */}\par
01622 {\cf20                                                                         /***********************************/}\par
01623 \par
01624         num_int divB (){\cf17  const }\{\par
01625             num_int cpy(*{\cf17 this});\par
01626             cpy.reduce();\par
01627             sign_e sgn = cpy.signo;\par
01628             cpy.absp();\par
01629             cpy.cthis.erase(0,1);\par
01630             {\cf19 if} (sgn==vminus) cpy.mC_B();\par
01631             cpy.reduce();\par
01632             {\cf19 return} cpy;\par
01633         \}\par
01634 \par
01635         dig remB (){\cf17  const }\{\par
01636             num_int cpy(*{\cf17 this});\par
01637             cpy.reduce();\par
01638             {\cf19 if} (signo==vminus) {\cf19 return} cpy.absp();\par
01639             {\cf19 return} cpy.lst_digs[0];\par
01640         \}\par
01641 \par
01642         {\cf17 const} num_int & divBp() \{\par
01643             num_int & cpy = (*this);\par
01644             cpy.reduce();\par
01645             sign_e sgn = cpy.signo;\par
01646             cpy.absp();\par
01647             cpy.cthis.erase(0,1);\par
01648             {\cf19 if} (sgn==vminus) cpy.mC_B();\par
01649             cpy.reduce();\par
01650             {\cf19 return} cpy;\par
01651         \}\par
01652 \par
01653         dig remBp() \{\par
01654             num_int & cpy = (*this);\par
01655             cpy.reduce();\par
01656             {\cf19 if} (signo==vminus) {\cf19 return} cpy.absp();\par
01657             {\cf19 return} cpy.lst_digs[0];\par
01658         \}\par
01659 \par
01660         num_int div2 (){\cf17  const }\{\par
01661             num_int & cthis = *{\cf17 this};\par
01662             {\cf17 const} sign_e sgn = signo;\par
01663             num_int dvndo_int(cthis.abs());\par
01664             dvndo_int.reduce();\par
01665             num_int rem(dvndo_int);\par
01666             {\cf17 const} dig dos = 2;\par
01667 \par
01668             num_int dvsor_int(dos);\par
01669 \par
01670             {\cf17 const} usint cssor = ((B==2)?(1):(0));\par
01671 \par
01672             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
01673             {\cf19 if} (B==2) dvsor_int[0]=1;{\cf20 // division por una potencia de B}\par
01674 \par
01675             dvndo_int.reduce();\par
01676             dvndo_fra.reduce();\par
01677 \par
01678             {\cf17 const} usint longtndo  = dvndo_int.size();\par
01679             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01680             {\cf17 const} usint longtsor  = 1;\par
01681             {\cf17 const} usint longsor   = 0;\par
01682 \par
01683             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01684             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01685             {\cf20 // cocientes enteros.}\par
01686             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01687             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01688             {\cf20 // dividendo obteniendo dvndo_fra}\par
01689 \par
01690             {\cf20 /* *}\par
01691 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01692 {\cf20 }\par
01693 {\cf20                 rem = rem.cthis.insert(0,cssor,0);}\par
01694 {\cf20                 rem += dvndo_fra;}\par
01695 {\cf20             * */}\par
01696             {\cf19 if} (sgn==vminus) dvndo_int.mC_B();\par
01697             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01698             {\cf20 // acomodar el formato al signo de la operacion}\par
01699             {\cf20 // determinar el signo de la operacion}\par
01700             {\cf19 return} dvndo_int;\par
01701         \}\par
01702 \par
01703         dig rem2 (){\cf17  const }\{\par
01704             num_int & cthis = *{\cf17 this};\par
01705             sign_e sgn = signo;\par
01706             num_int cpy = cthis.reduce();\par
01707             cpy.absp();\par
01708             cpy.reduce();\par
01709             {\cf19 if} (B%2==1) \{\par
01710                 {\cf19 if} (cpy.lst_digs.size()==1)\par
01711                     {\cf19 return} dig::Rem2(cpy.lst_digs[0]);\par
01712                 {\cf19 else} \{\par
01713                     usint paridad = 0;\par
01714                     {\cf19 for} ( usint k=0 ; k < cpy.lst_digs.size() ; ++k )\par
01715                         paridad += dig::Dig2UInt(dig::Rem2(cpy.lst_digs[k]));\par
01716                     paridad %= 2;\par
01717                     {\cf19 return} dig(paridad);\par
01718                 \}\par
01719             \}\par
01720             {\cf19 else} \{\par
01721                 {\cf19 return} dig::Rem2(cpy.lst_digs[0]);\par
01722             \}\par
01723         \}\par
01724 \par
01725         {\cf17 const} num_int & div2p() \{\par
01726             num_int & cthis = *{\cf17 this};\par
01727             sign_e sgn = signo;\par
01728             cthis.absp();\par
01729             cthis.reduce();\par
01730             num_int & dvndo_int = (*this);\par
01731             num_int rem(dvndo_int);\par
01732             {\cf17 const} dig dos = 2;\par
01733 \par
01734             num_int dvsor_int(dos);\par
01735 \par
01736             {\cf17 const} usint cssor = ((B==2)?(1):(0));\par
01737 \par
01738             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
01739             {\cf19 if} (B==2) dvsor_int[0]=1;{\cf20 // division por una potencia de B}\par
01740 \par
01741             dvndo_int.reduce();\par
01742             dvndo_fra.reduce();\par
01743 \par
01744             {\cf17 const} usint longtndo  = dvndo_int.size();\par
01745             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01746             {\cf17 const} usint longtsor  = 1;\par
01747             {\cf17 const} usint longsor   = 0;\par
01748 \par
01749             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01750             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01751             {\cf20 // cocientes enteros.}\par
01752             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01753             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01754             {\cf20 // dividendo obteniendo dvndo_fra}\par
01755 \par
01756             {\cf20 /* *}\par
01757 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01758 {\cf20 }\par
01759 {\cf20                 rem = rem.lst_digs.insert(0,cssor,0);}\par
01760 {\cf20                 rem += dvndo_fra;}\par
01761 {\cf20             * */}\par
01762             {\cf19 if} (sgn==vminus) dvndo_int.mC_B();\par
01763             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01764             {\cf20 // acomodar el formato al signo de la operacion}\par
01765             {\cf20 // determinar el signo de la operacion}\par
01766             {\cf19 return} dvndo_int;\par
01767         \}\par
01768 \par
01769         dig rem2p() \{\par
01770             num_int & cthis = *{\cf17 this};\par
01771             sign_e sgn = signo;\par
01772             cthis.absp();\par
01773             cthis.reduce();\par
01774             num_int & cpy = (*this);\par
01775             {\cf19 if} (B%2==1) \{\par
01776                 {\cf19 if} (cpy.size()==1)\par
01777                     {\cf19 return} dig::Rem2(cpy.lst_digs[0]);\par
01778                 {\cf19 else} \{\par
01779                     usint paridad = 0;\par
01780                     {\cf19 for} ( usint k=0 ; k < cpy.size() ; ++k )\par
01781                         paridad += dig::Dig2UInt(dig::Rem2(cpy[k]));\par
01782                     paridad %= 2;\par
01783                     {\cf19 return} dig(paridad);\par
01784                 \}\par
01785             \}\par
01786             {\cf19 else} \{\par
01787                 {\cf19 return} dig::Rem2(cpy[0]);\par
01788             \}\par
01789         \}\par
01790 \par
01791         {\cf20 /*              num_int div3() const;}\par
01792 {\cf20                         const num_int & div3p();}\par
01793 {\cf20                         dig rem3() const;}\par
01794 {\cf20                         const num_int & rem3p();}\par
01795 {\cf20                         const dig rem4() const;}\par
01796 {\cf20                         dig rem5() const;}\par
01797 {\cf20                         dig rem6() const;}\par
01798 {\cf20                         num_int div7 () const;}\par
01799 {\cf20                         dig rem7 () const;}\par
01800 {\cf20                         const num_int & div7p();}\par
01801 {\cf20                         dig rem7p();}\par
01802 {\cf20                         const dig rem8() const;}\par
01803 {\cf20         */}\par
01804 \par
01805         dig                     remBm1(){\cf17         const }\{\par
01806             num_int cthis(*{\cf17 this}),suma;\par
01807             sign_e sgn = signo;\par
01808             cthis.abs();\par
01809             cthis.reduce();\par
01810             suma.reduce();\par
01811             suma.lst_digs.insert(0,1,0);\par
01812             suma.lst_digs.erase(0,(cthis.size())-1);\par
01813             {\cf19 do} \{\par
01814                 {\cf19 for} ( usint i = 0 ; i < cthis.size() ; ++i ) \{\par
01815                     suma += cthis[i];\par
01816                     suma.reduce();\par
01817                 \}\par
01818             \} {\cf19 while} (suma.size()>1);\par
01819 \par
01820             {\cf19 if} ((suma[0]==0)||(suma[0]==(B-1))) {\cf19 return} 0;\par
01821             {\cf19 else} {\cf19 return} suma[0];\par
01822         \}\par
01823 \par
01824         {\cf20 // dig                          remBm1p()               ;}\par
01825         {\cf20 // num_int                      divBm1()        const;}\par
01826         {\cf20 // const num_int        &       divBm1p()               ;}\par
01827     {\cf17 private}:\par
01828 \par
01829 {\cf20 //              inline void     div3_step(pair< n2digs_t , usint > & S) const;}\par
01830 {\cf20 //              inline void div3p_step(pair< n2digs_t , usint > & S);}\par
01831 {\cf20 //              inline void     div7_step(pair< n2digs_t , usint > & S) const;}\par
01832 {\cf20 //              inline void div7p_step(pair< n2digs_t , usint > & S);}\par
01833 \par
01834 \par
01835 {\cf20                                                                 /******************************/}\par
01836                                                                 {\cf20 /*                                                                      */}\par
01837                                                                 {\cf20 /*        Division Generica                 */}\par
01838                                                                 {\cf20 /*                                                                      */}\par
01839 {\cf20                                                                 /******************************/}\par
01840 \par
01841 \par
01842         {\cf17 inline} {\cf18 void}     div_gen_step({\cf17 const} num_int & dvsor, num_int & rem, num_int & coc, usint & ndig){\cf17  const }\{\par
01843             num_int & cthis = *{\cf17 this};\par
01844             {\cf17 const} usint maxpos = (cthis.size())-1;\par
01845             {\cf17 const} num_int & dvndo = (*this);\par
01846             rem.insert(0,1,dvndo[maxpos-ndig]);\par
01847             {\cf19 if} (rem < coc) \{\par
01848                 coc.insert(0,1,0);\par
01849             \}\par
01850             {\cf19 else} {\cf19 if} (rem == coc) \{\par
01851                 coc.insert(0,1,1);\par
01852                 rem.erase(0,rem.size()-1);\par
01853                 rem[0]=0;\par
01854             \}\par
01855             {\cf19 else} \{\par
01856                 {\cf19 if} (rem.size() > dvsor.size()) \{\par
01857                     pardigs dighrem        = pardigs(rem[rem.size()-1],rem[rem.size()-2]) ;\par
01858                     pardigs dighsor        = pardigs(0,dvsor[dvsor.size()-1]) ;\par
01859                     pardigs & digcocprueba = dighrem ;\par
01860                     digcocprueba /= dighsor ;\par
01861                     num_int remprueba = dvsor*digcocprueba ;\par
01862                     {\cf19 for} ( dig_t<B> ix = 0  ; ix < pardigs(1,0) ; ix += 1 ) \{\par
01863                         {\cf19 if} ( remprueba > rem ) \{\par
01864                             --digcocprueba;\par
01865                             remprueba -= dvsor;\par
01866                         \}\par
01867                         {\cf19 else} \{\par
01868                             rem -= remprueba;\par
01869                             coc.insert(0,1,digcocprueba);\par
01870                             {\cf19 break};\par
01871                         \}\par
01872                     \}\par
01873                 \}\par
01874                 {\cf19 else} \{\par
01875                     dig_t<B> dighrem        = rem[rem.size()-1];\par
01876                     dig_t<B> dighsor        = dvsor[dvsor.size()-1];\par
01877                     dig_t<B> & digcocprueba = dighrem;\par
01878                     digcocprueba /= dighsor;\par
01879                     num_int remprueba = dvsor*digcocprueba; {\cf20 // no est\'E1 implementada esta funci\'F3n}\par
01880                     dig_t<B> ix = 0 ;\par
01881                     {\cf19 for} (  ; ix < pardigs(1,0) ; ix += 1 ) \{\par
01882                         {\cf19 if} ( remprueba > rem ) \{\par
01883                             --digcocprueba;\par
01884                             remprueba -= dvsor;\par
01885                         \}\par
01886                         {\cf19 else} \{\par
01887                             rem -= remprueba;\par
01888                             coc.insert(0,1,digcocprueba);\par
01889                             {\cf19 break};\par
01890                         \}\par
01891                     \}\par
01892                 \}\par
01893             \}\par
01894             ++ndig;\par
01895             {\cf19 return};\par
01896         \}\par
01897 \par
01898         {\cf17 inline} {\cf18 void} divp_gen_step({\cf17 const} num_int & dvsor, num_int & rem, num_int & coc, usint & ndig) \{\par
01899             num_int & cthis = *{\cf17 this};\par
01900             {\cf17 const} usint maxpos = (cthis.size())-1;\par
01901             num_int & dvndo = (*this);\par
01902             rem.insert(0,1,dvndo[maxpos-ndig]);\par
01903             {\cf19 if} (rem < coc) \{\par
01904                 coc.insert(0,1,0);\par
01905             \}\par
01906             {\cf19 else} {\cf19 if} (rem == coc) \{\par
01907                 coc.insert(0,1,1);\par
01908                 rem.erase(0,rem.size()-1);\par
01909                 rem[0]=0;\par
01910             \}\par
01911             {\cf19 else} \{\par
01912                 {\cf19 if} (rem.size() > dvsor.size()) \{\par
01913                     pardigs dighrem        = pardigs(rem[rem.size()-1],rem[rem.size()-2]);\par
01914                     {\cf17 const} pardigs dighsor  = pardigs(0,dvsor[dvsor.size()-1]);\par
01915                     pardigs & digcocprueba = dighrem;\par
01916                     digcocprueba /= dighsor;\par
01917                     num_int remprueba = dvsor*digcocprueba;\par
01918                     {\cf19 for} ( dig_t<B> Id = 0 ; Id < pardigs(1,0) ; Id+=1 ) \{\par
01919                         {\cf19 if} ( remprueba > rem ) \{\par
01920                             --digcocprueba;\par
01921                             remprueba -= dvsor;\par
01922                         \}\par
01923                         {\cf19 else} \{\par
01924                             rem -= remprueba;\par
01925                             coc.insert(0,1,digcocprueba);\par
01926                             {\cf19 break};\par
01927                         \}\par
01928                     \}\par
01929                 \}\par
01930                 {\cf19 else} \{\par
01931                     dig_t<B> dighrem        = rem[rem.size()-1];\par
01932                     {\cf17 const} dig_t<B> dighsor  = dvsor[dvsor.size()-1];\par
01933                     dig_t<B> & digcocprueba = dighrem;\par
01934                     digcocprueba /= dighsor;\par
01935                     num_int remprueba = dvsor*digcocprueba;\par
01936                     {\cf19 for} ( dig_t<B> Id = 0 ; Id < pardigs(1,0) ; Id+=1 ) \{\par
01937                         {\cf19 if} ( remprueba > rem ) \{\par
01938                             --digcocprueba;\par
01939                             remprueba -= dvsor;\par
01940                         \}\par
01941                         {\cf19 else} \{\par
01942                             rem -= remprueba;\par
01943                             coc.insert(0,1,digcocprueba);\par
01944                             {\cf19 break};\par
01945                         \}\par
01946                     \}\par
01947                 \}\par
01948             \}\par
01949             ++ndig;\par
01950             {\cf19 return};\par
01951         \}\par
01952 \par
01953 {\cf20                                                                 /******************************/}\par
01954                                                                 {\cf20 /*                                                                      */}\par
01955                                                                 {\cf20 /*        Division entre Uno            */}\par
01956                                                                 {\cf20 /*                                                                      */}\par
01957 {\cf20                                                                 /******************************/}\par
01958 \par
01959 \par
01960         {\cf17 inline} {\cf18 void} div_uno( num_int & rem , num_int & dvndo, num_int & dvsor, {\cf17 const} usint long_dvndo, {\cf17 const} usint long_dvsor){\cf17  const }\{\par
01961             num_int & cthis = *{\cf17 this};\par
01962             rem = dvndo;\par
01963             {\cf19 if} ((long_dvsor==0)||((long_dvsor==1)&&(dvsor[0]=0))) \{ {\cf20 // caso de division por 0}\par
01964                 {\cf19 return};\par
01965             \}\par
01966             {\cf19 else} {\cf19 if} ((long_dvndo==0)||(long_dvndo < long_dvsor)) \{ {\cf20 // caso de 0 dividido por !=0 \'F3 caso de cociente 0}\par
01967                 rem = dvndo;\par
01968                 dvndo.erase(0,(cthis.size())-1);\par
01969                 dvndo[0]=0;\par
01970                 {\cf19 return};\par
01971                 {\cf20 // rem=dvndo; hecho por defecto}\par
01972             \}\par
01973             {\cf19 else} {\cf19 if} (dvndo==dvsor) \{ {\cf20 // caso de dividir por si mismo}\par
01974                 dvndo.erase(0,(cthis.size())-1);\par
01975                 dvndo[0]=1;\par
01976                 rem.erase(0,rem.size()-1);\par
01977                 rem[0]=0;\par
01978                 {\cf19 return};\par
01979             \}\par
01980             {\cf19 else} {\cf19 if} ((long_dvsor==1)&&(dvsor[0]==1)) \{ {\cf20 // caso de dividir por potencias de B}\par
01981                 {\cf20 //dvndo;}\par
01982                 rem.erase(0,rem.size()-1);\par
01983                 rem[0]=0;\par
01984             \}\par
01985             {\cf20 /*          else if ((long_dvsor==1)&&((dvsor[0]==2)||(dvsor[0]==4)||(dvsor[0]==8))) \{}\par
01986 {\cf20                         // caso de dividir por potencias de B multiplicadas por 2, 4 u 8}\par
01987 {\cf20                                 //dvndo;}\par
01988 {\cf20                                 switch(dvsor[0]) \{}\par
01989 {\cf20                                         case 2  : rem=num_int(rem.rem2()); break;}\par
01990 {\cf20                                         case 4  : rem=num_int(rem.rem4()); break;}\par
01991 {\cf20                                         case 8  :}\par
01992 {\cf20                                         default : rem=num_int(rem.rem8());}\par
01993 {\cf20                                 \}}\par
01994 {\cf20                                 dvndo.div2p();}\par
01995 {\cf20                                 switch(dvsor[0]) \{}\par
01996 {\cf20                                         case 4:  dvndo.div2p(); break;}\par
01997 {\cf20                                         case 8:  dvndo.div2p(); dvndo.div2p();}\par
01998 {\cf20                                 \}}\par
01999 {\cf20 }\par
02000 {\cf20                         \}}\par
02001 {\cf20                         else if ((long_dvsor==1)&&((dvsor[0]==3)||(dvsor[0]==9))) \{}\par
02002 {\cf20                         // caso de dividir por potencias de B multiplicadas por 3 u 9}\par
02003 {\cf20                                 //dvndo;}\par
02004 {\cf20                                 switch(dvsor[0]) \{}\par
02005 {\cf20                                         case 3  : rem=num_int(rem.rem3()); break;}\par
02006 {\cf20                                         case B-1  :}\par
02007 {\cf20                                         default : rem=num_int(rem.rem9()); break;}\par
02008 {\cf20                                 \}}\par
02009 {\cf20                                 dvndo.div3p();}\par
02010 {\cf20                                 if(dvsor[0]==n) dvndo.div3p();}\par
02011 {\cf20                         \}}\par
02012 {\cf20                         else if ((long_dvsor==1)&&(dvsor[0]==6)) \{}\par
02013 {\cf20                         // caso de dividir por potencias de B multiplicadas por 6}\par
02014 {\cf20                                 //dvndo;}\par
02015 {\cf20                                 rem.rem6();}\par
02016 {\cf20                                 dvndo.div2p();}\par
02017 {\cf20                                 dvndo.div3p();}\par
02018 {\cf20                         \}}\par
02019 {\cf20                         else if ((long_dvsor==1)&&(dvsor[0]==5)) \{}\par
02020 {\cf20                         // caso de dividir por potencias de B multiplicadas por 5}\par
02021 {\cf20                                 rem.rem5();}\par
02022 {\cf20                                 if (long_dvndo > 1) \{}\par
02023 {\cf20                                         dvndolst_digs.erase(0,1);}\par
02024 {\cf20                                         // Divido por B}\par
02025 {\cf20                                         dvndo *= d;}\par
02026 {\cf20                                         // y he multiplicado por 2 (*2/B \'F3 *1/5)}\par
02027 {\cf20                                 \}}\par
02028 {\cf20                                 else \{}\par
02029 {\cf20                                         //dvndo;}\par
02030 {\cf20                                         //dvndolst_digs.erase(0,(cthis.size())-1);}\par
02031 {\cf20                                         switch (dvndo[0]) \{}\par
02032 {\cf20                                                 case 0 :}\par
02033 {\cf20                                                 case 1 :}\par
02034 {\cf20                                                 case 2 :}\par
02035 {\cf20                                                 case 3 :}\par
02036 {\cf20                                                 case 4 :  dvndo[0] = 0; break;}\par
02037 {\cf20                                                 default : dvndo[0] = 1;}\par
02038 {\cf20                                         \}}\par
02039 {\cf20                                 \}}\par
02040 {\cf20                         \}}\par
02041 {\cf20                         else if ((long_dvsor==1)&&(dvsor[0]==7)) \{}\par
02042 {\cf20                         // caso de dividir por potencias de B multiplicadas por 7}\par
02043 {\cf20                                 //dvndo;}\par
02044 {\cf20                                 rem.rem7();}\par
02045 {\cf20                                 dvndo.div7();}\par
02046 {\cf20                         \}*/}\par
02047             {\cf19 else} {\cf19 if} ((long_dvndo == long_dvsor) && (dvndo < dvsor)) \{\par
02048                 rem = dvndo;\par
02049                 dvndo.erase(0,(cthis.size())-1);\par
02050                 dvndo[0]    =0;\par
02051             \}\par
02052             {\cf19 else} \{\par
02053                 {\cf20 // algoritmo de resta general}\par
02054                 {\cf20 // implementar div_step pasamos (resto,cociente,i,dividendo,divisor) devuelve (resto,cociente,i,dividendo,divisor)}\par
02055                 {\cf20 // se puede hacer con una tupla}\par
02056                 {\cf20 //dvndo;}\par
02057                 num_int rem   = (dvndo = dvndo.substr((cthis.size())-1-long_dvsor,long_dvsor));\par
02058                 num_int coc(0);\par
02059                 usint ndig = 0;\par
02060                 {\cf19 do} \{\par
02061                     div_gen_step(dvsor,rem,coc,ndig);\par
02062                 \} {\cf19 while} ( rem >= dvsor );\par
02063                 dvndo = coc;\par
02064                 {\cf19 return};\par
02065             \}\par
02066         \}\par
02067         {\cf20 //END PRIVATE}\par
02068 \par
02069 \par
02070 {\cf20                                         /****************************/}\par
02071                                         {\cf20 /*                                                                  */}\par
02072                                         {\cf20 /*        Division Euclidea             */}\par
02073                                         {\cf20 /*                                                                  */}\par
02074 {\cf20                                         /****************************/}\par
02075 \par
02076 \par
02077     {\cf17 public}:\par
02078 \par
02079         pair< num_int , num_int > EuclidDiv ({\cf17 const} num_int & arg){\cf17  const }\{\par
02080             num_int & cthis = *{\cf17 this};\par
02081             {\cf17 const} sign_e sgn_ndo = signo;\par
02082             {\cf17 const} sign_e sgn_sor = arg.signo;\par
02083             num_int dvndo_int = cthis;\par
02084             dvndo_int.absp();\par
02085             dvndo_int.reduce();\par
02086             num_int dvsor_int = arg.abs();\par
02087             dvsor_int.reduce();\par
02088 \par
02089             num_int rem(dvndo_int);\par
02090 \par
02091             {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
02092 \par
02093             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
02094             dvsor_int.erase(0,cssor);{\cf20 // division por una potencia de B}\par
02095 \par
02096             dvsor_int.reduce();\par
02097             dvndo_int.reduce();\par
02098 \par
02099             dvndo_fra.reduce();\par
02100 \par
02101             {\cf17 const} usint longtndo  = dvndo_int.size();\par
02102             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
02103             {\cf17 const} usint longtsor  = dvsor_int.size();\par
02104             {\cf17 const} usint longsor   = longtsor;\par
02105 \par
02106             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
02107             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
02108             {\cf20 // cocientes enteros.}\par
02109             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
02110             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
02111             {\cf20 // dividendo obteniendo dvndo_fra}\par
02112 \par
02113             {\cf20 /* *}\par
02114 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
02115 {\cf20              * */}\par
02116             rem = rem.insert(0,cssor,0);\par
02117             rem += dvndo_fra;\par
02118 \par
02119             {\cf19 if} (sgn_ndo != sgn_sor) dvndo_int.mC_B();\par
02120             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
02121             {\cf20 // acomodar el formato al signo de la operacion}\par
02122             {\cf20 // determinar el signo de la operacion}\par
02123             {\cf19 return} make_pair(rem,dvndo_int);\par
02124         \}\par
02125 \par
02126         pair< num_int , const num_int & > EuclidDivP ({\cf17 const} num_int & arg) \{\par
02127             num_int & cthis = *{\cf17 this};\par
02128             {\cf17 const} sign_e sgn_ndo = signo;\par
02129             {\cf17 const} sign_e sgn_sor = arg.signo;\par
02130             cthis.absp();\par
02131             cthis.reduce();\par
02132             num_int & dvndo_int = cthis;\par
02133             num_int dvsor_int = arg.abs();\par
02134             dvsor_int.reduce();\par
02135 \par
02136             num_int rem(dvndo_int);\par
02137 \par
02138             {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
02139 \par
02140             num_int dvndo_fra(dvndo_int.substr(0,cssor));\par
02141             dvsor_int.erase(0,cssor);{\cf20 // division por una potencia de B}\par
02142 \par
02143             dvsor_int.reduce();\par
02144             dvndo_int.reduce();\par
02145 \par
02146             dvndo_fra.reduce();\par
02147 \par
02148             {\cf17 const} usint longtndo  = dvndo_int.size();\par
02149             {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
02150             {\cf17 const} usint longtsor  = dvsor_int.size();\par
02151             {\cf17 const} usint longsor   = longtsor;\par
02152 \par
02153             {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
02154             {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
02155             {\cf20 // cocientes enteros.}\par
02156             div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
02157             {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
02158             {\cf20 // dividendo obteniendo dvndo_fra}\par
02159 \par
02160             {\cf20 /* *}\par
02161 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
02162 {\cf20              * */}\par
02163             rem = rem.insert(0,cssor,0);\par
02164             rem += dvndo_fra;\par
02165 \par
02166             {\cf19 if} (sgn_ndo != sgn_sor) dvndo_int.mC_B();\par
02167             {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
02168             {\cf20 // acomodar el formato al signo de la operacion}\par
02169             {\cf20 // determinar el signo de la operacion}\par
02170             {\cf19 return} make_pair(rem,dvndo_int);\par
02171         \}\par
02172 \par
02173 \par
02174 {\cf20                                         /************************************/}\par
02175                                         {\cf20 /*                                                                                      */}\par
02176                                         {\cf20 /*                   PRE Y POST                             */}\par
02177                                         {\cf20 /*                                                                                      */}\par
02178 {\cf20                                         /************************************/}\par
02179 \par
02180 \par
02181 {\cf17 public}:\par
02182                 {\cf20 /*}\par
02183 {\cf20                 const Counter& Counter::operator++()}\par
02184 {\cf20                 \{}\par
02185 {\cf20                         ++itsVal;}\par
02186 {\cf20                         return *this;}\par
02187 {\cf20                 \}}\par
02188 {\cf20 }\par
02189 {\cf20                 const Counter Counter::operator++(int)}\par
02190 {\cf20                 \{}\par
02191 {\cf20                         Counter temp(*this);}\par
02192 {\cf20                         ++itsVal;}\par
02193 {\cf20                         return temp;}\par
02194 {\cf20                 \}}\par
02195 {\cf20                 */}\par
02196         {\cf17 const} num_int & operator ++ () \{\par
02197             num_int & cthis = *{\cf17 this};\par
02198                         {\cf17 const} {\cf18 size_t} long_inic = cthis.size();\par
02199                         {\cf19 if} (long_inic>1)\{\par
02200                                 cthis.reduce();\}\par
02201                         {\cf19 if} (cthis==num_int(vminus,dig(B-1),dig(B-1)))\{\par
02202                                 cthis.clear();\par
02203                                 cthis.resize(1);\par
02204                                 cthis[0]=dig(0);\par
02205                                 signo = vplus;\par
02206                                 cthis.reduce();\par
02207                                 {\cf19 return} cthis;\}\par
02208                         {\cf18 bool} es_negativo = (signo==vminus);\par
02209                         signo = vplus;\par
02210                         aux=spardigs(vplus,0,1);\par
02211                         aux += spardigs(vplus,0,cthis[0]);\par
02212                         cthis[0] = aux.g_uds();\par
02213                         aux.p_uds(aux.g_decs());\par
02214                         aux.p_decs(0);\par
02215                         {\cf18 bool} seguir = (aux.g_uds()!=dig(0));\par
02216                         ullint i=1;\par
02217                         {\cf19 while}( seguir and (i<long_inic)) \{\par
02218                                 aux += spardigs(vplus,0,cthis[i]);\par
02219                                 cthis[i]=(aux.g_uds());\par
02220                                 aux.p_uds(aux.g_decs());\par
02221                                 seguir = (aux.g_uds()!=dig(0));\par
02222                                 aux.p_decs(0);\par
02223                                 ++i;\par
02224                         \}\par
02225                         {\cf19 if}( seguir and (i >= long_inic) ) \{\par
02226                                 cthis.resize(long_inic+1);\par
02227                                 cthis[i]=aux.g_uds();\par
02228                         \}\par
02229                         ((seguir)and(es_negativo)?(signo=vplus):(signo=vminus));{\cf20 //}\par
02230                         signo=(es_negativo?vminus:vplus);\par
02231                         cthis.reduce();\par
02232                         {\cf19 return} cthis;\par
02233         \}\par
02234 \par
02235         {\cf17 const} num_int operator ++ ({\cf18 int}) \{\par
02236                         num_int cpThis(*{\cf17 this});\par
02237                         num_int & cthis = (*this);\par
02238                         {\cf17 const} {\cf18 size_t} long_inic = cthis.size();\par
02239                         {\cf19 if} (cthis==num_int(vminus,dig(B-1),dig(B-1)))\{\par
02240                                 cthis.clear();\par
02241                                 cthis.resize(1);\par
02242                                 cthis[0]=dig(0);\par
02243                                 signo = vplus;\par
02244                                 cthis.reduce();\par
02245                                 {\cf19 return} cpThis;\par
02246                         \}\par
02247                         {\cf18 bool} es_negativo = (signo==vminus);\par
02248                         signo = vplus;\par
02249                         aux=spardigs(vplus,0,1);\par
02250                         aux += spardigs(vplus,0,cthis[0]);\par
02251                         cthis[0] = aux.g_uds();\par
02252                         aux.p_uds(aux.g_decs());\par
02253                         aux.p_decs(0);\par
02254                         {\cf18 bool} seguir = (aux.g_uds()!=dig(0));\par
02255                         ullint i=1;\par
02256                         {\cf19 while}( seguir and (i<long_inic)) \{\par
02257                                 aux += spardigs(vplus,0,cthis[i]);\par
02258                                 cthis[i]=(aux.g_uds());\par
02259                                 aux.p_uds(aux.g_decs());\par
02260                                 seguir = (aux.g_uds()!=dig(0));\par
02261                                 aux.p_decs(0);\par
02262                                 ++i;\par
02263                         \}\par
02264                         {\cf19 if}( seguir and (i >= long_inic) ) \{\par
02265                                 cthis.resize(long_inic+1);\par
02266                                 cthis[i]=aux.g_uds();\par
02267                         \}\par
02268                         ((seguir)and(es_negativo)?(signo=vplus):(signo=vminus));{\cf20 //}\par
02269                         signo=(es_negativo?vminus:vplus);\par
02270                         cthis.reduce();\par
02271             {\cf19 return} cpThis;\par
02272         \}\par
02273 \par
02274         {\cf17 const} num_int & operator -- () \{\par
02275             num_int & cthis = *{\cf17 this};\par
02276                         {\cf17 const} {\cf18 size_t} long_inic = cthis.size();\par
02277                         {\cf20 // BEGIN TRATAMIENTO DEL 0}\par
02278                         {\cf19 if} (cthis==num_int(vplus,dig(0),dig(0)))\{\par
02279                                 cthis.clear();\par
02280                                 cthis.resize(1);\par
02281                                 cthis[0]=dig(B-1);\par
02282                                 signo = vminus;\par
02283                                 {\cf19 return} cthis;\par
02284                         \}\par
02285                         {\cf18 bool} es_negativo = (signo==vminus);\par
02286                         {\cf20 // END TRATAMIENTO DEL 0}\par
02287                         {\cf20 // BEGIN TRATAMIENTO DE POTENCIA DE B NEGATIVAS}\par
02288                         {\cf18 bool} es_pot_de_B_neg = {\cf17 false};\par
02289                         {\cf19 if} (es_negativo) \{\par
02290                                 es_pot_de_B_neg = {\cf17 true};\par
02291                                 {\cf19 for}(slint i=0 ; (i < long_inic) and es_pot_de_B_neg ; ++i)\par
02292                                 \{\par
02293                                         es_pot_de_B_neg = es_pot_de_B_neg and (cthis[i]==dig(0));\par
02294                                 \}\par
02295                         \} {\cf20 // Hemos calculado si es potencia de 10 negativa}\par
02296                         {\cf19 if} (es_pot_de_B_neg) \{\par
02297                                 cthis.resize(long_inic+1);\par
02298                                 {\cf19 for}(slint i=0; i < long_inic; ++i)\par
02299                                         cthis[i]=dig(B-1);\par
02300                                 cthis[long_inic] = dig(B-2);\par
02301                                 signo = vminus;\par
02302                                 {\cf19 return} cthis;\par
02303                         \} {\cf20 // Vemos que -000 pasa a -8999}\par
02304                         {\cf20 // END TRATAMIENTO DE POTENCIA DE B NEGATIVAS}\par
02305                         signo = vplus;\par
02306                         aux=spardigs(vminus,dig(B-1),dig(B-1));\par
02307                         aux+= spardigs(vplus,0,cthis[0]);\par
02308                         cthis[0] = aux.g_uds();\par
02309                         aux.p_uds(aux.g_decs());\par
02310                         aux.p_decs(B-1);\par
02311                         {\cf18 bool} seguir = (aux.g_uds()!=dig(0));\par
02312                         ullint i=1;\par
02313                         {\cf19 while}( seguir and (i<long_inic)) \{\par
02314                                 aux += spardigs(vplus,0,cthis[i]);\par
02315                                 cthis[i]=(aux.g_uds());\par
02316                                 aux.p_uds(aux.g_decs());\par
02317                                 seguir = (aux.g_uds()!=dig(0));\par
02318                                 aux.p_decs(B-1);\par
02319                                 ++i;\par
02320                         \}\par
02321                         {\cf19 if}( seguir and (i >= long_inic) ) \{\par
02322                                 cthis.resize(long_inic+1);\par
02323                                 cthis[i]=aux.g_uds();\par
02324                         \}\par
02325                         signo=(es_negativo?vminus:vplus);\par
02326                         cthis.reduce();\par
02327                         {\cf19 return} cthis;\par
02328         \}\par
02329 \par
02330         {\cf17 const} num_int operator -- ({\cf18 int}) \{\par
02331             num_int & cthis = (*this);\par
02332                         {\cf17 const} num_int cpThis(*{\cf17 this});\par
02333                         {\cf17 const} {\cf18 size_t} long_inic = cthis.size();\par
02334                         {\cf20 // BEGIN TRATAMIENTO DEL 0}\par
02335                         {\cf19 if} (cthis==num_int(vplus,dig(0),dig(0)))\{\par
02336                                 cthis.clear();\par
02337                                 cthis.resize(1);\par
02338                                 cthis[0]=dig(B-1);\par
02339                                 signo = vminus;\par
02340                                 {\cf19 return} cpThis;\par
02341                         \}\par
02342                         {\cf18 bool} es_negativo = (signo==vminus);\par
02343                         {\cf20 // END TRATAMIENTO DEL 0}\par
02344                         {\cf20 // BEGIN TRATAMIENTO DE POTENCIA DE B NEGATIVAS}\par
02345                         {\cf18 bool} es_pot_de_B_neg = {\cf17 false};\par
02346                         {\cf19 if} (es_negativo) \{\par
02347                                 es_pot_de_B_neg = {\cf17 true};\par
02348                                 {\cf19 for}(slint i=0 ; (i < long_inic) and es_pot_de_B_neg ; ++i)\par
02349                                 \{\par
02350                                         es_pot_de_B_neg = es_pot_de_B_neg and (cthis[i]==dig(0));\par
02351                                 \}\par
02352                         \} {\cf20 // Hemos calculado si es potencia de 10 negativa}\par
02353                         {\cf19 if} (es_pot_de_B_neg) \{\par
02354                                 cthis.resize(long_inic+1);\par
02355                                 {\cf19 for}(slint i=0; i < long_inic; ++i)\par
02356                                         cthis[i]=dig(B-1);\par
02357                                 cthis[long_inic] = dig(B-2);\par
02358                                 signo = vminus;\par
02359                                 {\cf19 return} cpThis;\par
02360                         \} {\cf20 // Vemos que -000 pasa a -8999}\par
02361                         {\cf20 // END TRATAMIENTO DE POTENCIA DE B NEGATIVAS}\par
02362                         signo = vplus;\par
02363                         aux=spardigs(vminus,dig(B-1),dig(B-1));\par
02364                         aux+= spardigs(vplus,0,cthis[0]);\par
02365                         cthis[0] = aux.g_uds();\par
02366                         aux.p_uds(aux.g_decs());\par
02367                         aux.p_decs(B-1);\par
02368                         {\cf18 bool} seguir = (aux.g_uds()!=dig(0));\par
02369                         ullint i=1;\par
02370                         {\cf19 while}( seguir and (i<long_inic)) \{\par
02371                                 aux += spardigs(vplus,0,cthis[i]);\par
02372                                 cthis[i]=(aux.g_uds());\par
02373                                 aux.p_uds(aux.g_decs());\par
02374                                 seguir = (aux.g_uds()!=dig(0));\par
02375                                 aux.p_decs(B-1);\par
02376                                 ++i;\par
02377                         \}\par
02378                         {\cf19 if}( seguir and (i >= long_inic) ) \{\par
02379                                 cthis.resize(long_inic+1);\par
02380                                 cthis[i]=aux.g_uds();\par
02381                         \}\par
02382                         signo=(es_negativo?vminus:vplus);\par
02383                         cthis.reduce();\par
02384                         {\cf19 return} cpThis;\par
02385         \}\par
02386 \par
02387 {\cf20                                                                         /******************************/}\par
02388                                                                         {\cf20 /*                                                                      */}\par
02389                                                                         {\cf20 /*         REDUCE                  */}\par
02390                                                                         {\cf20 /*                                                              */}\par
02391 {\cf20                                                                         /******************************/}\par
02392 \par
02393         {\cf17 const} num_int & reduce() \{\par
02394             num_int & cthis = *{\cf17 this};\par
02395                         {\cf17 const} usint nsz = cthis.digs_no_significativos();\par
02396                         {\cf17 const} usint longitud = cthis.size();\par
02397                         {\cf19 if} ((longitud==1)or(longitud==0)) {\cf19 return} cthis;\par
02398                         {\cf17 const} usint pos_p1 = longitud-nsz;\par
02399                         {\cf19 return} cthis.erase(pos_p1,nsz);\par
02400         \}\par
02401 \par
02402         num_int reduce(){\cf17  const }\{\par
02403             {\cf17 const} num_int & cthis = *{\cf17 this};\par
02404             num_int cpyreducida(cthis);\par
02405             {\cf17 const} usint nsz = cpyreducida.digs_no_significativos();\par
02406                         {\cf17 const} usint longitud = cpyreducida.size();\par
02407             {\cf17 const} usint pos = longitud-nsz;\par
02408                         {\cf19 return} cpyreducida.erase(pos,nsz);\par
02409         \}\par
02410 \par
02411                 {\cf17 const} num_int & reduce_fracc() \{\par
02412             num_int & cthis = *{\cf17 this};\par
02413             {\cf17 const} usint nsz = cthis.digs_fracc_no_significativos()-1;\par
02414             {\cf17 const} usint pos = 0;\par
02415             cthis.erase(pos,nsz);\par
02416             {\cf19 return} cthis;\par
02417         \}\par
02418 \par
02419         num_int reduce_fracc(){\cf17  const }\{\par
02420             num_int & cthis = *{\cf17 this};\par
02421             num_int cpyreducida(cthis);\par
02422             {\cf17 const} usint nsz = cpyreducida.digs_no_significativos()-1;\par
02423             {\cf17 const} usint pos = 0;\par
02424             cpyreducida.erase(pos,nsz);\par
02425             {\cf19 return} cpyreducida;\par
02426         \}\par
02427 \par
02428 \par
02429 {\cf20                                                                 /*********************************/}\par
02430                                                                 {\cf20 /*                                                                          */}\par
02431                                                                 {\cf20 /*         ISTREAM Y OSTREAM    */}\par
02432                                                                 {\cf20 /*                                                                          */}\par
02433 {\cf20                                                                 /*********************************/}\par
02434 \par
02435         {\cf17 template}<const uch{\cf18 int} Base>\par
02436         {\cf17 friend}\par
02437         istream & operator >> (istream & is,num_int<Base> & arg) \{\par
02438             {\cf17 enum} estado_e \{e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11\};\par
02439             vector<string> num(255);\par
02440             {\cf18 string} num_sgn;\par
02441             {\cf18 string} num_base;\par
02442             estado_e est_act = e0;\par
02443             uchint i=0;\par
02444             {\cf18 char} c;\par
02445             {\cf19 do} \{\par
02446                 is >> c;\par
02447                 {\cf19 switch} (est_act) \{\par
02448                 {\cf19 case} e0 :\par
02449                     {\cf19 if} (c=={\cf23 'i'}) est_act = e1;\par
02450                     {\cf19 break};\par
02451                 {\cf19 case} e1 :\par
02452                     {\cf19 if} (c=={\cf23 'n'}) est_act = e2;\par
02453                     {\cf19 else} est_act = e0;\par
02454                     {\cf19 break};\par
02455                 {\cf19 case} e2 :\par
02456                     {\cf19 if} (c=={\cf23 't'}) est_act = e3;\par
02457                     {\cf19 else} est_act = e0;\par
02458                     {\cf19 break};\par
02459                 {\cf19 case} e3 :\par
02460                     {\cf19 if} (c=={\cf23 '#'}) est_act = e4;\par
02461                     {\cf19 else} est_act = e0;\par
02462                     {\cf19 break};\par
02463                 {\cf19 case} e4 :\par
02464                     {\cf19 if} ((c=={\cf23 '1'})||(c=={\cf23 '0'})||(c=={\cf23 '-'})||(c=={\cf23 '+'})) \{\par
02465                         est_act = e5;\par
02466                         num_sgn.push_back(c-{\cf23 '0'});\par
02467                     \}\par
02468                     {\cf19 else} est_act = e0;\par
02469                     {\cf19 break};\par
02470                 {\cf19 case} e5 :\par
02471                     {\cf19 if} (c=={\cf23 ':'}) est_act = e6;\par
02472                     {\cf19 else} est_act = e0;\par
02473                     {\cf19 break};\par
02474                 {\cf19 case} e6 :\par
02475                     {\cf19 if} (c=={\cf23 ':'}) est_act = e7;\par
02476                     {\cf19 else} est_act = e0;\par
02477                     {\cf19 break};\par
02478                 {\cf19 case} e7 :\par
02479                     {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) \{\par
02480                         num[i].push_back(c-{\cf23 '0'});\par
02481                     \}\par
02482                     {\cf19 else} {\cf19 if} (c=={\cf23 ':'}) \{\par
02483                         ++i;\par
02484                         est_act = e6;\par
02485                     \}\par
02486                     {\cf19 else} {\cf19 if} (c=={\cf23 '#'}) est_act = e8;\par
02487                     {\cf19 else} est_act=e0;\par
02488                     {\cf19 break};\par
02489                 {\cf19 case} e8 :\par
02490                     {\cf19 if} (c == {\cf23 'B'}) est_act = e9;\par
02491                     {\cf19 else} est_act = e0;\par
02492                     {\cf19 break};\par
02493                 {\cf19 case} e9 :\par
02494                     {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) \{\par
02495                         est_act = e10;\par
02496                         num_base.push_back(c-{\cf23 '0'});\par
02497                     \}\par
02498                     {\cf19 else} est_act = e0;\par
02499                     {\cf19 break};\par
02500                 {\cf19 case} e10 :\par
02501                     {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) \{\par
02502                         num_base.push_back(c-{\cf23 '0'});\par
02503                     \}\par
02504                     {\cf19 else} est_act = e11;\par
02505                     {\cf19 break};\par
02506                 {\cf19 case} e11 :\par
02507                     {\cf19 break};\par
02508                 default :\par
02509                     est_act = e0;\par
02510                 \}\par
02511                 uint numero_base_recogido=0;\par
02512                 {\cf19 if} (est_act==e11) \{\par
02513                     {\cf19 for} (uint k=num_base.size() ; k > 0 ; --k ) \{\par
02514                         numero_base_recogido *= 10;\par
02515                         numero_base_recogido += num_base[k];\par
02516                     \}\par
02517                     numero_base_recogido *= 10;\par
02518                     numero_base_recogido += num_base[0];\par
02519                     {\cf19 if} (numero_base_recogido!=Base) est_act = e0;\par
02520                 \}\par
02521             \} {\cf19 while} ((est_act!=e11)and(c!={\cf23 '\\n'}));\par
02522             basic_string< dig_t<Base> > digito;\par
02523             digito.resize(i+1);\par
02524             {\cf19 for} (uchint j=0 ; j < 256 ; ++j) \{\par
02525                 digito[j]=0;\par
02526                 {\cf19 for} (uint k=num[j].size() ; k > 0 ; --k ) \{\par
02527                     digito[j] *= 10;\par
02528                     digito[j] += (num[j][k]-{\cf23 '0'});\par
02529                 \}\par
02530                 digito[j] *= 10;\par
02531                 digito[j] += (num[j][0]-{\cf23 '0'});\par
02532             \}\par
02533             sign_e sgn;\par
02534             {\cf19 if} ((num_sgn[0]=={\cf23 '1'}) || (num_sgn[0]=={\cf23 '-'})) sgn = vminus;\par
02535             {\cf19 else} sgn = vplus;\par
02536             arg.signo = sgn;\par
02537             arg.lst_digs = digito;\par
02538             arg.aux = spardigs_t<Base>();\par
02539             {\cf19 return} is;\par
02540         \}\par
02541 \par
02542         {\cf17 template}<const uch{\cf18 int} Base>\par
02543         {\cf17 friend}\par
02544         ostream & operator << (ostream & os,num_int<Base> arg) \{\par
02545             {\cf17 const} uchint sz = arg.size();\par
02546             os << {\cf22 "int#"}\par
02547             << ((arg.signo == vplus)?({\cf23 '+'}):({\cf23 '-'}));\par
02548             {\cf19 for} ({\cf18 int} k=sz-1 ; k>-1 ; --k) \{\par
02549                 os << {\cf22 "::"}\par
02550                    << {\cf17 static_cast<}usint{\cf17 >}(arg[k]());\par
02551             \}\par
02552             os <<{\cf22 "#B"}\par
02553             << {\cf17 static_cast<}usint{\cf17 >}(Base) ;\par
02554             {\cf19 return} os;\par
02555         \}\par
02556     \};\par
02557 \par
02558 {\cf21 #endif  }{\cf20 // INT_NUM_T__HPP__INCLUDED}\par
02559 \par
02560 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo int_reg_digs_t.hpp\par \pard\plain 
{\tc\tcl2 \v int_reg_digs_t.hpp}
{\xe \v int_reg_digs_t.hpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "nat_reg_digs_t.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para int_reg_digs_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "int__reg__digs__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "int__reg__digs__t_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
int_reg_digs_t.hpp\par \pard\plain 
{\tc\tcl2 \v int_reg_digs_t.hpp}
{\xe \v int_reg_digs_t.hpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef INT_REG_DIGS_T_HPP}\par
00002 {\cf21 #define INT_REG_DIGS_T_HPP}\par
00003 \par
00004 {\cf21 #include "nat_reg_digs_t.hpp"}\par
00005 \par
00006 {\cf17 namespace }NumRepr \{\par
00007 \par
00008 {\cf17 using }type_traits::allowable_base_type_c;\par
00009 {\cf17 using }type_traits::suitable_base;\par
00010 \par
00011 {\cf17 template}<allowable_base_type_c UINT_T,UINT_T B,{\cf18 size_t} L>\par
00012         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>() && (L>0))\par
00013 {\cf17 struct }int_reg_digs_t : {\cf17 protected} nat_reg_digs_t<UINT_T,B,L> \{\par
00021         {\cf17 using }SIG_UINT_T                = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00022         {\cf17 using }SIG_SINT_T                = {\cf17 typename} type_traits::sig_SInt_for_UInt_t<UINT_T>;\par
00023         {\cf17 using }dig_t                             = dig_t<UINT_T,B>;\par
00024         {\cf17 template}<std::{\cf18 size_t} N>\par
00025                 {\cf17 requires} (N>0)\par
00026         {\cf17 using} base_2_N_t      = std::array<dig_t,N>;\par
00027         {\cf17 using }base_2_t                          = base_2_N_t<L>;\par
00028         {\cf17 template}<std::{\cf18 size_t} N>\par
00029                 {\cf17 requires} (N>0)\par
00030         {\cf17 using} base_N_t                  = nat_reg_digs_t<UINT_T,B,N>;\par
00031         {\cf17 using }base_t            = base_N_t<L>;\par
00032         {\cf17 template}<std::{\cf18 size_t} N>\par
00033                 {\cf17 requires} (N>0)\par
00034         {\cf17 using} int_reg_N_digs_t  = int_reg_digs_t<UINT_T,B,N>;\par
00035 \par
00036         {\cf17 template}<std::{\cf18 size_t} N>\par
00037                 {\cf17 requires} (N>0)\par
00038         {\cf17 using} reg_N_ints_t                    = {\cf17 typename} std::array<UINT_T,N>;\par
00039         {\cf17 template}<std::{\cf18 size_t} N>\par
00040                 {\cf17 requires} (N>0)\par
00041         {\cf17 using} reg_N_ints_t_suints_t     = {\cf17 typename} std::array<SIG_UINT_T,N>;\par
00042         {\cf17 template}<std::{\cf18 size_t} N>\par
00043                 {\cf17 requires} (N>0)\par
00044         {\cf17 using} reg_N_ssints_t                            = {\cf17 typename} std::array<SIG_SINT_T,N>;\par
00045 \par
00046         {\cf17 constexpr} {\cf17 auto} minus           = sign_e::vminus;\par
00047         {\cf17 constexpr} {\cf17 auto} plus              = sign_e::vplus;\par
00048 \par
00049 {\cf17 private}:\par
00050         sign_e signo\{\};\par
00051         base_t magnitud\{\};\par
00052 \par
00053 public :\par
00054 \par
00055         {\cf17 static} {\cf17 constexpr} dig_t                          dig_0()                         noexcept        \{{\cf19 return} dig_t::dig_0();\}\par
00056         {\cf17 static} {\cf17 constexpr} dig_t                          dig_1()                         noexcept        \{{\cf19 return} dig_t::dig_1();\}\par
00057         {\cf17 static} {\cf17 constexpr} dig_t                          dig_Bm1()               noexcept        \{{\cf19 return} dig_t::dig_max();\}\par
00058         {\cf17 static} {\cf17 constexpr} dig_t                          dig_max()                       noexcept        \{{\cf19 return} dig_t::dig_max();\}\par
00059         {\cf17 static} {\cf17 constexpr} dig_t                          dig_Bm2()               noexcept        \{{\cf19 return} dig_t::dig_submax();\}\par
00060         {\cf17 static} {\cf17 constexpr} dig_t                          dig_submax()    noexcept        \{{\cf19 return} dig_t::dig_submax();\}\par
00061         {\cf17 static} {\cf17 constexpr} UINT_T                         ui_0()                          noexcept        \{{\cf19 return} dig_t::ui_0();\}\par
00062         {\cf17 static} {\cf17 constexpr} UINT_T                         ui_1()                          noexcept        \{{\cf19 return} dig_t::ui_1();\}\par
00063         {\cf17 static} {\cf17 constexpr} UINT_T                         ui_Bm1()                        noexcept        \{{\cf19 return} B-1;\}\par
00064         {\cf17 static} {\cf17 constexpr} UINT_T                         ui_B()                  noexcept        \{{\cf19 return} B;\}\par
00065         {\cf17 static} {\cf17 constexpr} UINT_T                         ui_submax()             noexcept        \{{\cf19 return} dig_t::ui_submax();\}\par
00066         {\cf17 static} {\cf17 constexpr} UINT_T                         ui_max()                        noexcept  \{{\cf19 return} dig_t::ui_max();\}\par
00067         {\cf17 static} {\cf17 constexpr} SIG_UINT_T     sui_0()                         noexcept        \{{\cf19 return} dig_t::sui_0();\}\par
00068         {\cf17 static} {\cf17 constexpr} SIG_UINT_T     sui_1()                         noexcept        \{{\cf19 return} dig_t::sui_1();\}\par
00069         {\cf17 static} {\cf17 constexpr} SIG_UINT_T     sui_Bm1()               noexcept        \{{\cf19 return} dig_t::sui_B()-1;\}\par
00070         {\cf17 static} {\cf17 constexpr} SIG_UINT_T     sui_B()                         noexcept  \{{\cf19 return} dig_t::sui_B();\}\par
00071         {\cf17 static} {\cf17 constexpr} SIG_UINT_T     sui_Bp1()               noexcept        \{{\cf19 return} dig_t::sui_B()+1;\}\par
00072 \par
00083 \par
00084         {\cf17 template}<std::{\cf18 size_t} N>\par
00085                 {\cf17 requires} (N>0)\par
00086         {\cf17 static} {\cf17 constexpr} base_2_N_t<N>&&        regd_b2_0()\par
00087         {\cf17 noexcept} \{\par
00088                 {\cf19 return} std::move(base_2_N_t<N>\{dig_0()\});\par
00089         \}\par
00090 \par
00091         {\cf17 template}<std::{\cf18 size_t} N>\par
00092                 {\cf17 requires} (N>0)\par
00093         {\cf17 static} {\cf17 constexpr} base_2_N_t<N>&&        regd_b2_1()\par
00094         {\cf17 noexcept} \{\par
00095                 base_2_N_t<N> ret\{dig_0()\};\par
00096                 ret[0] = dig_1();\par
00097                 {\cf19 return} std::move(ret);\par
00098         \}\par
00099 \par
00100         {\cf17 template}<std::{\cf18 size_t} N>\par
00101                 {\cf17 requires} (N>0)\par
00102         {\cf17 static} {\cf17 constexpr} base_2_N_t<N>&&        regd_b2_Bm1()\par
00103         {\cf17 noexcept} \{\par
00104                 base_2_N_t<N> ret\{regd_b2_0<N>()\};\par
00105                 ret[0] = dig_Bm1();\par
00106                 {\cf19 return} std::move(ret);\par
00107         \}\par
00108 \par
00109         {\cf17 template}<std::{\cf18 size_t} N>\par
00110                 {\cf17 requires} (N>0)\par
00111         {\cf17 static} {\cf17 constexpr} base_2_N_t<N>&&        regd_b2_B()\par
00112         {\cf17 noexcept} \{\par
00113                 base_2_N_t<N> ret\{regd_b2_0<N>()\};\par
00114                 ret[1] = dig_1();\par
00115                 {\cf19 return} std::move(ret);\par
00116         \}\par
00117 \par
00118         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00119                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < N))\par
00120         {\cf17 static} {\cf17 constexpr} base_2_N_t<N>&&        regd_b2_pow_n_B()\par
00121         noexcept \{\par
00122                 base_2_N_t<N> ret\{regd_b2_0<N>()\};\par
00123                 ret[n] = dig_1();\par
00124                 {\cf19 return} std::move(ret);\par
00125         \}\par
00126 \par
00127         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00128                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < L))\par
00129         {\cf17 static} {\cf17 constexpr} base_2_N_t<N>&&        regd_b2_pow_n_B_m1()\par
00130         noexcept        \{\par
00131                 base_2_N_t<N> ret\{dig_Bm1()\};\par
00132                 {\cf19 for}(std::size_t ix\{n\} ; ix < N ; ++ix) \{\par
00133                         ret[ix] = dig_0();\par
00134                 \}\par
00135                 {\cf19 return} std::move(ret);\par
00136         \}\par
00137 \par
00139 \par
00140         {\cf17 template}<std::{\cf18 size_t} N>\par
00141                 {\cf17 requires} (N>0)\par
00142         {\cf17 static} {\cf17 constexpr} base_N_t<N>&&  regd_N_0()\par
00143         {\cf17 noexcept} \{\par
00144                 base_N_t ret\{std::move(regd_b2_0<N>())\};\par
00145                 {\cf19 return} std::move(ret);\par
00146         \}\par
00147 \par
00148         {\cf17 template}<std::{\cf18 size_t} N>\par
00149                 {\cf17 requires} (N>0)\par
00150         {\cf17 static} {\cf17 constexpr} base_N_t<N>&&  regd_N_1()\par
00151         {\cf17 noexcept} \{\par
00152                 base_N_t<N> ret\{std::move(regd_b2_0<N>())\};\par
00153                 ret[0] = dig_1();\par
00154                 {\cf19 return} std::move(ret);\par
00155         \}\par
00156 \par
00157         {\cf17 template}<std::{\cf18 size_t} N>\par
00158                 {\cf17 requires} (N>0)\par
00159         {\cf17 static} {\cf17 constexpr} base_N_t<N>&&  regd_N_Bm1()\par
00160         {\cf17 noexcept} \{\par
00161                 base_N_t<N> ret\{std::move(regd_b2_0<N>())\};\par
00162                 ret[0] = dig_Bm1();\par
00163                 {\cf19 return} std::move(ret);\par
00164         \}\par
00165 \par
00166         {\cf17 template}<std::{\cf18 size_t} N>\par
00167                 {\cf17 requires} (N>0)\par
00168         {\cf17 static} {\cf17 constexpr} base_N_t<N>&&  regd_N_B()\par
00169         {\cf17 noexcept} \{\par
00170                 base_N_t<N> ret\{std::move(regd_b2_0<N>())\};\par
00171                 ret[1] = dig_1();\par
00172                 {\cf19 return} std::move(ret);\par
00173         \}\par
00174 \par
00175         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00176                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < N))\par
00177         {\cf17 static} {\cf17 constexpr} base_N_t<N>&&  regd_N_pow_n_B()\par
00178         noexcept \{\par
00179                 base_N_t<N> ret\{std::move(regd_b2_0<N>())\};\par
00180                 ret[n] = dig_1();\par
00181                 {\cf19 return} std::move(ret);\par
00182         \}\par
00183 \par
00184         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00185                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < L))\par
00186         {\cf17 static} {\cf17 constexpr} base_N_t<N>&&  regd_N_pow_n_B_m1()\par
00187         noexcept        \{\par
00188                 base_N_t<N> ret\{std::move(regd_b2_Bm1<N>())\};\par
00189                 {\cf19 for}(std::size_t ix\{n\} ; ix < N ; ++ix) \{\par
00190                         ret[ix] = dig_0();\par
00191                 \}\par
00192                 {\cf19 return} std::move(ret);\par
00193         \}\par
00195         {\cf17 static} {\cf17 constexpr} base_t&&       regd_0()\par
00196         noexcept \{\par
00197                 {\cf19 return} std::move(regd_N_0<L>());\par
00198         \}\par
00199 \par
00200         {\cf17 static} {\cf17 constexpr} base_t&&       regd_1()\par
00201         noexcept \{\par
00202                 {\cf19 return} std::move(regd_N_1<L>());\par
00203         \}\par
00204 \par
00205         {\cf17 static} {\cf17 constexpr} base_t&&       regd_Bm1()\par
00206         noexcept \{\par
00207                 {\cf19 return} std::move(regd_N_Bm1<L>());\par
00208         \}\par
00209 \par
00210         {\cf17 static} {\cf17 constexpr} base_t&&       regd_B()\par
00211         noexcept \{\par
00212                 {\cf19 return} std::move(regd_N_B<L>());\par
00213         \}\par
00214 \par
00215         {\cf17 template}<std::{\cf18 size_t} n>\par
00216                 {\cf17 requires} ((n >= 0)&&(n < L))\par
00217         {\cf17 static} {\cf17 constexpr} base_t&&       regd_pow_n_B()\par
00218         {\cf17 noexcept} \{\par
00219                 {\cf19 return} std::move(regd_N_pow_n_B<L,n>());\par
00220         \}\par
00221 \par
00222         {\cf17 template}<std::{\cf18 size_t} n>\par
00223                 {\cf17 requires} ((n >= 0)&&(n < L))\par
00224         {\cf17 static} {\cf17 constexpr} base_t&&       regd_pow_n_B_m1()\par
00225         {\cf17 noexcept}        \{\par
00226                 {\cf19 return} std::move(regd_N_pow_n_B_m1<L,n>());\par
00227         \}\par
00228 \par
00231 \par
00232         {\cf17 template}<std::{\cf18 size_t} N>\par
00233                 {\cf17 requires} (N>0)\par
00234         {\cf17 constexpr} {\cf17 inline}\par
00235         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&  sregd_N_0()\par
00236         {\cf17 noexcept} \{\par
00237                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{signo\{vplus\},magnitud\{regd_0<N>()\}\});\par
00238         \}\par
00239 \par
00240         {\cf17 constexpr} {\cf17 inline}\par
00241         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&&       sregd_0()\par
00242         noexcept \{\par
00243                 {\cf19 return} std::move(sregd_N_0<L>());\par
00244         \}\par
00245 \par
00246         {\cf17 template}<std::{\cf18 size_t} N>\par
00247                 {\cf17 requires} (N>0)\par
00248         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&  sregd_N_1()\par
00249         {\cf17 noexcept} \{\par
00250                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{signo\{vplus\},magnitud\{regd_1()<N>()\}\});\par
00251         \}\par
00252 \par
00253         {\cf17 constexpr} {\cf17 inline}\par
00254         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&&       sregd_1()\par
00255         noexcept \{\par
00256                 {\cf19 return} std::move(sregd_N_1()<L>());\par
00257         \}\par
00258 \par
00259         {\cf17 template}<std::{\cf18 size_t} N>\par
00260                 {\cf17 requires} (N>0)\par
00261         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&  sregd_N_m1()\par
00262         {\cf17 noexcept} \{\par
00263                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{signo\{vminus\},magnitud\{dig_Bm1()\}\});\par
00264         \}\par
00265 \par
00266         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&&       sregd_m1()\par
00267         noexcept \{\par
00268                 {\cf19 return} std::move(sregd_N_m1<L>);\par
00269         \}\par
00270 \par
00271         {\cf17 template}<std::{\cf18 size_t} N>\par
00272                 {\cf17 requires} (N>0)\par
00273         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&  sregd_N_Bm1()\par
00274         {\cf17 noexcept} \{\par
00275                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{signo\{vplus\},magnitud\{regd_N_Bm1<N>()\}\});\par
00276         \}\par
00277 \par
00278         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&&       sregd_Bm1()\par
00279         noexcept \{\par
00280                 {\cf19 return} std::move(sregd_N_Bm1<L>());\par
00281         \}\par
00285         {\cf17 template}<std::{\cf18 size_t} N>\par
00286                 {\cf17 requires} (N>0)\par
00287         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&  sregd_N_mBp1()\par
00288         {\cf17 noexcept} \{\par
00289                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{\par
00290                         signo\{vminus\},\par
00291                         magnitud\{\par
00292                                 std::move(\par
00293                                         concatenate_homogeneus_containers<dig_t,N-1,1>()\par
00294                                         nat_reg_digs_t<UINT_T,B,N-1>\{dig_Bm1()\}.concat(nat_reg_digs_t<UINT_T,B,1>\{dig_1()\})\par
00295                                 )\par
00296                         \}\par
00297                 \}\par
00298                 );\par
00299         \}\par
00300 \par
00301         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&&       sregd_mBp1()\par
00302         noexcept \{\par
00303                 {\cf19 return} std::move(sregd_N_mBp1<L>());\par
00304         \}\par
00305 \par
00306         {\cf17 template}<std::{\cf18 size_t} N>\par
00307                 {\cf17 requires} (N>0)\par
00308         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&& sregd_N_B()\par
00309         {\cf17 noexcept} \{\par
00310                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{\par
00311                         signo\{vplus\},\par
00312                         magnitud\{std::move((regd_0<N-1>().concat(regd_1<1>())).concat(regd_0<1>())\})\par
00313                 \});\par
00314         \}\par
00315 \par
00316         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&& sregd_B()\par
00317         noexcept \{\par
00318                 {\cf19 return} std::move(sregd_N_B<L>());\par
00319         \}\par
00320 \par
00323 \par
00324         {\cf17 template}<std::{\cf18 size_t} N>\par
00325                 {\cf17 requires} (N>0)\par
00326         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&& sregd_N_mB()\par
00327         {\cf17 noexcept} \{\par
00328                 {\cf19 return} std::move(int_reg_N_digs_t<N>\{\par
00329                         signo\{vminus\},\par
00330                         magnitud\{std::move(\par
00331                                 std::array<dig_t,N-1>(dig_Bm1()).concat(std::array<dig_t,1>(dig_0()))\par
00332                         )\}\par
00333                 \});\par
00334         \}\par
00335 \par
00336         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&& sregd_mB()\par
00337         noexcept \{\par
00338                 {\cf19 return} std::move(sregd_N_mB<L>());\par
00339         \}\par
00340 \par
00342 \par
00343         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00344                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < N))\par
00345         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&& sregd_pow_n_B()\par
00346         noexcept \{\par
00347                 int_reg_N_digs_t<N> ret\{\};\par
00348                 ret.signo = sign_e::vplus;\par
00349                 ret.magnitud = regd_0();\par
00350                 ret.magnitud[n] = dig_1();\par
00351                 {\cf19 return} std::move(ret);\par
00352         \}\par
00353 \par
00354         {\cf17 template}<std::{\cf18 size_t} n>\par
00355                 {\cf17 requires} ((n >= 0)&&(n < L))\par
00356         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&& sregd_pow_n_B(){\cf17 noexcept} \{\par
00357                 int_reg_digs_t ret\{\};\par
00358                 ret.signo = sign_e::vplus;\par
00359                 ret.magnitud = regd_0<L>();\par
00360                 ret.magnitud[n] = dig_1();\par
00361                 {\cf19 return} std::move(ret);\par
00362         \}\par
00363 \par
00364         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00365                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < N))\par
00366         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&& sregd_m_pow_n_B()noexcept \{\par
00367                 int_reg_N_digs_t<N> ret\{\};\par
00368                 ret.signo = sign_e::vminus;\par
00369                 ret.magnitud = regd_Bm1();\par
00370                 {\cf19 for}(std::size_t ix\{0\} ; ix < n-1 ; ++ix)\par
00371                         ret.magnitud[ix] = dig_0();\par
00372                 {\cf19 return} std::move(ret);\par
00373         \}\par
00374 \par
00375         {\cf17 template}<std::{\cf18 size_t} n>\par
00376                 {\cf17 requires} ((n >= 0)&&(n < L))\par
00377         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&& sregd_m_pow_n_B(){\cf17 noexcept} \{\par
00378                 int_reg_digs_t ret\{\};\par
00379                 ret.signo = sign_e::vminus;\par
00380                 ret.magnitud = regd_Bm1<L>();\par
00381                 {\cf19 for}(std::size_t ix\{0\} ; ix < n-1 ; ++ix)\par
00382                         ret.magnitud[ix] = dig_0();\par
00383                 {\cf19 return} std::move(ret);\par
00384         \}\par
00385 \par
00386         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00387                 {\cf17 requires} ((N > 0) && (n >= 0) && (n < N))\par
00388         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&sregd_pow_n_B_m1()noexcept        \{\par
00389                 int_reg_N_digs_t<N> ret\{\};\par
00390                 ret.signo = sign_e::vplus;\par
00391                 {\cf19 for}(std::size_t ix\{0\} ; ix < n ; ++ix) \{\par
00392                         ret.magnitud[ix] = dig_0();\par
00393                 \}\par
00394                 {\cf19 for}(std::size_t ix\{n\} ; ix < N ; ++ix) \{\par
00395                         ret.magnitud[ix] = dig_Bm1();\par
00396                 \}\par
00397                 {\cf19 return} std::move(ret);\par
00398         \}\par
00399 \par
00400         {\cf17 template}<std::{\cf18 size_t} n>\par
00401                 {\cf17 requires} ((n >= 0) && (n < L))\par
00402         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&&sregd_pow_n_B_m1(){\cf17 noexcept}     \{\par
00403                 int_reg_digs_t ret\{\};\par
00404                 ret.signo = sign_e::vplus;\par
00405                 {\cf19 for}(std::size_t ix\{0\} ; ix < n ; ++ix) \{\par
00406                         ret.magnitud[ix] = dig_0();\par
00407                 \}\par
00408                 {\cf19 for}(std::size_t ix\{n\} ; ix < L ; ++ix) \{\par
00409                         ret.magnitud[ix] = dig_Bm1();\par
00410                 \}\par
00411                 {\cf19 return} std::move(ret);\par
00412         \}\par
00413 \par
00414         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00415                 {\cf17 requires} ((N > 0) && (n >= 0) && (n < N))\par
00416         {\cf17 static} {\cf17 constexpr} int_reg_N_digs_t<N>&&sregd_m_pow_n_B_m1()noexcept      \{\par
00417                 int_reg_N_digs_t<N> ret\{\};\par
00418                 ret.signo = sign_e::vminus;\par
00419                 ret.magnitud = regd_0();\par
00420                 ret.magnitud[n] = dig_1();\par
00421                 {\cf19 return} std::move(ret);\par
00422         \}\par
00423 \par
00424         {\cf17 template}<std::{\cf18 size_t} n>\par
00425                 {\cf17 requires} ((n >= 0) && (n < L))\par
00426         {\cf17 static} {\cf17 constexpr} int_reg_digs_t&& sregd_m_pow_n_B_m1(){\cf17 noexcept}  \{\par
00427                 int_reg_digs_t ret\{\};\par
00428                 ret.signo = sign_e::vminus;\par
00429                 ret.magnitud = regd_0<L>();\par
00430                 ret.magnitud[n] = dig_1();\par
00431                 {\cf19 return} std::move(ret);\par
00432         \}\par
00433 \par
00435         {\cf17 template}<std::{\cf18 size_t} N>\par
00436                 {\cf17 requires} (N>0)\par
00437         {\cf17 static} {\cf17 constexpr} reg_ints_t<N>&&        regi_0()                                                {\cf17 noexcept}        \{\par
00438                 reg_ints_t<N> ret\{\};\par
00439                 {\cf19 for}({\cf17 auto}& digint : ret) \{\par
00440                         digint = dig_0()();\par
00441                 \}\par
00442                 {\cf19 return} std::move(ret);\par
00443         \}\par
00444 \par
00445         {\cf17 template}<std::{\cf18 size_t} N>\par
00446                 {\cf17 requires} (N>0)\par
00447         {\cf17 static} {\cf17 constexpr} reg_ints_t<N>&& regi_1()                                       {\cf17 noexcept}        \{\par
00448                 reg_ints_t<N> ret\{regi_0()\};\par
00449                 ret[0] = dig_1()();\par
00450                 {\cf19 return} std::move(ret);\par
00451         \}\par
00452 \par
00453         {\cf17 template}<std::{\cf18 size_t} N>\par
00454                 {\cf17 requires} (N>0)\par
00455         {\cf17 static} {\cf17 constexpr} reg_ints_t<N>&&        regi_Bm1()                              {\cf17 noexcept}        \{\par
00456                 reg_ints_t<N> ret\{regi_0()\};\par
00457                 ret[0] = dig_Bm1()();\par
00458                 {\cf19 return} std::move(ret);\par
00459         \}\par
00460 \par
00461         {\cf17 template}<std::{\cf18 size_t} N>\par
00462                 {\cf17 requires} (N>0)\par
00463         {\cf17 static} {\cf17 constexpr} reg_ints_t<N>&&        regi_B()                                        {\cf17 noexcept}  \{\par
00464                 reg_ints_t<N> ret\{regi_0()\};\par
00465                 ret[1] = dig_1()();\par
00466                 {\cf19 return} std::move(ret);\par
00467         \}\par
00468 \par
00469         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00470                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < N))\par
00471         {\cf17 static} {\cf17 constexpr} reg_ints_t<N>&&        regi_pow_n_B()          noexcept        \{\par
00472                 reg_ints_t<N> ret\{regi_0()\};\par
00473                 ret[n] = dig_1()();\par
00474                 {\cf19 return} std::move(ret);\par
00475         \}\par
00476 \par
00477         {\cf17 template}<std::{\cf18 size_t} N,std::{\cf18 size_t} n>\par
00478                 {\cf17 requires} ((N > 0)&&(n >= 0)&&(n < N))\par
00479         {\cf17 static} {\cf17 constexpr} reg_ints_t<L>&&        regi_pow_n_B_m1()       noexcept        \{\par
00480                 reg_ints_t<N> ret\{\};\par
00481                 {\cf19 for}(std::size_t ix\{0\} ; ix < n ; ++ix) \{\par
00482                         ret[ix] = dig_t(B-1)();\par
00483                 \}\par
00484                 {\cf19 for}(std::size_t ix\{n\} ; ix < N ; ++ix) \{\par
00485                         ret[ix] = dig_t(0)();\par
00486                 \}\par
00487                 {\cf19 return} std::move(ret);\par
00488         \}\par
00489 \par
00490 {\cf20                                 /****************************/}\par
00491                                 {\cf20 /*                                                                                                      */}\par
00492                                 {\cf20 /*    CONSTRUIR NUMERO                  */}\par
00493                                 {\cf20 /*                                                                                                      */}\par
00494 {\cf20                                 /****************************/}\par
00495 {\cf17 public}:\par
00496 \par
00498         {\cf17 consteval} {\cf17 inline}\par
00499         int_reg_digs_t()\par
00500         noexcept : signo\{sign_e::vplus\}, magnitud\{std::move(sregd_0<L>())\} \{\}\par
00502         {\cf17 constexpr} {\cf17 inline}\par
00503         int_reg_digs_t(sign_e arg_sign,{\cf17 const} std::initializer_list<dig_t> & arg)\par
00504         noexcept : signo\{arg_sign\},magnitud\{arg\} \{\}\par
00506         {\cf17 template}<{\cf17 typename} ... Ts>\par
00507                 {\cf17 requires} (std::is_same_v<Ts,dig_t>&&...)\par
00508         {\cf17 constexpr} {\cf17 inline}\par
00509         int_reg_digs_t(sign_e arg_sign,{\cf17 const} Ts &... args)\par
00510         noexcept : signo\{arg_sign\}, magnitud\{(utility::pack2array<Ts...>\{\})(args...)\} \{\}\par
00512 \par
00515         {\cf17 template}<std::{\cf18 size_t} N>\par
00516                 {\cf17 requires} (N>0)\par
00517         {\cf18 void} copy_arg_N({\cf17 const} base_N_t<N> & arg) \{\par
00518                 {\cf19 if} {\cf17 constexpr} (N<L) \{\par
00519                         {\cf19 for}(std::size_t ix\{N\} ; ix < L ; ++ix)\par
00520                                 magnitud[ix]=dig_0();\par
00521                         {\cf19 for}(std::size_t ix\{0\} ; ix < N ; ++ix)\par
00522                                 magnitud[ix]=arg[ix];\par
00523                 \}\par
00524                 {\cf19 else} \{\par
00525                         {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix)\par
00526                                 magnitud[ix]=arg[ix];\par
00527                 \}\par
00528         \}\par
00529 \par
00532         {\cf17 template}<std::{\cf18 size_t} N>\par
00533                 {\cf17 requires} (N>0)\par
00534         {\cf18 void} move_arg_N(base_N_t<N>&& arg) \{\par
00535                 {\cf19 if} {\cf17 constexpr} (N<L) \{\par
00536                         {\cf19 for}(std::size_t ix\{N\} ; ix < L ; ++ix)\par
00537                                 magnitud[ix]=std::move(dig_0());\par
00538                         {\cf19 for}(std::size_t ix\{0\} ; ix < N ; ++ix)\par
00539                                 magnitud[ix]=std::move(arg[ix]);\par
00540                 \}\par
00541                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (N > L) \{\par
00542                         {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix)\par
00543                                 magnitud[ix]=std::move(arg[ix]);\par
00544                 \}\par
00545                 {\cf19 else} \{\par
00546                         magnitud=std::move(arg);\par
00547                 \}\par
00548         \}\par
00550         {\cf17 template}<std::{\cf18 size_t} N>\par
00551                 {\cf17 requires} (N>0)\par
00552         {\cf17 constexpr} {\cf17 inline}\par
00553         int_reg_digs_t(sign_e argsign,{\cf17 const} base_N_t<N> & arg)\par
00554         noexcept : signo\{argsign\},magnitud\{copy_arg_N<N>(arg)\} \{\}\par
00556         {\cf17 template}<std::{\cf18 size_t} N>\par
00557                 {\cf17 requires} (N>0)\par
00558         {\cf17 constexpr} {\cf17 inline}\par
00559         int_reg_digs_t(sign_e argsign,{\cf17 const} base_N_t<N> && arg)\par
00560         noexcept : signo\{argsign\}, magnitud\{move_arg_N<N>(arg)\} \{\}\par
00564         {\cf17 template}<type_traits::integral_c ... Ints_type>\par
00565                 {\cf17 requires} (({\cf17 sizeof}...(Ints_type))<=L)\par
00566         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00567         base_t normalize(Ints_type ... digits_pow_i)\par
00568         {\cf17 noexcept} \{\par
00569                 {\cf17 using }pack_type         = {\cf17 typename} utility::pack2array<Ints_type...>;\par
00570                 {\cf17 using }unique_type = {\cf17 typename} pack_type::elem_type;\par
00571                 {\cf17 constexpr} std::size_t pack_sz\{pack_type::pack_size()\};\par
00572                 {\cf19 if} {\cf17 constexpr} ( type_traits::unsigned_integral_c<unique_type> ) \{\par
00573                         {\cf19 if} {\cf17 constexpr} (type_traits::is_unsigned_sz_gt_v<UINT_T,unique_type>) \{\par
00574                                         {\cf17 using }SUInt_type = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00575                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00576                                         base_t ret\{\};\par
00577                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00578                                                 ret[ix] = dig_t(ret_array[ix]);\par
00579                                         \}\par
00580                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00581                                                 ret[ix] = dig_0();\par
00582                                         \}\par
00583                                         {\cf19 return} ret;\par
00584                         \}\par
00585                         {\cf19 else} \{\par
00586                                         {\cf17 using }SUInt_type = type_traits::sig_UInt_for_UInt_t<unique_type>;\par
00587                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00588                                         base_t ret\{\};\par
00589                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00590                                                 ret[ix] = dig_t(ret_array[ix]);\par
00591                                         \}\par
00592                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00593                                                 ret[ix] = dig_t(0);\par
00594                                         \}\par
00595                                         {\cf19 return} ret;\par
00596                         \}\par
00597                 \}\par
00598                 {\cf19 else} \{\par
00599                         {\cf17 using }temp_SUInt_type = type_traits::sig_UInt_for_SInt_t<unique_type>;\par
00600                         {\cf19 if} {\cf17 constexpr} (type_traits::is_unsigned_sz_gt_v<UINT_T,temp_SUInt_type>)\par
00601                         \{\par
00602                                         {\cf17 using }SUInt_type = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00603                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00604                                         base_t ret\{\};\par
00605                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00606                                                 {\cf19 if} (ret_array[ix] < 0)\par
00607                                                         ret[ix] = dig_t((((ret_array[ix]/(-B))+1)*B)+ret_array[ix]);\par
00608                                                 {\cf19 else}\par
00609                                                         ret[ix] = dig_t(ret_array[ix]);\par
00610                                         \}\par
00611                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00612                                                 ret[ix] = dig_0();\par
00613                                         \}\par
00614                                         {\cf19 return} ret;\par
00615                         \}\par
00616                         {\cf19 else} \{\par
00617                                         {\cf17 using }SUInt_type = temp_SUInt_type;\par
00618                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00619                                         base_t ret\{\};\par
00620                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00621                                                 {\cf19 if} (ret_array[ix] < 0)\par
00622                                                         ret[ix] = dig_t((((ret_array[ix]/(-B))+1)*B)+ret_array[ix]);\par
00623                                                 {\cf19 else}\par
00624                                                         ret[ix] = dig_t(ret_array[ix]);\par
00625                                         \}\par
00626                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00627                                                 ret[ix] = dig_0();\par
00628                                         \}\par
00629                                         {\cf19 return} ret;\par
00630                         \}\par
00631                 \}\par
00632         \}\par
00634         {\cf17 template}<type_traits::integral_c ... Ints_type>\par
00635         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t(sign_e argsign, Ints_type ... dig_pow_i) noexcept :\par
00636                 signo\{sign_e::argsign\},magnitud\{normalize<Ints_type...>(dig_pow_i...)\} \{\}\par
00638         {\cf17 template}<std::{\cf18 size_t} N>\par
00639                 {\cf17 requires} (N>0)\par
00640         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t({\cf17 const} int_reg_N_digs_t<N> & arg) noexcept :\par
00641                 signo\{arg.signo\},magnitud\{copy_arg_N<N>(arg.magnitud)\} \{\}\par
00643         {\cf17 template}<std::{\cf18 size_t} N>\par
00644                 {\cf17 requires} (N>0)\par
00645         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t(int_reg_N_digs_t<N> && arg) noexcept :\par
00646                 signo\{std::move(arg.signo)\},magnituditud\{move_arg_N(arg.magnitud)\} \{\}\par
00647 \par
00649         {\cf17 template}<std::{\cf18 size_t} N>\par
00650                 {\cf17 requires} (N>0)\par
00651         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t & {\cf17 operator} = (int_reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
00652         \{\par
00653                 {\cf19 if} ({\cf17 this} != &arg) \{\par
00654                         copy_arg_N<N>(arg.m_dc);\par
00655                 \}\par
00656                 {\cf19 return} (*{\cf17 this});\par
00657         \}\par
00659         {\cf17 template}<std::{\cf18 size_t} N>\par
00660                 {\cf17 requires} (N>0)\par
00661         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t & {\cf17 operator} = (int_reg_N_digs_t<N> && arg) {\cf17 noexcept}\par
00662         \{\par
00663                 {\cf19 if} ({\cf17 this} != &arg) \{\par
00664                         move_arg_N<N>(arg.m_dc);\par
00665                 \}\par
00666                 {\cf19 return} (*{\cf17 this});\par
00667         \}\par
00669         {\cf17 template}<std::{\cf18 size_t} N>\par
00670                 {\cf17 requires} (N>0)\par
00671         {\cf17 constexpr} {\cf17 inline} {\cf17 const} int_reg_digs_t & {\cf17 operator} = ({\cf17 const} int_reg_N_digs_t<N> & arg)\par
00672         {\cf17 noexcept} \{\par
00673                 {\cf19 if} ({\cf17 this} != arg) \{\par
00674                                 copy_arg_N<N>(arg.m_dc);\par
00675                 \}\par
00676                 {\cf19 return} (*{\cf17 this});\par
00677         \}\par
00679         {\cf17 template}<std::{\cf18 size_t} N>\par
00680                 {\cf17 requires} (N>0)\par
00681         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t & {\cf17 operator} = ({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept}\par
00682         \{\par
00683                 {\cf19 if} (&(this->m_dc)!=(&arg))\par
00684                         copy_arg_N<N>(arg);\par
00685                 {\cf19 return} (*{\cf17 this});\par
00686         \}\par
00688         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t & operator = ({\cf17 const} dig_t & arg) {\cf17 noexcept} \{\par
00689                 {\cf19 if} (&(this->m_dc[0])!=(&arg)) \{\par
00690                         {\cf19 for} (dig_t& dig : m_dc)\par
00691                                 dig = dig_0();\par
00692                         m_dc[0] = arg;\par
00693                 \}\par
00694                 {\cf19 return} (*{\cf17 this});\par
00695         \}\par
00697         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00698         {\cf17 constexpr} {\cf17 inline} int_reg_digs_t & operator = (Int_Type&& arg) {\cf17 noexcept} \{\par
00699                 Int_Type creg_g\{std::forward(arg)\};\par
00700                 {\cf19 if} ((&(this->m_dc()))!=(&arg)) \{\par
00701                         uint128_t BasePowIx\{1\};\par
00702                         {\cf19 for}(std::size_t k\{0u\} ; k < L ; ++k) \{\par
00703                                 BasePowIx *= B;\par
00704                         \}\par
00705                         {\cf19 while} (creg_g < 0) \{\par
00706                                 creg_g += BasePowIx;\par
00707                         \}\par
00708                         {\cf19 for}(std::size_t k\{0u\} ; k < L ; ++k)\{\par
00709                                 m_dc[k] = dig_t(creg_g);\par
00710                                 creg_g /= B;\par
00711                         \}\par
00712                 \}\par
00713                 {\cf19 return} (*{\cf17 this});\par
00714         \}\par
00715 \par
00720 \par
00721         {\cf17 template}<std::{\cf18 size_t} N>\par
00722                 {\cf17 requires} (N>0)\par
00723         {\cf17 constexpr} {\cf17 inline}\par
00724         int_reg_N_digs_t<N+L> concat({\cf17 const} int_reg_N_digs_t<N> & arg) {\cf17 const}\par
00725         {\cf17 noexcept} \{\par
00726                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00727                 int_reg_N_digs_t<N+L> ret\{\};\par
00728                 {\cf19 for}(std::size_t ix\{0\} ; ix < N ; ++ix) \{\par
00729                         ret[ix] = arg[ix];\par
00730                 \}\par
00731                 {\cf19 for}(std::size_t ix\{N\} ; ix < L+N ; ++ix) \{\par
00732                         ret[ix] = cthis[ix-N];\par
00733                 \}\par
00734                 {\cf19 return} ret;\par
00735         \}\par
00736         {\cf17 constexpr} {\cf17 inline}\par
00737         int_reg_N_digs_t<L+1> concat({\cf17 const} dig_t & arg) {\cf17 const}\par
00738         {\cf17 noexcept} \{\par
00739                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00740                 int_reg_N_digs_t<L+1> ret\{\};\par
00741                 ret[0] = arg;\par
00742                 {\cf19 for}(std::size_t ix\{1\} ; ix < L+1 ; ++ix) \{\par
00743                         ret[ix] = cthis[ix-1];\par
00744                 \}\par
00745                 {\cf19 return} ret;\par
00746         \}\par
00747         {\cf17 template}<std::{\cf18 size_t} N>\par
00748                 {\cf17 requires} (N>0)\par
00749         {\cf17 constexpr} {\cf17 inline}\par
00750         int_reg_N_digs_t<N+L> concat_inv({\cf17 const} int_reg_N_digs_t<N> & arg) {\cf17 const}\par
00751         {\cf17 noexcept} \{\par
00752                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00753                 int_reg_N_digs_t<N+L> ret\{\};\par
00754                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
00755                         ret[ix] = cthis[ix];\par
00756                 \}\par
00757                 {\cf19 for}(std::size_t ix\{L\} ; ix < N+L ; ++ix) \{\par
00758                         ret[ix] = arg[ix-L];\par
00759                 \}\par
00760                 {\cf19 return} ret;\par
00761         \}\par
00762         {\cf17 constexpr} {\cf17 inline}\par
00763         int_reg_N_digs_t<L+1> concat_inv({\cf17 const} dig_t & arg) {\cf17 const}\par
00764         {\cf17 noexcept} \{\par
00765                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00766                 int_reg_N_digs_t<L+1> ret\{\};\par
00767                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
00768                         ret[ix] = cthis[ix];\par
00769                 \}\par
00770                 ret[L] = arg;\par
00771                 {\cf19 return} ret;\par
00772         \}\par
00773 \par
00774 \par
00775         {\cf17 template}<std::{\cf18 size_t} N>\par
00776                 {\cf17 requires} (N>0)\par
00777         {\cf17 constexpr} {\cf17 inline}\par
00778         int_reg_N_digs_t<N+L> concat(int_reg_N_digs_t<N> && arg)\par
00779         {\cf17 noexcept} \{\par
00780                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00781                 int_reg_N_digs_t<N+L> ret\{\};\par
00782                 {\cf19 for}(std::size_t ix\{0\} ; ix < N ; ++ix) \{\par
00783                         ret[ix] = std::move(arg[ix]);\par
00784                 \}\par
00785                 {\cf19 for}(std::size_t ix\{N\} ; ix < L+N ; ++ix) \{\par
00786                         ret[ix] = cthis[ix-N];\par
00787                 \}\par
00788                 {\cf19 return} ret;\par
00789         \}\par
00790         {\cf17 constexpr} {\cf17 inline}\par
00791         int_reg_N_digs_t<L+1> concat(dig_t && arg)\par
00792         {\cf17 noexcept} \{\par
00793                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00794                 int_reg_N_digs_t<L+1> ret\{\};\par
00795                 ret[0] = std::move(arg);\par
00796                 {\cf19 for}(std::size_t ix\{1\} ; ix < L+1 ; ++ix) \{\par
00797                         ret[ix] = cthis[ix-1];\par
00798                 \}\par
00799                 {\cf19 return} ret;\par
00800         \}\par
00801 \par
00802         {\cf17 template}<std::{\cf18 size_t} N>\par
00803                 {\cf17 requires} (N>0)\par
00804         {\cf17 constexpr} {\cf17 inline}\par
00805         int_reg_N_digs_t<N+L> concat_inv(int_reg_N_digs_t<N> && arg)\par
00806         {\cf17 noexcept} \{\par
00807                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00808                 int_reg_N_digs_t<N+L> ret\{\};\par
00809                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
00810                         ret[ix] = cthis[ix];\par
00811                 \}\par
00812                 {\cf19 for}(std::size_t ix\{L\} ; ix < N+L ; ++ix) \{\par
00813                         ret[ix] = std::move(arg[ix-L]);\par
00814                 \}\par
00815                 {\cf19 return} ret;\par
00816         \}\par
00817         {\cf17 constexpr} {\cf17 inline}\par
00818         int_reg_N_digs_t<L+1> concat_inv(dig_t && arg)\par
00819         {\cf17 noexcept} \{\par
00820                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00821                 int_reg_N_digs_t<L+1> ret\{\};\par
00822                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
00823                         ret[ix] = cthis[ix];\par
00824                 \}\par
00825                 ret[L] = std::move(arg);\par
00826                 {\cf19 return} ret;\par
00827         \}\par
00828 \par
00829         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00830                 {\cf17 requires} ((iend <= L)&&(ibegin < iend))\par
00831         {\cf17 constexpr} {\cf17 inline}\par
00832         int_reg_N_digs_t<iend-ibegin> subreg_digs() {\cf17 const}\par
00833         {\cf17 noexcept} \{\par
00834                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00835                 int_reg_N_digs_t<iend-ibegin> ret\{\};\par
00836                 {\cf19 for}(std::size_t ix\{ibegin\} ; ix < iend ; ++ix) \{\par
00837                         ret[ix-ibegin] = cthis[ix];\par
00838                 \}\par
00839                 {\cf19 return} ret;\par
00840         \}\par
00841         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00842                 {\cf17 requires} ((iend-ibegin>0)&&(iend <= L)&&(ibegin < iend))\par
00843         {\cf17 constexpr} {\cf17 inline}\par
00844         int_reg_N_digs_t<iend-ibegin> rev_subreg_digs() const\par
00845         noexcept \{\par
00846                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
00847                 int_reg_N_digs_t<iend-ibegin> ret\{\};\par
00848                 {\cf19 for}(std::int64_t ix\{iend\} ; ix > ibegin-1 ; --ix) \{\par
00849                         ret[ix-ibegin] = cthis[L-1-ix];\par
00850                 \}\par
00851                 {\cf19 return} ret;\par
00852         \}\par
00853 \par
00854 {\cf20                                 /**********************************/}\par
00855                                 {\cf20 /*                                                                                                      */}\par
00856                                 {\cf20 /*       Algunas Conversiones     */}\par
00857                                 {\cf20 /*                                                                                                      */}\par
00858 {\cf20                                 /**********************************/}\par
00859 \par
00860         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00861         {\cf17 constexpr} {\cf17 inline} {\cf17 operator} Int_Type() const noexcept \{\par
00862                 std::uint64_t retInt\{0\};\par
00863                 std::uint64_t BasePowIx\{1\};\par
00864                 {\cf19 for}(std::size_t k\{0\} ; k < L ; ++k) \{\par
00865                         retInt += m_dc[k]*BasePowIx;\par
00866                         BasePowIx *= B;\par
00867                 \}\par
00868                 {\cf19 return} (retInt);\par
00869         \}\par
00870 \par
00871 {\cf20                                 /********************************/}\par
00872                                 {\cf20 /*                                                                                                      */}\par
00873                                 {\cf20 /* OPERADORES COMPARATIVOS                      */}\par
00874                                 {\cf20 /*                                                                                                      */}\par
00875 {\cf20                                 /********************************/}\par
00876 \par
00877         {\cf17 template}<std::{\cf18 size_t} N>\par
00878                 {\cf17 requires} (N>0)\par
00879         {\cf17 constexpr} {\cf17 inline}\par
00880         {\cf18 bool} {\cf17 operator} == ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
00881         {\cf17 noexcept} \{\par
00884                 {\cf19 if} {\cf17 constexpr} (N>L) \{\par
00885                         {\cf19 for}(std::size_t k\{L\} ; k < N ; ++k) \{\par
00886                                 {\cf19 if} (!(arg[k].is_0())) \{\par
00887                                         {\cf19 return} {\cf17 false};\par
00888                                 \}\par
00889                         \}\par
00890                 \}\par
00893                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (L>N) \{\par
00894                         {\cf19 for}(std::size_t k\{N\} ; k < L ; ++k) \{\par
00895                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
00896                                         {\cf19 return} {\cf17 false};\par
00897                                 \}\par
00898                         \}\par
00899                 \}\par
00900                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(L,N)\};\par
00901                 {\cf19 for}(std::size_t k\{0\} ; k < Z ; ++k) \{\par
00902                                 {\cf19 if} (m_dc[k]!=arg.m_dc[k])\par
00903                                         {\cf19 return} {\cf17 false};\par
00904                 \}\par
00905                 {\cf19 return} {\cf17 true};\par
00906         \}\par
00907 \par
00908         {\cf17 template}<std::{\cf18 size_t} N>\par
00909                 {\cf17 requires} (N>0)\par
00910         {\cf17 constexpr} {\cf17 inline}\par
00911         {\cf18 bool} {\cf17 operator} != ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
00912         {\cf17 noexcept} \{\par
00913                 {\cf19 if} {\cf17 constexpr} (N>L) \{\par
00914                         {\cf19 for}(std::size_t k\{L\} ; k < N ; ++k) \{\par
00915                                 {\cf19 if} (!(arg[k].is_0())) \{\par
00916                                         {\cf19 return} {\cf17 true};\par
00917                                 \}\par
00918                         \}\par
00919                 \}\par
00920                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (L>N) \{\par
00921                         {\cf19 for}(std::size_t k\{N\} ; k < L ; ++k) \{\par
00922                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
00923                                         {\cf19 return} {\cf17 true};\par
00924                                 \}\par
00925                         \}\par
00926                 \}\par
00927                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(L,N)\};\par
00928                 {\cf19 for}(std::size_t k\{0\} ; k < Z ; ++k) \{\par
00929                                 {\cf17 const} {\cf18 bool} condition\{m_dc[k]!=arg.m_dc[k]\};\par
00930                                 {\cf19 if} (condition) \{\par
00931                                         {\cf19 return} {\cf17 true};\par
00932                                 \}\par
00933                 \}\par
00934                 {\cf19 return} {\cf17 false};\par
00935         \}\par
00936 \par
00937         {\cf17 template}<std::{\cf18 size_t} N>\par
00938                 {\cf17 requires} (N>0)\par
00939         {\cf17 constexpr} {\cf17 inline}\par
00940         {\cf18 bool} {\cf17 operator} <= ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
00941         {\cf17 noexcept} \{\par
00942                 {\cf19 if} {\cf17 constexpr} (N>L) \{\par
00943                         {\cf19 for}(std::size_t k\{L\} ; k < N ; ++k) \{\par
00944                                 {\cf19 if} (!(arg[k].is_0())) \{\par
00945                                         {\cf19 return} {\cf17 true};\par
00946                                 \}\par
00947                         \}\par
00948                 \}\par
00949                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (L>N) \{\par
00950                         {\cf19 for}(std::size_t k\{N\} ; k < L ; ++k) \{\par
00951                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
00952                                         {\cf19 return} {\cf17 false};\par
00953                                 \}\par
00954                         \}\par
00955                 \}\par
00956                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(L,N)\};\par
00957                 {\cf19 for}(std::size_t k\{0\} ; k < Z ; ++k) \{\par
00958                                 {\cf19 if} (m_dc[k]<arg.m_dc[k]) \{\par
00959                                         {\cf19 return} {\cf17 true};\par
00960                                 \}\par
00961                                 {\cf19 else} {\cf19 if} (m_dc[k]>arg.m_dc[k]) \{\par
00962                                         {\cf19 return} {\cf17 false};\par
00963                                 \}\par
00964                 \}\par
00965                 {\cf19 return} {\cf17 true};\par
00966         \}\par
00967 \par
00968         {\cf17 template}<std::{\cf18 size_t} N>\par
00969                 {\cf17 requires} (N>0)\par
00970         {\cf17 constexpr} {\cf17 inline}\par
00971         {\cf18 bool} {\cf17 operator} >= ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
00972         {\cf17 noexcept} \{\par
00973                 {\cf19 if} {\cf17 constexpr} (N>L) \{\par
00974                         {\cf19 for}(std::size_t k\{L\} ; k < N ; ++k) \{\par
00975                                 {\cf19 if} (!(arg[k].is_0())) \{\par
00976                                         {\cf19 return} {\cf17 false};\par
00977                                 \}\par
00978                         \}\par
00979                 \}\par
00980                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (L>N) \{\par
00981                         {\cf19 for}(std::size_t k\{N\} ; k < L ; ++k) \{\par
00982                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
00983                                         {\cf19 return} {\cf17 true};\par
00984                                 \}\par
00985                         \}\par
00986                 \}\par
00987                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(L,N)\};\par
00988                 {\cf19 for}(std::int64_t k\{Z-1\} ; k > -1 ; --k) \{\par
00989                                 {\cf19 if} (m_dc[k]>arg.m_dc[k]) \{\par
00990                                         {\cf19 return} {\cf17 false};\par
00991                                 \}\par
00992                                 {\cf19 else} {\cf19 if} (m_dc[k]<arg.m_dc[k]) \{\par
00993                                         {\cf19 return} {\cf17 true};\par
00994                                 \}\par
00995                 \}\par
00996                 {\cf19 return} {\cf17 true};\par
00997         \}\par
00998 \par
00999         {\cf17 template}<std::{\cf18 size_t} N>\par
01000                 {\cf17 requires} (N>0)\par
01001         {\cf17 constexpr} {\cf17 inline}\par
01002         {\cf18 bool} {\cf17 operator} <  ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
01003         {\cf17 noexcept} \{\par
01004                 {\cf19 if} {\cf17 constexpr} (N>L) \{\par
01005                         {\cf19 for}(std::size_t k\{L\} ; k < N ; ++k) \{\par
01006                                 {\cf19 if} (!(arg[k].is_0())) \{\par
01007                                         {\cf19 return} {\cf17 true};\par
01008                                 \}\par
01009                         \}\par
01010                 \}\par
01011                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (L>N) \{\par
01012                         {\cf19 for}(std::size_t k\{N\} ; k < L ; ++k) \{\par
01013                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
01014                                         {\cf19 return} {\cf17 false};\par
01015                                 \}\par
01016                         \}\par
01017                 \}\par
01018                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(L,N)\};\par
01019                 {\cf19 for}(std::int64_t k\{Z-1\} ; k > -1 ; --k) \{\par
01020                                 {\cf19 if} (m_dc[k]<arg.m_dc[k]) \{\par
01021                                         {\cf19 return} {\cf17 true};\par
01022                                 \}\par
01023                                 {\cf19 else} {\cf19 if} (m_dc[k]>arg.m_dc[k]) \{\par
01024                                         {\cf19 return} {\cf17 false};\par
01025                                 \}\par
01026                 \}\par
01027                 {\cf19 return} {\cf17 false};\par
01028         \}\par
01029 \par
01030         {\cf17 template}<std::{\cf18 size_t} N>\par
01031                 {\cf17 requires} (N>0)\par
01032         {\cf17 constexpr} {\cf17 inline}\par
01033         {\cf18 bool} {\cf17 operator} > ({\cf17 const} int_reg_N_digs_t<N> & arg) {\cf17 const}\par
01034         {\cf17 noexcept} \{\par
01035                 {\cf19 if} {\cf17 constexpr} (N>L) \{\par
01036                         {\cf19 for}(std::size_t k\{L\} ; k < N ; ++k) \{\par
01037                                 {\cf19 if} (!(arg[k].is_0())) \{\par
01038                                         {\cf19 return} {\cf17 false};\par
01039                                 \}\par
01040                         \}\par
01041                 \}\par
01042                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (L>N) \{\par
01043                         {\cf19 for}(std::size_t k\{N\} ; k < L ; ++k) \{\par
01044                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
01045                                         {\cf19 return} {\cf17 true};\par
01046                                 \}\par
01047                         \}\par
01048                 \}\par
01049                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(L,N)\};\par
01050                 {\cf19 for}(std::int64_t k\{Z-1\} ; k > -1 ; --k) \{\par
01051                                 {\cf19 if} (m_dc[k]>arg[k]) \{\par
01052                                         {\cf19 return} {\cf17 true};\par
01053                                 \}\par
01054                                 {\cf19 else} {\cf19 if} (m_dc[k]<arg[k]) \{\par
01055                                         {\cf19 return} {\cf17 false};\par
01056                                 \}\par
01057                 \}\par
01058                 {\cf19 return} {\cf17 false};\par
01059         \}\par
01061 \par
01062         {\cf17 template}<std::{\cf18 size_t} N>\par
01063                 {\cf17 requires} ((N>0)&&(N<L))\par
01064         {\cf17 constexpr} {\cf17 inline}\par
01065         std::strong_ordering operator <=> ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
01066         {\cf17 noexcept} \{\par
01067                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
01068                 {\cf19 for}(std::size_t ix\{N\} ; ix < L ; ++ix) \{\par
01069                         {\cf19 if} (!(cthis[ix].is_0()))\par
01070                                 {\cf19 return} std::strong_ordering::greater;\par
01071                 \}\par
01072                 int_reg_N_digs_t<N> cpthis\{\};\par
01073                 {\cf19 for}(std::size_t ix\{0\} ; ix < N ;++ix)\par
01074                         cpthis[ix] = cthis[ix];\par
01075                 {\cf19 if} (cpthis == arg)\par
01076                         {\cf19 return} std::strong_ordering::equal;\par
01077                 {\cf19 else} {\cf19 if} (cpthis < arg)\par
01078                         {\cf19 return} std::strong_ordering::less;\par
01079                 {\cf19 else}\par
01080                         {\cf19 return} std::strong_ordering::greater;\par
01081         \}\par
01082 \par
01083         {\cf17 template}<std::{\cf18 size_t} N>\par
01084                 {\cf17 requires} ((N>0)&&(N>L))\par
01085         {\cf17 constexpr} {\cf17 inline}\par
01086         std::strong_ordering operator <=> ({\cf17 const} int_reg_N_digs_t<N>& arg) {\cf17 const}\par
01087         {\cf17 noexcept} \{\par
01088                 {\cf17 const} int_reg_digs_t & cthis\{*{\cf17 this}\};\par
01089                 {\cf19 for}(std::size_t ix\{L\} ; ix < N ; ++ix) \{\par
01090                         {\cf19 if} (!(arg[ix].is_0()))\par
01091                                 {\cf19 return} std::strong_ordering::greater;\par
01092                 \}\par
01093                 int_reg_N_digs_t<L> cparg\{\};\par
01094                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ;++ix)\par
01095                         cparg[ix] = arg[ix];\par
01096                 {\cf19 if} (cthis == cparg)\par
01097                         {\cf19 return} std::strong_ordering::equal;\par
01098                 {\cf19 else} {\cf19 if} (cthis < cparg)\par
01099                         {\cf19 return} std::strong_ordering::less;\par
01100                 {\cf19 else}\par
01101                         {\cf19 return} std::strong_ordering::greater;\par
01102         \}\par
01103 \par
01104 {\cf20                                 /********************************/}\par
01105                                 {\cf20 /*                                                                                                              */}\par
01106                                 {\cf20 /*                PRIMER DIGITO                                 */}\par
01107                                 {\cf20 /*                SEGUNDO DIGITO                                        */}\par
01108                                 {\cf20 /*                                                                                                              */}\par
01109 {\cf20                                 /********************************/}\par
01110 \par
01111         {\cf17 template}<std::{\cf18 size_t} I>\par
01112                 {\cf17 requires} ((I<L)&&(I>=0))\par
01113         {\cf17 inline} {\cf17 constexpr} {\cf17 const} dig_t& get() {\cf17 const} {\cf17 noexcept} \{\par
01114                 {\cf19 return} (m_dc[I]);\par
01115         \}\par
01116 \par
01117         {\cf17 template}<std::{\cf18 size_t} I>\par
01118                 {\cf17 requires} ((I<L)&&(I>=0))\par
01119         {\cf17 inline} {\cf17 constexpr} {\cf18 void} put({\cf17 const} dig_t & arg) {\cf17 noexcept} \{\par
01120                 m_dc[I] = arg; {\cf19 return};\par
01121         \}\par
01122 \par
01123         {\cf17 template}<std::{\cf18 size_t} I>\par
01124                 {\cf17 requires} ((I<L)&&(I>=0))\par
01125         {\cf17 inline} {\cf17 constexpr} {\cf18 void} put(dig_t && arg) {\cf17 noexcept} \{\par
01126                 m_dc[I] = std::move(arg); {\cf19 return};\par
01127         \}\par
01128 \par
01129         {\cf17 inline} {\cf17 constexpr} {\cf17 const} dig_t & operator[](std::size_t idx) {\cf17 const} {\cf17 noexcept} \{\par
01130                 {\cf19 return} (m_dc[idx]);\par
01131         \}\par
01132 \par
01133         {\cf17 inline} {\cf17 constexpr} dig_t & operator[](std::size_t idx) {\cf17 noexcept} \{\par
01134                 {\cf19 return} (m_dc[idx]);\par
01135         \}\par
01136 \par
01137         {\cf17 inline} {\cf17 constexpr} UINT_T operator()(std::size_t idx) {\cf17 const} {\cf17 noexcept} \{\par
01138                 {\cf19 return} (m_dc[idx]());\par
01139         \}\par
01140 \par
01141 {\cf20                                                                 /****************************/}\par
01142                                                                 {\cf20 /*                                                                                                      */}\par
01143                                                                 {\cf20 /* OPERADORES ARITMETICOS               */}\par
01144                                                                 {\cf20 /*      POSTINCREMENTO ++(int)  */}\par
01145                                                                 {\cf20 /*      PREINCREMENTO ++()                */}\par
01146                                                                 {\cf20 /*      POSTDECREMENTO --(int)  */}\par
01147                                                                 {\cf20 /*      PREDECREMENTO ++()                */}\par
01148                                                                 {\cf20 /*                          */}\par
01149 {\cf20                                                                 /****************************/}\par
01150 \par
01151         {\cf17 constexpr} {\cf17 inline}\par
01152         {\cf17 const} int_reg_digs_t & operator ++ ()\par
01153         noexcept \{\par
01154                 int_reg_digs_t& cthis(*{\cf17 this});\par
01156                 dig_t carry\{dig_1()\};\par
01158                 {\cf19 for}(std::size_t ix\{0\} ; ix < L-1 ; ++ix) \{\par
01159                         {\cf19 if} ((cthis[ix]==dig_Bm1())&&(carry == dig_1())) \{\par
01160                                 cthis[ix]=dig_0();\par
01161                                 carry = dig_1();\par
01162                         \}\par
01163                         {\cf19 else} {\cf19 if} ((cthis[ix]<dig_Bm1())&&(carry == dig_1()))\{\par
01164                                 {\cf19 if} (carry != dig_0()) \{\par
01165                                         ++cthis[ix];\par
01166                                         {\cf20 // carry = dig_0();}\par
01167                                         {\cf19 break};\par
01168                                 \}\par
01169                         \}\par
01170                 \}\par
01171                 {\cf19 return} cthis;\par
01172         \}\par
01173 \par
01174         {\cf17 constexpr} {\cf17 inline}\par
01175         int_reg_digs_t operator ++ ({\cf18 int})\par
01176         {\cf17 noexcept} \{\par
01177                 int_reg_digs_t cpthis(*{\cf17 this});\par
01178                 ++(*this);\par
01179                 {\cf19 return} cpthis;\par
01180         \}\par
01181 \par
01182         {\cf17 constexpr} {\cf17 inline}\par
01183         {\cf17 const} int_reg_digs_t & operator -- ()\par
01184         noexcept \{\par
01185                 int_reg_digs_t& cthis(*{\cf17 this});\par
01187                 dig_t carry\{dig_0()\};\par
01189                 {\cf19 for}(std::size_t ix\{0\} ; ix < L-1 ; ++ix) \{\par
01190                                 SIG_UINT_T temp\{cthis(ix)+B-1+carry()\};\par
01191                                 cthis[ix]=dig_t(temp);\par
01192                                 carry = dig_t(temp/B);\par
01193                 \}\par
01194                 {\cf19 return} cthis;\par
01195         \}\par
01196 \par
01197         {\cf17 constexpr} {\cf17 inline}\par
01198         int_reg_digs_t operator -- ({\cf18 int})\par
01199         {\cf17 noexcept} \{\par
01200                 int_reg_digs_t cpthis(*{\cf17 this});\par
01201                 --(*this);\par
01202                 {\cf19 return} cpthis;\par
01203         \}\par
01204 \par
01205 {\cf20                                                                 /****************************/}\par
01206                                                                 {\cf20 /*                                                                                                      */}\par
01207                                                                 {\cf20 /* OPERADORES ARITMETICOS               */}\par
01208                                                                 {\cf20 /*       C_B()  C_Bm1()                                 */}\par
01209                                                                 {\cf20 /*      mC_B() mC_Bm1()               */}\par
01210                                                                 {\cf20 /*      operator!() operator-() */}\par
01211                                                                 {\cf20 /*                          */}\par
01212 {\cf20                                                                 /****************************/}\par
01213 \par
01214         {\cf17 constexpr} {\cf17 inline}\par
01215         {\cf17 const} int_reg_digs_t & mC_Bm1()\par
01216         noexcept \{\par
01217                 int_reg_digs_t& cthis(*{\cf17 this});\par
01218                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01219                                 cthis[ix] = !cthis[ix];\par
01220                 \}\par
01221                 {\cf19 return} cthis;\par
01222         \}\par
01223 \par
01224         {\cf17 constexpr} {\cf17 inline}\par
01225         {\cf17 const} int_reg_digs_t & mC_B()\par
01226         noexcept \{\par
01227                 int_reg_digs_t& cthis(*{\cf17 this});\par
01228                 cthis.mC_Bm1();\par
01229                 dig_t carry\{dig_1()\};\par
01231                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01232                         {\cf19 if} ((cthis[ix]==dig_Bm1())&&(carry != dig_1())) \{\par
01233                                 cthis[ix]=dig_0();\par
01234                                 carry = dig_1();\par
01235                         \}\par
01236                         {\cf19 else} {\cf19 if} (carry == dig_1())\{\par
01237                                 ++cthis[ix];\par
01238                                 {\cf19 break};\par
01239                         \}\par
01240                 \}\par
01241                 {\cf19 return} (cthis);\par
01242         \}\par
01243 \par
01244         {\cf17 constexpr} {\cf17 inline}\par
01245         int_reg_digs_t C_Bm1() const\par
01246         noexcept\par
01247         \{\par
01248                 int_reg_digs_t cpthis(*{\cf17 this});\par
01249                 cpthis.mC_Bm1();\par
01250                 {\cf19 return} cpthis;\par
01251         \}\par
01252 \par
01253         {\cf17 constexpr} {\cf17 inline}\par
01254         int_reg_digs_t C_B() const\par
01255         noexcept \{\par
01256                 int_reg_digs_t cpthis(*{\cf17 this});\par
01257                 cpthis.mC_B();\par
01258                 {\cf19 return} cpthis;\par
01259         \}\par
01260 \par
01261         {\cf17 constexpr} {\cf17 inline}\par
01262         int_reg_digs_t operator ! () const\par
01263         noexcept \{\par
01264                 int_reg_digs_t cpthis(*{\cf17 this});\par
01265                 cpthis.mC_Bm1();\par
01266                 {\cf19 return} cpthis;\par
01267         \}\par
01268 \par
01269         {\cf17 constexpr} {\cf17 inline}\par
01270         int_reg_digs_t operator - () const\par
01271         noexcept \{\par
01272                 int_reg_digs_t cpthis(*{\cf17 this});\par
01273                 cpthis.mC_B();\par
01274                 {\cf19 return} cpthis;\par
01275         \}\par
01276 \par
01277 {\cf20                                         /************************************/}\par
01278                                         {\cf20 /* OPERADORES ARITMETICOS BASICOS               */}\par
01279                                         {\cf20 /*                      int_reg_digs_t  @  dig_t                */}\par
01280                                         {\cf20 /*      int_reg_digs_t  @= dig_t    */}\par
01281                                         {\cf20 /*      int_reg_digs_t  @  10B^n    */}\par
01282                                         {\cf20 /*      int_reg_digs_t  @= 10B^n    */}\par
01283 {\cf20                                         /************************************/}\par
01284 \par
01285 {\cf20                                         /************************************/}\par
01286                                         {\cf20 /*                                                                                                                              */}\par
01287                                         {\cf20 /*  ARITMETICOS CON ASIGNACION                  */}\par
01288                                         {\cf20 /*                       int_reg_digs_t @= dig_t                */}\par
01289                                         {\cf20 /*                                  */}\par
01290 {\cf20                                         /************************************/}\par
01291 \par
01292         {\cf17 constexpr} {\cf17 inline}\par
01293         {\cf17 const} int_reg_digs_t & operator += (dig_t arg)\par
01294         {\cf17 noexcept} \{\par
01295                 int_reg_digs_t& cthis(*{\cf17 this});\par
01297                 dig_t carry\{arg\};\par
01304                 {\cf19 if} (arg==dig_0()) \{\par
01305                         {\cf19 return} (cthis);\par
01306                 \} {\cf19 else} {\cf19 if} (arg == dig_1()) \{\par
01307                         {\cf19 return} (++cthis);\par
01308                 \} {\cf19 else} \{\par
01309                         {\cf17 const} dig_t dig_BmArg\{dig_Bm1()-(arg-dig_1())\};\par
01311                         {\cf19 if} (cthis[0]==dig_BmArg) \{\par
01312                                 cthis[0] = dig_0();\par
01313                                 carry    = dig_1();\par
01314                         \}\par
01317                         {\cf19 for}(std::size_t ix\{1\} ; ix < L-1 ; ++ix) \{\par
01318                                 {\cf19 if} (cthis[ix]==dig_Bm1()&& !(carry.is_0())) \{\par
01319                                         cthis[ix]=dig_0();\par
01320                                         carry = dig_1();\par
01321                                 \}\par
01322                                 {\cf19 else} {\cf19 if} ((cthis[ix]<dig_Bm1())&&(carry == dig_1()))\{\par
01323                                         {\cf19 if} (carry != dig_0()) \{\par
01324                                                 ++cthis[ix];\par
01325                                                 {\cf19 break};\par
01326                                         \}\par
01327                                 \}\par
01328                         \}\par
01329                         {\cf19 return} cthis;\par
01330                 \}\par
01331         \}\par
01332 \par
01333         {\cf17 constexpr} {\cf17 inline}\par
01334         {\cf17 const} int_reg_digs_t & operator -= (dig_t arg)\par
01335         {\cf17 noexcept} \{\par
01336                 int_reg_digs_t& cthis(*{\cf17 this});\par
01338                 dig_t carry\{arg\};\par
01345                 {\cf19 if} (arg==dig_0()) \{\par
01346                         {\cf19 return} (cthis);\par
01347                 \} {\cf19 else} {\cf19 if} (arg == dig_1()) \{\par
01348                         {\cf19 return} (--cthis);\par
01349                 \} {\cf19 else} \{\par
01350                         {\cf17 const} dig_t dig_CBArg\{arg.C_B()\};\par
01351                         {\cf17 const} dig_t dig_sig_Arg\{dig_Bm1()\};\par
01352 \par
01354                         {\cf19 if} (cthis(0)+dig_CBArg()>dig_Bm1()()) \{\par
01355                                 carry = dig_1();\par
01356                         \} {\cf19 else} \{\par
01357                                 carry = dig_0();\par
01358                         \}\par
01359                         cthis[0] += dig_CBArg;\par
01360 \par
01363                         {\cf19 for}(std::size_t ix\{1\} ; ix < L-1 ; ++ix) \{\par
01364                                 {\cf19 if} (cthis[ix].is_0() && carry.is_0()) \{\par
01365                                         cthis[ix]=dig_Bm1();\par
01366                                         carry = dig_0();\par
01367                                 \}\par
01368                                 {\cf19 else} {\cf19 if} (cthis[ix].is_0() && !carry.is_0()) \{\par
01369                                         cthis[ix]=dig_0();\par
01370                                         carry = dig_1();\par
01371                                 \}\par
01372                                 {\cf19 else} {\cf19 if} (cthis[ix].is_1() && carry.is_0()) \{\par
01373                                         cthis[ix]=dig_0();\par
01374                                         carry = dig_1();\par
01375                                 \}\par
01376                                 {\cf19 else} \{\par
01377                                         cthis[ix] += dig_Bm1();\par
01378                                         cthis[ix] += carry;\par
01379                                         carry = dig_1();\par
01380                                 \}\par
01381                         \}\par
01382                         {\cf19 return} cthis;\par
01383                 \}\par
01384         \}\par
01385 \par
01388         {\cf17 constexpr} {\cf17 inline}\par
01389         std::array<int_reg_digs_t,2> mult(dig_t arg) {\cf17 const}\par
01390         {\cf17 noexcept} \{\par
01391                 int_reg_digs_t cpthis(*{\cf17 this});\par
01392                 std::array<int_reg_digs_t,2> ret\{\};\par
01393                 {\cf19 if} (arg.is_0()) \{\par
01394                         cpthis = ret[0];\par
01395                         {\cf19 return} ret;\par
01396                 \}\par
01397                 {\cf19 else} {\cf19 if} (arg.is_1()) \{\par
01398                         ret[0] = cpthis;\par
01399                         {\cf19 return} ret;\par
01400                 \}\par
01401                 {\cf19 else} \{\par
01402                         dig_t carry\{dig_0()\};\par
01403                         {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix)\{\par
01404                                 {\cf17 const} {\cf17 auto} res = cpthis[ix].mult(arg);\par
01405                                 {\cf17 const} {\cf17 auto} uds = res[0].add(carry);\par
01406                                 ret[0][ix] = cpthis[ix] = uds[0] + carry;\par
01407                                 carry = res[1] + uds[1];\par
01408                         \}\par
01409                         ret[1][0]=carry;\par
01410                         {\cf19 return} ret;\par
01411                 \}\par
01412         \}\par
01413 \par
01416         std::array<int_reg_digs_t,2> full_euclid_div(dig_t dsor) \{\par
01417                 {\cf17 const} int_reg_digs_t & dndo\{*{\cf17 this}\};\par
01418                 std::array<int_reg_digs_t,2> ret\{\};\par
01419                                                 {\cf19 if} (dsor == dig_0()) \{\par
01420                                 {\cf19 return} ret;\par
01421                 \}\par
01422                 {\cf19 else}    {\cf19 if} (dsor == dig_1()) \{\par
01423                         ret[0] = dndo;\par
01424                         ret[1] = regd_0();\par
01425                         {\cf19 return} ret;\par
01426                 \}\par
01427                 {\cf19 else}    {\cf19 if} (dndo < regd_B()) \{\par
01428                         ret[0] = dndo[0] / dsor;\par
01429                         ret[1] = dndo[0] % dsor;\par
01430                         {\cf19 return} ret;\par
01431                 \}\par
01432                 {\cf19 else} \{\par
01433                         int_reg_digs_t& coc\{ret[0]\};\par
01434                         int_reg_digs_t& rem\{ret[1]\};\par
01435                         {\cf19 for}(std::int64_t lx\{L-1\} ; lx > -1 ; --lx) \{\par
01436                                 {\cf19 if} (dndo[lx]>=dsor) \{\par
01437                                         coc << 1;\par
01438                                         coc[0] = dndo[lx]/dsor;\par
01439                                         rem[0] = dndo[lx]%dsor;\par
01440                                         rem << 1;\par
01441                                         rem[0] = dndo[lx-1];\par
01442                                 \}\par
01443                                 {\cf19 else} \{\par
01444                                         rem << 1;\par
01445                                         rem[0] = dndo[lx-1];\par
01446                                         {\cf19 for} (UINT_T int_coc\{0\}; int_coc < B ; ++int_coc) \{\par
01447                                                 {\cf17 auto} X\{dig_t(int_coc).mult(dsor)\};\par
01448                                                 int_reg_N_digs_t<2> prod\{X[1],X[0]\};\par
01449                                                 {\cf19 if} (prod >= rem) \{\par
01450                                                         rem -= prod;\par
01451                                                         rem << 1;\par
01452                                                         rem[0] = dndo[lx-2];\par
01453                                                         coc << 1;\par
01454                                                         coc[0] = dig_t(int_coc);\par
01455                                                         {\cf19 break};\par
01456                                                 \}\par
01457                                         \}\par
01458                                 \}\par
01459                         \}\par
01460                         {\cf19 return} ret;\par
01461                 \}\par
01462         \}\par
01463 \par
01465         {\cf17 constexpr} {\cf17 inline}\par
01466         std::array<int_reg_digs_t,2> add(dig_t arg) {\cf17 const}\par
01467         {\cf17 noexcept} \{\par
01468                 {\cf17 const} int_reg_digs_t& cthis\{*{\cf17 this}\};\par
01469                 std::array<int_reg_digs_t,2> result\{dig_0(),cthis\};\par
01470                 dig_t carry\{dig_0()\};\par
01471                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01472                         {\cf17 auto}    temp_result   =      result[0][ix].add(arg);\par
01473                         {\cf17 auto}  temp_result_2 = temp_result[0][ix].add(carry);\par
01474                         result[0][ix] = temp_result_2[0];\par
01475                         result[1][0]  = temp_result_2[1];\par
01476                         carry = result[1][0];\par
01477                 \}\par
01478                 {\cf19 for}(std::size_t ix\{1\} ; ix < L ; ++ix) \{\par
01479                         result[1][ix] = dig_0();\par
01480                 \}\par
01481                 {\cf19 return} result;\par
01482         \}\par
01483 \par
01486         {\cf17 constexpr} {\cf17 inline}\par
01487         std::array<int_reg_digs_t,2> subst(dig_t arg) {\cf17 const}\par
01488         {\cf17 noexcept} \{\par
01489                 {\cf17 const} int_reg_digs_t& cthis\{*{\cf17 this}\};\par
01490                 std::array<int_reg_digs_t,2> result\{dig_0(),cthis\};\par
01491                 int_reg_digs_t cb_arg\{-arg\};\par
01492                 {\cf19 if} (!(arg.is_0())) \{\par
01493                         {\cf19 for}(std::size_t ix\{1\} ; ix < L ; ++ix) \{\par
01494                                 cb_arg[ix] = dig_Bm1();\par
01495                         \}\par
01496                 \}\par
01497                 dig_t carry\{dig_0()\};\par
01498                 {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01499                         {\cf17 auto}    temp_result   =      result[0][ix].add(cb_arg[ix]);\par
01500                         {\cf17 auto}  temp_result_2 =     temp_result[0].add(carry);\par
01501                         result[0][ix]  = temp_result_2[0];\par
01502                         result[1][ix]  = (temp_result_2[1].add(temp_result_2[1]))[0];\par
01503                         carry = result[1][ix];\par
01504                 \}\par
01505                 {\cf19 return} result;\par
01506         \}\par
01507 \par
01508 \par
01509 {\cf20                                         /********************************/}\par
01510                                         {\cf20 /*                                                                                                                      */}\par
01511                                         {\cf20 /*    OPERADORES ARITMETICOS            */}\par
01512                                         {\cf20 /*                       int_reg_digs_t @ dig_t */}\par
01513                                         {\cf20 /*                                                                                                                      */}\par
01514 {\cf20                                         /********************************/}\par
01515 \par
01516                 {\cf17 constexpr} {\cf17 inline}\par
01517                 {\cf17 auto} operator + (dig_t arg) {\cf17 const}\par
01518                 {\cf17 noexcept} \{\par
01519                         int_reg_digs_t ret(*{\cf17 this});\par
01520                         ret += arg;\par
01521                         {\cf19 return} ret;\par
01522                 \}\par
01523 \par
01524                 {\cf17 constexpr} {\cf17 inline}\par
01525                 {\cf17 auto} operator - (dig_t arg) {\cf17 const}\par
01526                 {\cf17 noexcept} \{\par
01527                         int_reg_digs_t ret(*{\cf17 this});\par
01528                         ret -= arg;\par
01529                         {\cf19 return} ret;\par
01530                 \}\par
01531 \par
01532                 {\cf17 constexpr} {\cf17 inline}\par
01533                 {\cf17 auto} operator * (dig_t arg) {\cf17 const}\par
01534                 {\cf17 noexcept} \{\par
01535                         int_reg_digs_t ret(*{\cf17 this});\par
01536                         ret *= arg;\par
01537                         {\cf19 return} ret;\par
01538                 \}\par
01539 \par
01541                 {\cf17 constexpr} {\cf17 inline}\par
01542                 std::array<int_reg_digs_t,2> euclid_div (dig_t arg) {\cf17 const}\par
01543                 {\cf17 noexcept} \{\par
01544                         {\cf17 const} int_reg_digs_t& dndo\{*{\cf17 this}\};\par
01545                         {\cf17 const} dig_t&      dsor\{arg\};\par
01546                         {\cf17 const} int_reg_digs_t<UINT_T,B,2> tmp_dsor\{dig_0(),arg\};\par
01547                                                 int_reg_digs_t<UINT_T,B,2> part_rem\{dig_0(),dndo[L-1]\};\par
01548                                                 int_reg_digs_t rem\{regd_0()\};\par
01549                                                 int_reg_digs_t coc\{regd_0()\};\par
01550                         {\cf19 if} (dsor == dig_0()) \{\par
01551                                 std::array<int_reg_digs_t,2> rem_coc\{regd_0(),regd_0()\};\par
01552                                 {\cf19 return} rem_coc;\par
01553                         \}\par
01554                         {\cf19 else} {\cf19 if} (dsor == dig_1()) \{\par
01555                                 std::array<int_reg_digs_t,2> rem_coc\{regd_0(),(*this)\};\par
01556                                 {\cf19 return} rem_coc;\par
01557                         \}\par
01558                         {\cf19 else} {\cf19 if} ((dndo == regd_0())||(dndo == regd_1())) \{\par
01559                                 std::array<int_reg_digs_t,2> rem_coc\{(*this),regd_0()\};\par
01560                                 {\cf19 return} rem_coc;\par
01561                         \}\par
01562                         {\cf19 else} {\cf19 if} (dndo < regd_B()) \{\par
01563                                         dig_t retcoc\{dndo[1]/dsor\};\par
01564                                         dig_t retrem\{dndo[1]%dsor\};\par
01565                                         coc[0]=retcoc;\par
01566                                         rem[0]=retrem;\par
01567                                         {\cf19 return} std::make_pair(rem,coc);\par
01568                         \}\par
01569                         {\cf19 else} \{\par
01570                                 int_reg_digs_t<UINT_T,B,2> tmp_dsor\{dig_0(),arg\};\par
01571                                 std::int64_t ph_dndo\{L-1\};\par
01572                                 std::int64_t pl_dndo\{L-1\};\par
01573                                 {\cf20 // ph_dndo >= ix >= pl_dndo}\par
01574                                 {\cf19 while}((ph_dndo>-1)&&(pl_dndo>-1)) \{\par
01575                                         {\cf19 if} (pl_dndo == L-1) \{\par
01576                                                 part_rem[1] = dig_0();\par
01577                                                 part_rem[0] = dndo[L-1];\par
01578                                         \}\par
01579                                         {\cf19 else} {\cf19 if} ((pl_dndo == 0)&&(ph_dndo == 1)) \{\par
01580                                                 part_rem[1] = dndo[1];\par
01581                                                 part_rem[0] = dndo[0];\par
01582                                         \}\par
01583                                         {\cf19 else} {\cf19 if} ((pl_dndo == 0)&&(ph_dndo == 0)) \{\par
01584                                                 part_rem[1] = dig_0();\par
01585                                                 part_rem[0] = dndo[0];\par
01586                                         \}\par
01587                                         {\cf19 else} {\cf19 if} (ph_dndo > pl_dndo) \{\par
01588                                                 part_rem[1] = dndo[ph_dndo];\par
01589                                                 part_rem[0] = dndo[pl_dndo];\par
01590                                         \}\par
01591                                         {\cf19 else} \{\par
01592                                                 part_rem[1] = dig_0();\par
01593                                                 part_rem[0] = dndo[pl_dndo];\par
01594                                         \}\par
01595 \par
01596                                         coc << 1;\par
01597                                         {\cf19 if} (part_rem>=tmp_dsor) \{\par
01598                                                 dig_t cocdig\{dig_0()\};\par
01599                                                 {\cf19 while}(part_rem>=tmp_dsor) \{\par
01600                                                         ++cocdig;\par
01601                                                         part_rem -= tmp_dsor;\par
01602                                                 \}\par
01603                                                 coc |= cocdig;\par
01604                                                 {\cf19 if} (ph_dndo > pl_dndo) \{\par
01605                                                         --ph_dndo;\par
01606                                                         --pl_dndo;\par
01607                                                 \}\par
01608                                                 {\cf19 else} \{\par
01609                                                         --pl_dndo;\par
01610                                                 \}\par
01611                                         \}\par
01612                                         {\cf19 else} \{\par
01613                                                 {\cf19 if} (ph_dndo > pl_dndo) \{\par
01614                                                         --ph_dndo;\par
01615                                                         --pl_dndo;\par
01616                                                 \}\par
01617                                                 {\cf19 else} \{\par
01618                                                         --pl_dndo;\par
01619                                                 \}\par
01620                                         \}\par
01621                                 \}\par
01622                                 rem[1]=part_rem[1];\par
01623                                 rem[0]=part_rem[0];\par
01624                                 std::array<int_reg_digs_t,2> rem_coc\{std::make_pair(rem,coc)\};\par
01625                                 {\cf19 return} rem_coc;\par
01626                         \}\par
01627                 \}\par
01629                 {\cf17 constexpr} {\cf17 inline}\par
01630                 int_reg_digs_t operator / (dig_t arg) {\cf17 const}\par
01631                 {\cf17 noexcept} \{\par
01632                         {\cf19 return} (this->euclid_div(arg))[0];\par
01633                 \}\par
01635                 {\cf17 constexpr} {\cf17 inline}\par
01636                 int_reg_digs_t operator % (dig_t arg) {\cf17 const}\par
01637                 {\cf17 noexcept} \{\par
01638                         {\cf19 return} (this->euclid_div(arg))[1];\par
01639                 \}\par
01642                 {\cf17 constexpr} {\cf17 inline}\par
01643                 int_reg_digs_t operator << (std::size_t n) {\cf17 const}\par
01644                 {\cf17 noexcept} \{\par
01645                         int_reg_digs_t cpthis\{*{\cf17 this}\};\par
01646                         {\cf19 for}(std::int64_t ix\{n-1\} ; ix > -1 ; --ix) \{\par
01647                                 cpthis[ix+n] = cpthis[ix];\par
01648                                 cpthis[ix] = dig_0();\par
01649                         \}\par
01650                         {\cf19 return} cpthis;\par
01651                 \}\par
01652 \par
01653                 {\cf17 constexpr} {\cf17 inline}\par
01654                 {\cf17 const} int_reg_digs_t & operator <<= (std::size_t n)\par
01655                 {\cf17 noexcept} \{\par
01656                         int_reg_digs_t& cthis\{*{\cf17 this}\};\par
01657                         {\cf19 for}(std::int64_t ix\{n-1\} ; ix > -1 ; --ix) \{\par
01658                                 cthis[ix+n] = cthis[ix];\par
01659                                 cthis[ix] = dig_0();\par
01660                         \}\par
01661                         {\cf19 return} (*{\cf17 this});\par
01662                 \}\par
01664                 {\cf17 constexpr} {\cf17 inline}\par
01665                 int_reg_digs_t operator >> (std::size_t n) {\cf17 const}\par
01666                 {\cf17 noexcept} \{\par
01667                         int_reg_digs_t cpthis\{*{\cf17 this}\};\par
01668                         {\cf19 for}(std::int64_t ix\{0\} ; ix < n ; ++ix) \{\par
01669                                 cpthis[ix] = cpthis[ix+n];\par
01670                                 cpthis[ix+n] = dig_0();\par
01671                         \}\par
01672                         {\cf19 return} cpthis;\par
01673                 \}\par
01674                 {\cf17 constexpr} {\cf17 inline}\par
01675                 {\cf17 const} int_reg_digs_t & operator >>= (std::size_t n)\par
01676                 {\cf17 noexcept} \{\par
01677                         int_reg_digs_t& cthis\{*{\cf17 this}\};\par
01678                         {\cf19 for}(std::int64_t ix\{0\} ; ix < n ; ++ix) \{\par
01679                                 cthis[ix] = cthis[ix+n];\par
01680                                 cthis[ix+n] = dig_0();\par
01681                         \}\par
01682                         {\cf19 return} (*{\cf17 this});\par
01683                 \}\par
01687                 {\cf17 constexpr} {\cf17 inline}\par
01688                 int_reg_digs_t rem_B(std::size_t n) {\cf17 const}\par
01689                 {\cf17 noexcept} \{\par
01690                         int_reg_digs_t ret\{regd_0()\};\par
01691                         {\cf19 for}(std::size_t ix\{0\} ; ix < n ; ++ix) \{\par
01692                                 ret[ix] = m_dc[ix];\par
01693                         \}\par
01694                         {\cf19 return} ret;\par
01695                 \}\par
01696 \par
01697                 {\cf17 constexpr} {\cf17 inline}\par
01698                 {\cf17 const} int_reg_digs_t & m_rem_B(std::size_t n)\par
01699                 {\cf17 noexcept} \{\par
01700                         {\cf19 for}(std::size_t ix\{n\} ; ix < L ; ++ix) \{\par
01701                                 m_dc[ix] = dig_0();\par
01702                         \}\par
01703                         {\cf19 return} (*{\cf17 this});\par
01704                 \}\par
01707 \par
01709                 {\cf17 constexpr} {\cf17 inline}\par
01710                 {\cf17 const} int_reg_digs_t & operator |= ({\cf17 const} int_reg_digs_t & arg)\par
01711                 {\cf17 noexcept} \{\par
01712                         {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01713                                 m_dc[ix] |= arg[ix];\par
01714                         \}\par
01715                         {\cf19 return} (*{\cf17 this});\par
01716                 \}\par
01717 \par
01718                 {\cf17 constexpr} {\cf17 inline}\par
01719                 int_reg_digs_t operator | ({\cf17 const} int_reg_digs_t & arg)\par
01720                 {\cf17 noexcept} \{\par
01721                         int_reg_digs_t ret\{*{\cf17 this}\};\par
01722                         ret |= arg;\par
01723                         {\cf19 return} ret;\par
01724                 \}\par
01725 \par
01726                 {\cf17 constexpr} {\cf17 inline}\par
01727                 {\cf17 const} int_reg_digs_t & operator &= ({\cf17 const} int_reg_digs_t & arg)\par
01728                 {\cf17 noexcept} \{\par
01729                         {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01730                                 m_dc[ix] &= arg[ix];\par
01731                         \}\par
01732                         {\cf19 return} (*{\cf17 this});\par
01733                 \}\par
01734 \par
01735                 {\cf17 constexpr} {\cf17 inline}\par
01736                 int_reg_digs_t operator & ({\cf17 const} int_reg_digs_t & arg)\par
01737                 {\cf17 noexcept} \{\par
01738                         int_reg_digs_t ret\{*{\cf17 this}\};\par
01739                         ret &= arg;\par
01740                         {\cf19 return} ret;\par
01741                 \}\par
01742 \par
01744 \par
01745 {\cf20                                                                 /**************************************/}\par
01746                                                                 {\cf20 /*                                                                                                                                      */}\par
01747                                                                 {\cf20 /* OPERADORES ARITMETICOS                                               */}\par
01748                                                                 {\cf20 /* int_reg_digs_t @ int_reg_digs_t              */}\par
01749                                                                 {\cf20 /*                                                      */}\par
01750 {\cf20                                                                 /**************************************/}\par
01751 \par
01752         {\cf17 template}<std::{\cf18 size_t} N>\par
01753                 {\cf17 requires} (N>0)\par
01754         {\cf17 constexpr} {\cf17 inline}\par
01755         {\cf17 const} int_reg_digs_t & {\cf17 operator} += ({\cf17 const} base_N_t<N> & arg)\par
01756         {\cf17 noexcept} \{\par
01757                 int_reg_digs_t & cthis = (*this);\par
01758                 dig_t                           carry\{0\};\par
01759                 {\cf19 if} {\cf17 constexpr} (N < L) \{\par
01760                         {\cf19 for} (std::size_t ix\{0\} ; ix < N ; ++ix) \{\par
01761                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01762                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01763                                 {\cf17 const} dig_t     cparg\{arg[ix]\};\par
01764                                 cthis += cparg;\par
01765                                 cthis += carry;\par
01766                                 {\cf19 if} ((cthis < cpthis) || (cparg < cpthis))\par
01767                                         carry = dig_1();\par
01768                         \}\par
01769                         {\cf19 for} (std::size_t ix\{N\} ; ix < L ; ++ix) \{\par
01770                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01771                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01772                                 cthis += carry;\par
01773                                 {\cf19 if} (cthis < cpthis)\par
01774                                         carry = dig_1();\par
01775                         \}\par
01776                 \}\par
01777                 {\cf19 else} \{\par
01778                         {\cf19 for} (std::size_t ix\{0\} ; ix < L ; ++ix) \{\par
01779                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01780                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01781                                 {\cf17 const} dig_t     cparg\{arg[ix]\};\par
01782                                 cthis += cparg;\par
01783                                 cthis += carry;\par
01784                                 {\cf19 if} ((cthis < cpthis) || (cparg < cpthis))\par
01785                                         carry = dig_1();\par
01786                         \}\par
01787                 \}\par
01788                 {\cf19 return} (cthis);\par
01789         \}\par
01790 \par
01791         {\cf17 template}<std::{\cf18 size_t} N>\par
01792                 {\cf17 requires} (N>0)\par
01793         {\cf17 constexpr} {\cf17 inline}\par
01794         {\cf17 const} int_reg_digs_t & {\cf17 operator} += ({\cf17 const} int_reg_N_digs_t<N> & arg)\par
01795         {\cf17 noexcept} \{\par
01796                 (*this)+= arg.m_dc;\par
01797                 {\cf19 return} (*{\cf17 this});\par
01798         \}\par
01799 \par
01800         {\cf17 template}<std::{\cf18 size_t} N>\par
01801                 {\cf17 requires} (N>0)\par
01802         {\cf17 constexpr} {\cf17 inline}\par
01803         {\cf17 const} int_reg_digs_t & {\cf17 operator} -= ({\cf17 const} base_N_t<N> & arg)\par
01804         {\cf17 noexcept} \{\par
01805                 int_reg_digs_t & cthis\{*{\cf17 this}\};\par
01806                 base_N_t<N> cparg\{arg\};\par
01808                         {\cf20 // begin}\par
01809                         {\cf19 for}({\cf17 auto} & elem_dig : cparg) \{\par
01810                                 elem_dig = dig_t(B-1)-elem_dig;\par
01811                         \}\par
01812                         dig_t                   carry\{0\};\par
01813                         {\cf19 for} (std::size_t ix\{0\} ; ix < N ; ++ix) \{\par
01814                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01815                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01816                                 cthis += carry;\par
01817                                 {\cf19 if} (cthis < cpthis)\par
01818                                         carry = dig_1();\par
01819                         \}\par
01820                         {\cf20 // end}\par
01821                 cthis += cparg;\par
01822                 {\cf19 return} (cthis);\par
01823         \}\par
01824 \par
01825         {\cf17 template}<std::{\cf18 size_t} N>\par
01826                 {\cf17 requires} (N>0)\par
01827         {\cf17 constexpr} {\cf17 inline}\par
01828         {\cf17 const} int_reg_digs_t & {\cf17 operator} -= ({\cf17 const} int_reg_N_digs_t<N> & arg)\par
01829         {\cf17 noexcept} \{\par
01830                 (*this)-= arg.m_dc;\par
01831                 {\cf19 return} (*{\cf17 this});\par
01832         \}\par
01833 \par
01834         {\cf17 template}<std::{\cf18 size_t} N>\par
01835                 {\cf17 requires} (N>0)\par
01836         {\cf17 constexpr} {\cf17 inline}\par
01837         {\cf17 const} int_reg_digs_t & {\cf17 operator} *= ({\cf17 const} base_N_t<N> & arg)\par
01838         {\cf17 noexcept} \{\par
01839                 int_reg_digs_t cpthis\{*{\cf17 this}\};\par
01840                 int_reg_digs_t& cthis\{0\};\par
01841                 {\cf19 for}(std::size_t ix\{0\} ; ix < N ; ++ix) \{\par
01842                         cthis += (cpthis*arg[ix]);\par
01843                         cpthis <<= 1;\par
01844                 \}\par
01845                 {\cf19 return} (cthis);\par
01846         \}\par
01847 \par
01848         {\cf17 template}<std::{\cf18 size_t} N>\par
01849                 {\cf17 requires} (N>0)\par
01850         {\cf17 constexpr} {\cf17 inline}\par
01851         {\cf17 const} int_reg_digs_t & {\cf17 operator} *= ({\cf17 const} int_reg_N_digs_t<N> & arg)\par
01852         {\cf17 noexcept} \{\par
01853                 (*this)*= arg.m_dc;\par
01854                 {\cf19 return} (*{\cf17 this});\par
01855         \}\par
01856 \par
01858 {\cf20 //      constexpr inline}\par
01859 {\cf20 //      const int_reg_digs_t & operator /= (const int_reg_digs_t & arg)}\par
01860 {\cf20 //      noexcept \{}\par
01861 {\cf20 //              int_reg_digs_t & ret = (*this);}\par
01862 {\cf20 //              /// TO DO}\par
01863 {\cf20 //              return (*this);}\par
01864 {\cf20 //      \}}\par
01866 {\cf20 }{\cf20 //      constexpr inline}\par
01867 {\cf20 //      const int_reg_digs_t & operator %= (const int_reg_digs_t & arg)}\par
01868 {\cf20 //      noexcept \{}\par
01869 {\cf20 //              int_reg_digs_t & cthis\{*this\};}\par
01870 {\cf20 //              /// TO DO}\par
01871 {\cf20 //              return (*this);}\par
01872 {\cf20 //      \}}\par
01873 \par
01874                 {\cf17 template}<std::{\cf18 size_t} N>\par
01875                 {\cf17 constexpr} {\cf17 inline}\par
01876                 int_reg_digs_t operator + ({\cf17 const} base_N_t<N> & arg) {\cf17 const}\par
01877                 {\cf17 noexcept} \{\par
01878                         int_reg_digs_t ret(*{\cf17 this});\par
01879                         ret += arg;\par
01880                         {\cf19 return} ret;\par
01881                 \}\par
01882 \par
01883                 {\cf17 template}<std::{\cf18 size_t} N>\par
01884                 {\cf17 constexpr} {\cf17 inline}\par
01885                 int_reg_digs_t operator - ({\cf17 const} base_N_t<N> & arg) {\cf17 const}\par
01886                 {\cf17 noexcept} \{\par
01887                         int_reg_digs_t ret(*{\cf17 this});\par
01888                         ret -= arg;\par
01889                         {\cf19 return} ret;\par
01890                 \}\par
01891 \par
01892                 {\cf17 template}<std::{\cf18 size_t} N>\par
01893                 {\cf17 constexpr} {\cf17 inline}\par
01894                 int_reg_digs_t operator * ({\cf17 const} base_N_t<N> & arg) {\cf17 const}\par
01895                 {\cf17 noexcept} \{\par
01896                         int_reg_digs_t ret(*{\cf17 this});\par
01897                         ret *= arg;\par
01898                         {\cf19 return} ret;\par
01899                 \}\par
01900 \par
01901                 {\cf17 template}<std::{\cf18 size_t} N>\par
01902                 {\cf17 constexpr} {\cf17 inline}\par
01903                 int_reg_digs_t operator + ({\cf17 const} int_reg_N_digs_t<N> & arg) {\cf17 const}\par
01904                 {\cf17 noexcept} \{\par
01905                         int_reg_digs_t ret(*{\cf17 this});\par
01906                         ret += arg;\par
01907                         {\cf19 return} ret;\par
01908                 \}\par
01909 \par
01910                 {\cf17 template}<std::{\cf18 size_t} N>\par
01911                 {\cf17 constexpr} {\cf17 inline}\par
01912                 int_reg_digs_t operator - ({\cf17 const} int_reg_N_digs_t<N> & arg) {\cf17 const}\par
01913                 {\cf17 noexcept} \{\par
01914                         int_reg_digs_t ret(*{\cf17 this});\par
01915                         ret -= arg;\par
01916                         {\cf19 return} ret;\par
01917                 \}\par
01918 \par
01919                 {\cf17 template}<std::{\cf18 size_t} N>\par
01920                 {\cf17 constexpr} {\cf17 inline}\par
01921                 int_reg_digs_t operator * ({\cf17 const} int_reg_N_digs_t<N> & arg) {\cf17 const}\par
01922                 {\cf17 noexcept} \{\par
01923                         int_reg_digs_t ret(*{\cf17 this});\par
01924                         ret *= arg;\par
01925                         {\cf19 return} ret;\par
01926                 \}\par
01927 \par
01928 \par
01929                 {\cf17 constexpr} {\cf17 inline} {\cf17 static}\par
01930                 std::size_t cuenta_0s_desde_IZDA({\cf17 const} reg_ints_t<L>& arg)\par
01931                 {\cf17 noexcept} \{\par
01932                         std::size_t ret\{0\};\par
01933                         {\cf19 for}(std::int64_t ix\{L-1\} ; ix > -1 ; --ix) \{\par
01934                                 {\cf19 if} (arg[ix]==0) \{\par
01935                                         ++ret;\par
01936                                 \}\par
01937                                 {\cf19 else} \{\par
01938                                         {\cf19 return} ret;\par
01939                                 \}\par
01940                         \}\par
01941                         {\cf19 return} L;\par
01942                 \}\par
01943 \par
01944                 {\cf17 constexpr} {\cf17 inline} {\cf17 static}\par
01945                 std::size_t cuenta_0s_desde_DRCHA({\cf17 const} reg_ints_t<L>& arg)\par
01946                 {\cf17 noexcept} \{\par
01947                         std::size_t ret\{0\};\par
01948                         {\cf19 for}(std::int64_t ix\{0\} ; ix < L ; ++ix) \{\par
01949                                 {\cf19 if} (arg[ix]==0) \{\par
01950                                         ++ret;\par
01951                                 \}\par
01952                                 {\cf19 else} \{\par
01953                                         {\cf19 return} ret;\par
01954                                 \}\par
01955                         \}\par
01956                         {\cf19 return} L;\par
01957                 \}\par
01958 \par
01959                 {\cf17 constexpr} {\cf17 inline}\par
01960                 int_reg_digs_t operator / ({\cf17 const} int_reg_digs_t & arg) {\cf17 const}\par
01961                 {\cf17 noexcept} \{\par
01962                         {\cf17 const} int_reg_digs_t& dndo\{*{\cf17 this}\};\par
01963                         {\cf17 const} int_reg_digs_t& dsor\{arg\};\par
01964                         {\cf17 const} std::int64_t num_0s_IZDA_dsor\{cuenta_0s_desde_IZDA(dsor)\};\par
01965                         {\cf17 const} std::int64_t num_0s_IZDA_dndo\{cuenta_0s_desde_IZDA(dndo)\};\par
01966                         {\cf17 const} std::int64_t MSDig_dsor\{L-1-num_0s_IZDA_dsor\};\par
01967                         {\cf17 const} std::int64_t MSDig_dndo\{L-1-num_0s_IZDA_dndo\};\par
01968                         int_reg_digs_t rem\{regd_0()\};\par
01969                         int_reg_digs_t coc\{regd_0()\};\par
01970                         {\cf19 for}(std::int64_t num_loops\{0\} ;\par
01971                                                                                         num_loops < std::abs(MSDig_dndo-MSDig_dndo)\par
01972                                                                                                                                          ; ++num_loops)\par
01973                         \{\par
01974                                 {\cf19 if} (MSDig_dsor > MSDig_dndo) \{\par
01975                                         {\cf19 return} regd_0();\par
01976                                 \}\par
01977                                 {\cf19 else} {\cf19 if} (MSDig_dsor == MSDig_dndo) \{\par
01978                                         {\cf19 for}(std::int64_t ix\{MSDig_dsor\} ; ix > -1 ; --ix) \{\par
01979                                                         {\cf19 if} (dsor[ix] > dndo[ix]) \{\par
01980                                                                 {\cf19 return} regd_0();{\cf20 // DEVUELVE COCIENTE := 0 Y RESTO := DNDO}\par
01981                                                         \}\par
01982                                                         {\cf19 else} {\cf19 if} (dsor[ix] == dndo[ix]) \{\par
01983                                                                 {\cf19 if} (ix == 0)\par
01984                                                                         {\cf19 return} regd_1();{\cf20 // DEVUELVE COCIENTE := 1 Y RESTO := 0}\par
01985                                                                 {\cf19 else}\par
01986                                                                         {\cf19 continue};\par
01987                                                         \}\par
01988                                                         {\cf19 else} \{\par
01989                                                                 int_reg_digs_t coc\{0\};\par
01990                                                                 int_reg_digs_t idndo\{dndo\};\par
01991                                                                 int_reg_digs_t idsor\{dsor\};\par
01992                                                                 {\cf19 while} (idndo >= idsor) \{\par
01993                                                                         idndo -= idsor;\par
01994                                                                         ++coc[0];\par
01995                                                                 \}\par
01996                                                                 {\cf19 return} coc; {\cf20 // DEVUELVE COCIENTE := 000...L-1...0D}\par
01997                                                                                                                 {\cf20 // SIENDO D EL DIGITO 0 (Y EL VALOR DE COCIENTE)}\par
01998                                                                                                                 {\cf20 // DEVUELVE RESTO    := DNDO - DSOR * D}\par
01999                                                         \}\par
02000                                         \}\par
02001                                 \}\par
02002                                 {\cf19 else} {\cf19 if} (dsor == regd_1()) \{\par
02003                                         {\cf19 return} (*{\cf17 this});{\cf20 // DEVUELVE COCIENTE := DNDO Y RESTO := 0}\par
02004                                 \}\par
02005                                 {\cf19 else} {\cf19 if} (dsor == regd_0()) \{\par
02006                                         {\cf19 return} (*{\cf17 this});\par
02007                                 \}\par
02008                                 {\cf19 else} \{\par
02009                                         std::int64_t pl_dndo\{MSDig_dsor\};\par
02010                                         std::int64_t ph_dndo\{MSDig_dndo\};\par
02011 \par
02012                                         {\cf20 // ph_dndo >= ix > pl_dndo}\par
02013                                         {\cf19 for}(std::int64_t ix\{pl_dndo\} ; ix <= ph_dndo ; ++ix) \{\par
02014                                                 rem[ix-pl_dndo] = dndo[ix];\par
02015                                         \}\par
02016 \par
02017                                         {\cf19 if} (rem == dsor) \{\par
02018                                                 {\cf19 return} regd_1();{\cf20 // DEVUELVE COCIENTE:=1 Y RESTO:=0}\par
02019                                         \}\par
02020                                         {\cf19 else} {\cf19 if} (rem > dsor) \{\par
02021                                                 dig_t coc_dig\{dig_0()\};\par
02022                                                 {\cf19 while}(rem > dsor) \{\par
02023                                                         ++coc_dig;\par
02024                                                         rem -= dsor;\par
02025                                                 \}\par
02026                                                 coc *= regd_B();        {\cf20 // coc = coc * B}\par
02027                                                 coc[0] = coc_dig; {\cf20 // coc = coc + D  ; B-1 >= D > 1}\par
02028                                                 --pl_dndo;\par
02029                                                 {\cf19 for}(std::int64_t ix\{ph_dndo\} ; ix > pl_dndo ; --ix) \{\par
02030                                                         rem[ix-pl_dndo+1] = rem[ix-pl_dndo];\par
02031                                                 \}\par
02032                                                 rem[pl_dndo] = dndo[pl_dndo];\par
02033                                                 --ph_dndo;\par
02034                                         \}\par
02035                                         {\cf19 else} \{\par
02036                                                 {\cf19 if} (pl_dndo != 0) \{\par
02037                                                         --pl_dndo;\par
02038                                                         {\cf19 for}(std::int64_t ix\{ph_dndo\} ; ix > pl_dndo ; --ix) \{\par
02039                                                                 rem[ix-pl_dndo+1] = rem[ix-pl_dndo];\par
02040                                                         \}\par
02041                                                         rem[pl_dndo] = dndo[pl_dndo];\par
02042                                                         coc *= regd_B(); {\cf20 // coc = coc * B}\par
02043                                                         rem -= dsor;    {\cf20 // coc = coc + 0}\par
02044                                                 \}\par
02045                                                 {\cf19 else} \{\par
02046                                                         {\cf19 return} coc;{\cf20 // DEVOLVEMOS LO CALCULADO EN COC Y EL RESTO ES REM}\par
02047                                                 \}\par
02048                                         \}\par
02049                                 \}\par
02050                         \}\par
02051                         {\cf19 return} coc;{\cf20 // NO SE DEBER\'CDA LLEGAR AQUI}\par
02052                 \}\par
02053 \par
02054                 {\cf17 constexpr} {\cf17 inline}\par
02055                 int_reg_digs_t operator % ({\cf17 const} int_reg_digs_t & arg) {\cf17 const}\par
02056                 {\cf17 noexcept} \{\par
02057                         int_reg_digs_t ret(*{\cf17 this});\par
02058                         UINT_T retuds   = ret.m_dc[0]();\par
02059                         UINT_T retdecs  = ret.m_dc[1]();\par
02060                         UINT_T arguds   = arg.m_dc[0]();\par
02061                         UINT_T argdecs  = arg.m_dc[1]();\par
02062 \par
02063                         retuds  += (B*retdecs);\par
02064                         arguds  += (B*argdecs);\par
02065                         retuds  %= arguds;\par
02066                         retdecs  = retuds;\par
02067                         retdecs /= B;\par
02068                         retuds  %= B;\par
02069                         ret.m_dc[1]     = dig_t(retdecs);\par
02070                         ret.m_dc[0]     = dig_t(retuds);\par
02071                         {\cf19 return} ret;\par
02072                 \}\par
02073 \par
02093 \par
02094 \};\par
02095 \par
02096 \par
02097 {\cf20                                         /****************************/}\par
02098                                         {\cf20 /*                                                                                                      */}\par
02099                                         {\cf20 /*         ISTREAM Y OSTREAM            */}\par
02100                                         {\cf20 /*                                                                                                      */}\par
02101 {\cf20                                         /****************************/}\par
02102 \par
02104   {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} LE>\par
02105   {\cf18 bool} is_int_reg_digs_type_id(std::string in)\par
02106   \{     {\cf19 return}  (\par
02107       (in == {\cf22 "int_reg_digs"})||\par
02108       (in == {\cf22 "int_reg_dig"})||\par
02109       (in == {\cf22 "int_reg_di"})||\par
02110       (in == {\cf22 "int_reg_d"})||\par
02111       (in == {\cf22 "int_reg_"})||\par
02112       (in == {\cf22 "int_reg"})||\par
02113       (in == {\cf22 "int_re"})||\par
02114       (in == {\cf22 "int_r"})||\par
02115       (in == {\cf22 "int_"})||\par
02116       (in == {\cf22 "int"})||\par
02117       (in == {\cf22 "in"})||\par
02118       (in == {\cf22 "i"})\par
02119     );\par
02120   \}\par
02121 \par
02122   {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} LE>\par
02123   std::string to_int_reg_digs_type_string()\par
02124   \{     {\cf19 return} std::string\{{\cf22 "int_reg_digs"}\};     \}\par
02125 \par
02126   {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B>\par
02127   {\cf18 size_t} size_of_int_reg_digs_type_string_idT()\par
02128   \{   {\cf19 return} (to_int_reg_digs_type_string<UInt_t,B,LE>()).size();       \}\par
02129 \par
02130 \par
02131         {\cf17 template}<type_traits::allowable_base_type_c Int_Type,\par
02132                                         Int_Type Base,\par
02133                                         {\cf18 size_t} Length>\par
02134                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))\par
02135         get_int_reg_digs_t(     std::istream& is,\par
02136                                                                                         std::ostream& errs,\par
02137                                                                                         int_reg_digs_t<Int_Type,Base,Length>& value\par
02138         ) \{\par
02139 \par
02140                 {\cf17 using }lexst     = {\cf17 typename} lex::lexst_e;\par
02141                 {\cf17 using }lextk     = {\cf17 typename} lex::type_token_e;\par
02142                 {\cf17 using }lexact    = {\cf17 typename} lex::action_e;\par
02143 \par
02144                 lexst  actual_st        = lexst::reg_00;\par
02145                 lextk  actual_tk        = lextk::nothing;\par
02146                 lexact actual_act = lexact::nothing;\par
02147 \par
02148                 {\cf18 bool} get_new_char_in                            = {\cf17 true};\par
02149                 std::string buffer_in                           = {\cf22 ""};\par
02150                 std::string type_descriptor = {\cf22 ""};\par
02151                 std::string err                                                 = {\cf22 ""};\par
02152                 {\cf18 char} input_char                                                 = nullchar<char>;\par
02153                 Int_Type explicit_digit                 = 0;\par
02154                 Int_Type explicit_radix                 = 0;\par
02155                 {\cf18 size_t} index                                                            = 0;\par
02156                 semantic_error_number                           = 0;\par
02157                 sintax_error_number                                     = 0;\par
02158 \par
02159                 {\cf19 while} ({\cf17 true}) \{\par
02160                         {\cf19 switch}(actual_st) \{\par
02161                                 {\cf19 case} lexst::reg_00 : \{\par
02162                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02163                                                         actual_st  = lexst::reg_00;\par
02164                                                         get_new_char_in = {\cf17 true};\par
02165                                         \}\par
02166                                         {\cf19 else} {\cf19 if} (is_valid_char(input_char)) \{\par
02167                                                 {\cf19 if} (input_char == {\cf23 'i'}) \{\par
02168                                                         actual_st  = lexst::reg_01;\par
02169                                                         get_new_char_in = {\cf17 true};\par
02170                                                 \}\par
02171                                                 {\cf19 else} \{\par
02172                                                         actual_st  = lexst::err_00;\par
02173                                                         err ={\cf22 "En esta posici\'F3n, que es la primera, \\}\par
02174 {\cf22                                                         solo cabe la letra \\'i\\' del descriptor de tipo \\"int_reg_digs\\""};\par
02175                                                         get_new_char_in = {\cf17 false};\par
02176                                                         ++sintax_error_number;\par
02177                                                 \}\par
02178                                         \}\par
02179                                         {\cf19 else} \{\par
02180                                                 actual_st  = lexst::err_00;\par
02181                                                 err = {\cf22 "En esta posici\'F3n, que es la primera, \\}\par
02182 {\cf22                                                 solo caben caracteres, concretamente la \\'i\\' del descriptor de \\}\par
02183 {\cf22                                                 tipo \\"int_reg_digs\\""};\par
02184                                                 get_new_char_in = {\cf17 false};\par
02185                                                 ++sintax_error_number;\par
02186                                         \}\par
02187                                 \}\par
02188                                 {\cf19 break};\par
02189                                 {\cf19 case} lexst::reg_01 : \{\par
02190                                         {\cf19 if} (is_valid_char(input_char)) \{\par
02191                                                 descriptor_type += value_char(input_char);\par
02192                                                 {\cf19 if} (is_type_id(descriptor_type)) \{\par
02193                                                         {\cf19 if} (descriptor_type == {\cf22 "int_reg_digs"}) \{\par
02194                                                                 actual_st  = lexst::reg_02;\par
02195                                                                 get_new_char_in = {\cf17 true};\par
02196                                                         \}\par
02197                                                         {\cf19 else} \{\par
02198                                                                 actual_st  = lexst::reg_01;\par
02199                                                                 get_new_char_in = {\cf17 true};\par
02200                                                         \}\par
02201                                                 \}\par
02202                                                 {\cf19 else} \{\par
02203                                                         actual_st  = lexst::err_01;\par
02204                                                         err = {\cf22 "En esta posici\'F3n, que es la primera, \\}\par
02205 {\cf22                                                         solo cabe el descriptor de tipo \\"int_reg_digs\\" y has \\}\par
02206 {\cf22                                                         roto la cadena con el \'FAltimo car\'E1cter"};\par
02207                                                         get_new_char_in = {\cf17 false};\par
02208                                                         ++sintax_error_number;\par
02209                                                 \}\par
02210                                         \}\par
02211                                         {\cf19 else} \{\par
02212                                                 actual_st  = lexst::err_01;\par
02213                                                 err = {\cf22 "En esta posici\'F3n, que es la primera, \\}\par
02214 {\cf22                                                 solo cabe el descriptor de tipo \\"int_reg_digs\\", y has \\}\par
02215 {\cf22                                                 introducido un car\'E1cter inv\'E1lido"};\par
02216                                                 get_new_char_in = {\cf17 false};\par
02217                                                 ++sintax_error_number;\par
02218                                         \}\par
02219                                 \}\par
02220                                 {\cf19 break};\par
02221                                 {\cf19 case} lexst::reg_02 : \{\par
02222                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02223                                                 actual_st  = lexst::reg_02;\par
02224                                                 get_new_char_in = {\cf17 true};\par
02225                                         \}\par
02226                                         {\cf19 else} {\cf19 if}  (is_separator(input_char)) \{\par
02227                                                 {\cf19 if} (index < Length) \{\par
02228                                                         value[index] = dig_t\{explicit_digit\};\par
02229                                                         ++index;\par
02230                                                         explicit_digit = 0;\par
02231                                                         actual_st  = lexst::reg_03;\par
02232                                                         get_new_char_in = {\cf17 true};\par
02233                                                 \}\par
02234                                                 {\cf19 else} \{\par
02235                                                         actual_st  = lexst::sem_13;\par
02236                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02237 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02238                                                         get_new_char_in = {\cf17 false};\par
02239                                                         ++semantic_error_number;\par
02240                                                 \}\par
02241                                         \}\par
02242                                         {\cf19 else} \{\par
02243                                                 actual_st  = lexst::err_03;\par
02244                                                 err = {\cf22 "En esta posici\'F3n, estamos esperando un separador\\}\par
02245 {\cf22                                                 # pero el car\'E1cter que has puesto no coincide."};\par
02246                                                 get_new_char_in = {\cf17 false};\par
02247                                                 ++sintax_error_number;\par
02248                                         \}\par
02249                                 \}\par
02250                                 {\cf19 break};\par
02251                                 {\cf19 case} lexst::reg_03 : \{\par
02252                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02253                                                 actual_st  = lexst::reg_03;\par
02254                                                 get_new_char_in = {\cf17 true};\par
02255                                         \}\par
02256                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02257                                                 actual_st  = lexst::reg_06;\par
02258                                                 value.sign = sign_e::vplus;\par
02259                                                 get_new_char_in = {\cf17 true};\par
02260                                         \}\par
02261                                         {\cf19 else} {\cf19 if} (is_sign(input_char)) \{\par
02262                                                 actual_st  = lexst::reg_04;\par
02263                                                 value.sign = sign_value(input_char);\par
02264                                                 get_new_char_in = {\cf17 true};\par
02265                                         \}\par
02266                                         {\cf19 else} {\cf19 if} (is_separator(input_charar)) \{\par
02267                                                 {\cf19 if} (index < Length) \{\par
02268                                                         value[index] = dig_t\{explicit_digit\};\par
02269                                                         ++index;\par
02270                                                         explicit_digit = 0;\par
02271                                                         actual_st  = lexst::reg_07;\par
02272                                                         get_new_char_in = {\cf17 true};\par
02273                                                 \}\par
02274                                                 {\cf19 else} \{\par
02275                                                         actual_st  = lexst::sem_13;\par
02276                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02277 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02278                                                         get_new_char_in = {\cf17 false};\par
02279                                                         ++semantic_error_number;\par
02280                                                 \}\par
02281                                         \}\par
02282                                         {\cf19 else} \{\par
02283                                                 actual_st  = lexst::err_03;\par
02284                                                 err = {\cf22 "En esta posici\'F3n, estamos esperando bien un signo expl\'EDcito\\}\par
02285 {\cf22                                                  , bien un d\'EDgito suponiendo un signo positivo impl\'EDcito, o bien el\\}\par
02286 {\cf22                                                   separador #, pero el car\'E1cter que has puesto no coincide."};\par
02287                                                 get_new_char_in = {\cf17 false};\par
02288                                                 ++sintax_error_number;\par
02289                                         \}\par
02290                                 \}\par
02291                                 {\cf19 break};\par
02292                                 {\cf19 case} lexst::reg_04 :\{\par
02293                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02294                                                 actual_st  = lexst::reg_04;\par
02295                                                 get_new_char_in = {\cf17 true};\par
02296                                         \}\par
02297                                         {\cf19 else} {\cf19 if} (is_separator(input_char)) \{\par
02298                                                 {\cf19 if} (index < Length) \{\par
02299                                                         value[index] = dig_t\{explicit_digit\};\par
02300                                                         ++index;\par
02301                                                         explicit_digit = 0;\par
02302                                                         actual_st  = lexst::reg_05;\par
02303                                                         get_new_char_in = {\cf17 true};\par
02304                                                 \}\par
02305                                                 {\cf19 else} \{\par
02306                                                         actual_st  = lexst::sem_13;\par
02307                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02308 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02309                                                         get_new_char_in = {\cf17 false};\par
02310                                                         ++semantic_error_number;\par
02311                                                 \}\par
02312                                         \}\par
02313                                         {\cf19 else} \{\par
02314                                                 actual_st  = lexst::err_04;\par
02315                                                 err = {\cf22 "En esta posici\'F3n, estamos esperando \\}\par
02316 {\cf22                                                  el separador #, pero el car\'E1cter que has puesto no coincide."};\par
02317                                                 get_new_char_in = {\cf17 false};\par
02318                                                 ++sintax_error_number;\par
02319                                         \}\par
02320                                 \}\par
02321                                 {\cf19 break};\par
02322                                 {\cf19 case} lexst::reg_05 : \{\par
02323                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02324                                                 actual_st  = lexst::reg_05;\par
02325                                                 get_new_char_in = {\cf17 true};\par
02326                                         \}\par
02327                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02328                                                 {\cf19 if} (digit_value(input_char) < Radix) \{\par
02329                                                         actual_st  = lexst::reg_06;\par
02330                                                         explicit_digit *= 10;\par
02331                                                         explicit_digit += digit_value(input_char);\par
02332                                                         get_new_char_in = {\cf17 true};\par
02333                                                 \}\par
02334                                                 {\cf19 else} \{\par
02335                                                         actual_st  = lexst::sem_05;\par
02336                                                         err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02337 {\cf22                                                         es mayor que el valor de la base menos 1 : \\""}+char(Radix-1+{\cf23 '0'})+{\cf22 "\\""};\par
02338                                                         get_new_char_in = {\cf17 false};\par
02339                                                         ++semantic_error_number;\par
02340                                                 \}\par
02341                                         \}\par
02342                                         {\cf19 else} \{\par
02343                                                 actual_st  = lexst::err_05;\par
02344                                                 err = {\cf22 "Estamos esperando bien un espacio, bien un d\'EDgito"};\par
02345                                                 get_new_char_in = {\cf17 false};\par
02346                                                 ++sintax_error_number;\par
02347                                         \}\par
02348                                 \}\par
02349                                 {\cf19 break};\par
02350                                 {\cf19 case} lexst::reg_06 : \{\par
02351                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02352                                                 actual_st  = lexst::reg_06;\par
02353                                                 get_new_char_in = {\cf17 true};\par
02354                                         \}\par
02355                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02356                                                 {\cf19 if} (digit_value(input_char) < Radix) \{\par
02357                                                         explicit_digit *= 10;\par
02358                                                         explicit_digit += digit_value(input_char);\par
02359                                                         {\cf19 if} (explicit_digit < Radix) \{\par
02360                                                                 actual_st  = lexst::reg_06;\par
02361                                                                 get_new_char_in = {\cf17 true};\par
02362                                                         \}\par
02363                                                         {\cf19 else} \{\par
02364                                                                 actual_st  = lexst::sem_06;\par
02365                                                                 stringstream ss;\par
02366                                                                 ss << explicit_digit;\par
02367                                                                 err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02368 {\cf22                                                                 conforma un n\'FAmero que no puede ser un d\'EDgito de la base :\\}\par
02369 {\cf22                                                                  \\""}+char(Radix+{\cf23 '0'})+{\cf22 "\\"el n\'FAmero actual es \\"\\}\par
02370 {\cf22                                                                  "} + std::string(ss.str())  + {\cf22 "\\""};\par
02371                                                                 get_new_char_in = {\cf17 false};\par
02372                                                                 ++semantic_error_number;\par
02373                                                         \}\par
02374                                                 \}\par
02375                                                 {\cf19 else} \{\par
02376                                                         actual_st  = lexst::sem_06;\par
02377                                                         err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02378 {\cf22                                                         es mayor que el valor de la base menos 1 : \\""}+char(Radix-1+{\cf23 '0'})+{\cf22 "\\""};\par
02379                                                         get_new_char_in = {\cf17 false};\par
02380                                                         ++semantic_error_number;\par
02381                                                 \}\par
02382                                         \}\par
02383                                         {\cf19 else} {\cf19 if} (is_separator(input_char)) \{\par
02384                                                 {\cf19 if} (index < Length) \{\par
02385                                                         value[index] = dig_t\{explicit_digit\};\par
02386                                                         ++index;\par
02387                                                         explicit_digit = 0;\par
02388                                                         actual_st  = lexst::reg_08;\par
02389                                                         get_new_char_in = {\cf17 true};\par
02390                                                 \}\par
02391                                                 {\cf19 else} \{\par
02392                                                         actual_st  = lexst::sem_13;\par
02393                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02394 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02395                                                         get_new_char_in = {\cf17 false};\par
02396                                                         ++semantic_error_number;\par
02397                                                 \}\par
02398                                         \}\par
02399                                         {\cf19 else} \{\par
02400                                                 actual_st  = lexst::err_06;\par
02401                                                 err = {\cf22 "Esperamos bien un d\'EDgito 0-9 o bien un separador # "};\par
02402                                                 get_new_char_in = {\cf17 false};\par
02403                                                 ++sintax_error_number;\par
02404                                         \}\par
02405                                 \}\par
02406                                 {\cf19 break};\par
02407                                 {\cf19 case} lexst::reg_07 : \{\par
02408                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02409                                                 actual_st  = lexst::reg_07;\par
02410                                                 get_new_char_in = {\cf17 true};\par
02411                                         \}\par
02412                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02413                                                 {\cf19 if} (value_digit(input_char) < Radix)\{\par
02414                                                         explicit_digit *= 10;\par
02415                                                         explicit_digit += digit_value(input_char);\par
02416                                                         actual_st  = lexst::reg_06;\par
02417                                                         get_new_char_in = {\cf17 true};\par
02418                                                 \}\par
02419                                                 {\cf19 else} \{\par
02420                                                         actual_st  = lexst::sem_08;\par
02421                                                         err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02422 {\cf22                                                         es mayor que el valor de la base menos 1 : \\""}+char(Radix-1+{\cf23 '0'})+{\cf22 "\\""};\par
02423                                                         get_new_char_in = {\cf17 false};\par
02424                                                         ++semantic_error_number;\par
02425                                                 \}\par
02426                                         \}\par
02427                                         {\cf19 else} \{\par
02428                                                 actual_st  = lexst::err_08;\par
02429                                                 err = {\cf22 "Esperamos bien un d\'EDgito 0-9"};\par
02430                                                 get_new_char_in = {\cf17 false};\par
02431                                                 ++sintax_error_number;\par
02432                                         \}\par
02433                                 \}\par
02434                                 {\cf19 break};\par
02435                                 {\cf19 case} lexst::reg_08 : \{\par
02436                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02437                                                 actual_st  = lexst::reg_08;\par
02438                                                 get_new_char_in = {\cf17 true};\par
02439                                         \}\par
02440                                         {\cf19 else} {\cf19 if} (is_radix_descriptor(input_char)) \{\par
02441                                                 {\cf19 if} (index < Length) \{\par
02442                                                         value[index] = dig_t\{explicit_digit\};\par
02443                                                         ++index;\par
02444                                                         explicit_digit = 0;\par
02445                                                         actual_st  = lexst::reg_11;\par
02446                                                         get_new_char_in = {\cf17 true};\par
02447                                                 \}\par
02448                                                 {\cf19 else} \{\par
02449                                                         actual_st  = lexst::sem_13;\par
02450                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02451 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02452                                                         get_new_char_in = {\cf17 false};\par
02453                                                         ++semantic_error_number;\par
02454                                                 \}\par
02455                                         \}\par
02456                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02457                                                 {\cf19 if} (value_digit(input_char) < Radix)\{\par
02458                                                         actual_st  = lexst::reg_09;\par
02459                                                         get_new_char_in = {\cf17 true};\par
02460                                                 \}\par
02461                                                 {\cf19 else} \{\par
02462                                                         actual_st  = lexst::sem_08;\par
02463                                                         err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02464 {\cf22                                                         es mayor que el valor de la base menos 1 : \\""}+char(Radix-1+{\cf23 '0'})+{\cf22 "\\""};\par
02465                                                         get_new_char_in = {\cf17 false};\par
02466                                                         ++semantic_error_number;\par
02467                                                 \}\par
02468                                         \}\par
02469                                         {\cf19 else} \{\par
02470                                                 actual_st  = lexst::err_08;\par
02471                                                 err = {\cf22 "Esperamos bien un d\'EDgito 0-9 o bien el\\}\par
02472 {\cf22                                                  descriptor de base \\'B\\' o \\'b\\'"};\par
02473                                                 get_new_char_in = {\cf17 false};\par
02474                                                 ++sintax_error_number;\par
02475                                         \}\par
02476                                 \}\par
02477                                 {\cf19 break};\par
02478                                 {\cf19 case} lexst::reg_09 : \{\par
02479                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02480                                                 actual_st  = lexst::reg_09;\par
02481                                                 get_new_char_in = {\cf17 true};\par
02482                                         \}\par
02483                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02484                                                 {\cf19 if} (digit_value(input_char) < Radix) \{\par
02485                                                         explicit_digit *= 10;\par
02486                                                         explicit_digit += digit_value(input_char);\par
02487                                                         {\cf19 if} (explicit_digit < Radix) \{\par
02488                                                                 actual_st  = lexst::reg_10;\par
02489                                                                 get_new_char_in = {\cf17 true};\par
02490                                                         \}\par
02491                                                         {\cf19 else} \{\par
02492                                                                 actual_st  = lexst::sem_09;\par
02493                                                                 stringstream ss;\par
02494                                                                 ss << explicit_digit;\par
02495                                                                 err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02496 {\cf22                                                                 conforma un n\'FAmero que no puede ser un d\'EDgito de la base :\\}\par
02497 {\cf22                                                                  \\""}+char(Radix+{\cf23 '0'})+{\cf22 "\\"el n\'FAmero actual es \\"\\}\par
02498 {\cf22                                                                  "} + std::string(ss.str())  + {\cf22 "\\""};\par
02499                                                                 get_new_char_in = {\cf17 false};\par
02500                                                                 ++semantic_error_number;\par
02501                                                         \}\par
02502                                                 \}\par
02503                                                 {\cf19 else} \{\par
02504                                                         actual_st  = lexst::sem_09;\par
02505                                                         err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02506 {\cf22                                                         es mayor que el valor de la base menos 1 : \\""}+char(Radix-1+{\cf23 '0'})+{\cf22 "\\""};\par
02507                                                         get_new_char_in = {\cf17 false};\par
02508                                                         ++semantic_error_number;\par
02509                                                 \}\par
02510                                         \}\par
02511                                         {\cf19 else} {\cf19 if} (is_separator(input_char)) \{\par
02512                                                 {\cf19 if} (index < Length) \{\par
02513                                                         value[index] = dig_t\{explicit_digit\};\par
02514                                                         ++index;\par
02515                                                         explicit_digit = 0;\par
02516                                                         actual_st  = lexst::reg_10;\par
02517                                                         get_new_char_in = {\cf17 true};\par
02518                                                 \}\par
02519                                                 {\cf19 else} \{\par
02520                                                         actual_st  = lexst::sem_13;\par
02521                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02522 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02523                                                         get_new_char_in = {\cf17 false};\par
02524                                                         ++semantic_error_number;\par
02525                                                 \}\par
02526                                         \}\par
02527                                         {\cf19 else} \{\par
02528                                                 actual_st  = lexst::err_09;\par
02529                                                 err = {\cf22 "Esperamos bien un d\'EDgito 0-9 o bien un separador # "};\par
02530                                                 get_new_char_in = {\cf17 false};\par
02531                                                 ++sintax_error_number;\par
02532                                         \}\par
02533                                 \}\par
02534                                 {\cf19 break};\par
02535                                 {\cf19 case} lexst::reg_10 : \{\par
02536                                         {\cf19 if}(is_whitespace(input_char)) \{\par
02537                                                 actual_st  = lexst::reg_10;\par
02538                                                 get_new_char_in = {\cf17 true};\par
02539                                         \}\par
02540                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02541                                                 {\cf19 if} (digit_value(input_char) < Radix) \{\par
02542                                                         explicit_digit *= 10;\par
02543                                                         explicit_digit += digit_value(input_char);\par
02544                                                         {\cf19 if} (explicit_digit < Radix) \{\par
02545                                                                 actual_st  = lexst::reg_09;\par
02546                                                                 get_new_char_in = {\cf17 true};\par
02547                                                         \}\par
02548                                                         {\cf19 else} \{\par
02549                                                                 actual_st  = lexst::sem_10;\par
02550                                                                 stringstream ss;\par
02551                                                                 ss << explicit_digit;\par
02552                                                                 err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02553 {\cf22                                                                 conforma un n\'FAmero que no puede ser un d\'EDgito de la base :\\}\par
02554 {\cf22                                                                  \\" "} + char(Radix+{\cf23 '0'}) + {\cf22 " \\"el n\'FAmero actual es \\"\\}\par
02555 {\cf22                                                                  "} + std::string(ss.str())  + {\cf22 "\\""};\par
02556                                                                 get_new_char_in = {\cf17 false};\par
02557                                                                 ++semantic_error_number;\par
02558                                                         \}\par
02559                                                 \}\par
02560                                         \}\par
02561                                         {\cf19 else} {\cf19 if} (is_radix_descriptor(input_char)) \{\par
02562                                                 {\cf19 if} (index < Length) \{\par
02563                                                         value[index] = dig_t\{explicit_digit\};\par
02564                                                         ++index;\par
02565                                                         explicit_digit = 0;\par
02566                                                         actual_st  = lexst::reg_11;\par
02567                                                         get_new_char_in = {\cf17 true};\par
02568                                                 \}\par
02569                                                 {\cf19 else} \{\par
02570                                                         actual_st  = lexst::sem_13;\par
02571                                                         err = {\cf22 "El \'EDndice acaba de igualar la longitud m\'E1xima,\\}\par
02572 {\cf22                                                          con lo que ya es err\'F3neo."};\par
02573                                                         get_new_char_in = {\cf17 false};\par
02574                                                         ++semantic_error_number;\par
02575                                                 \}\par
02576                                         \}\par
02577                                         {\cf19 else} \{\par
02578                                                 actual_st  = lexst::err_10;\par
02579                                                 err = {\cf22 "Esperamos bien un d\'EDgito 0-9 o bien un descriptor\\}\par
02580 {\cf22                                                  de base como \\'b\\' o \\'B\\'"};\par
02581                                                 get_new_char_in = {\cf17 false};\par
02582                                                 ++sintax_error_number;\par
02583                                         \}\par
02584                                 \}\par
02585                                 {\cf19 break};\par
02586                                 {\cf19 case} lexst::reg_11 : \{\par
02587                                         {\cf19 if}(is_whitespace(input_char)) \{\par
02588                                                 actual_st  = lexst::reg_11;\par
02589                                                 get_new_char_in = {\cf17 true};\par
02590                                         \}\par
02591                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02592                                                 {\cf19 if} (digit_value(input_char) <= Radix) \{\par
02593                                                         explicit_radix *= 10;\par
02594                                                         explicit_radix += digit_value(input_char);\par
02595                                                         {\cf19 if} (explicit_radix <= Radix) \{\par
02596                                                                 actual_st  = lexst::reg_12;\par
02597                                                                 get_new_char_in = {\cf17 true};\par
02598                                                         \}\par
02599                                                         {\cf19 else} \{\par
02600                                                                 actual_st  = lexst::sem_11;\par
02601                                                                 stringstream ss;\par
02602                                                                 ss << explicit_digit;\par
02603                                                                 err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02604 {\cf22                                                                 conforma un n\'FAmero que no puede ser un d\'EDgito de la base :\\}\par
02605 {\cf22                                                                  \\" "} + char(Radix+{\cf23 '0'}) + {\cf22 " \\"el n\'FAmero actual es \\"\\}\par
02606 {\cf22                                                                  "} + std::string(ss.str())  + {\cf22 "\\""};\par
02607                                                                 get_new_char_in = {\cf17 false};\par
02608                                                                 ++semantic_error_number;\par
02609                                                         \}\par
02610                                                 \}\par
02611                                         \}\par
02612                                         {\cf19 else} \{\par
02613                                                 actual_st  = lexst::err_11;\par
02614                                                 err = {\cf22 "Esperamos un d\'EDgito 0-9"};\par
02615                                                 get_new_char_in = {\cf17 false};\par
02616                                                 ++sintax_error_number;\par
02617                                         \}\par
02618                                 \}\par
02619                                 {\cf19 break};\par
02620                                 {\cf19 case} lexst::reg_12 : \{\par
02621                                         {\cf19 if} (is_whitespace(input_char)) \{\par
02622                                                 actual_st  = lexst::reg_12;\par
02623                                                 get_new_char_in = {\cf17 true};\par
02624                                         \}\par
02625                                         {\cf19 else} {\cf19 if} (is_digit(input_char)) \{\par
02626                                                 {\cf19 if} (digit_value(input_char) <= Radix) \{\par
02627                                                         explicit_radix *= 10;\par
02628                                                         explicit_radix += digit_value(input_char);\par
02629                                                         {\cf19 if} (explicit_digit <= Radix) \{\par
02630                                                                 actual_st  = lexst::reg_12;\par
02631                                                                 get_new_char_in = {\cf17 true};\par
02632                                                         \}\par
02633                                                         {\cf19 else} \{\par
02634                                                                 actual_st  = lexst::sem_12;\par
02635                                                                 stringstream ss;\par
02636                                                                 ss << explicit_digit;\par
02637                                                                 err = {\cf22 "El d\'EDgito que has escrito \\'"}+ input_char + {\cf22 " \\'\\}\par
02638 {\cf22                                                                 conforma un n\'FAmero que no puede ser un d\'EDgito de la base :\\}\par
02639 {\cf22                                                                  \\" "}+ char(Radix+{\cf23 '0'})+{\cf22 " \\"el n\'FAmero actual es \\"\\}\par
02640 {\cf22                                                                  "} + std::string(ss.str())  + {\cf22 "\\""};\par
02641                                                                 get_new_char_in = {\cf17 false};\par
02642                                                                 ++semantic_error_number;\par
02643                                                         \}\par
02644                                                 \}\par
02645                                         \}\par
02646                                         {\cf19 else} {\cf19 if} (is_end_descriptor(input_char)) \{\par
02647                                                 explicit_radix = 0;\par
02648                                                 {\cf19 if} (index == L) \{\par
02649                                                         actual_st  = lexst::reg_13;\par
02650                                                         get_new_char_in = {\cf17 false};\par
02651                                                         {\cf19 return};\par
02652                                                 \}\par
02653                                                 {\cf19 else} {\cf19 if} (index < L)\{\par
02654                                                         actual_st  = lexst::sem_13;\par
02655                                                         stringstream ss;\par
02656                                                         ss << index;\par
02657                                                         stringstream ll;\par
02658                                                         ll << Length;\par
02659                                                         err = {\cf22 "El n\'FAmero de d\'EDgitos introducidos es menor que\\}\par
02660 {\cf22                                                          la longitud del registro "} + std::string(ss.str())  + {\cf22 "\\" \\}\par
02661 {\cf22                                                          < "}+ll+{\cf22 " "};\par
02662                                                         get_new_char_in = {\cf17 false};\par
02663                                                         {\cf19 return};\par
02664                                                 \}\par
02665                                                 {\cf19 else} \{\par
02666                                                         actual_st  = lexst::sem_13;\par
02667                                                         stringstream ss;\par
02668                                                         ss << index;\par
02669                                                         stringstream ll;\par
02670                                                         ll << Length;\par
02671                                                         err = {\cf22 "El n\'FAmero de d\'EDgitos introducidos es mayor que\\}\par
02672 {\cf22                                                          la longitud del registro "} + std::string(ss.str())  + {\cf22 "\\" \\}\par
02673 {\cf22                                                          > "}+ll+{\cf22 " "};\par
02674                                                         get_new_char_in = {\cf17 false};\par
02675                                                         {\cf19 return};\par
02676                                                 \}\par
02677                                         \}\par
02678                                         {\cf19 else} \{\par
02679                                                 actual_st  = lexst::err_12;\par
02680                                                 err = {\cf22 "Esperamos un d\'EDgito 0-9 o fin de la entrada"};\par
02681                                                 get_new_char_in = {\cf17 false};\par
02682                                                 ++sintax_error_number;\par
02683                                         \}\par
02684                                 \}\par
02685                                 {\cf19 break};\par
02686                                 {\cf19 case} lexst::err_00 : \{\par
02687                                         actual_st  = lexst::reg_00;\par
02688                                         errs << err << {\cf23 '\\n'};\par
02689                                 \}\par
02690                                 {\cf19 break};\par
02691                                 {\cf19 case} lexst::err_01 : \{\par
02692                                         actual_st  = lexst::reg_01;\par
02693                                         errs << err << {\cf23 '\\n'};\par
02694                                 \}\par
02695                                 {\cf19 break};\par
02696                                 {\cf19 case} lexst::err_02 : \{\par
02697                                         actual_st  = lexst::reg_02;\par
02698                                         errs << err << {\cf23 '\\n'};\par
02699                                 \}\par
02700                                 {\cf19 break};\par
02701                                 {\cf19 case} lexst::err_03 : \{\par
02702                                         actual_st  = lexst::reg_03;\par
02703                                         errs << err << {\cf23 '\\n'};\par
02704                                 \}\par
02705                                 {\cf19 break};\par
02706                                 {\cf19 case} lexst::err_04 : \{\par
02707                                         actual_st  = lexst::reg_04;\par
02708                                         errs << err << {\cf23 '\\n'};\par
02709                                 \}\par
02710                                 {\cf19 break};\par
02711                                 {\cf19 case} lexst::err_05 : \{\par
02712                                         actual_st  = lexst::reg_05;\par
02713                                         errs << err << {\cf23 '\\n'};\par
02714                                 \}\par
02715                                 {\cf19 break};\par
02716                                 {\cf19 case} lexst::err_06 : \{\par
02717                                         actual_st  = lexst::reg_06;\par
02718                                         errs << err << {\cf23 '\\n'};\par
02719                                 \}\par
02720                                 {\cf19 break};\par
02721                                 {\cf19 case} lexst::err_07 : \{\par
02722                                         actual_st  = lexst::reg_07;\par
02723                                         errs << err << {\cf23 '\\n'};\par
02724                                 \}\par
02725                                 {\cf19 break};\par
02726                                 {\cf19 case} lexst::err_08 : \{\par
02727                                         actual_st  = lexst::reg_08;\par
02728                                         errs << err << {\cf23 '\\n'};\par
02729                                 \}\par
02730                                 {\cf19 break};\par
02731                                 {\cf19 case} lexst::err_09 : \{\par
02732                                         actual_st  = lexst::reg_09;\par
02733                                         errs << err << {\cf23 '\\n'};\par
02734                                 \}\par
02735                                 {\cf19 break};\par
02736                                 {\cf19 case} lexst::err_10 : \{\par
02737                                         actual_st  = lexst::reg_10;\par
02738                                         errs << err << {\cf23 '\\n'};\par
02739                                 \}\par
02740                                 {\cf19 break};\par
02741                                 {\cf19 case} lexst::err_11 : \{\par
02742                                         actual_st  = lexst::reg_11;\par
02743                                         errs << err << {\cf23 '\\n'};\par
02744                                 \}\par
02745                                 {\cf19 break};\par
02746                                 {\cf19 case} lexst::err_12 : \{\par
02747                                         actual_st  = lexst::reg_12;\par
02748                                         errs << err << {\cf23 '\\n'};\par
02749                                 \}\par
02750                                 {\cf19 break};\par
02751                                 {\cf19 case} lexst::err_13 : \{\par
02752                                         actual_st  = lexst::reg_13;\par
02753                                         errs << err << {\cf23 '\\n'};\par
02754                                 \}\par
02755                                 {\cf19 break};\par
02756                                 {\cf19 case} lexst::sem_00 : \{\par
02757                                         actual_st  = lexst::reg_00;\par
02758                                         errs << err << {\cf23 '\\n'};\par
02759                                 \}\par
02760                                 {\cf19 case} lexst::sem_01 : \{\par
02761                                         actual_st  = lexst::reg_01;\par
02762                                         errs << err << {\cf23 '\\n'};\par
02763                                 \}\par
02764                                 {\cf19 case} lexst::sem_02 : \{\par
02765                                         actual_st  = lexst::reg_02;\par
02766                                         errs << err << {\cf23 '\\n'};\par
02767                                 \}\par
02768                                 {\cf19 case} lexst::sem_03 : \{\par
02769                                         actual_st  = lexst::reg_03;\par
02770                                         errs << err << {\cf23 '\\n'};\par
02771                                 \}\par
02772                                 {\cf19 case} lexst::sem_04 : \{\par
02773                                         actual_st  = lexst::reg_04;\par
02774                                         errs << err << {\cf23 '\\n'};\par
02775                                 \}\par
02776                                 {\cf19 case} lexst::sem_05 : \{\par
02777                                         actual_st  = lexst::reg_05;\par
02778                                         errs << err << {\cf23 '\\n'};\par
02779                                 \}\par
02780                                 {\cf19 case} lexst::sem_06 : \{\par
02781                                         actual_st  = lexst::reg_06;\par
02782                                         errs << err << {\cf23 '\\n'};\par
02783                                 \}\par
02784                                 {\cf19 case} lexst::sem_07 : \{\par
02785                                         actual_st  = lexst::reg_07;\par
02786                                         errs << err << {\cf23 '\\n'};\par
02787                                 \}\par
02788                                 {\cf19 case} lexst::sem_08 : \{\par
02789                                         actual_st  = lexst::reg_08;\par
02790                                         errs << err << {\cf23 '\\n'};\par
02791                                 \}\par
02792                                 {\cf19 case} lexst::sem_09 : \{\par
02793                                         actual_st  = lexst::reg_09;\par
02794                                         errs << err << {\cf23 '\\n'};\par
02795                                 \}\par
02796                                 {\cf19 case} lexst::sem_10 : \{\par
02797                                         actual_st  = lexst::reg_10;\par
02798                                         errs << err << {\cf23 '\\n'};\par
02799                                 \}\par
02800                                 {\cf19 case} lexst::sem_11 : \{\par
02801                                         actual_st  = lexst::reg_11;\par
02802                                         errs << err << {\cf23 '\\n'};\par
02803                                 \}\par
02804                                 {\cf19 case} lexst::sem_12 : \{\par
02805                                         actual_st  = lexst::reg_12;\par
02806                                         errs << err << {\cf23 '\\n'};\par
02807                                 \}\par
02808                         \}\par
02809                         {\cf19 if} ((semantic_error_number > 1)||(sintax_error_number > 2)) \{\par
02810                                 value = reg_digs_t<Int_Type,Radix,Length>::reg_digs_0();\par
02811                                 errs << {\cf22 "N\'FAmero de errores sem\'E1nticos = "} << semantic_error_number << {\cf23 '\\n'};\par
02812                                 errs << {\cf22 "N\'FAmero de errores sint\'E1cticos = "} << sintax_error_number << {\cf23 '\\n'};\par
02813                                 errs << {\cf22 "Devolvemos valor por defecto nulo"} << {\cf23 '\\n'};\par
02814                                 {\cf19 return};\par
02815                         \}\par
02816                         {\cf19 if} (get_new_char_in) \{\par
02817                                 is >> input_char;\par
02818                         \}\par
02819                 \}\par
02820         \}\par
02821 \par
02822         {\cf17 template}<type_traits::allowable_base_type_c Int_Type,\par
02823                                         Int_Type Base,\par
02824                                         {\cf18 size_t} Length>\par
02825                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))\par
02826         std::istream &\par
02827         operator >> (std::istream & is,int_reg_digs_t<Int_Type,Base,Length> & arg) \{\par
02828                 {\cf17 enum} estado_e \{\par
02829                         e0ini   , e1r           , e1e           , e1g                   , e1sep         ,\par
02830                         e1d             , e1i           , e2g           , e2start       , e2dig         ,\par
02831                         e2dp    , e2end , e2B           , e3dig         , e0fin\par
02832                 \};\par
02834                 std::string sds;\par
02836                 {\cf17 using }inttype = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
02837                 {\cf17 using }dig_t = dig_t<Int_Type,Base>;\par
02838                 {\cf17 using }int_reg_digs_t = int_reg_digs_t<Int_Type,Base,Length>;\par
02840                 std::size_t     indice\{0\};\par
02842                 Int_Type                digito\{0\};\par
02843                 std::size_t longitud\{0\};\par
02844                 inttype                 numero_base_recogido\{0\};\par
02846                 int_reg_digs_t& numero_ret\{arg\};\par
02848                 estado_e est_act = e0ini;\par
02850                 {\cf18 char} c\{{\cf23 '\\0'}\};\par
02852                 is >> sds;\par
02854                 {\cf19 do} \{\par
02855                         c = sds[indice];\par
02856                         {\cf19 switch}(est_act) \{\par
02857                                 {\cf19 case} e0ini :\par
02858                                         \{\par
02859                                                 {\cf19 if} (c=={\cf23 'r'}) \{\par
02860                                                         est_act = e1r;\par
02861                                                 \} {\cf19 else} \{\par
02862                                                         est_act = e0ini;\par
02863                                                 \}\par
02864                                         \}\par
02865                                         {\cf19 break};\par
02866                                 {\cf19 case} e1r :\par
02867                                         \{\par
02868                                                 \{\par
02869                                                         {\cf19 if} (c=={\cf23 'e'}) \{\par
02870                                                                 est_act = e1e;\par
02871                                                         \}\par
02872                                                         {\cf19 else} \{\par
02873                                                                 est_act = e0ini;\par
02874                                                         \}\par
02875                                                 \}\par
02876                                         \}\par
02877                                         {\cf19 break};\par
02878                                 {\cf19 case} e1e :\par
02879                                         \{\par
02880                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
02881                                                         est_act = e1g;\par
02882                                                 \}\par
02883                                                 {\cf19 else}  \{\par
02884                                                         est_act = e0ini;\par
02885                                                 \}\par
02886                                         \}\par
02887                                         {\cf19 break};\par
02888                                 {\cf19 case} e1g :\par
02889                                         \{\par
02890                                                 {\cf19 if} (c=={\cf23 '_'}) \{\par
02891                                                         est_act = e1sep;\par
02892                                                 \}\par
02893                                                 {\cf19 else}  \{\par
02894                                                         est_act = e0ini;\par
02895                                                 \}\par
02896                                         \}\par
02897                                         {\cf19 break};\par
02898                                 {\cf19 case} e1sep :\par
02899                                         \{\par
02900                                                 {\cf19 if} (c=={\cf23 'd'}) \{\par
02901                                                         est_act = e1d;\par
02902                                                 \}\par
02903                                                 {\cf19 else}  \{\par
02904                                                         est_act = e0ini;\par
02905                                                 \}\par
02906                                         \}\par
02907                                         {\cf19 break};\par
02908                                 {\cf19 case} e1d :\par
02909                                         \{\par
02910                                                 {\cf19 if} (c=={\cf23 'i'}) \{\par
02911                                                         est_act = e1i;\par
02912                                                 \}\par
02913                                                 {\cf19 else}  \{\par
02914                                                         est_act = e0ini;\par
02915                                                 \}\par
02916                                         \}\par
02917                                         {\cf19 break};\par
02918                                 {\cf19 case} e1i :\par
02919                                         \{\par
02920                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
02921                                                         est_act = e2g;\par
02922                                                 \}\par
02923                                                 {\cf19 else}  \{\par
02924                                                         est_act = e0ini;\par
02925                                                 \}\par
02926                                         \}\par
02927                                         {\cf19 break};\par
02928                                 {\cf19 case} e2g :\par
02929                                         \{\par
02930                                                 {\cf19 if} (c=={\cf23 '#'}) \{\par
02931                                                         est_act = e2start;\par
02932                                                 \}\par
02933                                                 {\cf19 else}  \{\par
02934                                                         est_act = e0ini;\par
02935                                                 \}\par
02936                                         \}\par
02937                                         {\cf19 break};\par
02938                                 {\cf19 case} e2start :\par
02939                                         \{\par
02940                                                 {\cf19 if} (((c>={\cf23 '0'})&&(c<={\cf23 '9'}))&&(std::abs(c-{\cf23 '0'})<Base)) \{\par
02941                                                         est_act = e2dig;\par
02942                                                         digito = (c-{\cf23 '0'});\par
02943                                                         longitud = 0;\par
02944                                                         numero_base_recogido = 0;\par
02945                                                         numero_ret = int_reg_digs_t::regd_0();\par
02946                                                 \}\par
02947                                                 {\cf19 else}  \{\par
02948                                                         est_act = e0ini;\par
02949                                                         digito = 0;\par
02950                                                         longitud = 0;\par
02951                                                         numero_base_recogido = 0;\par
02952                                                         numero_ret = int_reg_digs_t::regd_0();\par
02953                                                 \}\par
02954                                         \}\par
02955                                         {\cf19 break};\par
02956                                 {\cf19 case} e2dig :\par
02957                                         \{\par
02958                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
02959                                                 {\cf17 const} {\cf18 bool} dig_lt_Base\{digito<Base\};\par
02960                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{dig_c && dig_lt_Base\};\par
02961                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{c_es_dig_B && (longitud < Length-1)\};\par
02962                                                 {\cf17 const} {\cf18 bool} tt_dig_B_cdl \{(c=={\cf23 ':'})&&dig_lt_Base&&(longitud < Length-1)\};\par
02963                                                 {\cf17 const} {\cf18 bool} tf_dig_B_cdl \{(c=={\cf23 '#'})&&dig_lt_Base&&(longitud == Length-1)\};\par
02964                                                 {\cf19 if} (dig_B_cdl) \{\par
02965                                                         digito *= 10;\par
02966                                                         digito += (c-{\cf23 '0'});\par
02967                                                         est_act = e2dig;\par
02968                                                 \}\par
02969                                                 {\cf19 else} {\cf19 if} (tt_dig_B_cdl) \{\par
02970                                                         est_act = e2dp;\par
02971                                                 \}\par
02972                                                 {\cf19 else} {\cf19 if} (tf_dig_B_cdl) \{\par
02973                                                         est_act = e2end;\par
02974                                                 \}\par
02975                                                 {\cf19 else}  \{\par
02976                                                         est_act = e0ini;\par
02977                                                         digito = 0;\par
02978                                                         longitud = 0;\par
02979                                                         numero_base_recogido = 0;\par
02980                                                         numero_ret = int_reg_digs_t::regd_0();\par
02981                                                 \}\par
02982                                         \}\par
02983                                         {\cf19 break};\par
02984                                 {\cf19 case} e2dp :\par
02985                                         \{\par
02986                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
02987                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{(std::abs(c-{\cf23 '0'})<Base) && (digito<Base)\};\par
02988                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{dig_c && c_es_dig_B && (longitud < Length-1)\};\par
02989                                                 {\cf17 const} {\cf18 bool} rdig_B_cdl \{dig_c && c_es_dig_B && dig_B_cdl\};\par
02990                                                 {\cf19 if} (rdig_B_cdl) \{\par
02991                                                         est_act = e2dig;\par
02992                                                         numero_ret[Length-1-longitud] = dig_t(digito);\par
02993                                                         ++longitud;\par
02994                                                         digito = c-{\cf23 '0'};\par
02995                                                 \}\par
02996                                                 {\cf19 else}  \{\par
02997                                                         est_act = e0ini;\par
02998                                                         digito = 0;\par
02999                                                         longitud = 0;\par
03000                                                         numero_base_recogido = 0;\par
03001                                                         indice = 0;\par
03002                                                         numero_ret = int_reg_digs_t::regd_0();\par
03003                                                 \}\par
03004                                         \}\par
03005                                         {\cf19 break};\par
03006                                 {\cf19 case} e2end :\par
03007                                         \{\par
03008                                                 {\cf17 const} {\cf18 bool} c_es_sepfin \{c == {\cf23 'B'}\};\par
03009                                                 {\cf17 const} {\cf18 bool} d_es_digB \{digito < Base\};\par
03010                                                 {\cf17 const} {\cf18 bool} l_coincide \{longitud == Length-1\};{\cf20 // llega al cero ?}\par
03011                                                 {\cf17 const} {\cf18 bool} rdigB_cdl \{c_es_sepfin && d_es_digB && l_coincide\};\par
03012                                                 {\cf19 if} (rdigB_cdl) \{\par
03013                                                         est_act = e2B;\par
03014                                                         numero_ret[Length-1-longitud] = dig_t(digito);\par
03015                                                         digito = 0;\par
03016                                                         longitud = 0;\par
03017                                                 \}\par
03018                                                 {\cf19 else}  \{\par
03019                                                         est_act = e0ini;\par
03020                                                         indice = 0;\par
03021                                                         digito = 0;\par
03022                                                         longitud = 0;\par
03023                                                         numero_ret = int_reg_digs_t::regd_0();\par
03024                                                 \}\par
03025                                         \}\par
03026                                         {\cf19 break};\par
03027                                 {\cf19 case} e2B :\par
03028                                         \{\par
03029                                                 {\cf19 if} ((c >= {\cf23 '0'})&&(c <= {\cf23 '9'})) \{\par
03030                                                         est_act = e3dig;\par
03031                                                         numero_base_recogido = c-{\cf23 '0'};\par
03032                                                         digito = 0;\par
03033                                                 \}\par
03034                                                 {\cf19 else}  \{\par
03035                                                         est_act = e0ini;\par
03036                                                         digito = 0;\par
03037                                                         longitud = 0;\par
03038                                                         numero_base_recogido = 0;\par
03039                                                         numero_ret = int_reg_digs_t::regd_0();\par
03040                                                 \}\par
03041                                         \}\par
03042                                         {\cf19 break};\par
03043                                 {\cf19 case} e3dig :\par
03044                                         \{\par
03045                                                 {\cf17 const} {\cf18 bool} espacio_c \{c < 16\};\par
03046                                                 {\cf17 const} {\cf18 bool} digito_c \{(c>={\cf23 '0'}) && (c<={\cf23 '9'})\};\par
03047                                                 {\cf17 const} {\cf18 bool} num_base_lt_Base \{numero_base_recogido < Base\};\par
03048                                                 {\cf17 const} {\cf18 bool} num_base_eq_Base \{numero_base_recogido == Base\};\par
03049                                                 {\cf19 if} (digito_c && num_base_lt_Base) \{\par
03050                                                         est_act = e3dig;\par
03051                                                         numero_base_recogido *= 10;\par
03052                                                         numero_base_recogido += (c-{\cf23 '0'});\par
03053                                                 \}\par
03054                                                 {\cf19 else} {\cf19 if} (espacio_c && num_base_eq_Base) \{\par
03055                                                         numero_base_recogido *= 10;\par
03056                                                         numero_base_recogido += (c-{\cf23 '0'});\par
03057                                                                 est_act = e0fin;\par
03058                                                                 numero_base_recogido = 0;\par
03059                                                 \}\par
03060                                                 {\cf19 else}  \{\par
03061                                                         est_act = e0ini;\par
03062                                                         numero_base_recogido = 0;\par
03063                                                 \}\par
03064                                         \}\par
03065                                         {\cf19 break};\par
03066                                 {\cf19 case} e0fin :\par
03067                                         \{\par
03068                                                 est_act = e0fin;\par
03069                                         \}\par
03070                         \}\par
03071                         ++indice;\par
03072                 \} {\cf19 while} (est_act!=e0fin);\par
03073 \par
03074                 {\cf19 return} (is);\par
03075         \}\par
03076 \par
03077         {\cf17 template}<type_traits::allowable_base_type_c Int_Type,Int_Type Base,std::{\cf18 size_t} Long>\par
03078                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>())\par
03079         std::ostream &\par
03080         {\cf17 operator} << (std::ostream & os,{\cf17 const} int_reg_digs_t<Int_Type,Base,Long> & arg) \{\par
03081                 {\cf17 using }inttype = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
03082                 os << {\cf22 "reg_dig#"};\par
03083                 {\cf19 for}(std::int64_t ix\{Long-1\} ; ix > 0 ; --ix) \{\par
03084                                 os << static_cast<inttype>(arg(ix));\par
03085                                 os << {\cf23 ':'};\par
03086                 \}\par
03087                 os << static_cast<inttype>(arg(0));\par
03088                 os << {\cf22 "#B"};\par
03089                 os << static_cast<inttype>(Base);\par
03090                 {\cf19 return} (os);\par
03091         \}\par
03092 \par
03093 \par
03094 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo lexer_parser.hpp\par \pard\plain 
{\tc\tcl2 \v lexer_parser.hpp}
{\xe \v lexer_parser.hpp}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "auxiliary_types.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para lexer_parser.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "lexer__parser_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "lexer__parser_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr::lex}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeraciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::lex::reglexst_e} : uint16_t \{ {\b NumRepr::lex::st_00} = 0
, {\b NumRepr::lex::st_01} = 1
, {\b NumRepr::lex::st_02} =2
, {\b NumRepr::lex::st_03} =3
, {\b NumRepr::lex::st_04} = 4
, {\b NumRepr::lex::st_05} = 5
, {\b NumRepr::lex::st_06} = 6
, {\b NumRepr::lex::st_07} = 7
, {\b NumRepr::lex::st_08} =8
, {\b NumRepr::lex::st_09} =9
, {\b NumRepr::lex::st_10} =10
, {\b NumRepr::lex::st_11} =11
, {\b NumRepr::lex::st_12} =12
, {\b NumRepr::lex::st_13} =13
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::lex::sintaxerrlexst_e} : uint16_t \{ {\b NumRepr::lex::st_err_00} = 256
, {\b NumRepr::lex::st_err_01} = 257
, {\b NumRepr::lex::st_err_02} = 258
, {\b NumRepr::lex::st_err_03} = 259
, {\b NumRepr::lex::st_err_04} = 260
, {\b NumRepr::lex::st_err_05} = 261
, {\b NumRepr::lex::st_err_06} = 262
, {\b NumRepr::lex::st_err_07} = 263
, {\b NumRepr::lex::st_err_08} = 264
, {\b NumRepr::lex::st_err_09} = 265
, {\b NumRepr::lex::st_err_10} = 266
, {\b NumRepr::lex::st_err_11} = 267
, {\b NumRepr::lex::st_err_12} = 268
, {\b NumRepr::lex::st_err_13} = 269
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::lex::semerrlexst_e} : uint16_t \{ {\b NumRepr::lex::st_sem_00} = 4096
, {\b NumRepr::lex::st_sem_01} = 4097
, {\b NumRepr::lex::st_sem_02} = 4098
, {\b NumRepr::lex::st_sem_03} = 4099
, {\b NumRepr::lex::st_sem_04} = 4100
, {\b NumRepr::lex::st_sem_05} = 4101
, {\b NumRepr::lex::st_sem_06} = 4102
, {\b NumRepr::lex::st_sem_07} = 4103
, {\b NumRepr::lex::st_sem_08} = 4104
, {\b NumRepr::lex::st_sem_09} = 4105
, {\b NumRepr::lex::st_sem_10} = 4106
, {\b NumRepr::lex::st_sem_11} = 4107
, {\b NumRepr::lex::st_sem_12} = 4108
, {\b NumRepr::lex::st_sem_13} = 4109
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b NumRepr::lex::lexst_e} : uint16_t \{ {\b NumRepr::lex::reg_00} = 0
, {\b NumRepr::lex::reg_01} = 1
, {\b NumRepr::lex::reg_02} = 2
, {\b NumRepr::lex::reg_03} = 3
, {\b NumRepr::lex::reg_04} = 4
, {\b NumRepr::lex::reg_05} = 5
, {\b NumRepr::lex::reg_06} = 6
, {\b NumRepr::lex::reg_07} = 7
, {\b NumRepr::lex::reg_08} = 8
, {\b NumRepr::lex::reg_09} = 9
, {\b NumRepr::lex::reg_10} = 10
, {\b NumRepr::lex::reg_11} = 11
, {\b NumRepr::lex::reg_12} = 12
, {\b NumRepr::lex::reg_13} = 13
, {\b NumRepr::lex::err_00} = 256
, {\b NumRepr::lex::err_01} = 257
, {\b NumRepr::lex::err_02} = 258
, {\b NumRepr::lex::err_03} = 259
, {\b NumRepr::lex::err_04} = 260
, {\b NumRepr::lex::err_05} = 261
, {\b NumRepr::lex::err_06} = 262
, {\b NumRepr::lex::err_07} = 263
, {\b NumRepr::lex::err_08} = 264
, {\b NumRepr::lex::err_09} = 265
, {\b NumRepr::lex::err_10} = 266
, {\b NumRepr::lex::err_11} = 267
, {\b NumRepr::lex::err_12} = 268
, {\b NumRepr::lex::err_13} = 269
, {\b NumRepr::lex::sem_00} = 4096
, {\b NumRepr::lex::sem_01} = 4097
, {\b NumRepr::lex::sem_02} = 4098
, {\b NumRepr::lex::sem_03} = 4099
, {\b NumRepr::lex::sem_04} = 4100
, {\b NumRepr::lex::sem_05} = 4101
, {\b NumRepr::lex::sem_06} = 4102
, {\b NumRepr::lex::sem_07} = 4103
, {\b NumRepr::lex::sem_08} = 4104
, {\b NumRepr::lex::sem_09} = 4105
, {\b NumRepr::lex::sem_10} = 4106
, {\b NumRepr::lex::sem_11} = 4107
, {\b NumRepr::lex::sem_12} = 4108
, {\b NumRepr::lex::sem_13} = 4109
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_digit} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b NumRepr::lex::digit_value} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_valid_char} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::char_value} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_separator} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_end_of_number} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_whitespace} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_end_descriptor} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_radix_descriptor} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b NumRepr::lex::is_sign} (char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sign_e {\b NumRepr::lex::sign_value} (char)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lexer_parser.hpp\par \pard\plain 
{\tc\tcl2 \v lexer_parser.hpp}
{\xe \v lexer_parser.hpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef LEXER_PARSER_HPP_INCLUDED}\par
00002 {\cf21 #define LEXER_PARSER_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "auxiliary_types.hpp"}\par
00005 \par
00006 {\cf17 namespace }NumRepr \{\par
00007 {\cf17 namespace }lex \{\par
00008   {\cf17 enum class} reglexst_e : uint16_t \{\par
00009     st_00= 0,st_01= 1,st_02=2,st_03=3,st_04= 4,st_05= 5,\par
00010     st_06= 6,st_07= 7,st_08=8,st_09=9,st_10=10,st_11=11,\par
00011     st_12=12,st_13=13\par
00012   \};\par
00013   {\cf17 enum class} sintaxerrlexst_e : uint16_t \{\par
00014     st_err_00 = 256,st_err_01 = 257,st_err_02 = 258,\par
00015     st_err_03 = 259,st_err_04 = 260,st_err_05 = 261,\par
00016     st_err_06 = 262,st_err_07 = 263,st_err_08 = 264,\par
00017     st_err_09 = 265,st_err_10 = 266,st_err_11 = 267,\par
00018     st_err_12 = 268,st_err_13 = 269\par
00019   \};\par
00020   {\cf17 enum class} semerrlexst_e : uint16_t \{\par
00021     st_sem_00 = 4096,st_sem_01 = 4097,st_sem_02 = 4098,\par
00022     st_sem_03 = 4099,st_sem_04 = 4100,st_sem_05 = 4101,\par
00023     st_sem_06 = 4102,st_sem_07 = 4103,st_sem_08 = 4104,\par
00024     st_sem_09 = 4105,st_sem_10 = 4106,st_sem_11 = 4107,\par
00025     st_sem_12 = 4108,st_sem_13 = 4109\par
00026   \};\par
00027   {\cf17 enum class} lexst_e : uint16_t \{\par
00028     reg_00 =  0,\par
00029     reg_01 =  1,\par
00030     reg_02 =  2,\par
00031     reg_03 =  3,\par
00032     reg_04 =  4,\par
00033     reg_05 =  5,\par
00034     reg_06 =  6,\par
00035     reg_07 =  7,\par
00036     reg_08 =  8,\par
00037     reg_09 =  9,\par
00038     reg_10 = 10,\par
00039     reg_11 = 11,\par
00040     reg_12 = 12,\par
00041     reg_13 = 13,\par
00042     err_00 = 256,\par
00043     err_01 = 257,\par
00044     err_02 = 258,\par
00045     err_03 = 259,\par
00046     err_04 = 260,\par
00047     err_05 = 261,\par
00048     err_06 = 262,\par
00049     err_07 = 263,\par
00050     err_08 = 264,\par
00051     err_09 = 265,\par
00052     err_10 = 266,\par
00053     err_11 = 267,\par
00054     err_12 = 268,\par
00055     err_13 = 269,\par
00056     sem_00 = 4096,\par
00057     sem_01 = 4097,\par
00058     sem_02 = 4098,\par
00059     sem_03 = 4099,\par
00060     sem_04 = 4100,\par
00061     sem_05 = 4101,\par
00062     sem_06 = 4102,\par
00063     sem_07 = 4103,\par
00064     sem_08 = 4104,\par
00065     sem_09 = 4105,\par
00066     sem_10 = 4106,\par
00067     sem_11 = 4107,\par
00068     sem_12 = 4108,\par
00069     sem_13 = 4109\par
00070   \};\par
00071 \par
00072   {\cf18 bool} is_digit({\cf18 char});\par
00073   {\cf18 bool} is_digit({\cf18 char} in) \{\par
00074     {\cf19 return} ((in >= {\cf23 '0'})&&(in <= {\cf23 '9'}));\par
00075   \}\par
00076 \par
00077   {\cf18 size_t} digit_value({\cf18 char});\par
00078   {\cf18 size_t} digit_value({\cf18 char} in) \{\par
00079     {\cf19 return} {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(in-{\cf23 '0'});\par
00080   \}\par
00081 \par
00082   {\cf18 bool} is_valid_char({\cf18 char});\par
00083   {\cf18 bool} is_valid_char({\cf18 char} in) \{\par
00084     {\cf19 return} (in>={\cf23 'a'} && in <={\cf23 'z'})||(in>={\cf23 'A'} && in<={\cf23 'Z'});\par
00085   \}\par
00086 \par
00087   {\cf18 bool} char_value({\cf18 char});\par
00088   {\cf18 bool} char_value({\cf18 char} in) \{\par
00089     {\cf19 if} ((in>={\cf23 'a'})&&(in <={\cf23 'z'}))\{\par
00090       {\cf19 return} in;\par
00091     \}\par
00092     {\cf19 else}\{\par
00093       {\cf19 return} (in-({\cf23 'A'}-{\cf23 'a'}));\par
00094     \}\par
00095   \}\par
00096 \par
00097   {\cf18 bool} is_separator({\cf18 char});\par
00098   {\cf18 bool} is_separator({\cf18 char} in) \{\par
00099     {\cf19 return} (in == {\cf23 '#'});\par
00100   \}\par
00101 \par
00102   {\cf18 bool} is_end_of_number({\cf18 char});\par
00103   {\cf18 bool} is_end_of_number({\cf18 char} in) \{\par
00104     {\cf19 return} (in == {\cf23 '_'});\par
00105   \}\par
00106 \par
00107   {\cf18 bool} is_whitespace({\cf18 char});\par
00108   {\cf18 bool} is_whitespace({\cf18 char} in) \{\par
00109     {\cf19 return} ((in == {\cf23 ' '})||(in == {\cf23 '\\t'}));\par
00110   \}\par
00111 \par
00112   {\cf18 bool} is_end_descriptor({\cf18 char});\par
00113   {\cf18 bool} is_end_descriptor({\cf18 char} in) \{\par
00114     {\cf19 return} (in == {\cf23 '\\n'})||(in == std::char_traits<char>::eof());\par
00115   \}\par
00116 \par
00117   {\cf18 bool} is_radix_descriptor({\cf18 char});\par
00118   {\cf18 bool} is_radix_descriptor({\cf18 char} in) \{\par
00119     {\cf19 return} ((in == {\cf23 'b'})||(in == {\cf23 'B'}));\par
00120   \}\par
00121 \par
00122   {\cf18 bool} is_sign({\cf18 char});\par
00123   {\cf18 bool} is_sign({\cf18 char} in) \{\par
00124     {\cf19 return} ((in == {\cf23 '+'})||(in == {\cf23 '-'}));\par
00125   \}\par
00126 \par
00127   sign_e sign_value({\cf18 char});\par
00128   sign_e sign_value({\cf18 char} in) \{\par
00129     {\cf19 if} (in == {\cf23 '+'})\par
00130       {\cf19 return} sign_e::vplus;\par
00131     {\cf19 else}\par
00132       {\cf19 return} sign_e::vminus;\par
00133   \}\par
00134 \}\par
00135 \}\par
00136 {\cf21 #endif }{\cf20 // LEXER_PARSER_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo memory_handler.hpp\par \pard\plain 
{\tc\tcl2 \v memory_handler.hpp}
{\xe \v memory_handler.hpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "dig_t.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para memory_handler.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "memory__handler_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_new< aT, T, num_vars, B >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_new< 2 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_new< 1u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_new< 0u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_delete< aT, T, B >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_delete< 2u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_delete< 1u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b details::cp_delete< 0u >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b func_refvar_t< aT, T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b func_refvar_t< INT **, INT *, INT >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b func_refvar_t< UINT **, UINT *, UINT >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b details}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b par_dir_t} = std::pair< uchint, uchint >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b func_refn2digs_prim_t} = std::map< std::string, {\b par_dir_t} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b func_refdig_prim_t} = std::map< std::string, {\b par_dir_t} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b INT} = long long int\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b UINT} = unsigned long long int\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename aT , template< uchint > class T, usint num_vars> \par
requires (num_vars>0)aT ** {\b construye_matriz_de_variables} (aT **matd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename aT , template< uchint > class T> void {\b destruye_matriz_de_variables} (aT **matd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<usint num_vars> \par
requires (num_vars>0){\b INT} ** {\b construye_matriz_de_variables< INT, INT >} ({\b INT} **matd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> void {\b destruye_matriz_de_variables< INT, INT >} ({\b INT} **matd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<usint num_vars> {\b UINT} ** {\b construye_matriz_de_variables< UINT, UINT >} ({\b UINT} **matd)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<> void {\b destruye_matriz_de_variables< UINT, UINT >} ({\b UINT} **matd)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'typedefs'\par
\pard\plain 
{\xe \v func_refdig_prim_t\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:func_refdig_prim_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b func_refdig_prim_t} =  std::map< std::string , {\b par_dir_t} >}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 10} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v func_refn2digs_prim_t\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:func_refn2digs_prim_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b func_refn2digs_prim_t} =  std::map< std::string , {\b par_dir_t} >}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 9} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v INT\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:INT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b INT} =  long long int}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 147} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v par_dir_t\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:par_dir_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b par_dir_t} =  std::pair< uchint , uchint >}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 8} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v UINT\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:UINT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b UINT} =  unsigned long long int}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 165} del archivo {\b memory_handler.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v construye_matriz_de_variables\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:construye_matriz_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T, usint num_vars> \par
requires (num_vars>0)aT ** construye_matriz_de_variables (aT **  {\i matd})}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 137} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v construye_matriz_de_variables< INT, INT >\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:construye_matriz_de_variables< INT, INT >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<usint num_vars> \par
requires (num_vars>0){\b INT} ** {\b construye_matriz_de_variables}< {\b INT}, {\b INT} > ({\b INT} **  {\i matd})}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 151} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v construye_matriz_de_variables< UINT, UINT >\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:construye_matriz_de_variables< UINT, UINT >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<usint num_vars> {\b UINT} ** {\b construye_matriz_de_variables}< {\b UINT}, {\b UINT} > ({\b UINT} **  {\i matd})}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 168} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v destruye_matriz_de_variables\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:destruye_matriz_de_variables}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename aT , template< uchint > class T> void destruye_matriz_de_variables (aT **  {\i matd})}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 143} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v destruye_matriz_de_variables< INT, INT >\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:destruye_matriz_de_variables< INT, INT >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> void {\b destruye_matriz_de_variables}< {\b INT}, {\b INT} > ({\b INT} **  {\i matd})}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 159} del archivo {\b memory_handler.hpp}.}\par
}
{\xe \v destruye_matriz_de_variables< UINT, UINT >\:memory_handler.hpp}
{\xe \v memory_handler.hpp\:destruye_matriz_de_variables< UINT, UINT >}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<> void {\b destruye_matriz_de_variables}< {\b UINT}, {\b UINT} > ({\b UINT} **  {\i matd})}}
\par
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 175} del archivo {\b memory_handler.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
memory_handler.hpp\par \pard\plain 
{\tc\tcl2 \v memory_handler.hpp}
{\xe \v memory_handler.hpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef MEMORY_HANDLER_HPP_INCLUDED}\par
00002 {\cf21 #define MEMORY_HANDLER_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "dig_t.hpp"}\par
00005 \par
00006 {\cf17 using namespace }std;\par
00007 \par
00008 {\cf17 using }par_dir_t                                                 = std::pair< uchint , uchint >;\par
00009 {\cf17 using }func_refn2digs_prim_t = std::map< std::string , par_dir_t >;\par
00010 {\cf17 using }func_refdig_prim_t                = std::map< std::string , par_dir_t >;\par
00011 \par
00012 {\cf17 namespace }details \{\par
00013 \par
00014 {\cf17 template}<       {\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T ,\par
00015                                         usint num_vars , uchint B                                                               >\par
00016 {\cf17 struct }cp_new \{\par
00017 {\cf17 private}:\par
00018         {\cf17 static} aT* contruye_lista_de_variables(aT* var_list) \{\par
00019                 var_list = {\cf17 new} aT[num_vars];\par
00020                 {\cf19 return} var_list;\par
00021         \}\par
00022 {\cf17 public}:\par
00023         {\cf18 void} operator()(aT** var_list_list) \{\par
00024                         {\cf17 static_cast<}T<B>*{\cf17 >}(contruye_lista_de_variables(var_list_list[B]));\par
00025                         cp_new<aT,T,num_vars,B-1u>(var_list_list);\par
00026         \}\par
00027 \};\par
00028 \par
00029 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T ,  usint num_vars>\par
00030 {\cf17 struct }cp_new<aT,T,std::numeric_limits<uchint>::max()> \{\par
00031 {\cf17 private}:\par
00032         {\cf17 static} aT** contruye_lista_de_listas_de_variables(aT** var_list_list) \{\par
00033                 var_list_list = {\cf17 new} aT*[std::numeric_limits<uchint>::max()];\par
00034                 {\cf19 return} var_list_list;\par
00035         \}\par
00036         {\cf17 static} aT* contruye_lista_de_variables(aT* var_list) \{\par
00037                 var_list = {\cf17 new} aT[num_vars];\par
00038                 {\cf19 return} var_list;\par
00039         \}\par
00040 {\cf17 public}:\par
00041         {\cf18 void} operator()(aT** var_list_list) \{\par
00042                         construye_lista_de_lista_de_variables(var_list_listlist_list);\par
00043                         {\cf17 static_cast<}T<std::numeric_limits<uchint>::max(){\cf17 >}*>(contruye_lista_de_variables(var_list_list[std::numeric_limits<uchint>::max()]));\par
00044                         cp_new<aT,T,num_vars,std::numeric_limits<uchint>::max()-1>(var_list_list);\par
00045         \}\par
00046 \};\par
00047 \par
00048 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T ,  usint num_vars>\par
00049 {\cf17 struct }cp_new<2> \{\par
00050 {\cf17 private}:\par
00051         {\cf17 static} aT* contruye_lista_de_variables(aT* var_list) \{\par
00052                 var_list = {\cf17 new} aT[num_vars];\par
00053                 {\cf19 return} var_list;\par
00054         \}\par
00055 {\cf17 public}:\par
00056         {\cf18 void} operator()(aT** var_list_list) \{\par
00057                         {\cf17 static_cast<}T<2u>*{\cf17 >}(contruye_lista_de_variables(var_list_list[2u]));\par
00058                         cp_new<aT,T,num_vars,1u>(var_list_list);\par
00059         \}\par
00060 \};\par
00061 \par
00062 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T ,  usint num_vars>\par
00063 {\cf17 struct }cp_new<1u> \{\par
00064         {\cf18 void} operator()(aT** var_list_list) \{\par
00065                 var_list_list[1u]={\cf17 nullptr};\par
00066                 cp_new<aT,T,num_vars,0u>(var_list_list);\par
00067         \}\par
00068 \};\par
00069 \par
00070 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T ,  usint num_vars>\par
00071 {\cf17 struct }cp_new<0u> \{\par
00072         {\cf18 void} operator()(aT** var_list_list) \{\par
00073                 var_list_list[0u]={\cf17 nullptr};\par
00074         \}\par
00075 \};\par
00076 \par
00077 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T , uchint B>\par
00078 {\cf17 struct }cp_delete \{\par
00079 {\cf17 private}:\par
00080         {\cf17 static} {\cf18 void} destruye_lista_de_variables(aT* var_list) \{\par
00081                 {\cf17 delete} [] matd[B];\par
00082         \}\par
00083 {\cf17 public}:\par
00084         {\cf18 void} operator()(aT** var_list_list) \{\par
00085                         destruye_lista_de_variables(var_list_list[B]);\par
00086                         cp_delete<aT,T,B-1>(var_list_list);\par
00087         \}\par
00088 \};\par
00089 \par
00090 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T>\par
00091 {\cf17 struct }cp_delete<aT,T,std::numeric_limits<uchint>::max()> \{\par
00092 {\cf17 private}:\par
00093         {\cf17 static} {\cf18 void} contruye_lista_de_variables(aT* var_list) \{\par
00094                 {\cf17 delete} [] matd[std::numeric_limits<uchint>::max()];\par
00095         \}\par
00096 {\cf17 public}:\par
00097         {\cf18 void} operator()(aT** var_list_list) \{\par
00098                         destruye_lista_de_variables(var_list_list[std::numeric_limits<uchint>::max()]);\par
00099                         cp_delete<aT,T,std::numeric_limits<uchint>::max()-1u>(var_list_list);\par
00100         \}\par
00101 \};\par
00102 \par
00103 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T>\par
00104 {\cf17 struct }cp_delete<2u> \{\par
00105 {\cf17 private}:\par
00106         {\cf17 static} {\cf18 void} contruye_lista_de_variables(aT* var_list) \{\par
00107                 destruye_lista_de_variables(var_list_list[2u]);\par
00108         \}\par
00109 {\cf17 public}:\par
00110         {\cf18 void} operator()(aT** var_list_list) \{\par
00111                         {\cf17 static_cast<}T<2u>*{\cf17 >}(contruye_lista_de_variables(var_list_list[2u]));\par
00112                         cp_delete<aT,T,1>(var_list_list);\par
00113         \}\par
00114 \};\par
00115 \par
00116 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T>\par
00117 {\cf17 struct }cp_delete<1u> \{\par
00118         {\cf18 void} operator()(aT** var_list_list) \{\par
00119                 {\cf19 if} (var_list_list[1u] != {\cf17 nullptr})\par
00120                         {\cf17 delete} var_list_list[1u];\par
00121                 cp_delete<aT,T,0u>(var_list_list);\par
00122         \}\par
00123 \};\par
00124 \par
00125 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T ,  usint num_vars>\par
00126 {\cf17 struct }cp_delete<0u> \{\par
00127         {\cf18 void} operator()(aT** var_list_list) \{\par
00128                 {\cf19 if} (var_list_list[0u] != {\cf17 nullptr})\par
00129                         {\cf17 delete} var_list_list[0u];\par
00130                 {\cf17 delete} [] var_list_list;\par
00131         \}\par
00132 \};\par
00133 \}\par
00134 \par
00135 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T , usint num_vars>\par
00136         {\cf17 requires} (num_vars>0)\par
00137 aT** construye_matriz_de_variables(aT** matd) \{\par
00138                 details::cp_new<aT,T,num_vars,std::numeric_limits<uchint>::max()>(matd);\par
00139                 {\cf19 return} matd;\par
00140 \}\par
00141 \par
00142 {\cf17 template}<{\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T>\par
00143 {\cf18 void} destruye_matriz_de_variables(aT** matd) \{\par
00144                 details::cp_delete<aT,T,std::numeric_limits<uchint>::max()>(matd);\par
00145 \}\par
00146 \par
00147 {\cf17 using }INT = {\cf18 long} {\cf18 long} int;\par
00148 \par
00149 {\cf17 template}<us{\cf18 int} num_vars>\par
00150         {\cf17 requires} (num_vars>0)\par
00151 INT** construye_matriz_de_variables<INT,INT>(INT** matd)\par
00152 \{\par
00153         matd = {\cf17 new} (INT*);\par
00154         *matd = {\cf17 new} INT[num_vars];\par
00155         {\cf19 return} matd;\par
00156 \}\par
00157 \par
00158 {\cf17 template}<>\par
00159 {\cf18 void} destruye_matriz_de_variables<INT,INT>(INT** matd)\par
00160 \{\par
00161         {\cf17 delete} *matd;\par
00162         {\cf17 delete} [] matd;\par
00163 \}\par
00164 \par
00165 {\cf17 using }UINT = {\cf18 unsigned} {\cf18 long} {\cf18 long} int;\par
00166 \par
00167 {\cf17 template}<us{\cf18 int} num_vars>\par
00168 UINT** construye_matriz_de_variables<UINT,UINT>(UINT** matd)\par
00169 \{\par
00170         matd = {\cf17 new} (UINT*);\par
00171         *matd = {\cf17 new} UINT[num_vars];\par
00172         {\cf19 return} matd;\par
00173 \}\par
00174 {\cf17 template}<>\par
00175 {\cf18 void} destruye_matriz_de_variables<UINT,UINT>(UINT** matd)\par
00176 \{\par
00177         {\cf17 delete} *matd;\par
00178         {\cf17 delete} [] matd;\par
00179 \}\par
00180 \par
00181 {\cf17 template}< {\cf17 typename} aT , {\cf17 template}<uch{\cf18 int}> {\cf17 class }T >\par
00182 {\cf17 class }func_refvar_t \{\par
00183 {\cf17 private}:\par
00184 \par
00185         vector< vector<bool> >                  mapmem;\par
00186         map< string , par_dir_t >               mapvd;\par
00187         aT**                                                                                    matd;\par
00188         vector<uint>                                                    cuentavars;\par
00189 \par
00190         {\cf20 // Mira si un nombre de variable esta disponible y si esta libre un lugar concreto de}\par
00191         {\cf20 // "memoria". Arregla el mapa de memoria. Si ha tenido exito y se puede insertar la}\par
00192         {\cf20 // variable devuelve true, sino false.}\par
00193     {\cf18 bool} insert( {\cf18 string} nombre , uchint base , uchint var_base )\par
00194     \{\par
00195                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00196                 {\cf17 const} map< string , par_dir_t >::iterator itend = mapvd.end();\par
00197                 {\cf19 for}( ; it != itend ; ++it) \{\par
00198                         {\cf19 if} (((*it).second.second == var_base)or((*it).first==nombre)) {\cf19 return} {\cf17 false};\par
00199                 \}\par
00200                 {\cf19 if} (mapmem[base][var_base]=={\cf17 false}) \{\par
00201                         mapvd.insert(\par
00202                                 std::make_pair<std::string,par_dir_t>\par
00203                                 (\par
00204                                         nombre ,\par
00205                                         std::make_pair<uchint,uchint>(base,var_base)\par
00206                                 )\par
00207                         );\par
00208                         mapmem[base][var_base]={\cf17 true};\par
00209                         {\cf19 return} {\cf17 true};\par
00210                 \}\par
00211                 {\cf19 else} {\cf19 return} {\cf17 false};\par
00212         \}\par
00213 \par
00214         func_refvar_t({\cf17 const} func_refvar_t &);\par
00215 \par
00216 {\cf17 public}:\par
00217 \par
00218         func_refvar_t()\par
00219         \{\par
00220                 {\cf20 //inicia_matriz_digs_y_pp(matd,256u,256u);}\par
00221                 matd = construye_matriz_de_variables<ppT,pT,T>(matd);\par
00222                 mapmem.resize(256);\par
00223                 cuentavars.resize(256);\par
00224                 {\cf19 for}(uint I=0 ; I < 256 ; ++I)\{\par
00225                         mapmem[I].resize(256);\par
00226                         cuentavars[I]=0;\par
00227                         {\cf19 for}(uint J=0 ; J < 256 ; ++J)\{\par
00228                                 mapmem[I][J]={\cf17 false};\par
00229                         \}\par
00230                 \}\par
00231         \}\par
00232 \par
00233         ~func_refvar_t()\par
00234         \{\par
00235                 destruye_matriz_de_variables<T,T>(matd);\par
00236         \}\par
00237 \par
00238 {\cf17 private}: {\cf20 // BAJO NIVEL}\par
00239         {\cf20 // encuentra espacio para una variable de base B}\par
00240         {\cf20 // devuelve true si ha tenido exito y false si no}\par
00241         {\cf18 bool} escribe_var( {\cf18 string} nombre , uchint base , uchint var_base) \{\par
00242                 {\cf18 bool} se_puede_insertar = {\cf17 false};\par
00243                 {\cf19 if} (cuentavars[base] <= 256) \{\par
00244                         uint var_base = 0;\par
00245                         {\cf19 while} (! se_puede_insertar) \{\par
00246                                 se_puede_insertar = insert( nombre ,  base , var_base );\par
00247                                 {\cf19 if} (!se_puede_insertar) var_base++;\par
00248                         \}\par
00249                         {\cf19 if} (se_puede_insertar) (cuentavars[base])++;\par
00250                 \}\par
00251                 {\cf19 return} se_puede_insertar;\par
00252         \}\par
00253 {\cf17 public}:\par
00254         {\cf20 // borra el lugar de una variable de base B}\par
00255         {\cf18 void} borra_var( {\cf18 string} nombre ) \{\par
00256                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00257                 map< string , par_dir_t >::const_iterator itend = mapvd.end();\par
00258                 {\cf19 for}( ; it != itend ; ++it) \{\par
00259                         {\cf19 if} ((*it).first==nombre) \{\par
00260                                 mapmem[(*it).second.first][(*it).second.second]={\cf17 false};\par
00261                                 --cuentavars[(*it).second.first];\par
00262                                 mapvd.erase(it);{\cf20 // ponerlo a 0}\par
00263                                 {\cf19 return};\par
00264                         \}\par
00265                 \}\par
00266                 {\cf19 return};\par
00267         \}\par
00268 \par
00269         {\cf18 bool} existe_lugar_de_base( uchint Base ) \{\par
00270                 {\cf18 bool} ret = {\cf17 true};\par
00271                 {\cf19 for}(uint I=0; I < 256 ; ++I)\{\par
00272                         ret = ret and mapmem[Base][I];\par
00273                         {\cf19 if} (!ret) {\cf19 return} {\cf17 true};\par
00274                 \}\par
00275                 {\cf19 return} {\cf17 false};\par
00276         \}\par
00277 \par
00278         {\cf18 bool} este_nombre_ya_ha_sido_declarado({\cf18 string} nombre)\{\par
00279                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00280                 map< string , par_dir_t >::const_iterator itend = mapvd.end();\par
00281                 {\cf19 for}( ; it != itend ; ++it) \{\par
00282                         {\cf19 if} ((*it).first==nombre) \{\par
00283                                 {\cf19 return} {\cf17 true};\par
00284                         \}\par
00285                 \}\par
00286                 {\cf19 return} {\cf17 false};\par
00287         \}\par
00288 \par
00289         {\cf17 template}<const uch{\cf18 int} B>\par
00290         T<B> get({\cf18 string} nombre)\par
00291         \{\par
00292                 {\cf19 return} ({\cf17 reinterpret_cast<} T<B>* {\cf17 >}(matd[B]))[mapvd[nombre].second];\par
00293         \}\par
00294 \par
00295         {\cf17 template}<const uch{\cf18 int} B>\par
00296         {\cf18 bool} operator()({\cf18 string} nombre,{\cf18 string} lhs)\par
00297         \{\par
00298                 T<B> temp(lhs);\par
00299                 {\cf18 bool} se_puede_hacer = este_nombre_ya_ha_sido_declarado(nombre);\par
00300                 {\cf19 if} (se_puede_hacer) ({\cf17 reinterpret_cast<} T<B>* {\cf17 >}(matd[B]))[mapvd[nombre].second]=temp;\par
00301                 {\cf19 return} se_puede_hacer;\par
00302         \}\par
00303 \};\par
00304 \par
00305 {\cf17 class }func_refvar_t<INT**,INT*,INT> \{\par
00306 {\cf17 private}:\par
00307 \par
00308         vector< vector<bool> >                  mapmem;\par
00309         map< string , par_dir_t >               mapvd;\par
00310         INT**                                                   matd;\par
00311         vector<uint>                                    cuentavars;\par
00312 \par
00313         {\cf20 // Mira si un nombre de variable est\'E1 disponible y si est\'E1 libre un lugar concreto de}\par
00314         {\cf20 // "memoria". Arregla el mapa de memoria. Si ha tenido exito y se puede insertar la}\par
00315         {\cf20 // variable devuelve true, sino false.}\par
00316     {\cf18 bool} insert( {\cf18 string} nombre , uchint base , uchint var_base )\par
00317     \{\par
00318                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00319                 {\cf17 const} map< string , par_dir_t >::iterator itend = mapvd.end();\par
00320                 {\cf19 for}( ; it != itend ; ++it) \{\par
00321                         {\cf19 if} (((*it).second.second == var_base)or((*it).first==nombre)) {\cf19 return} {\cf17 false};\par
00322                 \}\par
00323                 {\cf19 if} (mapmem[base][var_base]=={\cf17 false}) \{\par
00324                         mapvd.insert(\par
00325                                 std::make_pair<std::string,par_dir_t>\par
00326                                 (\par
00327                                         nombre ,\par
00328                                         std::make_pair<uchint,uchint>(base,var_base)\par
00329                                 )\par
00330                         );\par
00331                         mapmem[base][var_base]={\cf17 true};\par
00332                         {\cf19 return} {\cf17 true};\par
00333                 \}\par
00334                 {\cf19 else} {\cf19 return} {\cf17 false};\par
00335         \}\par
00336 \par
00337         func_refvar_t({\cf17 const} func_refvar_t &)={\cf17 delete};\par
00338 \par
00339 {\cf17 public}:\par
00340 \par
00341         func_refvar_t()\par
00342         \{\par
00343                 {\cf20 //inicia_matriz_digs_y_pp(matd,256u,256u);}\par
00344                 matd = construye_matriz_de_variables<INT**,INT*,INT>(matd);\par
00345                 mapmem.resize(256);\par
00346                 cuentavars.resize(256);\par
00347                 {\cf19 for}(uint I=0 ; I < 256 ; ++I)\{\par
00348                         mapmem[I].resize(256);\par
00349                         cuentavars[I]=0;\par
00350                         {\cf19 for}(uint J=0 ; J < 256 ; ++J)\{\par
00351                                 mapmem[I][J]={\cf17 false};\par
00352                         \}\par
00353                 \}\par
00354         \}\par
00355 \par
00356         ~func_refvar_t()\par
00357         \{\par
00358                 destruye_matriz_de_variables<INT**,INT*,INT>(matd);\par
00359         \}\par
00360 \par
00361 {\cf17 private}: {\cf20 // BAJO NIVEL}\par
00362         {\cf20 // encuentra espacio para una variable de base B}\par
00363         {\cf20 // devuelve true si ha tenido exito y false si no}\par
00364         {\cf18 bool} escribe_var( {\cf18 string} nombre , uchint base , uchint var_base) \{\par
00365                 {\cf18 bool} se_puede_insertar = {\cf17 false};\par
00366                 {\cf19 if} (cuentavars[base] <= 256) \{\par
00367                         uint var_base = 0;\par
00368                         {\cf19 while} (! se_puede_insertar) \{\par
00369                                 se_puede_insertar = insert( nombre ,  base , var_base );\par
00370                                 {\cf19 if} (!se_puede_insertar) var_base++;\par
00371                         \}\par
00372                         {\cf19 if} (se_puede_insertar) (cuentavars[base])++;\par
00373                 \}\par
00374                 {\cf19 return} se_puede_insertar;\par
00375         \}\par
00376 {\cf17 public}:\par
00377         {\cf20 // borra el lugar de una variable de base B}\par
00378         {\cf18 void} borra_var( {\cf18 string} nombre ) \{\par
00379                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00380                 map< string , par_dir_t >::const_iterator itend = mapvd.end();\par
00381                 {\cf19 for}( ; it != itend ; ++it) \{\par
00382                         {\cf19 if} ((*it).first==nombre) \{\par
00383                                 mapmem[(*it).second.first][(*it).second.second]={\cf17 false};\par
00384                                 --cuentavars[(*it).second.first];\par
00385                                 mapvd.erase(it);{\cf20 // ponerlo a 0}\par
00386                                 {\cf19 return};\par
00387                         \}\par
00388                 \}\par
00389                 {\cf19 return};\par
00390         \}\par
00391 \par
00392         {\cf18 bool} existe_lugar_de_base( uchint Base ) \{\par
00393                 {\cf18 bool} ret = {\cf17 true};\par
00394                 {\cf19 for}(uint I=0; I < 256 ; ++I)\{\par
00395                         ret = ret and mapmem[Base][I];\par
00396                         {\cf19 if} (!ret) {\cf19 return} {\cf17 true};\par
00397                 \}\par
00398                 {\cf19 return} {\cf17 false};\par
00399         \}\par
00400 \par
00401         {\cf18 bool} este_nombre_ya_ha_sido_declarado({\cf18 string} nombre)\{\par
00402                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00403                 map< string , par_dir_t >::const_iterator itend = mapvd.end();\par
00404                 {\cf19 for}( ; it != itend ; ++it) \{\par
00405                         {\cf19 if} ((*it).first==nombre) \{\par
00406                                 {\cf19 return} {\cf17 true};\par
00407                         \}\par
00408                 \}\par
00409                 {\cf19 return} {\cf17 false};\par
00410         \}\par
00411 \par
00412         INT get({\cf18 string} nombre)\par
00413         \{\par
00414                 {\cf19 return} (*matd[B])[mapvd[nombre].second];\par
00415         \}\par
00416 \par
00417         {\cf18 bool} operator()({\cf18 string} nombre,{\cf18 string} lhs)\par
00418         \{\par
00419                 INT temp(lhs);\par
00420                 {\cf18 bool} se_puede_hacer = este_nombre_ya_ha_sido_declarado(nombre);\par
00421                 {\cf19 if} (se_puede_hacer) (*matd)[mapvd[nombre].second]=temp;\par
00422                 {\cf19 return} se_puede_hacer;\par
00423         \}\par
00424 \};\par
00425 \par
00426 {\cf17 class }func_refvar_t<UINT**,UINT*,UINT> \{\par
00427 {\cf17 private}:\par
00428 \par
00429         vector< vector<bool> >                  mapmem;\par
00430         map< string , par_dir_t >               mapvd;\par
00431         UINT**                                                          matd;\par
00432         vector<uint>                                    cuentavars;\par
00433 \par
00434         {\cf20 // Mira si un nombre de variable est\'E1 disponible y si est\'E1 libre un lugar concreto de}\par
00435         {\cf20 // "memoria". Arregla el mapa de memoria. Si ha tenido exito y se puede insertar la}\par
00436         {\cf20 // variable devuelve true, sino false.}\par
00437     {\cf18 bool} insert( {\cf18 string} nombre , uchint base , uchint var_base )\par
00438     \{\par
00439                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00440                 {\cf17 const} map< string , par_dir_t >::iterator itend = mapvd.end();\par
00441                 {\cf19 for}( ; it != itend ; ++it) \{\par
00442                         {\cf19 if} (((*it).second.second == var_base)or((*it).first==nombre)) {\cf19 return} {\cf17 false};\par
00443                 \}\par
00444                 {\cf19 if} (mapmem[base][var_base]=={\cf17 false}) \{\par
00445                         mapvd.insert(\par
00446                                 std::make_pair<std::string,par_dir_t>\par
00447                                 (\par
00448                                         nombre ,\par
00449                                         std::make_pair<uchint,uchint>(base,var_base)\par
00450                                 )\par
00451                         );\par
00452                         mapmem[base][var_base]={\cf17 true};\par
00453                         {\cf19 return} {\cf17 true};\par
00454                 \}\par
00455                 {\cf19 else} {\cf19 return} {\cf17 false};\par
00456         \}\par
00457 \par
00458         func_refvar_t({\cf17 const} func_refvar_t &);\par
00459 \par
00460 {\cf17 public}:\par
00461 \par
00462         func_refvar_t()\par
00463         \{\par
00464                 {\cf20 //inicia_matriz_digs_y_pp(matd,256u,256u);}\par
00465                 matd = construye_matriz_de_variables<UINT**,UINT*,UINT>(matd);\par
00466                 mapmem.resize(256);\par
00467                 cuentavars.resize(256);\par
00468                 {\cf19 for}(uint I=0 ; I < 256 ; ++I)\{\par
00469                         mapmem[I].resize(256);\par
00470                         cuentavars[I]=0;\par
00471                         {\cf19 for}(uint J=0 ; J < 256 ; ++J)\{\par
00472                                 mapmem[I][J]={\cf17 false};\par
00473                         \}\par
00474                 \}\par
00475         \}\par
00476 \par
00477         ~func_refvar_t()\par
00478         \{\par
00479                 destruye_matriz_de_variables<UINT**,UINT*,UINT>(matd);\par
00480         \}\par
00481 \par
00482 {\cf17 private}: {\cf20 // BAJO NIVEL}\par
00483         {\cf20 // encuentra espacio para una variable de base B}\par
00484         {\cf20 // devuelve true si ha tenido exito y false si no}\par
00485         {\cf18 bool} escribe_var( {\cf18 string} nombre , uchint base , uchint var_base) \{\par
00486                 {\cf18 bool} se_puede_insertar = {\cf17 false};\par
00487                 {\cf19 if} (cuentavars[base] <= 256) \{\par
00488                         uint var_base = 0;\par
00489                         {\cf19 while} (! se_puede_insertar) \{\par
00490                                 se_puede_insertar = insert( nombre ,  base , var_base );\par
00491                                 {\cf19 if} (!se_puede_insertar) var_base++;\par
00492                         \}\par
00493                         {\cf19 if} (se_puede_insertar) (cuentavars[base])++;\par
00494                 \}\par
00495                 {\cf19 return} se_puede_insertar;\par
00496         \}\par
00497 {\cf17 public}:\par
00498         {\cf20 // borra el lugar de una variable de base B}\par
00499         {\cf18 void} borra_var( {\cf18 string} nombre ) \{\par
00500                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00501                 map< string , par_dir_t >::const_iterator itend = mapvd.end();\par
00502                 {\cf19 for}( ; it != itend ; ++it) \{\par
00503                         {\cf19 if} ((*it).first==nombre) \{\par
00504                                 mapmem[(*it).second.first][(*it).second.second]={\cf17 false};\par
00505                                 --cuentavars[(*it).second.first];\par
00506                                 mapvd.erase(it);{\cf20 // ponerlo a 0}\par
00507                                 {\cf19 return};\par
00508                         \}\par
00509                 \}\par
00510                 {\cf19 return};\par
00511         \}\par
00512 \par
00513         {\cf18 bool} existe_lugar_de_base( uchint Base ) \{\par
00514                 {\cf18 bool} ret = {\cf17 true};\par
00515                 {\cf19 for}(uint I=0; I < 256 ; ++I)\{\par
00516                         ret = ret and mapmem[Base][I];\par
00517                         {\cf19 if} (!ret) {\cf19 return} {\cf17 true};\par
00518                 \}\par
00519                 {\cf19 return} {\cf17 false};\par
00520         \}\par
00521 \par
00522         {\cf18 bool} este_nombre_ya_ha_sido_declarado({\cf18 string} nombre)\{\par
00523                 map< string , par_dir_t >::iterator it = mapvd.begin();\par
00524                 map< string , par_dir_t >::const_iterator itend = mapvd.end();\par
00525                 {\cf19 for}( ; it != itend ; ++it) \{\par
00526                         {\cf19 if} ((*it).first==nombre) \{\par
00527                                 {\cf19 return} {\cf17 true};\par
00528                         \}\par
00529                 \}\par
00530                 {\cf19 return} {\cf17 false};\par
00531         \}\par
00532 \par
00533         {\cf17 template}<const uch{\cf18 int} B>\par
00534         UINT get({\cf18 string} nombre)\par
00535         \{\par
00536                 {\cf19 return} (*matd)[mapvd[nombre].second];\par
00537         \}\par
00538 \par
00539 \par
00540         {\cf18 bool} operator()({\cf18 string} nombre,{\cf18 string} lhs)\par
00541         \{\par
00542                 UINT temp(lhs);\par
00543                 {\cf18 bool} se_puede_hacer = este_nombre_ya_ha_sido_declarado(nombre);\par
00544                 {\cf19 if} (se_puede_hacer) *matd[mapvd[nombre].second]=temp;\par
00545                 {\cf19 return} se_puede_hacer;\par
00546         \}\par
00547 \};\par
00548 \par
00549 \par
00550 \par
00551 {\cf21 #endif }{\cf20 // MEMORY_HANDLER_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo nat_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_num_t.hpp}
{\xe \v nat_num_t.hpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "base_num_t.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para nat_num_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__num__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__num__t_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b nat_num_t< UINT_T, B >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint Base> istream & {\b operator>>} (istream &is, {\b nat_num_t}< Base > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<const uchint Base> ostream & {\b operator<<} (ostream &os, const {\b nat_num_t}< Base > &arg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v operator<<\:nat_num_t.hpp}
{\xe \v nat_num_t.hpp\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<const uchint Base> ostream & operator<< (ostream &  {\i os}, const {\b nat_num_t}< Base > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 2103} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__num__t_8hpp_a326c05d0b52b1046d8d49c08bad23fa1_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
{\xe \v operator>>\:nat_num_t.hpp}
{\xe \v nat_num_t.hpp\:operator>>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<const uchint Base> istream & operator>> (istream &  {\i is}, {\b nat_num_t}< Base > &  {\i arg})}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 1965} del archivo {\b nat_num_t.hpp}.}\par
Gr\'E1fico de llamadas para esta funci\'F3n:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__num__t_8hpp_abb536e9b1b1447052db560972a06adbe_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nat_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_num_t.hpp}
{\xe \v nat_num_t.hpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef NAT_NUM_T_HPP_INCLUDED}\par
00002 {\cf21 #define NAT_NUM_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "base_num_t.hpp"}\par
00005 \par
00006 {\cf17 using namespace }std;\par
00007 \par
00008 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00009 {\cf17 class }nat_num_t : {\cf17 public} base_num_t<UINT_T,B> \{\par
00010 {\cf17 private}:\par
00011 {\cf17 using }dig_t = dig_t<UINT_T,B>;\par
00012 {\cf17 using }base_num_t = base_num_t<UINT_T,B>;\par
00013 {\cf17 using }nbstr = basic_string< dig >;\par
00014 {\cf17 using }striterator = {\cf17 typename} nbstr::iterator;\par
00015 {\cf17 using }rstriterator = {\cf17 typename} nbstr::reverse_iterator;\par
00016 {\cf17 using }cstriterator = {\cf17 typename} nbstr::const_iterator;\par
00017 {\cf17 using }crstriterator = {\cf17 typename} nbstr::const_reverse_iterator;\par
00018 {\cf17 using   }b_iterator = {\cf17 typename} base_num_t<UINT_T,B>::iterator;\par
00019 {\cf17 using }b_riterator = {\cf17 typename} base_num_t<UINT_T,B>::reverse_iterator;\par
00020 {\cf17 using }b_citerator = {\cf17 typename} base_num_t<UINT_T,B>::const_iterator;\par
00021 {\cf17 using }b_criterator = {\cf17 typename} base_num_t<UINT_T,B>::const_reverse_iterator;\par
00022 {\cf17 using }iterator = {\cf17 typename} nat_num_t<UINT_T,B>::iterator;\par
00023 {\cf17 using }riterator = {\cf17 typename} nat_num_t<UINT_T,B>::reverse_iterator;\par
00024 {\cf17 using }citerator = {\cf17 typename} nat_num_t<UINT_T,B>::const_iterator;\par
00025 {\cf17 using }criterator = {\cf17 typename} nat_num_t<UINT_T,B>::const_reverse_iterator;\par
00026 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
00027 {\cf17 using }base_N_t = std::array<dig_t<UINT_T,B>,N>;\par
00028 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00029 {\cf17 using }base_t = nat_reg_N_digs_t<UINT_T,B,2>;\par
00030 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
00031 {\cf17 using }nat_reg_N_digs_t = nat_reg_N_digs_t<UINT_T,B,N>;\par
00032 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00033 {\cf17 using }nat_reg_digs_t = nat_reg_N_digs_t<UINT_T,B,2>;\par
00034 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
00035 {\cf17 using }int_reg_N_digs_t = int_reg_N_digs_t<UINT_T,B,N>;\par
00036 {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00037 {\cf17 using }int_reg_digs_t = int_reg_N_digs_t<UINT_T,B,2>;\par
00038 \par
00039 \par
00040 {\cf17 private}:\par
00041 pardigs         aux;\par
00042 \par
00043 {\cf20                                                 /****************************/}\par
00044                                                 {\cf20 /*                                                                                                      */}\par
00045                                                 {\cf20 /*              CONSTRUCTORES                                   */}\par
00046                                                 {\cf20 /*                                                                                                      */}\par
00047 {\cf20                                                 /****************************/}\par
00048 {\cf17 public}:\par
00049 {\cf17 inline} {\cf18 size_t} size(){\cf17  const }\{\par
00050         {\cf17 const} base_num_t & cthis = (*this);\par
00051         {\cf19 return} cthis.base_num_t::size();\par
00052 \}\par
00053 {\cf17 private}:\par
00054 {\cf17 inline} {\cf18 void} resize({\cf18 size_t} arg) \{\par
00055         base_num_t & cthis = (*this);\par
00056         cthis.base_num_t::resize(arg);\par
00057         {\cf19 return};\par
00058 \}\par
00059 {\cf17 public}:\par
00060 {\cf17 inline} {\cf18 void} push_front(dig_t parg) \{\par
00061         base_num_t & cthis = (*this);\par
00062         cthis.base_num_t::push_front(parg);\par
00063         {\cf19 return};\par
00064 \}\par
00065 {\cf17 private}:\par
00066 {\cf17 inline} nat_num_t& insert ( {\cf18 size_t} pos1, {\cf17 const} dig_t chardig )\{\par
00067         base_num_t & cthis = (*this);\par
00068         cthis.base_num_t::insert(pos1,1,chardig);\par
00069         {\cf19 return} (*{\cf17 this});\par
00070 \}\par
00071 {\cf17 inline} nat_num_t& insert ( {\cf18 size_t} pos1, {\cf18 size_t} n, dig_t c )\{\par
00072         base_num_t & cthis = (*this);\par
00073         cthis.base_num_t::insert(pos1,n,c);\par
00074         {\cf19 return} (*{\cf17 this});\par
00075 \}\par
00076 \par
00077 {\cf17 inline} {\cf17 const} nat_num_t & operator &= ({\cf17 const} nat_num_t & arg) \{\par
00078         base_num_t & cthis = (*this);\par
00079         cthis.base_num_t::operator +=(arg);\par
00080         {\cf19 return} (*{\cf17 this});\par
00081 \}\par
00082 \par
00083 {\cf20 // string& erase ( size_t pos = 0, size_t n = npos );}\par
00084 \par
00085 {\cf17 inline} nat_num_t& erase ( {\cf18 size_t} pos, {\cf18 size_t} npos )\{\par
00086         nat_num_t & cthis = (*this);\par
00087         {\cf18 size_t} npos_2= npos;\par
00088         {\cf17 const} {\cf18 size_t} sz = size();\par
00089         {\cf19 if} ((sz == npos) and (pos == 0)) \{\par
00090                 npos_2--;\par
00091                 operator[](sz-1) = dig_t(0);\par
00092         \}\par
00093         cthis.base_num_t::erase(pos,npos_2);\par
00094         {\cf19 return} (*{\cf17 this});\par
00095 \}\par
00096 \par
00097 {\cf17 inline} iterator erase ( iterator first, iterator last )\{\par
00098         {\cf18 size_t} npos= last-first;\par
00099         {\cf17 const} {\cf18 size_t} sz = size();\par
00100         {\cf19 if} (sz == npos) \{\par
00101                 last--;\par
00102                 operator[](sz-1) = d_0<B>();\par
00103         \}\par
00104         {\cf19 return} base_num_t::erase(first,last);\par
00105 \}\par
00106 {\cf17 public}:\par
00107 {\cf17 inline} dig_t operator[](uint arg){\cf17  const }\{\par
00108         {\cf17 const} nat_num_t & cthis = (*this);\par
00109         {\cf19 return} cthis.base_num_t::operator[](arg);\par
00110 \}\par
00111 {\cf17 inline} dig_t & operator[](uint arg) \{\par
00112         base_num_t & cthis = (*this);\par
00113         {\cf19 return} cthis.base_num_t::operator[](arg);\par
00114 \}\par
00115 \par
00116 {\cf17 inline} {\cf18 void} clear() \{\par
00117         base_num_t & cthis = (*this);\par
00118         cthis.base_num_t::clear();\par
00119 \}\par
00120 \par
00121 {\cf17 inline} {\cf18 void} push_back(dig_t arg) \{\par
00122         base_num_t & cthis = (*this);\par
00123         cthis.base_num_t::push_back(arg);\par
00124 \}\par
00125 \par
00126 {\cf17 inline} striterator begin() \{\par
00127         base_num_t & cthis = (*this);\par
00128         {\cf19 return} cthis.base_num_t::begin();\par
00129 \}\par
00130 \par
00131 {\cf17 inline} cstriterator end(){\cf17  const }\{\par
00132         {\cf17 const} base_num_t & cthis = (*this);\par
00133         {\cf19 return} cthis.base_num_t::end();\par
00134 \}\par
00135 \par
00136 {\cf17 public}:\par
00137 nat_num_t() \{\par
00138         nat_num_t & cthis = (*this);\par
00139         aux=pardigs();\par
00140         cthis.resize(1);\par
00141         cthis[0] = dig(0);\par
00142 \}\par
00143 \par
00144 {\cf17 const} nat_num_t & operator = ({\cf17 const} nat_num_t & a) \{\par
00145         nat_num_t & cthis = (*this);\par
00146         cthis.clear();\par
00147         aux=a.aux;\par
00148         {\cf17 const} {\cf18 int} sz = a.size();\par
00149         cthis.resize(sz);\par
00150         {\cf19 for} ({\cf18 int} k=0; k < sz ; ++k)\{\par
00151                 cthis[k]=a[k];\par
00152         \}\par
00153         cthis.reduce();\par
00154         {\cf19 return} cthis;\par
00155 \}\par
00156 \par
00157 nat_num_t & operator = (nat_num_t & a) \{\par
00158         nat_num_t & cthis = (*this);\par
00159         aux=a.aux;\par
00160         {\cf17 const} {\cf18 int} sz = a.size();\par
00161         cthis.clear();\par
00162         cthis.resize(sz);\par
00163         {\cf19 for} ({\cf18 int} k=0; k < sz ; ++k) \{\par
00164                 cthis[k]=a[k];\par
00165         \}\par
00166         cthis.reduce();\par
00167         {\cf19 return} cthis;\par
00168 \}\par
00169 \par
00170 nat_num_t({\cf17 const} nat_num_t & a) \{\par
00171         nat_num_t & cthis = (*this);\par
00172         aux=a.aux;\par
00173         cthis.clear();\par
00174         cthis.resize(a.size());\par
00175         {\cf19 for} (usint k=0; k < a.size() ; ++k)\par
00176                 cthis[k]=a[k];\par
00177         cthis.reduce();\par
00178 \}\par
00179 \par
00180 nat_num_t({\cf17 const} {\cf18 string} & a ) \{\par
00181         nat_num_t & cthis = (*this);\par
00182         cthis.clear();\par
00183         basic_stringstream<char> in;\par
00184         in.clear();\par
00185         in << a;\par
00186         in >> (*this);\par
00187         {\cf19 return};\par
00188 \}\par
00189 \par
00190 {\cf17 const} nat_num_t & operator = ({\cf17 const} {\cf18 string} & a ) \{\par
00191         nat_num_t & cthis = (*this);\par
00192         cthis.clear();\par
00193         basic_stringstream<char> in;\par
00194         in.clear();\par
00195         in << a;\par
00196         in >> cthis;\par
00197         {\cf19 return} cthis;\par
00198 \}\par
00199 \par
00200 {\cf17 operator} string (){\cf17  const }\{\par
00201 \par
00202         {\cf17 const} nat_num_t & cthis = (*this);\par
00203         {\cf18 string} ret;\par
00204         basic_stringstream<char> sal_aux;\par
00205         sal_aux << cthis;\par
00206         sal_aux >> ret;\par
00207         {\cf19 return} ret;\par
00208 \}\par
00209 \par
00210 nat_num_t(dig a0) \{\par
00211         nat_num_t & cthis = (*this);\par
00212         aux=pardigs();\par
00213         cthis.clear();\par
00214         cthis.resize(1);\par
00215         cthis[0]=a0;\par
00216 \}\par
00217 \par
00218 {\cf17 const} nat_num_t & operator = ({\cf17 const} dig & a0) \{\par
00219         nat_num_t & cthis = (*this);\par
00220         aux=pardigs();\par
00221         cthis.clear();\par
00222         cthis.resize(1);\par
00223         cthis[0]=a0;\par
00224         {\cf19 return} cthis;\par
00225 \}\par
00226 \par
00227 nat_num_t({\cf17 const} dig & a1,{\cf17 const} dig & a0 ) \{\par
00228         nat_num_t & cthis = (*this);\par
00229         aux=pardigs();\par
00230         cthis.clear();\par
00231         cthis.resize(2);\par
00232         cthis[1]=a0;\par
00233         cthis[0]=a1;\par
00234         cthis.reduce();\par
00235 \}\par
00236 \par
00237 nat_num_t({\cf17 const} dig & a2,{\cf17 const} dig & a1,{\cf17 const} dig & a0) \{\par
00238         nat_num_t & cthis = (*this);\par
00239         aux=pardigs();\par
00240         cthis.clear();\par
00241         cthis.resize(3);\par
00242         cthis[2]=a0;\par
00243         cthis[1]=a1;\par
00244         cthis[0]=a2;\par
00245         cthis.reduce();\par
00246 \}\par
00247 \par
00248 nat_num_t({\cf17 const} vector<dig> & arg) \{\par
00249         nat_num_t & cthis = (*this);\par
00250         aux=pardigs();\par
00251         cthis.clear();\par
00252         {\cf19 for} ( {\cf18 int} ix=0; ix < arg.size() ; ++ix )\par
00253                 cthis.push_back(arg[ix]);\par
00254         cthis.reduce();\par
00255 \}\par
00256 \par
00257 {\cf17 const} nat_num_t & operator = ({\cf17 const} vector<dig> & arg) \{\par
00258         nat_num_t & cthis = (*this);\par
00259         aux=pardigs();\par
00260         cthis.clear();\par
00261         {\cf19 for} ( {\cf18 int} ix=0; ix < arg.size() ; ++ix )\par
00262                 cthis.push_back(arg[ix]);\par
00263         cthis.reduce();\par
00264         {\cf19 return} cthis;\par
00265 \}\par
00266 \par
00267 {\cf17 operator} vector<dig> (){\cf17  const }\{\par
00268         {\cf17 const} nat_num_t & cthis = (*this);\par
00269         {\cf17 const} usint sz = (cthis.reduce()).size();\par
00270         {\cf17 const} usint pos_max = sz-1;\par
00271         vector<dig> ret(sz);\par
00272         {\cf19 for} ( {\cf18 int} ix=0; ix < sz ; ++ix )\par
00273                 ret[pos_max-ix] = cthis[ix];\par
00274         {\cf19 return} ret;\par
00275 \}\par
00276 \par
00277 nat_num_t({\cf17 const} pardigs & a) \{\par
00278         nat_num_t & cthis = (*this);\par
00279         aux=pardigs();\par
00280         cthis.clear();\par
00281         cthis.resize(2);\par
00282         cthis[0] = a.g_first();\par
00283         cthis[1] = a.g_second();\par
00284         cthis.reduce();\par
00285 \}\par
00286 \par
00287 {\cf17 const} nat_num_t & operator = ({\cf17 const} pardigs & a) \{\par
00288         {\cf17 const} nat_num_t & cthis = (*this);\par
00289         aux=pardigs();\par
00290         cthis.clear();\par
00291         cthis.resize(2);\par
00292         cthis[0] = a.g_first();\par
00293         cthis[1] = a.g_second();\par
00294         cthis.reduce();\par
00295         {\cf19 return} cthis;\par
00296 \}\par
00297 \par
00298 nat_num_t({\cf17 const} n2digs & a) \{\par
00299         nat_num_t & cthis = (*this);\par
00300         aux=pardigs();\par
00301         cthis.clear();\par
00302         cthis.resize(2);\par
00303         cthis[0] = a.first();\par
00304         cthis[1] = a.second();\par
00305         cthis.reduce();\par
00306 \}\par
00307 \par
00308 {\cf17 const} nat_num_t & operator = ({\cf17 const} n2digs & a) \{\par
00309         {\cf17 const} nat_num_t & cthis = (*this);\par
00310         aux=pardigs();\par
00311         cthis.clear();\par
00312         cthis.resize(2);\par
00313         cthis[0] = a.first();\par
00314         cthis[1] = a.second();\par
00315         cthis.reduce();\par
00316         {\cf19 return} cthis;\par
00317 \}\par
00318 \par
00319 nat_num_t({\cf18 char} ch) \{\par
00320         nat_num_t & cthis = (*this);\par
00321         cthis.clear();\par
00322         aux=pardigs();\par
00323         cthis.resize(1);\par
00324         cthis[0] = dig_t({\cf17 static_cast<}uchint{\cf17 >}(ch-{\cf23 '0'}));\par
00325 \}\par
00326 \par
00327 {\cf17 const} nat_num_t & operator = ({\cf18 char} ch) \{\par
00328         nat_num_t & cthis = (*this);\par
00329         cthis.clear();\par
00330         aux=pardigs();\par
00331         cthis.resize(1);\par
00332         cthis[0] = dig_t({\cf17 static_cast<}uchint{\cf17 >}(ch-{\cf23 '0'}));\par
00333         {\cf19 return} cthis;\par
00334 \}\par
00335 \par
00336 nat_num_t(uchint a) \{\par
00337         nat_num_t & cthis = (*this);\par
00338         aux=pardigs();\par
00339         cthis.clear();\par
00340         cthis.resize(1);\par
00341         cthis[0]=UInt2Dig<B>(a);\par
00342 \}\par
00343 \par
00344 {\cf17 const} nat_num_t & operator = (uchint a) \{\par
00345         nat_num_t & cthis = (*this);\par
00346         aux=pardigs();\par
00347         cthis.clear();\par
00348         cthis.resize(1);\par
00349         cthis[0]=UInt2Dig<B>(a);\par
00350         {\cf19 return} cthis;\par
00351 \}\par
00352 \par
00353 nat_num_t(usint a) \{\par
00354         nat_num_t & cthis = (*this);\par
00355         base_num_t<B> temp;\par
00356         cthis.clear();\par
00357         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<usint,B>().first);}\par
00358         aux=pardigs();\par
00359         usint rem=0,coc=a;\par
00360         {\cf19 while} (coc >= B) \{\par
00361                 rem = coc%B;\par
00362                 cthis.push_front(UInt2Dig<B>(rem));\par
00363                 coc = coc/B;\par
00364         \}\par
00365         rem = coc%B;\par
00366         cthis.push_front(UInt2Dig<B>(rem));\par
00367 \}\par
00368 \par
00369 {\cf17 const} nat_num_t & operator = (usint a) \{\par
00370         nat_num_t & cthis = (*this);\par
00371         base_num_t<B> temp;\par
00372         cthis.clear();\par
00373         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<usint,B>());}\par
00374         aux=pardigs();\par
00375         usint rem=0,coc=a;\par
00376         {\cf19 while} (coc >= B) \{\par
00377                 rem = coc%B;\par
00378                 cthis.push_front(UInt2Dig<B>(rem));\par
00379                 coc = coc/B;\par
00380         \}\par
00381         rem = coc%B;\par
00382         cthis.push_front(UInt2Dig<B>(rem));\par
00383         {\cf19 return} cthis;\par
00384 \}\par
00385 \par
00386 nat_num_t(uint a) \{\par
00387         nat_num_t & cthis = (*this);\par
00388         cthis.clear();\par
00389         {\cf20 //const ullint tsz = pot_max_base_B_en_Int_T<uint,B>();}\par
00390         {\cf20 //cout << tsz << " digitos base 10 en un uint " << endl;}\par
00391         {\cf20 //cthis.resize(tsz);}\par
00392         aux=pardigs();\par
00393         uint rem=0,coc=a;\par
00394         {\cf19 while} (coc >= B) \{\par
00395                 rem = coc%B;\par
00396                 cthis.push_front(UInt2Dig<B>(rem));\par
00397                 coc = coc/B;\par
00398         \}\par
00399         rem = coc%B;\par
00400         cthis.push_front(UInt2Dig<B>(rem));\par
00401 \}\par
00402 \par
00403 {\cf17 const} nat_num_t & operator = (uint a) \{\par
00404         nat_num_t & cthis = (*this);\par
00405         cthis.clear();\par
00406         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<uint,B>());}\par
00407         aux=pardigs();\par
00408         uint rem=0,coc=a;\par
00409         {\cf19 while} (coc >= B) \{\par
00410                 rem = coc%B;\par
00411                 cthis.push_front(UInt2Dig<B>(rem));\par
00412                 coc = coc/B;\par
00413         \}\par
00414         rem = coc%B;\par
00415         cthis.push_front(UInt2Dig<B>(rem));\par
00416         {\cf19 return} cthis;\par
00417 \}\par
00418 \par
00419 nat_num_t(ulint a) \{\par
00420         nat_num_t & cthis = (*this);\par
00421         aux=pardigs();\par
00422         cthis.clear();\par
00423         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<ulint,B>().second);}\par
00424         ulint rem=0,coc=a;\par
00425         {\cf19 while} (coc >= B) \{\par
00426                 rem = coc%B;\par
00427                 cthis.push_front(UInt2Dig<B>(rem));\par
00428                 coc = coc/B;\par
00429         \}\par
00430         rem = coc%B;\par
00431         cthis.push_front(UInt2Dig<B>(rem));\par
00432 \}\par
00433 \par
00434 {\cf17 const} nat_num_t & operator = (ulint a) \{\par
00435         nat_num_t & cthis = (*this);\par
00436         aux=pardigs();\par
00437         cthis.clear();\par
00438         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<ulint,B>());}\par
00439         ulint rem=0,coc=a;\par
00440         {\cf19 while} (coc >= B) \{\par
00441                 rem = coc%B;\par
00442                 cthis.push_front(UInt2Dig<B>(rem));\par
00443                 coc = coc/B;\par
00444         \}\par
00445         rem = coc%B;\par
00446         cthis.push_front(UInt2Dig<B>(rem));\par
00447         {\cf19 return} cthis;\par
00448 \}\par
00449 \par
00450 nat_num_t(ullint a) \{\par
00451         nat_num_t & cthis = (*this);\par
00452         aux=pardigs();\par
00453         cthis.clear();\par
00454         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<ullint,B>().second);}\par
00455         ullint rem=0,coc=a;\par
00456         {\cf19 while} (coc >= B) \{\par
00457                 rem = coc%B;\par
00458                 cthis.push_front(UInt2Dig<B>(rem));\par
00459                 coc = coc/B;\par
00460         \}\par
00461         rem = coc%B;\par
00462         cthis.push_front(UInt2Dig<B>(rem));\par
00463 \}\par
00464 \par
00465 {\cf17 const} nat_num_t & operator = (ullint a) \{\par
00466         nat_num_t & cthis = (*this);\par
00467         aux=pardigs();\par
00468         cthis.clear();\par
00469         {\cf20 //cthis.resize(pot_max_base_B_en_Int_T<ullint,B>());}\par
00470         ullint rem=0,coc=a;\par
00471         {\cf19 while} (coc >= B) \{\par
00472                 rem = coc%B;\par
00473                 cthis.push_front(UInt2Dig<B>(rem));\par
00474                 coc = coc/B;\par
00475         \}\par
00476         rem = coc%B;\par
00477         cthis.push_front(UInt2Dig<B>(rem));\par
00478         {\cf19 return} cthis;\par
00479 \}\par
00480 \par
00481 {\cf17 operator} uint (){\cf17  const }\{\par
00482         {\cf17 const} nat_num_t & cthis = (*this);\par
00483         {\cf17 const} uint sz = (cthis.reduce()).size();\par
00484         {\cf17 const} uint pos_max = sz-1;\par
00485         {\cf17 const} uint nds = num_digs_max_base_B_en_Int_T<uint,B>();\par
00486         {\cf20 //cout << nds << endl;}\par
00487         uchint ret = 0;\par
00488         {\cf19 for}(uint il = 0; (il < sz)and(il < nds) ;++il) \{\par
00489                 ret *= B;\par
00490                 ret += cthis[sz-nds+il].Dig2UInt();\par
00491         \}\par
00492         {\cf19 return} ret;\par
00493 \}\par
00494 \par
00495 {\cf17 operator} usint (){\cf17  const }\{\par
00496         {\cf17 const} nat_num_t & cthis = (*this);\par
00497         {\cf17 const} uint sz = (cthis.reduce()).size();\par
00498         {\cf17 const} uint pos_max = sz-1;\par
00499         {\cf17 const} uint nds = num_digs_max_base_B_en_Int_T<usint,B>();\par
00500         {\cf20 //cout << nds << endl;}\par
00501         uchint ret = 0;\par
00502         {\cf19 for}(uint il = 0; (il < sz)and(il < nds) ;++il) \{\par
00503                 ret *= ullint(B);\par
00504                 ret += cthis[sz-nds+il].Dig2UInt();\par
00505         \}\par
00506         {\cf19 return} ret;\par
00507 \}\par
00508 \par
00509 {\cf17 operator} uchint (){\cf17  const }\{\par
00510         {\cf17 const} nat_num_t & cthis = (*this);\par
00511         {\cf17 const} uint sz = (cthis.reduce()).size();\par
00512         {\cf17 const} uint pos_max = sz-1;\par
00513         {\cf17 const} uint nds = num_digs_max_base_B_en_Int_T<uchint,B>();\par
00514         {\cf20 //cout << nds << endl;}\par
00515         uchint ret = 0;\par
00516         {\cf19 for}(uint il = 0; (il < sz)and(il < nds) ;++il) \{\par
00517                 ret *= B;\par
00518                 ret += cthis[sz-nds+il].Dig2UInt();\par
00519         \}\par
00520         {\cf19 return} ret;\par
00521 \}\par
00522 \par
00523 {\cf17 operator} ulint (){\cf17  const }\{\par
00524         {\cf17 const} nat_num_t & cthis = (*this);\par
00525         {\cf17 const} uint sz = (cthis.reduce()).size();\par
00526         {\cf17 const} uint pos_max = sz-1;\par
00527         {\cf17 const} uint nds = num_digs_max_base_B_en_Int_T<ulint,B>();\par
00528         {\cf20 //cout << nds << endl;}\par
00529         uchint ret = 0;\par
00530         {\cf19 for}(uint il = 0; (il < sz)and(il < nds) ;++il) \{\par
00531                 ret *= B;\par
00532                 ret += cthis[sz-nds+il].Dig2UInt();\par
00533         \}\par
00534         {\cf19 return} ret;\par
00535 \}\par
00536 \par
00537 {\cf17 operator} ullint (){\cf17  const }\{\par
00538         {\cf17 const} nat_num_t & cthis = (*this);\par
00539         {\cf17 const} uint sz = (cthis.reduce()).size();\par
00540         {\cf17 const} uint pos_max = sz-1;\par
00541         {\cf17 const} uint nds = num_digs_max_base_B_en_Int_T<ullint,B>();\par
00542         {\cf20 //cout << nds << endl;}\par
00543         uchint ret = 0;\par
00544         {\cf19 for}(uint il = 0; (il < sz)and(il < nds) ;++il) \{\par
00545                 ret *= B;\par
00546                 ret += cthis[sz-nds+il].Dig2UInt();\par
00547         \}\par
00548         {\cf19 return} ret;\par
00549 \}\par
00550 \par
00551 nat_num_t & operator = (dig a0) \{\par
00552         nat_num_t & cthis = (*this);\par
00553         aux=pardigs();\par
00554         cthis.clear();\par
00555         cthis.resize(1);\par
00556         cthis[0]=a0;\par
00557         {\cf19 return} cthis;\par
00558 \}\par
00559 \par
00560 {\cf20                                         /*********************************/}\par
00561                                         {\cf20 /*                                                               */}\par
00562                                         {\cf20 /*  DIGITOS NO SIGNIFICATIVOS    */}\par
00563                                         {\cf20 /*                                                               */}\par
00564 {\cf20                                         /*********************************/}\par
00565 \par
00566 usint ceros_a_la_izqda (){\cf17  const }\{\par
00567         {\cf17 const} nat_num_t & cthis = (*this);\par
00568         {\cf20 //digitos no significativos para n\'FAmeros positivos}\par
00569         {\cf18 bool} Exit = {\cf17 false};\par
00570         {\cf18 int} sz=0;\par
00571         {\cf17 const} {\cf18 size_t} fin= cthis.size();\par
00572         {\cf19 for} ( uint i=0 ; (i < fin) and (!Exit) ; ++i) \{\par
00573                 {\cf19 if} (cthis[i]==0) ++sz;\par
00574                 {\cf19 else} Exit={\cf17 true};\par
00575         \}\par
00576         {\cf19 return} sz;\par
00577 \}\par
00578 {\cf20 //digitos no significativos para n\'FAmeros positivos}\par
00579 {\cf18 size_t} ceros_a_la_drcha (){\cf17  const }\{\par
00580         {\cf17 const} nat_num_t & cthis = (*this);\par
00581         {\cf18 bool} Exit = {\cf17 false};\par
00582         {\cf18 size_t} sz=0;\par
00583         {\cf17 const} {\cf18 size_t} fin=cthis.size();\par
00584         {\cf17 const} {\cf18 size_t} finl = fin-1;\par
00585         {\cf19 if} (cthis[finl]==0) \{\par
00586                 {\cf19 for} ( {\cf18 int} i=finl ; (i >=0) and (!Exit) ; --i) \{\par
00587                         {\cf19 if} (cthis[i]==0) ++sz;\par
00588                         {\cf19 else} Exit={\cf17 true};\par
00589                 \}\par
00590         \}\par
00591         {\cf19 return} sz;\par
00592 \}\par
00593 \par
00594 usint digs_no_significativos (){\cf17  const }\{\par
00595         {\cf17 const} nat_num_t & cthis = (*this);\par
00596         {\cf20 //digitos no significativos}\par
00597         {\cf19 return} ceros_a_la_izqda();\par
00598 \}\par
00599 usint digs_fracc_no_significativos (){\cf17  const }\{\par
00600         {\cf17 const} nat_num_t & cthis = (*this);\par
00601         {\cf20 //digitos no significativos}\par
00602         {\cf19 return} ceros_a_la_drcha();\par
00603 \}\par
00604 \par
00605 {\cf20                         /************************************/}\par
00606                         {\cf20 /*                                                                      */}\par
00607                         {\cf20 /*   OPERACIONES COMPARATIVAS           */}\par
00608                         {\cf20 /*                                                                      */}\par
00609 {\cf20                         /************************************/}\par
00610 \par
00611 {\cf18 bool} operator == ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00612         {\cf17 const} nat_num_t & cthis = (*this);\par
00613         {\cf17 const} usint thisnsz = ceros_a_la_izqda();\par
00614         {\cf17 const} usint thisvsz = cthis.size()-thisnsz;\par
00615         {\cf17 const} usint argnsz = arg.ceros_a_la_izqda();\par
00616         {\cf17 const} usint argvsz = arg.size()-argnsz;\par
00617         {\cf19 if} ((thisvsz > argvsz)||(thisvsz < argvsz))\par
00618                 {\cf19 return} {\cf17 false};\par
00619         {\cf19 else} \{\par
00620                 {\cf19 for} (slint k=(thisvsz-1);k>=0;--k)\par
00621                         {\cf19 if} (arg[k]!=cthis[k]) {\cf19 return} {\cf17 false};\par
00622                 {\cf19 return} {\cf17 true};\par
00623         \}\par
00624 \}\par
00625 \par
00626 {\cf18 bool} operator != ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00627         {\cf17 const} nat_num_t & cthis = (*this);\par
00628         {\cf17 const} usint thisnsz = ceros_a_la_izqda();\par
00629         {\cf17 const} usint thisvsz = (cthis.size())-thisnsz;\par
00630         {\cf17 const} usint argnsz = arg.ceros_a_la_izqda();\par
00631         {\cf17 const} usint argvsz = arg.size()-argnsz;\par
00632         {\cf19 if} ((thisvsz > argvsz)||(thisvsz < argvsz))\par
00633                 {\cf19 return} {\cf17 true};\par
00634         {\cf19 else} \{\par
00635                 {\cf19 for} (slint k=(thisvsz-1);k>=0;--k)\par
00636                         {\cf19 if} (arg[k]!=cthis[k])\par
00637                                 {\cf19 return} {\cf17 true};\par
00638                 {\cf19 return} {\cf17 false};\par
00639         \}\par
00640 \}\par
00641 \par
00642 {\cf18 bool} operator >= ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00643         {\cf17 const} nat_num_t & cthis = (*this);\par
00644         {\cf17 const} usint thisnsz = ceros_a_la_izqda();\par
00645         {\cf17 const} usint thisvsz = (cthis.size())-thisnsz;\par
00646         {\cf17 const} usint argnsz = arg.ceros_a_la_izqda();\par
00647         {\cf17 const} usint argvsz = arg.size()-argnsz;\par
00648 \par
00649         {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 true};\par
00650         {\cf19 else} {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 false};\par
00651 \par
00652         {\cf19 for} (usint k=0;k<thisvsz;++k) \{\par
00653                 {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 true};\par
00654                 {\cf19 else} {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 false};\par
00655         \}\par
00656         {\cf19 return} {\cf17 false};\par
00657 \}\par
00658 \par
00659 {\cf18 bool} operator <= ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00660         {\cf17 const} nat_num_t & cthis = (*this);\par
00661         {\cf17 const} usint thisnsz = ceros_a_la_izqda();\par
00662         {\cf17 const} usint thisvsz = (cthis.size())-thisnsz;\par
00663         {\cf17 const} usint argnsz = arg.ceros_a_la_izqda();\par
00664         {\cf17 const} usint argvsz = arg.size()-argnsz;\par
00665         {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 true};\par
00666         {\cf19 else} {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 false};\par
00667         {\cf19 for} (usint k=0;k<thisvsz;++k) \{\par
00668                 {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 true};\par
00669                 {\cf19 else} {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 false};\par
00670         \}\par
00671         {\cf19 return} {\cf17 false};\par
00672 \}\par
00673 \par
00674 {\cf18 bool} operator >  ({\cf17 const} nat_num_t & arg ){\cf17  const }\{\par
00675         {\cf17 const} nat_num_t & cthis = (*this);\par
00676         {\cf17 const} usint thisnsz = ceros_a_la_izqda();\par
00677         {\cf17 const} usint thisvsz = (cthis.size())-thisnsz;\par
00678         {\cf17 const} usint argnsz = arg.ceros_a_la_izqda();\par
00679         {\cf17 const} usint argvsz = arg.size()-argnsz;\par
00680         {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 true};\par
00681         {\cf19 else} {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 false};\par
00682 \par
00683         {\cf19 for} (usint k=0;k<thisvsz;++k) \{\par
00684                 {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 true};\par
00685                 {\cf19 else} {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 false};\par
00686         \}\par
00687         {\cf19 return} {\cf17 false};\par
00688 \}\par
00689 \par
00690 {\cf18 bool} operator <  ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00691         {\cf17 const} nat_num_t & cthis = (*this);\par
00692         {\cf17 const} usint thisnsz = ceros_a_la_izqda();\par
00693         {\cf17 const} usint thisvsz = (cthis.size())-thisnsz;\par
00694         {\cf17 const} usint argnsz = arg.ceros_a_la_izqda();\par
00695         {\cf17 const} usint argvsz = arg.size()-argnsz;\par
00696 \par
00697         {\cf19 if} (thisvsz < argvsz) {\cf19 return} {\cf17 true};\par
00698         {\cf19 else} {\cf19 if} (thisvsz > argvsz) {\cf19 return} {\cf17 false};\par
00699         {\cf19 for} (usint k=0;k<thisvsz;++k) \{\par
00700                 {\cf19 if} ((cthis[k] < arg[k])) {\cf19 return} {\cf17 true};\par
00701                 {\cf19 else} {\cf19 if} ((cthis[k] > arg[k])) {\cf19 return} {\cf17 false};\par
00702         \}\par
00703         {\cf19 return} {\cf17 false};\par
00704 \}\par
00705 \par
00706 {\cf20                         /************************************/}\par
00707                         {\cf20 /*                                                                      */}\par
00708                         {\cf20 /*     OPERACIONES ARITMETICAS          */}\par
00709                         {\cf20 /*                                                                      */}\par
00710 {\cf20                         /************************************/}\par
00711 \par
00712 nat_num_t operator + ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00713 \par
00714         {\cf17 const} nat_num_t & cthis = (*this);\par
00715         pardigs_t<B> tempt ;\par
00716         {\cf17 const} {\cf18 bool} cthis_is_max = (cthis>=arg);\par
00717         nat_num_t<B> cpyarg(arg);\par
00718         nat_num_t<B> cpythis(cthis);\par
00719         cpythis.reduce();\par
00720         cpyarg.reduce();\par
00721         nat_num_t<B> * pmax = ((cthis_is_max)?(&cpythis):(&cpyarg));\par
00722         nat_num_t<B> & max = (*pmax);\par
00723         nat_num_t<B> * pmin = ((cthis_is_max)?(&cpyarg):(&cpythis));\par
00724         nat_num_t<B> & min = (*pmin);\par
00725 \par
00726         dig carry(0);\par
00727 \par
00728         {\cf18 int} M = (max.size())-1;\par
00729         {\cf18 int} m = (min.size())-1;\par
00730         {\cf19 for} ( ; !(m<0) ; --M,--m) \{\par
00731                 tempt.p_uds(max[M]);\par
00732                 tempt.p_decs(dig_t(0));\par
00733                 tempt += min[m];\par
00734                 tempt += carry;\par
00735                 carry =tempt.g_decs();\par
00736                 max[M]=tempt.g_uds();\par
00737         \}\par
00738         {\cf19 for} ( ; !(M<0) ; --M) \{\par
00739                 tempt.p_uds(max[M]);\par
00740                 tempt.p_decs(dig_t(0));\par
00741                 tempt += carry;\par
00742                 carry =tempt.g_decs();\par
00743                 max[M]=tempt.g_uds();\par
00744         \}\par
00745 \par
00746         {\cf19 if} (carry!=dig(0)) \{\par
00747                 max.push_front(carry);\par
00748         \}\par
00749 \par
00750         max.aux =  pardigs();\par
00751         {\cf19 return} max;\par
00752 \}\par
00753 \par
00754 nat_num_t operator - ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00755         nat_num_t ret(*{\cf17 this});\par
00756         ret.reduce();\par
00757         {\cf17 const} {\cf18 size_t} szret = ret.size();\par
00758         nat_num_t cpy(arg.minus(ret.size()));\par
00759         ret += cpy;\par
00760         {\cf19 if} (ret.size() > szret) \{\par
00761                 ret.erase(0,1);\par
00762         \}\par
00763         ret.reduce();\par
00764         {\cf19 return} ret;\par
00765 \}\par
00766 \par
00767 {\cf20 // Utilizamos una funcion nat_num_t * dig_t}\par
00768 nat_num_t operator * ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00769         {\cf17 const} nat_num_t & cthis = (*this);\par
00770         cthis.reduce();\par
00771         nat_num_t multtemp;\par
00772         nat_num_t sumatemp;\par
00773         nat_num_t cadena_de_ceros;\par
00774         {\cf17 const} {\cf18 int} argsz = arg.size();\par
00775         {\cf17 const} {\cf18 int} argmsb = argsz-2;\par
00776 \par
00777 \par
00778         multtemp = cthis*arg[argsz-1];\par
00779         sumatemp += multtemp;\par
00780 \par
00781         {\cf19 for} ({\cf18 int} j = argmsb ; j >= 0 ; --j) \{\par
00782                 multtemp = cthis*arg[j];\par
00783                 multtemp &= cadena_de_ceros;\par
00784                 sumatemp += multtemp;\par
00785                 cadena_de_ceros.push_back(dig(0));\par
00786         \}\par
00787 \par
00788         {\cf19 return} sumatemp;\par
00789 \}\par
00790 \par
00791 nat_num_t operator / ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00792         {\cf17 const} nat_num_t & cthis = (*this);\par
00793         nat_num_t dvndo_int(cthis); {\cf20 //Siempre ser\'E1 positivo}\par
00794         dvndo_int.reduce();\par
00795         nat_num_t rem(dvndo_int);\par
00796         rem.reduce();\par
00797         nat_num_t dvsor_int(arg);{\cf20 //Siempre ser\'E1 positivo}\par
00798         dvsor_int.reduce();\par
00799 \par
00800         {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 // ceros que tienen valor y por los que dividir}\par
00801         {\cf20 // divisor y dividendo}\par
00802         nat_num_t dvndo_fra(dvndo_int);\par
00803 \par
00804         {\cf19 if} (dvndo_int.size()>=dvsor_int.size()) \{\par
00805                 dvndo_fra.erase(0,dvndo_int.size()-cssor);\par
00806                 {\cf19 if} (dvndo_int != nat_num_t(dig(0))) \{\par
00807                         dvndo_int.erase(dvndo_int.size()-cssor,cssor);{\cf20 // division por una potencia de B, /B^cssor}\par
00808                 \}\par
00809                 dvndo_int.reduce();\par
00810                 {\cf19 if} (dvsor_int != nat_num_t(dig(0))) \{\par
00811                         dvsor_int.erase(dvsor_int.size()-cssor,cssor);{\cf20 // division por una potencia de B  /B^cssor}\par
00812                 \}\par
00813                 nat_num_t dvsor_fra(dvsor_int);\par
00814                 dvsor_fra.erase(0,dvsor_int.size()-cssor);\par
00815                 dvsor_int.reduce();\par
00816         \}\par
00817         {\cf19 else} \{\par
00818                 dvndo_int = nat_num_t(dig(0));\par
00819                 {\cf19 return} dvndo_int;\par
00820         \}\par
00821         {\cf20 //dvndo_fra.reduce();//dvndo_fra.reduce_fra() HAY QUE HACERLO}\par
00822         {\cf17 const} {\cf18 int} szndo         = dvndo_int.size();\par
00823         {\cf17 const} {\cf18 int} lsb_ndo   = szndo-1;\par
00824         {\cf17 const} {\cf18 int} msb_ndo       = 0;\par
00825         {\cf17 const} {\cf18 int} szsor     = dvsor_int.size();\par
00826         {\cf17 const} {\cf18 int} lsb_sor   = szsor-1;\par
00827         {\cf17 const} {\cf18 int} msb_sor   = 0;\par
00828 \par
00829         {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
00830         {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
00831         {\cf20 // cocientes enteros.}\par
00832         div_uno(rem,dvndo_int,dvsor_int,szndo,szsor);\par
00833         {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
00834         {\cf20 // dividendo obteniendo dvndo_fra}\par
00835 \par
00836         {\cf20 /* *}\par
00837 {\cf20                 RemReal = RemObtenido*(B^cssor) + Dvndo_fra}\par
00838 {\cf20 }\par
00839 {\cf20                 rem = rem.insert(rem.size()-1,cssor,0);}\par
00840 {\cf20                 rem += dvndo_fra;}\par
00841 {\cf20         * */}\par
00843         {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
00844         {\cf20 // acomodar el formato al signo de la operacion}\par
00845         {\cf20 // determinar el signo de la operacion}\par
00846         {\cf19 return} dvndo_int;\par
00847 \}\par
00848 \par
00849 nat_num_t operator % ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
00850         {\cf17 const} nat_num_t & cthis = (*this);\par
00851         nat_num_t dvndo_int(cthis); {\cf20 //Siempre ser\'E1 positivo}\par
00852         dvndo_int.reduce();\par
00853         nat_num_t rem(dvndo_int);\par
00854         rem.reduce();\par
00855         nat_num_t dvsor_int(arg);{\cf20 //Siempre ser\'E1 positivo}\par
00856         dvsor_int.reduce();\par
00857         dvndo_int/=dvsor_int;\par
00858         dvndo_int*=dvsor_int;\par
00859         rem -= dvndo_int;\par
00860         {\cf19 return} rem;\par
00861 \}\par
00862 \par
00863 nat_num_t operator * (pardigs a){\cf17  const }\{\par
00864         {\cf17 const} nat_num_t & cthis = (*this);\par
00865         pardigs                 temp;\par
00866         dig                     carry=0;\par
00867         nat_num_t               ret(*{\cf17 this});\par
00868         {\cf19 for} ( ssint k=(cthis.size()-1) ; k >= 0  ; --k ) \{\par
00869                 temp = (pardigs(cthis[k]))*(pardigs(a.g_first()));\par
00870                 temp += carry;\par
00871                 ret[k]= temp.g_first();\par
00872                 carry=temp.g_second();\par
00873         \}\par
00874         {\cf19 if} (carry != 0)\par
00875                 ret.insert(0,carry);\par
00876         ret.reduce();\par
00877         carry = 0;\par
00878         nat_num_t ret2(ret);\par
00879         {\cf19 for} ( ssint k=((cthis.size())-1) ; k >= 0  ; --k ) \{\par
00880                 temp = pardigs(cthis[k])*pardigs(a.g_second());\par
00881                 temp += carry;\par
00882                 ret2.erase(0,k-1);\par
00883                 ret2 += temp.g_first();{\cf20 //\'BF?}\par
00884                 carry = temp.g_second();\par
00885         \}\par
00886         ret += ret2;\par
00887         {\cf19 if} (carry != 0)\par
00888                 ret.insert(0,carry);\par
00889         ret.reduce();\par
00890 \par
00891         {\cf19 return} ret;\par
00892 \}\par
00893 \par
00894 {\cf20 //      nat_num_t operator / (pardigs) const;}\par
00895 {\cf20 //      nat_num_t operator % (pardigs) const;}\par
00896 \par
00897 nat_num_t operator + (dig arg){\cf17  const }\{\par
00898         nat_num_t ret(*{\cf17 this});\par
00899         ret.reduce();\par
00900         pardigs tempt;\par
00901         {\cf17 const} usint szt = ret.size();\par
00902         ssint k = szt-1;\par
00903         dig carry;\par
00904 \par
00905         tempt.p_uds(ret[k]);\par
00906         tempt += arg;\par
00907         ret[k] = tempt.g_uds();\par
00908         carry = tempt.g_decs();\par
00909         tempt.p_decs(dig(0));\par
00910 \par
00911         {\cf19 if} (szt>=1) \{\par
00912                 {\cf19 for} ( k=szt-2 ; k>=0 ; --k) \{\par
00913                         tempt.p_uds(ret[k]);\par
00914                         tempt += carry;\par
00915                         ret[k]=tempt.g_uds();\par
00916                         carry =tempt.g_decs();\par
00917                         tempt.p_decs(dig(0));\par
00918                 \}\par
00919         \}\par
00920 \par
00921         ret.push_front(carry) ;\par
00922         ret.aux = pardigs();\par
00923         ret.reduce();\par
00924         {\cf19 return} ret;\par
00925 \}\par
00926 \par
00927 nat_num_t operator - (dig arg){\cf17  const }\{\par
00928         nat_num_t ret(*{\cf17 this});\par
00929         ret.reduce();\par
00930         {\cf19 if} (arg == dig(0)) {\cf19 return} ret;\par
00931         nat_num_t cpy(nat_num_t(arg).minus(ret.size()));\par
00932         pardigs tempt;\par
00933         pardigs tempa;\par
00934         sint szt = ret.size();\par
00935         sint k = szt-1;\par
00936         tempt.p_uds(ret[k]);\par
00937         tempt.p_decs(dig(0));\par
00938         tempa.p_uds(cpy[k]);\par
00939         tempa.p_decs(dig(0));\par
00940         tempt += tempa;\par
00941         ret[k] =tempt.g_uds();\par
00942         dig carry(tempt.g_decs());\par
00943         --k;\par
00944         {\cf19 for} ( ; k >= 0 ; --k) \{\par
00945                 tempt.p_uds(ret[k]);\par
00946                 tempt += cpy[k];\par
00947                 tempt += carry;\par
00948                 carry =tempt.g_decs();\par
00949                 ret[k] =tempt.g_uds();\par
00950         \}\par
00951 \par
00952         ret.reduce();\par
00953         ret.aux =  pardigs();\par
00954         {\cf19 return} ret;\par
00955 \}\par
00956 \par
00957 nat_num_t operator * (dig a){\cf17  const }\{\par
00958         {\cf17 const} nat_num_t & cthis = (*this);\par
00959         pardigs         temp;\par
00960         dig             carry=0;\par
00961         {\cf17 const} {\cf18 int}       sz = cthis.size();\par
00962         {\cf17 const} {\cf18 int}       lsb = sz - 1;\par
00963         nat_num_t ret(*{\cf17 this});\par
00964         {\cf19 for} ( {\cf18 int} k=lsb ; k >= 0 ; --k ) \{\par
00965                 temp = pardigs(dig(0),cthis[k])*a;\par
00966                 temp += carry;\par
00967                 ret[k]= temp.g_uds();\par
00968                 carry=temp.g_decs();\par
00969         \}\par
00970         {\cf19 if} (carry != 0) \{\par
00971                 ret.push_front(carry);\par
00972         \}\par
00973         ret.reduce();\par
00974         {\cf19 return} ret;\par
00975 \}\par
00976 \par
00977 {\cf20                         /************************************/}\par
00978                         {\cf20 /*                                                                      */}\par
00979                         {\cf20 /*   OPERACIONES ARITMETICAS            */}\par
00980                         {\cf20 /*           CON ASIGNACION                             */}\par
00981                         {\cf20 /*                                                                      */}\par
00982 {\cf20                         /************************************/}\par
00983 \par
00984 {\cf17 const} nat_num_t & operator += ({\cf17 const} nat_num_t &arg) \{\par
00985         nat_num_t & cthis = (*this);\par
00986         cthis.reduce();\par
00987         pardigs_t<B> tempt ;\par
00988         {\cf17 const} {\cf18 bool} cthis_is_max = (cthis>=arg);\par
00989         nat_num_t<B> cpyarg(arg);\par
00990         cpyarg.reduce();\par
00991         nat_num_t<B> * pmax = ((cthis_is_max)?(&cthis):(&cpyarg));\par
00992         nat_num_t<B> & max = (*pmax);\par
00993         nat_num_t<B> * pmin = ((cthis_is_max)?(&cpyarg):(&cthis));\par
00994         nat_num_t<B> & min = (*pmin);\par
00995 \par
00996         dig carry(0);\par
00997 \par
00998         {\cf18 int} M = (max.size())-1;\par
00999         {\cf18 int} m = (min.size())-1;\par
01000         cthis.aux = pardigs();\par
01001         {\cf19 for} ( ; !(m<0) ; --M,--m) \{\par
01002                 tempt.p_uds(max[M]);\par
01003                 tempt.p_decs(dig_t(0));\par
01004                 tempt += min[m];\par
01005                 tempt += carry;\par
01006                 carry =tempt.g_decs();\par
01007                 max[M]=tempt.g_uds();\par
01008         \}\par
01009         {\cf19 for} ( ; !(M<0) ; --M) \{\par
01010                 tempt.p_uds(max[M]);\par
01011                 tempt.p_decs(dig_t(0));\par
01012                 tempt += carry;\par
01013                 carry =tempt.g_decs();\par
01014                 max[M]=tempt.g_uds();\par
01015         \}\par
01016 \par
01017         {\cf19 if} (carry!=dig(0)) \{\par
01018                 max.push_front(carry);\par
01019         \}\par
01020 \par
01021         {\cf19 if} ((&cthis)!=(&max)) \{\par
01022                 cthis = (max.reduce());\par
01023         \}\par
01024         {\cf19 else} \{\par
01025                 cthis.reduce();\par
01026         \}\par
01027         cthis.aux =  pardigs();\par
01028         {\cf19 return} cthis;\par
01029 \}\par
01030 \par
01031 {\cf17 const} nat_num_t & operator -= ({\cf17 const} nat_num_t & arg) \{\par
01032         nat_num_t & ret = (*this);\par
01033         ret.reduce();\par
01034         {\cf17 const} {\cf18 size_t} szret = ret.size();\par
01035         nat_num_t cpy(arg.minus(ret.size()));\par
01036         {\cf20 //cpy.reduce();}\par
01037         ret += cpy;\par
01038         {\cf19 if} (ret.size() > szret) \{\par
01039                 ret.erase(0,1);\par
01040         \}\par
01041         ret.reduce();\par
01042         {\cf19 return} ret;\par
01043 \}\par
01044 \par
01045 {\cf17 const} nat_num_t & operator *= ({\cf17 const} nat_num_t & arg) \{\par
01046         nat_num_t & cthis = (*this);\par
01047         cthis.reduce();\par
01048         nat_num_t multtemp;\par
01049         nat_num_t sumatemp;\par
01050         nat_num_t cadena_de_ceros;\par
01051         {\cf17 const} {\cf18 int} argsz = arg.size();\par
01052         {\cf17 const} {\cf18 int} argmsb = argsz-2;\par
01053 \par
01054 \par
01055         multtemp = cthis*arg[argsz-1];\par
01056         sumatemp += multtemp;\par
01057 \par
01058         {\cf19 for} ({\cf18 int} j = argmsb ; j >= 0 ; --j) \{\par
01059                 multtemp = cthis*arg[j];\par
01060                 multtemp &= cadena_de_ceros;\par
01061                 sumatemp += multtemp;\par
01062                 cadena_de_ceros.push_back(dig(0));\par
01063         \}\par
01064         cthis = sumatemp;\par
01065         {\cf19 return} cthis;\par
01066 \}\par
01067 \par
01068 {\cf17 inline} nat_num_t substr ( {\cf18 size_t} pos , {\cf18 size_t} n ){\cf17  const }\{\par
01069         {\cf17 const} base_num_t & cthis = (*this);\par
01070         cthis.nbstr::substr(pos,n);\par
01071         {\cf19 return} (*{\cf17 this});\par
01072 \}\par
01073 \par
01074 {\cf17 const} nat_num_t & operator /= ({\cf17 const} nat_num_t & arg) \{\par
01075         nat_num_t & cthis = (*this);\par
01076         nat_num_t dvndo_int(*{\cf17 this}); {\cf20 //Siempre ser\'E1 positivo}\par
01077         dvndo_int.reduce();\par
01078         nat_num_t rem(dvndo_int);\par
01079         rem.reduce();\par
01080         nat_num_t dvsor_int(arg);{\cf20 //Siempre ser\'E1 positivo}\par
01081         dvsor_int.reduce();\par
01082 \par
01083         {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 // ceros que tienen valor y por los que dividir}\par
01084         {\cf20 // divisor y dividendo}\par
01085         nat_num_t dvndo_fra(dvndo_int);\par
01086 \par
01087         {\cf19 if} (dvndo_int.size()>=dvsor_int.size()) \{\par
01088                 dvndo_fra.erase(0,dvndo_int.size()-cssor);\par
01089                 {\cf19 if} (dvndo_int != nat_num_t(dig(0))) \{\par
01090                         dvndo_int.erase(dvndo_int.size()-cssor,cssor);{\cf20 // division por una potencia de B, /B^cssor}\par
01091                 \}\par
01092                 dvndo_int.reduce();\par
01093                 {\cf19 if} (dvsor_int != nat_num_t(dig(0))) \{\par
01094                         dvsor_int.erase(dvsor_int.size()-cssor,cssor);{\cf20 // division por una potencia de B  /B^cssor}\par
01095                 \}\par
01096                 nat_num_t dvsor_fra(dvsor_int);\par
01097                 dvsor_fra.erase(0,dvsor_int.size()-cssor);\par
01098                 dvsor_int.reduce();\par
01099         \}\par
01100         {\cf19 else} \{\par
01101                 dvndo_int = nat_num_t(dig(0));\par
01102                 cthis = dvndo_int;\par
01103                 {\cf19 return} cthis;\par
01104         \}\par
01105         {\cf20 //dvndo_fra.reduce();//dvndo_fra.reduce_fra() HAY QUE HACERLO}\par
01106         {\cf17 const} {\cf18 int} szndo         = dvndo_int.size();\par
01107         {\cf17 const} {\cf18 int} lsb_ndo   = szndo-1;\par
01108         {\cf17 const} {\cf18 int} msb_ndo       = 0;\par
01109         {\cf17 const} {\cf18 int} szsor     = dvsor_int.size();\par
01110         {\cf17 const} {\cf18 int} lsb_sor   = szsor-1;\par
01111         {\cf17 const} {\cf18 int} msb_sor   = 0;\par
01112 \par
01113         {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01114         {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01115         {\cf20 // cocientes enteros.}\par
01116         div_uno(rem,dvndo_int,dvsor_int,szndo,szsor);\par
01117         {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01118         {\cf20 // dividendo obteniendo dvndo_fra}\par
01119 \par
01120         {\cf20 /* *}\par
01121 {\cf20                 RemReal = RemObtenido*(B^cssor) + Dvndo_fra}\par
01122 {\cf20 }\par
01123 {\cf20                 rem = rem.insert(rem.size()-1,cssor,0);}\par
01124 {\cf20                 rem += dvndo_fra;}\par
01125 {\cf20         * */}\par
01127         {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01128         {\cf20 // acomodar el formato al signo de la operacion}\par
01129         {\cf20 // determinar el signo de la operacion}\par
01130         cthis=dvndo_int;\par
01131         {\cf19 return} cthis;\par
01132 \}\par
01133 \par
01134 {\cf17 const} nat_num_t & operator %= ({\cf17 const} nat_num_t & arg) \{\par
01135         nat_num_t & cthis = (*this);\par
01136         nat_num_t dvndo_int(cthis); {\cf20 //Siempre ser\'E1 positivo}\par
01137         dvndo_int.reduce();\par
01138         nat_num_t rem(dvndo_int);\par
01139         rem.reduce();\par
01140         nat_num_t dvsor_int(arg);{\cf20 //Siempre ser\'E1 positivo}\par
01141         dvsor_int.reduce();\par
01142         dvndo_int/=dvsor_int;\par
01143         dvndo_int*=dvsor_int;\par
01144         rem -= dvndo_int;\par
01145         cthis = rem;\par
01146         {\cf19 return} cthis;\par
01147 \}\par
01148 \par
01149 {\cf17 const} nat_num_t & operator *= (pardigs a) \{\par
01150         nat_num_t               cthis = (*this);\par
01151         nat_num_t &             ret = (*this);\par
01152         ret *= a.g_uds();\par
01153         cthis.push_back(dig(0));\par
01154         ret += cthis * a.g_decs();\par
01155         ret.reduce();\par
01156         {\cf19 return} ret;\par
01157 \}\par
01158 \par
01159 {\cf17 const} nat_num_t & operator += (dig arg) \{\par
01160         nat_num_t & cthis = (*this);\par
01161         cthis.reduce();\par
01162         dig             carry(0);\par
01163         pardigs tempt;\par
01164 \par
01165         {\cf18 int} k =  cthis.size() ;\par
01166         tempt.p_uds(cthis[k-1]);\par
01167         tempt += arg;\par
01168         cthis[k-1]=tempt.g_uds();\par
01169         carry = tempt.g_decs();\par
01170         --k;\par
01171         {\cf19 for} (; k > 0 ; --k) \{\par
01172                 tempt = pardigs();\par
01173                 tempt += carry;\par
01174                 tempt += cthis[k-1];\par
01175                 cthis[k-1]=tempt.g_uds();\par
01176                 carry = tempt.g_decs();\par
01177         \}\par
01178 \par
01179         {\cf19 if} (carry != dig(0)) cthis.push_front(carry);\par
01180         cthis.reduce();\par
01181         {\cf19 return} cthis;\par
01182 \}\par
01183 \par
01184 {\cf17 const} nat_num_t & operator -= (dig arg) \{\par
01185         nat_num_t & cthis = (*this);\par
01186         cthis.reduce();\par
01187         {\cf19 if} (arg == dig(0)) {\cf19 return} cthis;\par
01188         nat_num_t cpy(nat_num_t(arg).minus(cthis.size()));\par
01189         pardigs tempt;\par
01190         pardigs tempa;\par
01191         sint szt = cthis.size();\par
01192         sint k = szt-1;\par
01193         tempt.p_uds(cthis[k]);\par
01194         tempt.p_decs(dig(0));\par
01195         tempa.p_uds(cpy[k]);\par
01196         tempa.p_decs(dig(0));\par
01197         tempt += tempa;\par
01198         cthis[k] =tempt.g_uds();\par
01199         dig carry(tempt.g_decs());\par
01200         --k;\par
01201         {\cf19 for} ( ; k >= 0 ; --k) \{\par
01202                 tempt.p_uds(cthis[k]);\par
01203                 tempt += cpy[k];\par
01204                 tempt += carry;\par
01205                 carry =tempt.g_decs();\par
01206                 cthis[k] =tempt.g_uds();\par
01207         \}\par
01208 \par
01209         cthis.reduce();\par
01210         cthis.aux =  pardigs();\par
01211         {\cf19 return} cthis;\par
01212 \}\par
01213 \par
01214 {\cf17 const} nat_num_t & operator *= (dig arg) \{\par
01215         nat_num_t & cthis = (*this);\par
01216         pardigs temp;\par
01217         dig     carry=0;\par
01218         cthis.reduce();\par
01219         {\cf19 for} ( ssint k=((cthis.size())-1) ; k >= 0 ; --k ) \{\par
01220                 temp.p_uds(cthis[k]);\par
01221                 temp *= arg;\par
01222                 temp += carry;\par
01223                 cthis[k]= temp.g_uds();\par
01224                 carry=temp.g_decs();\par
01225                 temp.p_decs(dig(0));\par
01226         \}\par
01227         {\cf19 if} (carry != 0) push_front(carry);\par
01228         cthis.reduce();\par
01229         {\cf19 return} cthis;\par
01230 \}\par
01231 \par
01232 {\cf20                                                 /****************************/}\par
01233                                                 {\cf20 /*                                                      */}\par
01234                                                 {\cf20 /*      COMPLEMENTO A BASE Y    */}\par
01235                                                 {\cf20 /*              BASE MENOS 1            */}\par
01236                                                 {\cf20 /*                                                      */}\par
01237 {\cf20                                                 /****************************/}\par
01238 \par
01239 nat_num_t operator - (){\cf17  const }\{\par
01240         nat_num_t cpy(*{\cf17 this});\par
01241         cpy.reduce();\par
01242         crstriterator start = cpy.rend();\par
01243         rstriterator  it    = cpy.rbegin();\par
01244         {\cf19 for} ( ; it != start ; ++it ) \{\par
01245                 (*it) = (!(*it));\par
01246         \}\par
01247         cpy.reduce();\par
01248         it = cpy.rbegin();\par
01249         cpy.aux.p_uds(*it);\par
01250         cpy.aux.p_decs(dig());\par
01251         cpy.aux += pd_1<B>();\par
01252         (*it) = cpy.aux.g_uds();\par
01253         ++it;\par
01254         {\cf19 if} ((cpy.aux.g_decs())!= dig(0)) \{\par
01255                 {\cf19 for} ( ; it != start ; ++it ) \{\par
01256                         cpy.aux.p_uds(cpy.aux.g_decs());\par
01257                         cpy.aux.p_decs(0);\par
01258 \par
01259                         {\cf19 if} (cpy.aux == pardigs()) {\cf19 break};\par
01260                         cpy.aux += pardigs(*it);\par
01261                         (*it) = cpy.aux.g_uds();\par
01262                 \}\par
01263                 cpy.push_front(cpy.aux.g_uds());\par
01264                 cpy.push_front(cpy.aux.g_decs());\par
01265         \}\par
01266 \par
01267         cpy.aux = pardigs();\par
01268         cpy.reduce();\par
01269         {\cf19 return} cpy;\par
01270 \}\par
01271 \par
01272 \par
01273 nat_num_t minus ({\cf18 size_t} sz){\cf17  const }\{\par
01274         nat_num_t cpy(*{\cf17 this});\par
01275         cpy.reduce();\par
01276         {\cf19 if} (cpy.size() < sz) \{\par
01277                 {\cf17 const} {\cf18 int} tm = sz - cpy.size();\par
01278                 {\cf19 for}({\cf18 int} i=0; i<tm ; ++i) \{\par
01279                         cpy.push_front(dig(0));\par
01280                 \}\par
01281         \}\par
01282         {\cf19 else} {\cf19 if} (cpy.size() > sz) \{\par
01283                 cpy.erase(0,1);\par
01284         \}\par
01285         crstriterator start = cpy.rend();\par
01286         rstriterator  it    = cpy.rbegin();\par
01287         {\cf19 for} ( ; it != start ; ++it ) \{\par
01288                 (*it) = (!(*it));\par
01289         \}\par
01290         it = cpy.rbegin();\par
01291         cpy.aux.p_uds(*it);\par
01292         cpy.aux.p_decs(dig(0));\par
01293         cpy.aux += pd_1<B>();\par
01294         (*it) = cpy.aux.g_uds();\par
01295         ++it;\par
01296         {\cf19 if} ((cpy.aux.g_decs())!= dig(0)) \{\par
01297                 {\cf19 for} ( ; it != start ; ++it ) \{\par
01298                         cpy.aux.p_uds(cpy.aux.g_decs());\par
01299                         cpy.aux.p_decs(0);\par
01300 \par
01301                         {\cf19 if} (cpy.aux == pardigs()) {\cf19 break};\par
01302                         cpy.aux += pardigs(*it);\par
01303                         (*it) = cpy.aux.g_uds();\par
01304                 \}\par
01305                 cpy.push_front(cpy.aux.g_uds());\par
01306                 cpy.push_front(cpy.aux.g_decs());\par
01307         \}\par
01308 \par
01309         cpy.aux = pardigs();\par
01310         {\cf19 if} (cpy.size() < sz) \{\par
01311                 {\cf17 const} {\cf18 int} tm = sz - cpy.size();\par
01312                 {\cf19 for}({\cf18 int} i=0; i<tm ; ++i) \{\par
01313                         cpy.push_front(dig(B-1));\par
01314                 \}\par
01315         \}\par
01316         {\cf19 else} {\cf19 if} (cpy.size() > sz) \{\par
01317                 cpy.erase(0,1);\par
01318         \}\par
01319         {\cf20 //cpy.reduce();}\par
01320         {\cf19 return} cpy;\par
01321 \}\par
01322 \par
01323 \par
01324 nat_num_t operator ! (){\cf17  const }\{\par
01325         nat_num_t cpy(*{\cf17 this});\par
01326         {\cf17 const} striterator fin = cpy.end();\par
01327         striterator  it = cpy.begin();\par
01328         {\cf19 for} ( ; it != fin ; ++it )\par
01329                 (*it) = (!(*it));\par
01330         cpy.aux = pardigs();\par
01331         cpy.reduce();\par
01332         {\cf19 return} cpy;\par
01333 \}\par
01334 \par
01335 {\cf20                                         /****************************/}\par
01336                                         {\cf20 /*                                                      */}\par
01337                                         {\cf20 /*               MODIFICADOR            */}\par
01338                                         {\cf20 /*      COMPLEMENTO A BASE Y    */}\par
01339                                         {\cf20 /*              BASE MENOS 1            */}\par
01340                                         {\cf20 /*                                                      */}\par
01341 {\cf20                                         /****************************/}\par
01342 \par
01343 {\cf17 const} nat_num_t & mC_B () \{\par
01344         nat_num_t & cpy = (*this);\par
01345         cpy.reduce();\par
01346         crstriterator start = cpy.rend();\par
01347         rstriterator  it    = cpy.rbegin();\par
01348         {\cf19 for} ( ; it != start ; ++it ) \{\par
01349                 (*it) = (!(*it));\par
01350         \}\par
01351         cpy.reduce();\par
01352         it = cpy.rbegin();\par
01353         cpy.aux.p_uds(*it);\par
01354         cpy.aux.p_decs(dig());\par
01355         cpy.aux += pd_1<B>();\par
01356         (*it) = cpy.aux.g_uds();\par
01357         ++it;\par
01358         {\cf19 if} ((cpy.aux.g_decs())!= dig(0)) \{\par
01359                 {\cf19 for} ( ; it != start ; ++it ) \{\par
01360                         cpy.aux.p_uds(cpy.aux.g_decs());\par
01361                         cpy.aux.p_decs(0);\par
01362 \par
01363                         {\cf19 if} (cpy.aux == pardigs()) {\cf19 break};\par
01364                         cpy.aux += pardigs(*it);\par
01365                         (*it) = cpy.aux.g_uds();\par
01366                 \}\par
01367                 cpy.push_front(cpy.aux.g_uds());\par
01368                 cpy.push_front(cpy.aux.g_decs());\par
01369         \}\par
01370 \par
01371         cpy.aux = pardigs();\par
01372         cpy.reduce();\par
01373         {\cf19 return} cpy;\par
01374 \}\par
01375 \par
01376 {\cf17 const} nat_num_t & mC_Bm1 () \{\par
01377         nat_num_t & cpy = (*this);\par
01378         {\cf17 const} striterator fin = cpy.end();\par
01379         striterator  it = cpy.begin();\par
01380         {\cf19 for} ( ; it != fin ; ++it )\par
01381                 (*it) = (!(*it));\par
01382         cpy.aux = pardigs();\par
01383         cpy.reduce();\par
01384         {\cf19 return} cpy;\par
01385 \}\par
01386 \par
01387 {\cf20                                         /****************************/}\par
01388                                         {\cf20 /*                                                      */}\par
01389                                         {\cf20 /*         ABSOLUTO                     */}\par
01390                                         {\cf20 /*                                                      */}\par
01391 {\cf20                                         /****************************/}\par
01392 \par
01393 {\cf17 inline} nat_num_t abs (){\cf17  const }\{\par
01394         {\cf19 return} (*{\cf17 this});\par
01395 \}\par
01396 \par
01397 {\cf17 inline} {\cf17 const} nat_num_t & m_abs () \{\par
01398         nat_num_t & cthis = (*this);\par
01399         {\cf19 return} cthis;\par
01400 \}\par
01401 \par
01402 {\cf20                                                         /****************************/}\par
01403                                                         {\cf20 /*                                                      */}\par
01404                                                         {\cf20 /*      DIVIDIR ENTRE BASE o 2  */}\par
01405                                                         {\cf20 /*                                                      */}\par
01406 {\cf20                                                         /****************************/}\par
01407 \par
01408 nat_num_t divB (){\cf17  const }\{\par
01409         nat_num_t cpy(*{\cf17 this});\par
01410         cpy.reduce();\par
01411         cpy.m_abs();\par
01412         cpy.cthis.erase(0,1);\par
01413         cpy.reduce();\par
01414         {\cf19 return} cpy;\par
01415 \}\par
01416 \par
01417 dig remB (){\cf17  const }\{\par
01418         nat_num_t cpy(*{\cf17 this});\par
01419         cpy.reduce();\par
01420         {\cf19 return} cpy[0];\par
01421 \}\par
01422 \par
01423 {\cf17 const} nat_num_t & m_divB() \{\par
01424         nat_num_t & cpy = (*this);\par
01425         cpy.reduce();\par
01426         cpy.cthis.erase(0,1);\par
01427         cpy.reduce();\par
01428         {\cf19 return} cpy;\par
01429 \}\par
01430 \par
01431 dig m_remB() \{\par
01432         nat_num_t & cpy = (*this);\par
01433         cpy.reduce();\par
01434         {\cf19 return} cpy[0];\par
01435 \}\par
01436 \par
01437 nat_num_t div2 (){\cf17  const }\{\par
01438         nat_num_t & cthis = (*this);\par
01439         nat_num_t dvndo_int(cthis.abs());\par
01440         dvndo_int.reduce();\par
01441         nat_num_t rem(dvndo_int);\par
01442         {\cf17 const} dig dos = 2;\par
01443 \par
01444         nat_num_t dvsor_int(dos);\par
01445 \par
01446         {\cf17 const} usint cssor = ((B==2)?(1):(0));\par
01447 \par
01448         nat_num_t dvndo_fra(dvndo_int.substr(0,cssor));\par
01449         {\cf19 if} (B==2) dvsor_int[0]=1;{\cf20 // division por una potencia de B}\par
01450 \par
01451         dvndo_int.reduce();\par
01452         dvndo_fra.reduce();\par
01453 \par
01454         {\cf17 const} usint longtndo  = dvndo_int.size();\par
01455         {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01456         {\cf17 const} usint longtsor  = 1;\par
01457         {\cf17 const} usint longsor   = 0;\par
01458 \par
01459         {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01460         {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01461         {\cf20 // cocientes enteros.}\par
01462         div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01463         {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01464         {\cf20 // dividendo obteniendo dvndo_fra}\par
01465 \par
01466         {\cf20 /* *}\par
01467 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01468 {\cf20 }\par
01469 {\cf20                 rem = rem.cthis.insert(0,cssor,0);}\par
01470 {\cf20                 rem += dvndo_fra;}\par
01471 {\cf20         * */}\par
01473         {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01474         {\cf20 // acomodar el formato al signo de la operacion}\par
01475         {\cf20 // determinar el signo de la operacion}\par
01476         {\cf19 return} dvndo_int;\par
01477 \}\par
01478 \par
01479 dig rem2 (){\cf17  const }\{\par
01480         nat_num_t & cthis = (*this);\par
01481         nat_num_t cpy = cthis.reduce();\par
01482         cpy.reduce();\par
01483         {\cf19 if} (B%2==1) \{\par
01484                 {\cf19 if} (cpy.size()==1)\par
01485                         {\cf19 return} dig::Rem2(cpy[0]);\par
01486                 {\cf19 else} \{\par
01487                         usint paridad = 0;\par
01488                         {\cf19 for} ( usint k=0 ; k < cpy.size() ; ++k )\par
01489                                 paridad += dig::Dig2UInt(dig::Rem2(cpy[k]));\par
01490                         paridad %= 2;\par
01491                         {\cf19 return} dig(paridad);\par
01492                 \}\par
01493         \}\par
01494         {\cf19 else} \{\par
01495                 {\cf19 return} Rem2<B>(cpy[0]);\par
01496         \}\par
01497 \}\par
01498 \par
01499 {\cf17 const} nat_num_t & m_div2() \{\par
01500         nat_num_t & cthis = (*this);\par
01501         cthis.reduce();\par
01502         nat_num_t & dvndo_int = (*this);\par
01503         nat_num_t rem(dvndo_int);\par
01504         {\cf17 const} dig dos = 2;\par
01505 \par
01506         nat_num_t dvsor_int(dos);\par
01507 \par
01508         {\cf17 const} usint cssor = ((B==2)?(1):(0));\par
01509 \par
01510         nat_num_t dvndo_fra(dvndo_int.substr(0,cssor));\par
01511         {\cf19 if} (B==2) dvsor_int[0]=1;{\cf20 // division por una potencia de B}\par
01512 \par
01513         dvndo_int.reduce();\par
01514         dvndo_fra.reduce();\par
01515 \par
01516         {\cf17 const} usint longtndo  = dvndo_int.size();\par
01517         {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01518         {\cf17 const} usint longtsor  = 1;\par
01519         {\cf17 const} usint longsor   = 0;\par
01520 \par
01521         {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01522         {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01523         {\cf20 // cocientes enteros.}\par
01524         div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01525         {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01526         {\cf20 // dividendo obteniendo dvndo_fra}\par
01527 \par
01528         {\cf20 /* *}\par
01529 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01530 {\cf20 }\par
01531 {\cf20                 rem = rem.insert(0,cssor,0);}\par
01532 {\cf20                 rem += dvndo_fra;}\par
01533 {\cf20         * */}\par
01535         {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01536         {\cf20 // acomodar el formato al signo de la operacion}\par
01537         {\cf20 // determinar el signo de la operacion}\par
01538         {\cf19 return} dvndo_int;\par
01539 \}\par
01540 \par
01541 dig m_rem2() \{\par
01542         nat_num_t & cthis = (*this);\par
01543         cthis.reduce();\par
01544         nat_num_t & cpy = (*this);\par
01545         {\cf19 if} (B%2==1) \{\par
01546                 {\cf19 if} (cpy.size()==1)\par
01547                         {\cf19 return} dig::Rem2(cpy[0]);\par
01548                 {\cf19 else} \{\par
01549                         usint paridad = 0;\par
01550                         {\cf19 for} ( usint k=0 ; k < cpy.size() ; ++k )\par
01551                                 paridad += dig::Dig2UInt(dig::Rem2(cpy[k]));\par
01552                         paridad %= 2;\par
01553                         {\cf19 return} dig(paridad);\par
01554                 \}\par
01555         \}\par
01556         {\cf19 else} \{\par
01557                 {\cf19 return} Rem2<B>(cpy[0]);\par
01558         \}\par
01559 \}\par
01560 \par
01561 dig     remBm1(){\cf17  const }\{\par
01562         nat_num_t cthis(*{\cf17 this}),suma;\par
01563         cthis.abs();\par
01564         cthis.reduce();\par
01565         suma.reduce();\par
01566         suma.insert(0,1,0);\par
01567         suma.erase(0,(cthis.size())-1);\par
01568         {\cf19 do} \{\par
01569                 {\cf19 for} ( usint i = 0 ; i < cthis.size() ; ++i ) \{\par
01570                         suma += cthis[i];\par
01571                         suma.reduce();\par
01572                 \}\par
01573         \} {\cf19 while} (suma.size()>1);\par
01574 \par
01575         {\cf19 if} ((suma[0]==0)||(suma[0]==(B-1))) {\cf19 return} 0;\par
01576         {\cf19 else} {\cf19 return} suma[0];\par
01577 \}\par
01578 \par
01579 {\cf20 // dig                          remBm1p()               ;}\par
01580 {\cf20 // nat_num_t                    divBm1()        const;}\par
01581 {\cf20 // const nat_num_t      &       divBm1p()               ;}\par
01582 \par
01583 {\cf17 private}:\par
01584 \par
01585 {\cf20 //              inline void     div3_step(pair< n2digs_t , usint > & S) const;}\par
01586 {\cf20 //              inline void div3p_step(pair< n2digs_t , usint > & S);}\par
01587 {\cf20 //              inline void     div7_step(pair< n2digs_t , usint > & S) const;}\par
01588 {\cf20 //              inline void div7p_step(pair< n2digs_t , usint > & S);}\par
01589 {\cf17 public}:\par
01590         {\cf17 inline} pardigs  g_aux(){\cf17  const }\{\par
01591                 base_num_t & cthis = (*this);\par
01592                 {\cf19 return} cthis.aux;\par
01593         \}\par
01594         {\cf17 inline} {\cf18 void}     p_aux(pardigs arg) \{\par
01595                 aux=arg;\par
01596                 {\cf19 return};\par
01597         \}\par
01598 \par
01599 {\cf17 private}:\par
01600 \par
01601 {\cf20                                                 /****************************/}\par
01602                                                 {\cf20 /*                                                      */}\par
01603                                                 {\cf20 /*              Division Generica       */}\par
01604                                                 {\cf20 /*                                                      */}\par
01605 {\cf20                                                 /****************************/}\par
01606 \par
01607 \par
01608 {\cf17 inline} {\cf18 void}     div_gen_step({\cf17 const} nat_num_t & dvsor, nat_num_t & rem, nat_num_t & coc, usint & ndig){\cf17  const }\{\par
01609         {\cf17 const} nat_num_t & cthis = (*this);\par
01610         {\cf17 const} {\cf18 int} szsor = dvsor.size();\par
01611         {\cf17 const} {\cf18 int} maxpossor = szsor-1;\par
01612         {\cf17 const} {\cf18 int} szndo = cthis.size();\par
01613         {\cf17 const} {\cf18 int} maxposndo = szndo-1;\par
01614         {\cf17 const} nat_num_t & dvndo = cthis;\par
01615         {\cf17 const} uint szrem = rem.size();\par
01616         {\cf19 if} (ndig==0) ndig = szrem;\par
01617         {\cf19 if} (rem < dvsor) \{\par
01618                 coc.push_back(dig(0));\par
01619                 coc.reduce();\par
01620         \}\par
01621         {\cf19 else} {\cf19 if} (rem == dvsor) \{\par
01622                 coc.push_back(dig(1));\par
01623                 coc.reduce();\par
01624                 rem.erase(0,rem.size()-1);\par
01625                 rem[0]=dig(0);\par
01626         \}\par
01627         {\cf19 else} \{\par
01628                         pardigs dighrem;\par
01629                         {\cf19 if} ( szrem > szsor ) dighrem = pardigs(rem[0],rem[1]) ;\par
01630                         {\cf19 else} dighrem = pardigs(dig(0),rem[0]) ;\par
01631                         pardigs dighsor        = pardigs(dig(0),dvsor[0]) ;\par
01632                         pardigs & digcocprueba = dighrem ;\par
01633                         digcocprueba /= dighsor ;\par
01634                         {\cf19 if} (digcocprueba > pd_Bm1<B>()) \{\par
01635                                 digcocprueba = pd_Bm1<B>();\par
01636                         \}\par
01637                         nat_num_t remprueba(dvsor) ;\par
01638                         remprueba *= digcocprueba;\par
01639                         {\cf19 for} ( pardigs ix(0,0)  ; ix < pardigs(1,0) ; ix += pardigs(0,1) ) \{\par
01640                                 {\cf19 if} ( remprueba > rem ) \{\par
01641                                         --digcocprueba;\par
01642                                         remprueba -= dvsor;\par
01643                                 \}\par
01644                                 {\cf19 else} \{\par
01645                                         rem -= remprueba;\par
01646                                         coc.push_back(digcocprueba.g_uds());{\cf20 //g_first, g_second ??}\par
01647                                         coc.reduce();\par
01648                                         {\cf19 break};\par
01649                                 \}\par
01650                         \}\par
01651         \}\par
01652         {\cf19 if}(dvndo.size()> ndig) \{\par
01653                 rem.push_back(dvndo[ndig]);\par
01654         \}\par
01655         rem.reduce();\par
01656         ++ndig;\par
01657         {\cf19 return};\par
01658 \}\par
01659 \par
01660 {\cf20                                                 /************************************/}\par
01661                                                 {\cf20 /*                                                              */}\par
01662                                                 {\cf20 /*              Un Paso de Division Simple      */}\par
01663                                                 {\cf20 /*                                                              */}\par
01664 {\cf20                                                 /************************************/}\par
01665 {\cf17 public}:\par
01666 {\cf17 inline} {\cf18 bool} es_cero(){\cf17  const }\{\par
01667         {\cf18 bool} escero = (size()==0);\par
01668         {\cf19 if} (escero) {\cf19 return} {\cf17 true};\par
01669         escero = (size()==1)and({\cf17 operator}[](0)==dig_t(0));\par
01670         {\cf19 if} (escero) {\cf19 return} {\cf17 true};\par
01671         {\cf19 return} {\cf17 false};\par
01672 \}\par
01673 \par
01674 {\cf17 inline} {\cf18 bool} no_es_cero(){\cf17  const }\{\par
01675         {\cf18 bool} noescero = (size()>1);\par
01676         {\cf19 if} (noescero) {\cf19 return} {\cf17 true};\par
01677         noescero = (size()==1)and({\cf17 operator}[](0)!=dig_t(0));\par
01678         {\cf19 if} (noescero) {\cf19 return} {\cf17 true};\par
01679         {\cf19 return} {\cf17 false};\par
01680 \}\par
01681 {\cf17 private}:\par
01682 {\cf17 inline} {\cf18 void} div_uno( nat_num_t & rem , nat_num_t & dvndo, nat_num_t & dvsor, {\cf17 const} usint szndo, {\cf17 const} usint szsor){\cf17  const }\{\par
01683         {\cf17 const} nat_num_t & cthis = (*this);\par
01684         rem = dvndo;\par
01685         {\cf19 if} (dvsor.es_cero()) \{ {\cf20 // caso de division por 0}\par
01686                 {\cf19 return};\par
01687         \}\par
01688         {\cf19 else} {\cf19 if} ((dvndo.es_cero())or(szndo < szsor)) \{ {\cf20 // caso de 0 dividido por !=0 \'F3 caso de cociente 0}\par
01689                 rem = dvndo;\par
01690                 dvndo.erase(0,(cthis.size())-2);\par
01691                 dvndo[0] = dig(0);\par
01692                 {\cf19 return};\par
01693                 {\cf20 // rem=dvndo; hecho por defecto}\par
01694         \}\par
01695         {\cf19 else} {\cf19 if} (dvndo==dvsor) \{ {\cf20 // caso de dividir por si mismo}\par
01696                 dvndo.clear();\par
01697                 rem.clear();\par
01698                 dvndo.push_front(dig(1));\par
01699                 rem.push_front(dig(0));\par
01700                 {\cf19 return};\par
01701         \}\par
01702         {\cf19 else} {\cf19 if} ((szsor==1)&&(dvsor[0]==1)) \{ {\cf20 // caso de dividir por potencias de B (1)}\par
01703                 {\cf20 //dvndo;}\par
01704                 {\cf19 if} (rem.size() > 1)\{\par
01705                         rem.erase(0,rem.size()-2);\par
01706                 \}\par
01707                 rem[0]=dig(0);\par
01708                 {\cf19 return};\par
01709         \}\par
01710         {\cf19 else} {\cf19 if} ((szndo == szsor) && (dvndo < dvsor)) \{\par
01711                 rem = dvndo;\par
01712                 dvndo.clear();\par
01713                 dvndo.push_front(dig(0));\par
01714                 {\cf19 return};\par
01715         \}\par
01716         {\cf19 else} \{\par
01717                 {\cf20 // ((long_dvndo > long_dvsor) or (dvndo > dvsor))}\par
01718                 {\cf20 // algoritmo de resta general}\par
01719                 {\cf20 // implementar div_step pasamos (resto,cociente,i,dividendo,divisor) devuelve (resto,cociente,i,dividendo,divisor)}\par
01720                 {\cf20 // se puede hacer con una tupla}\par
01721                 {\cf20 // dvndo;}\par
01722                 rem   = dvndo;\par
01723                 rem.reduce();\par
01724                 rem.erase(szsor,szndo-szsor);\par
01725                 nat_num_t coc(dig(0));\par
01726                 usint ndig = 0;\par
01727                 {\cf19 do} \{\par
01728                         div_gen_step(dvsor,rem,coc,ndig);\par
01729                 \} {\cf19 while} ( ndig <= szndo );\par
01730                 dvndo = coc;\par
01731                 {\cf19 return};\par
01732         \}\par
01733 \}\par
01734 {\cf20 //END PRIVATE}\par
01735 \par
01736 \par
01737 {\cf20                         /****************************/}\par
01738                         {\cf20 /*                                                      */}\par
01739                         {\cf20 /*              Division Euclidea       */}\par
01740                         {\cf20 /*                                                      */}\par
01741 {\cf20                         /****************************/}\par
01742 \par
01743 {\cf17 public}:\par
01744 \par
01745 pair< nat_num_t , nat_num_t > EuclidDiv ({\cf17 const} nat_num_t & arg){\cf17  const }\{\par
01746         {\cf17 const} nat_num_t & cthis = (*this);\par
01749         nat_num_t dvndo_int = cthis;\par
01750         dvndo_int.reduce();\par
01751         nat_num_t dvsor_int = arg.abs();\par
01752         dvsor_int.reduce();\par
01753 \par
01754         nat_num_t rem(dvndo_int);\par
01755 \par
01756         {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
01757 \par
01758         nat_num_t dvndo_fra(dvndo_int.substr(0,cssor));\par
01759         dvsor_int.erase(0,cssor);{\cf20 // division por una potencia de B}\par
01760 \par
01761         dvsor_int.reduce();\par
01762         dvndo_fra.reduce_fracc();{\cf20 // reduce 0s a la derecha}\par
01763 \par
01764         {\cf17 const} usint longtndo  = dvndo_int.size();\par
01765         {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01766         {\cf17 const} usint longtsor  = dvsor_int.size();\par
01767         {\cf17 const} usint longsor   = longtsor;\par
01768 \par
01769         {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01770         {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01771         {\cf20 // cocientes enteros.}\par
01772         div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01773         {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01774         {\cf20 // dividendo obteniendo dvndo_fra}\par
01775 \par
01776         {\cf20 /* *}\par
01777 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01778 {\cf20          * */}\par
01779         rem = rem.insert(0,cssor,0);\par
01780         rem += dvndo_fra;\par
01781 \par
01783         {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01784         {\cf20 // acomodar el formato al signo de la operacion}\par
01785         {\cf20 // determinar el signo de la operacion}\par
01786         {\cf19 return} make_pair(rem,dvndo_int);\par
01787 \}\par
01788 \par
01789 pair< nat_num_t , const nat_num_t & > m_EuclidDiv ({\cf17 const} nat_num_t & arg) \{\par
01790         {\cf17 const} nat_num_t & cthis = (*this);\par
01793         cthis.absp();\par
01794         cthis.reduce();\par
01795         nat_num_t & dvndo_int = cthis;\par
01796         nat_num_t dvsor_int = arg.abs();\par
01797         dvsor_int.reduce();\par
01798 \par
01799         nat_num_t rem(dvndo_int);\par
01800 \par
01801         {\cf17 const} usint cssor = dvsor_int.ceros_a_la_drcha(); {\cf20 //\'BF?}\par
01802 \par
01803         nat_num_t dvndo_fra(dvndo_int.substr(0,cssor));\par
01804         dvsor_int.erase(0,cssor);{\cf20 // division por una potencia de B}\par
01805 \par
01806         dvsor_int.reduce();\par
01807         dvndo_int.reduce();\par
01808 \par
01809         dvndo_fra.reduce_fracc();\par
01810 \par
01811         {\cf17 const} usint longtndo  = dvndo_int.size();\par
01812         {\cf17 const} usint longtndo2 = dvndo_fra.size();\par
01813         {\cf17 const} usint longtsor  = dvsor_int.size();\par
01814         {\cf17 const} usint longsor   = longtsor;\par
01815 \par
01816         {\cf20 // hemos dividido por los ceros del divisor (por una potencia de B)}\par
01817         {\cf20 // tanto divisor como dividendo, obteniendo dvndo_int y dvsor_int como}\par
01818         {\cf20 // cocientes enteros.}\par
01819         div_uno(rem,dvndo_int,dvsor_int,longtndo,longsor);\par
01820         {\cf20 // ahora hacemos lo mismo con el cociente de las potencias de B del}\par
01821         {\cf20 // dividendo obteniendo dvndo_fra}\par
01822 \par
01823         {\cf20 /* *}\par
01824 {\cf20                 RemReal = RemObtenido*B^cssor + Dvndo_fra}\par
01825 {\cf20          * */}\par
01826         rem = rem.insert(0,cssor,0);\par
01827         rem += dvndo_fra;\par
01828 \par
01830         {\cf20 // rehacer el resto tomando en cuenta los ceros quitados}\par
01831         {\cf20 // acomodar el formato al signo de la operacion}\par
01832         {\cf20 // determinar el signo de la operacion}\par
01833         {\cf19 return} make_pair(rem,dvndo_int);\par
01834 \}\par
01835 \par
01836 {\cf20                         /************************************/}\par
01837                         {\cf20 /*                                                                                                                                      */}\par
01838                         {\cf20 /*                      PRE Y POST                                                                      */}\par
01839                         {\cf20 /*                                                                                                                                      */}\par
01840 {\cf20                         /************************************/}\par
01841 \par
01842 {\cf17 public}:\par
01843 \par
01844 {\cf17 const} nat_num_t & operator ++ () \{\par
01845         nat_num_t & cthis = (*this);\par
01846         cthis += dig(1);\par
01847         {\cf19 return} cthis;\par
01848 \}\par
01849 \par
01850 nat_num_t operator ++ ({\cf18 int}) \{\par
01851         nat_num_t cpThis(*{\cf17 this});\par
01852         nat_num_t & cthis = (*this);\par
01853         cpThis += dig(1);\par
01854         cthis = cpThis;\par
01855         {\cf19 return} cpThis;\par
01856 \}\par
01857 \par
01858 {\cf17 const} nat_num_t & operator -- () \{\par
01859         nat_num_t & cthis = (*this);\par
01860         cthis -= dig(1);\par
01861         {\cf19 return} cthis;\par
01862 \}\par
01863 \par
01864 nat_num_t operator -- ({\cf18 int}) \{\par
01865         nat_num_t cpThis(*{\cf17 this});\par
01866         nat_num_t & cthis = (*this);\par
01867         cpThis -= dig(1);\par
01868         cthis = cpThis;\par
01869         {\cf19 return} cpThis;\par
01870 \}\par
01871 {\cf20                                                         /****************************/}\par
01872                                                         {\cf20 /*                                                      */}\par
01873                                                         {\cf20 /*                      REDUCE                  */}\par
01874                                                         {\cf20 /*                                                      */}\par
01875 {\cf20                                                         /****************************/}\par
01876 \par
01877 {\cf17 inline} {\cf17 const} nat_num_t & reduce() \{\par
01878         nat_num_t & cthis = (*this);\par
01879         {\cf19 if} (cthis.size()==0) \{\par
01880                 cthis = nat_num_t(dig(0));\par
01881                 {\cf19 return} cthis;\par
01882         \}\par
01883         {\cf19 else} {\cf19 if} (cthis.size()==1) {\cf19 return} cthis;\par
01884         {\cf19 else} \{\par
01885                 {\cf17 const} usint nsz = digs_no_significativos();\par
01886                 {\cf19 if} (nsz==0) {\cf19 return} cthis;\par
01887                 {\cf19 else} \{\par
01888                         {\cf17 const} usint pos = 0;\par
01889                         {\cf19 if} (nsz>0) cthis.erase(pos,nsz);\par
01890                         {\cf19 return} cthis;\par
01891                 \}\par
01892         \}\par
01893 \}\par
01894 \par
01895 {\cf17 inline} nat_num_t reduce(){\cf17  const }\{\par
01896         {\cf17 const} nat_num_t & cthis = (*this);\par
01897         nat_num_t cpyreducida(cthis);\par
01898                 {\cf19 if} (cpyreducida.size()==0) \{\par
01899                 cpyreducida = nat_num_t(dig(0));\par
01900                 {\cf19 return} cpyreducida;\par
01901         \}\par
01902         {\cf19 else} {\cf19 if} (cpyreducida.size()==1) {\cf19 return} cpyreducida;\par
01903         {\cf19 else} \{\par
01904                 {\cf17 const} usint nsz = cpyreducida.digs_no_significativos();\par
01905                 {\cf19 if} (nsz==0) {\cf19 return} cpyreducida;\par
01906                 {\cf19 else} \{\par
01907                         {\cf17 const} usint pos = 0;\par
01908                         {\cf19 if} (nsz>0) cpyreducida.erase(pos,nsz);\par
01909                         {\cf19 return} cpyreducida;\par
01910                 \}\par
01911         \}\par
01912 \}\par
01913 \par
01914 {\cf17 inline} {\cf17 const} nat_num_t & reduce_fracc() \{\par
01915         nat_num_t & cthis = (*this);\par
01916         {\cf19 if} (cthis.size()==0) \{\par
01917                 cthis = nat_num_t(dig(0));\par
01918                 {\cf19 return} cthis;\par
01919         \}\par
01920         {\cf19 else} {\cf19 if} (cthis.size()==1) {\cf19 return} cthis;\par
01921         {\cf19 else} \{\par
01922                 {\cf17 const} usint nsz = digs_fracc_no_significativos();\par
01923                 {\cf19 if} (nsz==0) {\cf19 return} cthis;\par
01924                 {\cf19 else} \{\par
01925                         {\cf17 const} usint pos = 0;\par
01926                         cthis.erase(pos,nsz);\par
01927                         {\cf19 return} cthis;\par
01928                 \}\par
01929         \}\par
01930 \}\par
01931 \par
01932 {\cf17 inline} nat_num_t reduce_fracc(){\cf17  const }\{\par
01933         {\cf17 const} nat_num_t & cthis = (*this);\par
01934         nat_num_t cpyreducida(cthis);\par
01935                 {\cf19 if} (cpyreducida.size()==0) \{\par
01936                 cpyreducida = nat_num_t(dig(0));\par
01937                 {\cf19 return} cpyreducida;\par
01938         \}\par
01939         {\cf19 else} {\cf19 if} (cpyreducida.size()==1) {\cf19 return} cpyreducida;\par
01940         {\cf19 else} \{\par
01941                 {\cf17 const} usint nsz = cpyreducida.digs_fracc_no_significativos();\par
01942                 {\cf19 if} (nsz==0) {\cf19 return} cpyreducida;\par
01943                 {\cf19 else} \{\par
01944                         {\cf17 const} usint pos = 0;\par
01945                         cpyreducida.erase(pos,nsz);\par
01946                         {\cf19 return} cpyreducida;\par
01947                 \}\par
01948         \}\par
01949 \}\par
01950 \par
01951 \};\par
01952 \par
01953 \par
01954 \par
01955 {\cf20                                                 /****************************/}\par
01956                                                 {\cf20 /*                                                      */}\par
01957                                                 {\cf20 /*              ISTREAM Y OSTREAM       */}\par
01958                                                 {\cf20 /*                                                      */}\par
01959 {\cf20                                                 /****************************/}\par
01960 \par
01961 \par
01962 \par
01963 {\cf20 //uint#:dig:dig:#B}\par
01964 {\cf17 template}<const uch{\cf18 int} Base>\par
01965 istream & operator >> (istream & is,nat_num_t<Base> & arg) \{\par
01966         {\cf17 enum} estado_e \{e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13\};\par
01967         vector<string> num(255);\par
01968         {\cf18 string} sds;\par
01969         {\cf18 string} num_digint;\par
01970         {\cf18 string} num_base;\par
01971         usint numero_base_recogido      = 0;\par
01972         usint ind_sds                           = 0;\par
01973         usint digint                            = 0;\par
01974         usint ind_num                           = 0;\par
01975         estado_e est_act                        = e0;\par
01976         {\cf18 char} c;\par
01977         is >> sds;\par
01978         {\cf19 do} \{\par
01979                 c = sds[ind_sds];\par
01980                 {\cf19 switch} (est_act) \{\par
01981                 {\cf19 case} e0 :\par
01982                         \{\par
01983                                 num_digint.clear();\par
01984                                 num_base.clear();\par
01985                                 numero_base_recogido = 0;\par
01986                                 digint = 0;\par
01987                                 ind_num = 0;\par
01988                         \}\par
01989                         {\cf19 if} (c=={\cf23 'u'}) est_act = e1;\par
01990                         {\cf19 break};\par
01991 \par
01992                 {\cf19 case} e1 :\par
01993                         {\cf19 if} (c=={\cf23 'i'}) est_act = e2;\par
01994                         {\cf19 else} est_act = e0;\par
01995                         {\cf19 break};\par
01996 \par
01997                 {\cf19 case} e2 :\par
01998                         {\cf19 if} (c=={\cf23 'n'}) est_act = e3;\par
01999                         {\cf19 else} est_act = e0;\par
02000                         {\cf19 break};\par
02001 \par
02002                 {\cf19 case} e3 :\par
02003                         {\cf19 if} (c=={\cf23 't'}) est_act = e4;\par
02004                         {\cf19 else} est_act = e0;\par
02005                         {\cf19 break};\par
02006 \par
02007                 {\cf19 case} e4 :\par
02008                         {\cf19 if} (c=={\cf23 '#'}) est_act = e5;\par
02009                         {\cf19 else} est_act = e0;\par
02010                         {\cf19 break};\par
02011 \par
02012                 {\cf19 case} e5 :\par
02013                         {\cf19 if} ((c>={\cf23 '1'})and(c<={\cf23 '9'})) \{\par
02014                                 num[ind_num].push_back(c-{\cf23 '0'});\par
02015                                 est_act = e6;\par
02016                         \}\par
02017                         {\cf19 else} est_act=e0;\par
02018                         {\cf19 break};\par
02019                 {\cf19 case} e6 :\par
02020                         {\cf19 if} ((c>={\cf23 '0'})and(c<={\cf23 '9'})) \{\par
02021                                 num[ind_num].push_back(c-{\cf23 '0'});\par
02022                         \}\par
02023                         {\cf19 else} {\cf19 if} (c=={\cf23 ':'}) \{\par
02024                                 est_act=e7;\par
02025                                 ++ind_num;\par
02026                         \}\par
02027                         {\cf19 else} {\cf19 if} (c=={\cf23 '#'}) \{\par
02028                                 est_act=e8;\par
02029                                 ++ind_num;\par
02030                         \}\par
02031                         {\cf19 else} est_act=e0;\par
02032                         {\cf19 break};\par
02033                 {\cf19 case} e7 :\par
02034                         {\cf19 if} ((c>={\cf23 '0'})and(c<={\cf23 '9'})) \{\par
02035                                 est_act = e6;\par
02036                                 num[ind_num].push_back(c-{\cf23 '0'});\par
02037                         \}\par
02038                         {\cf19 else} est_act = e0;\par
02039                         {\cf19 break};\par
02040                 {\cf19 case} e8 :\par
02041                         {\cf19 if} (c=={\cf23 'B'}) \{\par
02042                                 est_act = e9;\par
02043                         \}\par
02044                         {\cf19 else} est_act = e0;\par
02045                         {\cf19 break};\par
02046                 {\cf19 case} e9 :\par
02047                         {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '2'}))\{\par
02048                                 est_act = e10;\par
02049                                 num_base.push_back(c-{\cf23 '0'});\par
02050                         \}\par
02051                         {\cf19 else} {\cf19 if} (c=={\cf23 '1'}) \{\par
02052                                 est_act = e11;\par
02053                                 num_base.push_back(1);\par
02054                         \}\par
02055                         {\cf19 else} {\cf19 if} (c=={\cf23 ' '} || c=={\cf23 '\\0'})\par
02056                                 est_act = e12;\par
02057                         {\cf19 else} est_act=e0;\par
02058                         {\cf19 break};\par
02059                 {\cf19 case} e10 :\par
02060                         {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'}))\par
02061                                 num_base.push_back(c-{\cf23 '0'});\par
02062                         {\cf19 else} {\cf19 if}(c=={\cf23 ' '} || c=={\cf23 '\\0'})\par
02063                                 est_act = e12;\par
02064                         {\cf19 else} est_act = e0;\par
02065                         {\cf19 break};\par
02066                 {\cf19 case} e11 :\par
02067                         {\cf19 if} ((c<={\cf23 '9'})and(c>={\cf23 '0'})) \{\par
02068                                 est_act=e9;\par
02069                                 num_base.push_back(c-{\cf23 '0'});\par
02070                         \}\par
02071                         {\cf19 else} {\cf19 if}(c=={\cf23 ' '} || c=={\cf23 '\\0'})\par
02072                                 est_act = e12;\par
02073                         {\cf19 else} est_act = e0;\par
02074                         {\cf19 break};\par
02075                 {\cf19 case} e12 :\par
02076                         {\cf19 for} (uint k=0 ; k < num_base.size() ; ++k ) \{\par
02077                                 numero_base_recogido *= 10;\par
02078                                 numero_base_recogido += num_base[k];\par
02079                         \}\par
02080                         {\cf19 if} (numero_base_recogido!=Base) est_act = e0;\par
02081                         {\cf19 else} est_act = e13;\par
02082                 {\cf19 case} e13 : {\cf19 break};\par
02083                 default  : est_act=e0;\par
02084                 \}\par
02085                 ++ind_sds;\par
02086         \} {\cf19 while} ((est_act!=e13)and(c!={\cf23 '\\0'}));\par
02087 \par
02088         arg.clear();\par
02089         uchint numero;\par
02090         {\cf19 for} (uchint j=0 ; j < ind_num ; ++j) \{\par
02091                 numero=0;\par
02092                 {\cf19 for} (uint k=0 ; k < num[j].size() ; ++k ) \{\par
02093                         numero *= 10;\par
02094                         numero += num[j][k];\par
02095                 \}\par
02096                 arg.push_back(dig_t<Base>(numero));\par
02097         \}\par
02098         arg.p_aux(pardigs_t<Base>());\par
02099         {\cf19 return} is;\par
02100 \}\par
02101 \par
02102 {\cf17 template}<const uch{\cf18 int} Base>\par
02103 ostream & operator << (ostream & os,{\cf17 const} nat_num_t<Base> & arg) \{\par
02104         usint sz = arg.size();\par
02105         os  << {\cf22 "uint#"};\par
02106         {\cf19 for} ({\cf18 int} k=0 ; k<sz ; ++k) \{\par
02107                 {\cf19 if} (k==0)\par
02108                         os      << arg[k].Dig2Int();\par
02109                 {\cf19 else}\par
02110                         os      << {\cf22 ":"} << arg[k].Dig2Int();\par
02111         \}\par
02112         os      <<{\cf22 "#B"}\par
02113                 << {\cf17 static_cast<}{\cf18 int}{\cf17 >}(Base) ;\par
02114         {\cf19 return} os;\par
02115 \}\par
02116 \par
02117 {\cf21 #endif  }{\cf20 // NAT_NUM_T__HPP__INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo nat_rat_fixed_reg_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_rat_fixed_reg_t.hpp}
{\xe \v nat_rat_fixed_reg_t.hpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "int_reg_digs_t.hpp"}\par
{\f2 #include "utilities.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para nat_rat_fixed_reg_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__rat__fixed__reg__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::nat_rat_fixed_reg_t< UINT_T, B, LE, LF >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Length> \par
requires (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))std::istream & {\b NumRepr::operator>>} (std::istream &is, pfx_rat_reg_digs_t< Int_Type, Base, Length > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c Int_Type, Int_Type Base, std::size_t Long> \par
requires (type_traits::suitable_base<Int_Type,Base>())std::ostream & {\b NumRepr::operator<<} (std::ostream &os, const pfx_rat_reg_digs_t< Int_Type, Base, Long > &arg)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nat_rat_fixed_reg_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_rat_fixed_reg_t.hpp}
{\xe \v nat_rat_fixed_reg_t.hpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef NAT_RAT_FIXED_REG_T_HPP_INCLUDED}\par
00002 {\cf21 #define NAT_RAT_FIXED_REG_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "int_reg_digs_t.hpp"}\par
00005 {\cf21 #include "utilities.hpp"}\par
00006 \par
00007 {\cf17 namespace }NumRepr \{\par
00008 \par
00009 {\cf17 template}<       type_traits::uint_type_for_radix_c UINT_T,\par
00010                                         UINT_T B,std::size_t LE,std::size_t LF          >\par
00011         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>() && (LE>0))\par
00012 {\cf17 struct }nat_rat_fixed_reg_t \{\par
00013         {\cf17 using }dig_t = dig_t<UINT_T,B>;\par
00014         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00015         {\cf17 using }base_NEXNF_t = std::array<dig_t<UINT_T,B>,NE+NF>;\par
00016         {\cf17 using }base_t       = base_NEXNF_t<LE,LF>;\par
00017         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00018                 {\cf17 requires} (NE>0)\par
00019         {\cf17 using} pfx_rat_reg_NExNF_digs_t          = pfx_rat_reg_digs_t<UINT_T,B,NE,NF>;\par
00020         {\cf17 using }SIG_UINT_T                = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00021         {\cf17 using }SIG_SINT_T                = {\cf17 typename} type_traits::sig_SInt_for_UInt_t<UINT_T>;\par
00022         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00023         {\cf17 using }nat_reg_NExNF_digs_t = nat_reg_digs_t<UINT_T,B,NE+NF>;\par
00024         {\cf17 using }nat_reg_digs_t = nat_reg_digs_t<UINT_T,B,LE+LF>;\par
00025         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00026                 {\cf17 requires} (NE>0)\par
00027         {\cf17 using} reg_ints_t                = {\cf17 typename} std::array<UINT_T,NE+NF>;\par
00028         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00029                 {\cf17 requires} (NE>0)\par
00030         {\cf17 using} reg_suints_t      = {\cf17 typename} std::array<SIG_UINT_T,NE+NF>;\par
00031         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00032                 {\cf17 requires} (NE>0)\par
00033         {\cf17 using} reg_ssints_t      = {\cf17 typename} std::array<SIG_SINT_T,NE+NF>;\par
00034 {\cf17 private}:\par
00035         base_t m_dc;\par
00036 public :\par
00037         {\cf17 static} {\cf17 constexpr} dig_t                  dig_0()                         noexcept        \{{\cf19 return} dig_t::dig_0();\}\par
00038         {\cf17 static} {\cf17 constexpr} dig_t                  dig_1()                         noexcept        \{{\cf19 return} dig_t::dig_1();\}\par
00039         {\cf17 static} {\cf17 constexpr} dig_t                  dig_Bm1()                       noexcept        \{{\cf19 return} dig_t::dig_max();\}\par
00040         {\cf17 static} {\cf17 constexpr} dig_t                  dig_max()                       noexcept        \{{\cf19 return} dig_t::dig_max();\}\par
00041         {\cf17 static} {\cf17 constexpr} dig_t                  dig_Bm2()                       noexcept        \{{\cf19 return} dig_t::dig_submax();\}\par
00042         {\cf17 static} {\cf17 constexpr} dig_t                  dig_submax()  noexcept  \{{\cf19 return} dig_t::dig_submax();\}\par
00043         {\cf17 static} {\cf17 constexpr} UINT_T                 ui_0()                          noexcept        \{{\cf19 return} dig_t::ui_0();\}\par
00044         {\cf17 static} {\cf17 constexpr} UINT_T                 ui_1()                          noexcept        \{{\cf19 return} dig_t::ui_1();\}\par
00045         {\cf17 static} {\cf17 constexpr} UINT_T                 ui_Bm1()                        noexcept        \{{\cf19 return} dig_t::ui_Bm1();\}\par
00046         {\cf17 static} {\cf17 constexpr} SIG_UINT_T     sui_B()                         noexcept  \{{\cf19 return} dig_t::sui_B();\}\par
00047         {\cf17 static} {\cf17 constexpr} SIG_UINT_T sui_Bp1()           noexcept        \{{\cf19 return} dig_t::sui_B()+1;\}\par
00048         {\cf17 static} {\cf17 constexpr} UINT_T                 ui_submax()             noexcept        \{{\cf19 return} dig_t::ui_submax();\}\par
00049         {\cf17 static} {\cf17 constexpr} UINT_T                 ui_max()                        noexcept  \{{\cf19 return} dig_t::ui_max();\}\par
00050 \par
00051         {\cf17 static} {\cf17 constexpr} pfx_rat_reg_digs_t     regd_0()                noexcept    \{\par
00052                 pfx_rat_reg_digs_t ret\{\};\par
00053                 {\cf19 for}({\cf17 auto}& dig : ret.m_dc) \{\par
00054                         dig = dig_0();\par
00055                 \}\par
00056                 {\cf19 return} ret;\par
00057         \}\par
00058         {\cf17 static} {\cf17 constexpr} pfx_rat_reg_digs_t             regd_1()                noexcept \{\par
00059                 pfx_rat_reg_digs_t ret\{regd_0()\};\par
00060                 ret.m_dc[LF] = dig_1();\par
00061                 {\cf19 return} ret;\par
00062         \}\par
00063         {\cf17 static} {\cf17 constexpr} pfx_rat_reg_digs_t             regd_Bm1()              noexcept \{\par
00064                 pfx_rat_reg_digs_t ret\{regd_0()\};\par
00065                 ret.m_dc[LF] = dig_Bm1();\par
00066                 {\cf19 return} ret;\par
00067         \}\par
00068         {\cf17 static} {\cf17 constexpr} pfx_rat_reg_digs_t             regd_B()                noexcept \{\par
00069                 pfx_rat_reg_digs_t ret\{regd_0()\};\par
00070                 ret.m_dc[LF+1] = dig_1();\par
00071                 {\cf19 return} ret;\par
00072         \}\par
00073 \par
00074         {\cf17 template}<std::{\cf18 int}32_t n>\par
00075                 {\cf17 requires} ((n < LE) && (n > -(LF+1)))\par
00076         {\cf17 static} {\cf17 constexpr} pfx_rat_reg_digs_t             regd_pow_n_B()  noexcept \{\par
00077                 pfx_rat_reg_digs_t ret\{regd_0()\};\par
00078                 ret.m_dc[LF+n] = dig_1();\par
00079                 {\cf19 return} ret;\par
00080         \}\par
00081         {\cf17 template}<std::{\cf18 int}32_t n>\par
00082                 {\cf17 requires} ((n < LE) && (n > -(LF+1)))\par
00083         {\cf17 static} {\cf17 constexpr} pfx_rat_reg_digs_t             regd_pow_n_B_m1()       noexcept    \{\par
00084                 pfx_rat_reg_digs_t ret\{\};\par
00085                 {\cf19 for}(std::size_t ix\{-LF\} ; ix < n ; ++ix) \{\par
00086                         ret.m_dc[LF+ix] = dig_t(B-1);\par
00087                 \}\par
00088                 {\cf19 for}(std::size_t ix\{n\} ; ix < LE ; ++ix) \{\par
00089                         ret.m_dc[LF+ix] = dig_t(0);\par
00090                 \}\par
00091                 {\cf19 return} ret;\par
00092         \}\par
00094         {\cf17 static} {\cf17 constexpr} reg_ints_t<LE+LF>      regi_0()                                noexcept        \{\par
00095                 reg_ints_t<LE+LF> ret\{\};\par
00096                 {\cf19 for}({\cf17 auto}& digint : ret) \{\par
00097                         digint = dig_0()();\par
00098                 \}\par
00099                 {\cf19 return} ret;\par
00100         \}\par
00101 \par
00102         {\cf17 static} {\cf17 constexpr} reg_ints_t<LE+LF>      regi_1()                        noexcept        \{\par
00103                 reg_ints_t<LE+LF> ret\{regi_0()\};\par
00104                 ret[LF] = dig_1()();\par
00105                 {\cf19 return} ret;\par
00106         \}\par
00107 \par
00108         {\cf17 static} {\cf17 constexpr} reg_ints_t<LE+LF>      regi_Bm1()                      noexcept        \{\par
00109                 reg_ints_t<LE+LF> ret\{regi_0()\};\par
00110                 ret[LF] = dig_Bm1()();\par
00111                 {\cf19 return} ret;\par
00112         \}\par
00113 \par
00114         {\cf17 static} {\cf17 constexpr} reg_ints_t<LE+LF>      regi_B()                        noexcept    \{\par
00115                 reg_ints_t<LE+LF> ret\{regi_0()\};\par
00116                 ret[LF+1] = dig_1()();\par
00117                 {\cf19 return} ret;\par
00118         \}\par
00119 \par
00120         {\cf17 template}<std::{\cf18 int}32_t n>\par
00121                 {\cf17 requires} ((n < LE) && (n > -(LF+1)))\par
00122         {\cf17 static} {\cf17 constexpr} reg_ints_t<LE+LF>      regi_pow_n_B()          noexcept        \{\par
00123                 reg_ints_t<LE+LF> ret\{regi_0()\};\par
00124                 ret[LF+n] = dig_1()();\par
00125                 {\cf19 return} ret;\par
00126         \}\par
00127 \par
00128         {\cf17 template}<std::{\cf18 int}32_t n>\par
00129                 {\cf17 requires} ((n < LE) && (n > -(LF+1)))\par
00130         {\cf17 static} {\cf17 constexpr} reg_ints_t<LE+LF>      regi_pow_n_B_m1()       noexcept        \{\par
00131                 reg_ints_t<LE+LF> ret\{\};\par
00132                 {\cf19 for}(std::int32_t ix\{-LF\} ; ix < n ; ++ix) \{\par
00133                         ret[LF+ix] = dig_t(B-1)();\par
00134                 \}\par
00135                 {\cf19 for}(std::int32_t ix\{n\} ; ix < LE ; ++ix) \{\par
00136                         ret[LF+ix] = dig_t(0)();\par
00137                 \}\par
00138                 {\cf19 return} ret;\par
00139         \}\par
00140 \par
00141 {\cf20                                 /****************************/}\par
00142                                 {\cf20 /*                                                                                                      */}\par
00143                                 {\cf20 /*    CONSTRUIR NUMERO                  */}\par
00144                                 {\cf20 /*                                                                                                      */}\par
00145 {\cf20                                 /****************************/}\par
00146 {\cf17 public}:\par
00147 \par
00151         {\cf17 constexpr} {\cf17 inline}\par
00152         pfx_rat_reg_digs_t()\par
00153         noexcept : m_dc\{dig_0()\} \{\}\par
00157         {\cf17 constexpr} {\cf17 inline}\par
00158         pfx_rat_reg_digs_t({\cf17 const} std::initializer_list<dig_t> & arg)\par
00159         noexcept : m_dc\{arg\} \{\}\par
00163         {\cf17 template}<{\cf17 typename} ... Ts>\par
00164                 {\cf17 requires} (std::is_same_v<Ts,dig_t>&&...)\par
00165         {\cf17 constexpr} {\cf17 inline}\par
00166         pfx_rat_reg_digs_t({\cf17 const} Ts &... args)\par
00167         noexcept : m_dc\{(utility::pack2array<Ts...>\{\})(args...)\} \{\}\par
00169 \par
00173         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00174                 {\cf17 requires} (NE>0)\par
00175         {\cf18 void} copy_arg_N({\cf17 const} base_NEXNF_t<NE,NF> & arg) \{\par
00176                 {\cf17 constexpr} int64_t cLE\{LE\};\par
00177                 {\cf17 constexpr} int64_t cLF\{LF\};\par
00178                 {\cf17 constexpr} int64_t cNE\{NE\};\par
00179                 {\cf17 constexpr} int64_t cNF\{NF\};\par
00180                 {\cf19 if} {\cf17 constexpr} (NE<LE) \{\par
00181                         {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
00182                                 {\cf19 for}(std::size_t ix\{NE\} ; ix < LE ; ++ix)\par
00183                                         m_dc[LF+ix]=dig_0();\par
00184                                 {\cf19 for}(std::size_t ix\{0\} ; ix < LF-NE ; ++ix)\par
00185                                         m_dc[LF+ix]=arg[NF+ix];\par
00186                         \}\par
00187                         {\cf19 else} \{\par
00188                                 {\cf19 for}(std::size_t ix\{NE\} ; ix < LE ; ++ix)\par
00189                                         m_dc[LF+ix]=dig_0();\par
00190                                 {\cf19 for}(std::size_t ix\{0\} ; ix < NF-LF ; ++ix)\par
00191                                         m_dc[cLF+ix]=arg[cNF+ix];\par
00192                         \}\par
00193                 \}\par
00194                 {\cf19 else} \{\par
00195                         {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
00196                                 {\cf19 for}(std::size_t ix\{LF\} ; ix < LE ; ++ix)\par
00197                                         m_dc[NF+ix]=arg[ix];\par
00198                         \}\par
00199                         {\cf19 else} \{\par
00200 \par
00201                         \}\par
00202                 \}\par
00203         \}\par
00204 \par
00208         {\cf17 template}<std::{\cf18 size_t} N>\par
00209                 {\cf17 requires} (N>0)\par
00210         {\cf18 void} move_arg_N(base_N_t<NE,NF>&& arg) \{\par
00211                 {\cf19 if} {\cf17 constexpr} (N<L) \{\par
00212                         {\cf19 for}(std::size_t ix\{N\} ; ix < L ; ++ix)\par
00213                                 m_dc[ix]=dig_0();\par
00214                         {\cf19 for}(std::size_t ix\{0\} ; ix < N ; ++ix)\par
00215                                 m_dc[ix]=std::move(arg[ix]);\par
00216                 \}\par
00217                 {\cf19 else} \{\par
00218                         {\cf19 for}(std::size_t ix\{0\} ; ix < L ; ++ix)\par
00219                                 m_dc[ix]=std::move(arg[ix]);\par
00220                 \}\par
00221         \}\par
00224         {\cf17 template}<std::{\cf18 size_t} N>\par
00225                 {\cf17 requires} (N>0)\par
00226         {\cf17 constexpr} {\cf17 inline}\par
00227         pfx_rat_reg_digs_t({\cf17 const} base_NExNF_t<NE,NF> & arg)\par
00228         noexcept : m_dc\{copy_arg_N<N>(arg)\} \{\}\par
00231         {\cf17 template}<std::{\cf18 size_t} N>\par
00232                 {\cf17 requires} (N>0)\par
00233         {\cf17 constexpr} {\cf17 inline}\par
00234         pfx_rat_reg_digs_t({\cf17 const} base_NExNF_t<NE,NF> && arg)\par
00235         noexcept : m_dc\{move_arg_N<N>(arg)\} \{\}\par
00237 \par
00241         {\cf17 template}<type_traits::integral_c ... Ints_type>\par
00242                 {\cf17 requires} (({\cf17 sizeof}...(Ints_type))<=L)\par
00243         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00244         base_t normalize(Ints_type ... digits_pow_i)\par
00245         {\cf17 noexcept} \{\par
00246                 {\cf17 using }pack_type         = {\cf17 typename} utility::pack2array<Ints_type...>;\par
00247                 {\cf17 using }unique_type = {\cf17 typename} pack_type::elem_type;\par
00248                 {\cf17 constexpr} std::size_t pack_sz\{pack_type::pack_size()\};\par
00249                 {\cf19 if} {\cf17 constexpr} ( type_traits::unsigned_integral_c<unique_type> ) \{\par
00250                         {\cf19 if} {\cf17 constexpr} (type_traits::is_unsigned_sz_gt_v<UINT_T,unique_type>) \{\par
00251                                         {\cf17 using }SUInt_type = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00252                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00253                                         base_t ret\{\};\par
00254                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00255                                                 ret[ix] = dig_t(ret_array[ix]);\par
00256                                         \}\par
00257                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00258                                                 ret[ix] = dig_t(0);\par
00259                                         \}\par
00260                                         {\cf19 return} ret;\par
00261                         \}\par
00262                         {\cf19 else} \{\par
00263                                         {\cf17 using }SUInt_type = type_traits::sig_UInt_for_UInt_t<unique_type>;\par
00264                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00265                                         base_t ret\{\};\par
00266                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00267                                                 ret[ix] = dig_t(ret_array[ix]);\par
00268                                         \}\par
00269                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00270                                                 ret[ix] = dig_t(0);\par
00271                                         \}\par
00272                                         {\cf19 return} ret;\par
00273                         \}\par
00274                 \}\par
00275                 {\cf19 else} \{\par
00276                         {\cf17 using }temp_SUInt_type = type_traits::sig_UInt_for_SInt_t<unique_type>;\par
00277                         {\cf19 if} {\cf17 constexpr} (type_traits::is_unsigned_sz_gt_v<UINT_T,temp_SUInt_type>)\par
00278                         \{\par
00279                                         {\cf17 using }SUInt_type = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00280                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00281                                         base_t ret\{\};\par
00282                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00283                                                 {\cf19 if} (ret_array[ix] < 0)\par
00284                                                         ret[ix] = dig_t((((ret_array[ix]/(-B))+1)*B)+ret_array[ix]);\par
00285                                                 {\cf19 else}\par
00286                                                         ret[ix] = dig_t(ret_array[ix]);\par
00287                                         \}\par
00288                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00289                                                 ret[ix] = dig_0();\par
00290                                         \}\par
00291                                         {\cf19 return} ret;\par
00292                         \}\par
00293                         {\cf19 else} \{\par
00294                                         {\cf17 using }SUInt_type = temp_SUInt_type;\par
00295                                         std::array<SUInt_type,L> ret_array\{digits_pow_i...\};\par
00296                                         base_t ret\{\};\par
00297                                         {\cf19 for}(std::size_t ix\{0\} ; ix < pack_sz ; ++ix) \{\par
00298                                                 {\cf19 if} (ret_array[ix] < 0)\par
00299                                                         ret[ix] = dig_t((((ret_array[ix]/(-B))+1)*B)+ret_array[ix]);\par
00300                                                 {\cf19 else}\par
00301                                                         ret[ix] = dig_t(ret_array[ix]);\par
00302                                         \}\par
00303                                         {\cf19 for}(std::size_t ix\{pack_sz\} ; ix < L ; ++ix) \{\par
00304                                                 ret[ix] = dig_0();\par
00305                                         \}\par
00306                                         {\cf19 return} ret;\par
00307                         \}\par
00308                 \}\par
00309         \}\par
00310 \par
00314         {\cf17 template}<type_traits::integral_c ... Ints_type>\par
00315         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t(Ints_type ... dig_pow_i) noexcept :\par
00316                 m_dc\{normalize<Ints_type...>(dig_pow_i...)\} \{\}\par
00320         {\cf17 template}<std::{\cf18 size_t} NE, std::{\cf18 size_t} NF>\par
00321                 {\cf17 requires} (NE>0)\par
00322         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t({\cf17 const} nat_reg_NExNF_digs_t<NE,NF> & arg) noexcept :\par
00323                 m_dc\{copy_arg<NE,NF>(arg.m_dc)\} \{\}\par
00328         {\cf17 template}<std::{\cf18 size_t} NE , std::{\cf18 size_t} NF>\par
00329                 {\cf17 requires} (NE>0)\par
00330         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t(nat_reg_NExNF_digs_t<NE,NF> && arg) noexcept :\par
00331                 m_dc\{move_arg<NE,NF>(arg.m_dc)\} \{\}\par
00332 \par
00339         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00340                 {\cf17 requires} (NE>0)\par
00341         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t & {\cf17 operator} = (nat_reg_NExNF_digs_t<NE,NF> & arg) {\cf17 noexcept}\par
00342         \{\par
00343                 {\cf19 if} ({\cf17 this} != &arg) \{\par
00344                         copy_arg<NE,NF>(arg.m_dc);\par
00345                 \}\par
00346                 {\cf19 return} (*{\cf17 this});\par
00347         \}\par
00354         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00355                 {\cf17 requires} (NE>0)\par
00356         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t & {\cf17 operator} = (nat_reg_NExNF_digs_t<NE,NF> && arg) {\cf17 noexcept}\par
00357         \{\par
00358                 {\cf19 if} ({\cf17 this} != &arg) \{\par
00359                         move_arg<NE,NF>(arg.m_dc);\par
00360                 \}\par
00361                 {\cf19 return} (*{\cf17 this});\par
00362         \}\par
00364         {\cf17 template}<std::{\cf18 size_t} NE, std::{\cf18 size_t} NF>\par
00365                 {\cf17 requires} (NE>0)\par
00366         {\cf17 constexpr} {\cf17 inline} {\cf17 const} pfx_rat_reg_digs_t & {\cf17 operator} = ({\cf17 const} nat_reg_N_digs_t<NE,NF> & arg)\par
00367         {\cf17 noexcept} \{\par
00368                 {\cf19 if} ({\cf17 this} != &arg) \{\par
00369                                 copy_arg<NE,NF>(arg.m_dc);\par
00370                 \}\par
00371                 {\cf19 return} (*{\cf17 this});\par
00372         \}\par
00374         {\cf17 template}<std::{\cf18 size_t} NE, std::{\cf18 size_t} NF>\par
00375                 {\cf17 requires} (NE>0)\par
00376         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t & {\cf17 operator} = ({\cf17 const} base_NEXNF_t<NE,NF> & arg) {\cf17 noexcept}\par
00377         \{\par
00378                 {\cf19 if} (&(this->m_dc)!=(&arg))\par
00379                         copy_arg<NE+NF>(arg);\par
00380                 {\cf19 return} (*{\cf17 this});\par
00381         \}\par
00387         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t & operator = ({\cf17 const} dig_t & arg) {\cf17 noexcept} \{\par
00388                 {\cf19 if} (&(this->m_dc[LF])!=(&arg)) \{\par
00389                         {\cf19 for} (dig_t& dig : m_dc)\par
00390                                 dig = dig_0();\par
00391                         m_dc[LF] = arg;\par
00392                 \}\par
00393                 {\cf19 return} (*{\cf17 this});\par
00394         \}\par
00399         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00400         {\cf17 constexpr} {\cf17 inline} pfx_rat_reg_digs_t & operator = (Int_Type arg) {\cf17 noexcept} \{\par
00401                 Int_Type creg_g\{arg\};\par
00402                 {\cf19 if} ((&(this->m_dc()))!=(&arg)) \{\par
00403                         uint128_t BasePowIx\{1\};\par
00404                         {\cf19 for}(std::size_t k\{LF\} ; k < LE+LF ; ++k) \{\par
00405                                 BasePowIx *= B;\par
00406                         \}\par
00407                         {\cf19 while} (creg_g < 0) \{\par
00408                                 creg_g += BasePowIx;\par
00409                         \}\par
00410                         {\cf19 for}(std::size_t k\{LF\} ; k < LE+LF ; ++k)\{\par
00411                                 m_dc[k] = dig_t(creg_g);\par
00412                                 creg_g /= B;\par
00413                         \}\par
00414                         {\cf19 for}(std::size_t k\{LF-1\} ; k >= 0 ; --k)\par
00415                                 m_dc[k]= dig_0();\par
00416                 \}\par
00417                 {\cf19 return} (*{\cf17 this});\par
00418         \}\par
00419 \par
00424 \par
00430         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00431                 {\cf17 requires} (NE>0)\par
00432         {\cf17 constexpr} {\cf17 inline}\par
00433         nat_reg_NExNF_digs_t<LE+NE,LF+NF> concat({\cf17 const} nat_reg_NExNF_digs_t<NE,NF> & arg) {\cf17 const}\par
00434         {\cf17 noexcept} \{\par
00435                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00436                 nat_reg_NExNF_digs_t<LE+NE,LF+NF> ret\{\};\par
00437                 {\cf19 for}(std::size_t ix\{0\} ; ix < NE+NF ; ++ix) \{\par
00438                         ret[ix] = arg[ix];\par
00439                 \}\par
00440                 {\cf19 for}(std::size_t ix\{NE+NF\} ; ix < LE+LF+NE+NF ; ++ix) \{\par
00441                         ret[ix] = cthis[ix-NE-NF];\par
00442                 \}\par
00443                 {\cf19 return} ret;\par
00444         \}\par
00445 \par
00451         {\cf17 constexpr} {\cf17 inline}\par
00452         reg_N_digs_t<LE+LF+1> concat({\cf17 const} dig_t & arg) {\cf17 const}\par
00453         {\cf17 noexcept} \{\par
00454                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00455                 reg_N_digs_t<LE+LF+1> ret\{\};\par
00456                 ret[0] = arg;\par
00457                 {\cf19 for}(std::size_t ix\{1\} ; ix < LE+LF+1 ; ++ix) \{\par
00458                         ret[ix] = cthis[ix-1];\par
00459                 \}\par
00460                 {\cf19 return} ret;\par
00461         \}\par
00462 \par
00463         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00464                 {\cf17 requires} (NE>0)\par
00465         {\cf17 constexpr} {\cf17 inline}\par
00466         nat_reg_NExNF_digs_t<LE+NE,LF+NF> concat_inv({\cf17 const} nat_reg_NExNF_digs_t<NE,NF> & arg) {\cf17 const}\par
00467         {\cf17 noexcept} \{\par
00468                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00469                 nat_reg_NExNF_digs_t<LE+NE,LF+NF> ret\{\};\par
00470                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
00471                         ret[ix] = cthis[ix];\par
00472                 \}\par
00473                 {\cf19 for}(std::size_t ix\{LE+LF\} ; ix < NE+NF+LE+LF ; ++ix) \{\par
00474                         ret[ix] = arg[ix-LE-LF];\par
00475                 \}\par
00476                 {\cf19 return} ret;\par
00477         \}\par
00478 \par
00479         {\cf17 constexpr} {\cf17 inline}\par
00480         reg_N_digs_t<LE+LF+1> concat_inv({\cf17 const} dig_t & arg) {\cf17 const}\par
00481         {\cf17 noexcept} \{\par
00482                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00483                 reg_N_digs_t<LE+LF+1> ret\{\};\par
00484                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
00485                         ret[ix] = cthis[ix];\par
00486                 \}\par
00487                 ret[LE+LF] = arg;\par
00488                 {\cf19 return} ret;\par
00489         \}\par
00490 \par
00491         {\cf17 template}<std::{\cf18 size_t} NE, std::{\cf18 size_t} NF>\par
00492                 {\cf17 requires} (NE>0)\par
00493         {\cf17 constexpr} {\cf17 inline}\par
00494         nat_reg_NExNF_digs_t<LE+NE,LF+NF> concat(nat_reg_NExNF_digs_t<NE,NF> && arg)\par
00495         {\cf17 noexcept} \{\par
00496                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00497                 nat_reg_NExNF_digs_t<LE+NE,LF+NF> ret\{\};\par
00498                 {\cf19 for}(std::size_t ix\{0\} ; ix < NE+NF ; ++ix) \{\par
00499                         ret[ix] = std::move(arg[ix]);\par
00500                 \}\par
00501                 {\cf19 for}(std::size_t ix\{NE+NF\} ; ix < LE+LF+NE+NF ; ++ix) \{\par
00502                         ret[ix] = cthis[ix-NE-NF];\par
00503                 \}\par
00504                 {\cf19 return} ret;\par
00505         \}\par
00506 \par
00507         {\cf17 constexpr} {\cf17 inline}\par
00508         reg_N_digs_t<LE+LF+1> concat(dig_t && arg)\par
00509         {\cf17 noexcept} \{\par
00510                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00511                 reg_N_digs_t<LE+LF+1> ret\{\};\par
00512                 ret[0] = std::move(arg);\par
00513                 {\cf19 for}(std::size_t ix\{1\} ; ix < LE+LF+1 ; ++ix) \{\par
00514                         ret[ix] = cthis[ix-1];\par
00515                 \}\par
00516                 {\cf19 return} ret;\par
00517         \}\par
00518         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00519                 {\cf17 requires} (NE>0)\par
00520         {\cf17 constexpr} {\cf17 inline}\par
00521         nat_reg_NExNF_digs_t<LE+NE,LF+NF> concat_inv(nat_reg_NExNF_digs_t<NE,NF> && arg)\par
00522         {\cf17 noexcept} \{\par
00523                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00524                 nat_reg_NExNF_digs_t<LE+NE,LF+NF> ret\{\};\par
00525                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
00526                         ret[ix] = cthis[ix];\par
00527                 \}\par
00528                 {\cf19 for}(std::size_t ix\{LE+LF\} ; ix < NE+NF+LE+LF ; ++ix) \{\par
00529                         ret[ix] = std::move(arg[ix-LE-LF]);\par
00530                 \}\par
00531                 {\cf19 return} ret;\par
00532         \}\par
00533 \par
00534         {\cf17 constexpr} {\cf17 inline}\par
00535         reg_N_digs_t<LE+LF+1> concat_inv(dig_t && arg)\par
00536         {\cf17 noexcept} \{\par
00537                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00538                 reg_N_digs_t<LE+LF+1> ret\{\};\par
00539                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
00540                         ret[ix] = cthis[ix];\par
00541                 \}\par
00542                 ret[LE+LF] = std::move(arg);\par
00543                 {\cf19 return} ret;\par
00544         \}\par
00545 \par
00546         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00547                 {\cf17 requires} ((iend-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))\par
00548         {\cf17 constexpr} {\cf17 inline}\par
00549         reg_N_digs_t<iend-ibegin> subreg_digs() const\par
00550         noexcept \{\par
00551                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00552                 reg_N_digs_t<iend-ibegin> ret\{\};\par
00553                 {\cf19 for}(std::size_t ix\{ibegin\} ; ix < iend ; ++ix) \{\par
00554                         ret[ix-ibegin] = cthis[ix];\par
00555                 \}\par
00556                 {\cf19 return} ret;\par
00557         \}\par
00558 \par
00559         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00560                 {\cf17 requires} ((iend-ibegin>0)&&(iend <= LE+LF)&&(ibegin < iend))\par
00561         {\cf17 constexpr} {\cf17 inline}\par
00562         reg_N_digs_t<iend-ibegin> rev_subreg_digs() const\par
00563         noexcept \{\par
00564                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00565                 reg_N_digs_t<iend-ibegin> ret\{\};\par
00566                 {\cf19 for}(std::size_t ix\{iend\} ; ix > ibegin-1 ; --ix) \{\par
00567                         ret[ix-ibegin] = cthis[LE+LF-1-ix];\par
00568                 \}\par
00569                 {\cf19 return} ret;\par
00570         \}\par
00571 \par
00572         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00573                 {\cf17 requires} ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))\par
00574         {\cf17 constexpr} {\cf17 inline}\par
00575         reg_N_digs_t<iend-ibegin> subreg_digs_pe() const\par
00576         noexcept \{\par
00577                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00578                 reg_N_digs_t<iend-ibegin> ret\{\};\par
00579                 {\cf19 for}(std::size_t ix\{ibegin\} ; ix < iend ; ++ix) \{\par
00580                         ret[ix-ibegin] = cthis[ix];\par
00581                 \}\par
00582                 {\cf19 return} ret;\par
00583         \}\par
00584 \par
00585         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00586                 {\cf17 requires}  ((iend <= LE+LF)&&(ibegin < iend)&&(ibegin >= LF))\par
00587         {\cf17 constexpr} {\cf17 inline}\par
00588         reg_N_digs_t<iend-ibegin> rev_subreg_digs_pe() const\par
00589         noexcept \{\par
00590                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00591                 reg_N_digs_t<iend-ibegin> ret\{\};\par
00592                 {\cf19 for}(std::size_t ix\{iend\} ; ix > ibegin-1 ; --ix) \{\par
00593                         ret[ix-ibegin] = cthis[LE+LF-1-ix];\par
00594                 \}\par
00595                 {\cf19 return} ret;\par
00596         \}\par
00597 \par
00598         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00599                 {\cf17 requires} ((iend < LF)&&(ibegin < iend))\par
00600         {\cf17 constexpr} {\cf17 inline}\par
00601         reg_N_digs_t<iend-ibegin> subreg_digs_pf() {\cf17 const}\par
00602         {\cf17 noexcept} \{\par
00603                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00604                 reg_N_digs_t<iend-ibegin> ret\{\};\par
00605                 {\cf19 for}(std::size_t ix\{ibegin\} ; ix < iend ; ++ix) \{\par
00606                         ret[ix-ibegin] = cthis[ix];\par
00607                 \}\par
00608                 {\cf19 return} ret;\par
00609         \}\par
00610 \par
00611         {\cf17 template}<std::{\cf18 size_t} ibegin,std::{\cf18 size_t} iend>\par
00612                 {\cf17 requires} ((iend < LF)&&(ibegin < iend))\par
00613         {\cf17 constexpr} {\cf17 inline}\par
00614         reg_N_digs_t<iend-ibegin> rev_subreg_digs_pf() {\cf17 const}\par
00615         {\cf17 noexcept} \{\par
00616                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
00617                 reg_N_digs_t<iend-ibegin> ret\{\};\par
00618                 {\cf19 for}(std::size_t ix\{iend\} ; ix > ibegin-1 ; --ix) \{\par
00619                         ret[ix-ibegin] = cthis[LF-1-ix];\par
00620                 \}\par
00621                 {\cf19 return} ret;\par
00622         \}\par
00623 \par
00624 \par
00625 \par
00626 {\cf20                                 /**********************************/}\par
00627                                 {\cf20 /*                                                                                                      */}\par
00628                                 {\cf20 /*       Algunas Conversiones     */}\par
00629                                 {\cf20 /*                                                                                                      */}\par
00630 {\cf20                                 /**********************************/}\par
00631 \par
00632         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00633         {\cf17 constexpr} {\cf17 inline} Int_Type IntPart() const noexcept \{\par
00634                 std::uint64_t retInt\{0\};\par
00635                 std::uint64_t BasePowIx\{1\};\par
00636                 {\cf19 for}(std::size_t k\{LF\} ; k < LE+LF ; ++k) \{\par
00637                         retInt += m_dc[k]*BasePowIx;\par
00638                         BasePowIx *= B;\par
00639                 \}\par
00640                 {\cf19 return} (retInt);\par
00641         \}\par
00642 \par
00643 {\cf20                                 /********************************/}\par
00644                                 {\cf20 /*                                                                                                      */}\par
00645                                 {\cf20 /* OPERADORES COMPARATIVOS                      */}\par
00646                                 {\cf20 /*                                                                                                      */}\par
00647 {\cf20                                 /********************************/}\par
00648 \par
00654         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00655                 {\cf17 requires} (NE>0)\par
00656         {\cf17 constexpr} {\cf17 inline}\par
00657         {\cf18 bool} {\cf17 operator} == ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
00658         {\cf17 noexcept} \{\par
00659                 {\cf19 if} {\cf17 constexpr} (NE>LE) \{\par
00660                         {\cf19 for}(std::size_t k\{LE\} ; k < NE ; ++k) \{\par
00661                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00662                                         {\cf19 return} {\cf17 false};\par
00663                                 \}\par
00664                         \}\par
00665                 \}\par
00666                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LE>NE) \{\par
00667                         {\cf19 for}(std::size_t k\{NE\} ; k < LE ; ++k) \{\par
00668                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00669                                         {\cf19 return} {\cf17 false};\par
00670                                 \}\par
00671                         \}\par
00672                 \}\par
00673                 {\cf17 constexpr} {\cf17 auto} ZE\{std::min(LE,NE)\};\par
00674                 {\cf19 for}(std::size_t k\{0\} ; k < ZE ; ++k) \{\par
00675                                 {\cf19 if} (m_dc[k+LF]!=arg.m_dc[k+NF])\par
00676                                         {\cf19 return} {\cf17 false};\par
00677                 \}\par
00678                 {\cf17 constexpr} {\cf17 auto} ZF\{std::min(LF,NF)\};\par
00679                 {\cf19 for}(std::size_t k\{0\} ; k < ZF-1 ; ++k) \{\par
00680                                 {\cf19 if} (m_dc[LF-1-k]!=arg.m_dc[NF-1-k])\par
00681                                         {\cf19 return} {\cf17 false};\par
00682                 \}\par
00683                 {\cf19 if} {\cf17 constexpr} (NF>LF) \{\par
00684                         {\cf19 for}(std::size_t k\{LF\} ; k < NF ; ++k) \{\par
00685                                 {\cf19 if} (!(arg[k].is_0())) \{\par
00686                                         {\cf19 return} {\cf17 false};\par
00687                                 \}\par
00688                         \}\par
00689                 \}\par
00690                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LF>NF) \{\par
00691                         {\cf19 for}(std::size_t k\{NF\} ; k < LF ; ++k) \{\par
00692                                 {\cf19 if} (!(m_dc[k].is_0())) \{\par
00693                                         {\cf19 return} {\cf17 false};\par
00694                                 \}\par
00695                         \}\par
00696                 \}\par
00697                 {\cf19 return} {\cf17 true};\par
00698         \}\par
00699 \par
00700         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00701                 {\cf17 requires} (NE>0)\par
00702         {\cf17 constexpr} {\cf17 inline}\par
00703         {\cf18 bool} {\cf17 operator} == ({\cf17 const} pfx_rat_reg_digs_t<NE,NF>& arg) {\cf17 const}\par
00704         {\cf17 noexcept} \{\par
00705                 {\cf19 return} ((*{\cf17 this})==arg.m_dc);\par
00706         \}\par
00707 \par
00713 \par
00714         {\cf17 template}<std::{\cf18 size_t} NE , std::{\cf18 size_t} NF>\par
00715                 {\cf17 requires} (NE>0)\par
00716         {\cf17 constexpr} {\cf17 inline}\par
00717         {\cf18 bool} {\cf17 operator} != ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
00718         {\cf17 noexcept} \{\par
00719                 {\cf19 if} {\cf17 constexpr} (LE<NE) \{\par
00720                         {\cf19 for}(std::size_t k\{LE\} ; k < NE ; ++k) \{\par
00721                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00722                                         {\cf19 return} {\cf17 true};\par
00723                                 \}\par
00724                         \}\par
00725                 \}\par
00726                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (NE<LE) \{\par
00727                         {\cf19 for}(std::size_t k\{NE\} ; k < LE ; ++k) \{\par
00728                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00729                                         {\cf19 return} {\cf17 true};\par
00730                                 \}\par
00731                         \}\par
00732                 \}\par
00733 \par
00734                         {\cf17 constexpr} {\cf17 auto} ZE\{std::min(LE,NE)\};\par
00735                         {\cf19 for}(std::size_t k\{0\} ; k < ZE ; ++k) \{\par
00736                                 {\cf19 if} (m_dc[k+LF]!=arg.m_dc[k+NF]) \{\par
00737                                         {\cf19 return} {\cf17 true};\par
00738                                 \}\par
00739                         \}\par
00740 \par
00741                         {\cf17 constexpr} {\cf17 auto} ZF\{std::min(LF,NF)\};\par
00742                         {\cf19 for}(std::size_t k\{0\} ; k < ZF ; ++k) \{\par
00743                                 {\cf19 if} (m_dc[LF-1-k]!=arg.m_dc[NF-1-k]) \{\par
00744                                         {\cf19 return} {\cf17 true};\par
00745                                 \}\par
00746                         \}\par
00747 \par
00748                 {\cf19 if} {\cf17 constexpr} (LF<NF) \{\par
00749                         {\cf19 for}(std::size_t k\{LF-1\} ; k < NF ; ++k) \{\par
00750                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00751                                         {\cf19 return} {\cf17 true};\par
00752                                 \}\par
00753                         \}\par
00754                 \}\par
00755                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
00756                         {\cf19 for}(std::size_t k\{NF-1\} ; k < LF ; ++k) \{\par
00757                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00758                                         {\cf19 return} {\cf17 true};\par
00759                                 \}\par
00760                         \}\par
00761                 \}\par
00762 \par
00763                 {\cf19 return} {\cf17 false};\par
00764         \}\par
00765 \par
00766         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00767                 {\cf17 requires} (NE>0)\par
00768         {\cf17 constexpr} {\cf17 inline}\par
00769         {\cf18 bool} {\cf17 operator} != ({\cf17 const} pfx_rat_reg_digs_t<NE,NF>& arg) {\cf17 const}\par
00770         {\cf17 noexcept} \{\par
00771                 {\cf19 return} ((*{\cf17 this})!=arg.m_dc);\par
00772         \}\par
00773 \par
00779 \par
00780         {\cf17 template}<std::{\cf18 size_t} NE , std::{\cf18 size_t} NF>\par
00781                 {\cf17 requires} (NE>0)\par
00782         {\cf17 constexpr} {\cf17 inline}\par
00783         {\cf18 bool} {\cf17 operator} <= ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
00784         {\cf17 noexcept} \{\par
00785                 {\cf19 if} {\cf17 constexpr} (NE<LE) \{\par
00786                         {\cf19 for}(std::size_t k\{NE\} ; k < LE ; ++k) \{\par
00787                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00788                                         {\cf19 return} {\cf17 true};\par
00789                                 \}\par
00790                         \}\par
00791                 \}\par
00792                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LE<NE) \{\par
00793                         {\cf19 for}(std::size_t k\{LE\} ; k < NE ; ++k) \{\par
00794                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00795                                         {\cf19 return} {\cf17 false};\par
00796                                 \}\par
00797                         \}\par
00798                 \}\par
00799                 {\cf17 constexpr} {\cf17 auto} ZE\{std::min(LE,NE)\};\par
00800                 {\cf19 for}(std::size_t k\{0\} ; k < ZE ; ++k) \{\par
00801                                 {\cf19 if} (m_dc[k+NF]<arg.m_dc[k+LF]) \{\par
00802                                         {\cf19 return} {\cf17 true};\par
00803                                 \}\par
00804                                 {\cf19 else} {\cf19 if} (m_dc[k+NF]>arg.m_dc[k+LF]) \{\par
00805                                         {\cf19 return} {\cf17 false};\par
00806                                 \}\par
00807                 \}\par
00808                 {\cf17 constexpr} {\cf17 auto} ZF\{std::min(LF,NF)\};\par
00809                 {\cf19 for}(std::size_t k\{0\} ; k < ZF ; ++k) \{\par
00810                                 {\cf19 if} (m_dc[NF-1-k]<arg.m_dc[LF-1-k]) \{\par
00811                                         {\cf19 return} {\cf17 true};\par
00812                                 \}\par
00813                                 {\cf19 else} {\cf19 if} (m_dc[NF-1-k]>arg.m_dc[LF-1-k]) \{\par
00814                                         {\cf19 return} {\cf17 false};\par
00815                                 \}\par
00816                 \}\par
00817                 {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
00818                         {\cf19 for}(std::size_t k\{0\} ; k < LF-NF ; ++k) \{\par
00819                                 {\cf19 if} (!(arg[NF-1-k].is_0())) \{\par
00820                                         {\cf19 return} {\cf17 true};\par
00821                                 \}\par
00822                         \}\par
00823                 \}\par
00824                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LF<NF) \{\par
00825                         {\cf19 for}(std::size_t k\{0\} ; k < NF-LF ; ++k) \{\par
00826                                 {\cf19 if} (!(m_dc[LF-1-k].is_0())) \{\par
00827                                         {\cf19 return} {\cf17 false};\par
00828                                 \}\par
00829                         \}\par
00830                 \}\par
00831                 {\cf19 return} {\cf17 true};\par
00832         \}\par
00833 \par
00834         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00835                 {\cf17 requires} (NE>0)\par
00836         {\cf17 constexpr} {\cf17 inline}\par
00837         {\cf18 bool} {\cf17 operator} <= ({\cf17 const} pfx_rat_reg_digs_t<NE,NF>& arg) {\cf17 const}\par
00838         {\cf17 noexcept} \{\par
00839                 {\cf19 return} ((*{\cf17 this})<=arg.m_dc);\par
00840         \}\par
00841 \par
00847 \par
00848         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00849                 {\cf17 requires} (NE>0)\par
00850         {\cf17 constexpr} {\cf17 inline}\par
00851         {\cf18 bool} {\cf17 operator} >= ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
00852         {\cf17 noexcept} \{\par
00853                 {\cf19 if} {\cf17 constexpr} (NE>LE) \{\par
00854                         {\cf19 for}(std::size_t k\{LE\} ; k < NE ; ++k) \{\par
00855                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00856                                         {\cf19 return} {\cf17 false};\par
00857                                 \}\par
00858                         \}\par
00859                 \}\par
00860                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LE>NE) \{\par
00861                         {\cf19 for}(std::size_t k\{NE\} ; k < LE ; ++k) \{\par
00862                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00863                                         {\cf19 return} {\cf17 true};\par
00864                                 \}\par
00865                         \}\par
00866                 \}\par
00867                 {\cf17 constexpr} {\cf17 auto} ZE\{std::min(LE,NE)\};\par
00868                 {\cf19 for}(std::int64_t k\{ZE-1\} ; k > -1 ; --k) \{\par
00869                                 {\cf19 if} (m_dc[k+LF]>arg.m_dc[k+NF]) \{\par
00870                                         {\cf19 return} {\cf17 true};\par
00871                                 \}\par
00872                                 {\cf19 else} {\cf19 if} (m_dc[k+LF]<arg.m_dc[k+NF]) \{\par
00873                                         {\cf19 return} {\cf17 false};\par
00874                                 \}\par
00875                 \}\par
00876                 {\cf17 constexpr} {\cf17 auto} ZF\{std::min(LF,NF)\};\par
00877                 {\cf19 for}(std::int64_t k\{ZF-1\} ; k > -1 ; --k) \{\par
00878                                 {\cf19 if} (m_dc[LF-1-k]>arg.m_dc[NF-1-k]) \{\par
00879                                         {\cf19 return} {\cf17 true};\par
00880                                 \}\par
00881                                 {\cf19 else} {\cf19 if} (m_dc[LF-1-k]<arg.m_dc[NF-1-k]) \{\par
00882                                         {\cf19 return} {\cf17 false};\par
00883                                 \}\par
00884                 \}\par
00885                 {\cf19 if} {\cf17 constexpr} (LF<NF) \{\par
00886                         {\cf19 for}(std::size_t k\{0\} ; k < NF-LF ; ++k) \{\par
00887                                 {\cf19 if} (!(arg[NF-1-k].is_0())) \{\par
00888                                         {\cf19 return} {\cf17 false};\par
00889                                 \}\par
00890                         \}\par
00891                 \}\par
00892                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
00893                         {\cf19 for}(std::size_t k\{0\} ; k < LF-NF ; ++k) \{\par
00894                                 {\cf19 if} (!(m_dc[LF-1-k].is_0())) \{\par
00895                                         {\cf19 return} {\cf17 true};\par
00896                                 \}\par
00897                         \}\par
00898                 \}\par
00899                 {\cf19 return} {\cf17 true};\par
00900         \}\par
00901 \par
00902         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00903                 {\cf17 requires} (NE>0)\par
00904         {\cf17 constexpr} {\cf17 inline}\par
00905         {\cf18 bool} {\cf17 operator} >= ({\cf17 const} pfx_rat_reg_digs_t<NE,NF>& arg) {\cf17 const}\par
00906         {\cf17 noexcept} \{\par
00907                 {\cf19 return} ((*{\cf17 this})>=arg.m_dc);\par
00908         \}\par
00909 \par
00915 \par
00916         {\cf17 template}<std::{\cf18 size_t} NE , std::{\cf18 size_t} NF>\par
00917                 {\cf17 requires} (NE>0)\par
00918         {\cf17 constexpr} {\cf17 inline}\par
00919         {\cf18 bool} {\cf17 operator} < ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
00920         {\cf17 noexcept} \{\par
00921                 {\cf19 if} {\cf17 constexpr} (NE<LE) \{\par
00922                         {\cf19 for}(std::size_t k\{NE\} ; k < LE ; ++k) \{\par
00923                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00924                                         {\cf19 return} {\cf17 true};\par
00925                                 \}\par
00926                         \}\par
00927                 \}\par
00928                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LE<NE) \{\par
00929                         {\cf19 for}(std::size_t k\{LE\} ; k < NE ; ++k) \{\par
00930                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00931                                         {\cf19 return} {\cf17 false};\par
00932                                 \}\par
00933                         \}\par
00934                 \}\par
00935                 {\cf17 constexpr} {\cf17 auto} ZE\{std::min(LE,NE)\};\par
00936                 {\cf19 for}(std::size_t k\{0\} ; k < ZE ; ++k) \{\par
00937                                 {\cf19 if} (m_dc[k+NF]<arg.m_dc[k+LF]) \{\par
00938                                         {\cf19 return} {\cf17 true};\par
00939                                 \}\par
00940                                 {\cf19 else} {\cf19 if} (m_dc[k+NF]>arg.m_dc[k+LF]) \{\par
00941                                         {\cf19 return} {\cf17 false};\par
00942                                 \}\par
00943                 \}\par
00944                 {\cf17 constexpr} {\cf17 auto} ZF\{std::min(LF,NF)\};\par
00945                 {\cf19 for}(std::size_t k\{0\} ; k < ZF ; ++k) \{\par
00946                                 {\cf19 if} (m_dc[NF-1-k]<arg.m_dc[LF-1-k]) \{\par
00947                                         {\cf19 return} {\cf17 true};\par
00948                                 \}\par
00949                                 {\cf19 else} {\cf19 if} (m_dc[NF-1-k]>arg.m_dc[LF-1-k]) \{\par
00950                                         {\cf19 return} {\cf17 false};\par
00951                                 \}\par
00952                 \}\par
00953                 {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
00954                         {\cf19 for}(std::size_t k\{0\} ; k < LF-NF ; ++k) \{\par
00955                                 {\cf19 if} (!(arg[NF-1-k].is_0())) \{\par
00956                                         {\cf19 return} {\cf17 true};\par
00957                                 \}\par
00958                         \}\par
00959                 \}\par
00960                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LF<NF) \{\par
00961                         {\cf19 for}(std::size_t k\{0\} ; k < NF-LF ; ++k) \{\par
00962                                 {\cf19 if} (!(m_dc[LF-1-k].is_0())) \{\par
00963                                         {\cf19 return} {\cf17 false};\par
00964                                 \}\par
00965                         \}\par
00966                 \}\par
00967                 {\cf19 return} {\cf17 false};\par
00968         \}\par
00969 \par
00970         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00971                 {\cf17 requires} (NE>0)\par
00972         {\cf17 constexpr} {\cf17 inline}\par
00973         {\cf18 bool} {\cf17 operator} < ({\cf17 const} pfx_rat_reg_digs_t<NE,NF>& arg) {\cf17 const}\par
00974         {\cf17 noexcept} \{\par
00975                 {\cf19 return} ((*{\cf17 this})<arg.m_dc);\par
00976         \}\par
00977 \par
00983 \par
00984         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
00985                 {\cf17 requires} (NE>0)\par
00986         {\cf17 constexpr} {\cf17 inline}\par
00987         {\cf18 bool} {\cf17 operator} > ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
00988         {\cf17 noexcept} \{\par
00989                 {\cf19 if} {\cf17 constexpr} (NE>LE) \{\par
00990                         {\cf19 for}(std::size_t k\{LE\} ; k < NE ; ++k) \{\par
00991                                 {\cf19 if} (!(arg[k+NF].is_0())) \{\par
00992                                         {\cf19 return} {\cf17 false};\par
00993                                 \}\par
00994                         \}\par
00995                 \}\par
00996                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (LE>NE) \{\par
00997                         {\cf19 for}(std::size_t k\{NE\} ; k < LE ; ++k) \{\par
00998                                 {\cf19 if} (!(m_dc[k+LF].is_0())) \{\par
00999                                         {\cf19 return} {\cf17 true};\par
01000                                 \}\par
01001                         \}\par
01002                 \}\par
01003                 {\cf17 constexpr} {\cf17 auto} ZE\{std::min(LE,NE)\};\par
01004                 {\cf19 for}(std::int64_t k\{ZE-1\} ; k > -1 ; --k) \{\par
01005                                 {\cf19 if} (m_dc[k+LF]>arg.m_dc[k+NF]) \{\par
01006                                         {\cf19 return} {\cf17 true};\par
01007                                 \}\par
01008                                 {\cf19 else} {\cf19 if} (m_dc[k+LF]<arg.m_dc[k+NF]) \{\par
01009                                         {\cf19 return} {\cf17 false};\par
01010                                 \}\par
01011                 \}\par
01012                 {\cf17 constexpr} {\cf17 auto} ZF\{std::min(LF,NF)\};\par
01013                 {\cf19 for}(std::int64_t k\{ZF-1\} ; k > -1 ; --k) \{\par
01014                                 {\cf19 if} (m_dc[LF-1-k]>arg.m_dc[NF-1-k]) \{\par
01015                                         {\cf19 return} {\cf17 true};\par
01016                                 \}\par
01017                                 {\cf19 else} {\cf19 if} (m_dc[LF-1-k]<arg.m_dc[NF-1-k]) \{\par
01018                                         {\cf19 return} {\cf17 false};\par
01019                                 \}\par
01020                 \}\par
01021                 {\cf19 if} {\cf17 constexpr} (LF<NF) \{\par
01022                         {\cf19 for}(std::size_t k\{0\} ; k < NF-LF ; ++k) \{\par
01023                                 {\cf19 if} (!(arg[NF-1-k].is_0())) \{\par
01024                                         {\cf19 return} {\cf17 false};\par
01025                                 \}\par
01026                         \}\par
01027                 \}\par
01028                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (NF<LF) \{\par
01029                         {\cf19 for}(std::size_t k\{0\} ; k < LF-NF ; ++k) \{\par
01030                                 {\cf19 if} (!(m_dc[LF-1-k].is_0())) \{\par
01031                                         {\cf19 return} {\cf17 true};\par
01032                                 \}\par
01033                         \}\par
01034                 \}\par
01035                 {\cf19 return} {\cf17 false};\par
01036         \}\par
01037 \par
01041         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
01042                 {\cf17 requires} (NE>0)\par
01043         {\cf17 constexpr} {\cf17 inline}\par
01044         std::weak_ordering operator <=> ({\cf17 const} nat_reg_NExNF_digs_t<NE,NF>& arg) {\cf17 const}\par
01045         {\cf17 noexcept} \{\par
01046                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
01047                 {\cf19 if} (cthis > arg)\par
01048                         {\cf19 return} std::weak_ordering::greater;\par
01049                 {\cf19 else} {\cf19 if} (cthis < arg)\par
01050                         {\cf19 return} std::weak_ordering::less;\par
01051                 {\cf19 else}\par
01052                         {\cf19 return} std::weak_ordering::equivalent;\par
01053         \}\par
01054 \par
01055         {\cf17 template}<std::{\cf18 size_t} NE,std::{\cf18 size_t} NF>\par
01056                 {\cf17 requires} (NE>0)\par
01057         {\cf17 constexpr} {\cf17 inline}\par
01058         std::strong_ordering operator <=> ({\cf17 const} pfx_rat_reg_digs_t<NE,NF> & arg) {\cf17 const}\par
01059         {\cf17 noexcept} \{\par
01060                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
01061                 {\cf19 if} (cthis > arg)\par
01062                         {\cf19 return} std::strong_ordering::greater;\par
01063                 {\cf19 else} {\cf19 if} (cthis < arg)\par
01064                         {\cf19 return} std::strong_ordering::less;\par
01065                 {\cf19 else}\par
01066                         {\cf19 return} std::strong_ordering::equal;\par
01067         \}\par
01068 \par
01069 {\cf20                                 /************************************/}\par
01070                                 {\cf20 /*                                                                                                                              */}\par
01071                                 {\cf20 /*                PRIMER DIGITO DESDE MSB                       */}\par
01072                                 {\cf20 /*                SEGUNDO DIGITO                                                        */}\par
01073                                 {\cf20 /*                                                                                                                              */}\par
01074 {\cf20                                 /************************************/}\par
01075 \par
01088         {\cf17 template}<std::{\cf18 int}32_t I>\par
01089                 {\cf17 requires} ((I < LE)&&(std::abs(I) < LF+1))\par
01090         {\cf17 inline} {\cf17 constexpr} {\cf17 const} dig_t& get() const noexcept \{\par
01091                 {\cf19 return} (m_dc[I+LF]);\par
01092         \}\par
01093 \par
01096         {\cf17 template}<std::{\cf18 int}32_t I>\par
01097                 {\cf17 requires} ((I < LE)&&(std::abs(I) < LF+1))\par
01098         {\cf17 inline} {\cf17 constexpr} {\cf18 void} put({\cf17 const} dig_t & arg) {\cf17 noexcept} \{\par
01099                 m_dc[I+LF] = arg; {\cf19 return};\par
01100         \}\par
01101 \par
01102         {\cf17 template}<std::{\cf18 int}32_t I>\par
01103                 {\cf17 requires} ((I < LE)&&(std::abs(I) < LF+1))\par
01104         {\cf17 inline} {\cf17 constexpr} {\cf18 void} put(dig_t && arg) {\cf17 noexcept} \{\par
01105                 m_dc[I+LF] = std::move(arg); {\cf19 return};\par
01106         \}\par
01107 \par
01108         {\cf17 inline} {\cf17 constexpr} {\cf17 const} dig_t & operator[](std::int32_t idx) {\cf17 const} {\cf17 noexcept} \{\par
01109                 {\cf19 if} ((idx < LE)&&(std::abs(idx) < LF+1))\par
01110                         {\cf19 return} (m_dc[idx+LF]);\par
01111                 {\cf19 else}\par
01112                         {\cf19 return} dig_0();\par
01113         \}\par
01114 \par
01115         {\cf17 inline} {\cf17 constexpr} dig_t & operator[](std::int32_t idx) {\cf17 noexcept} \{\par
01116                 {\cf19 if} ((idx < LE)&&(std::abs(idx) < LF+1))\par
01117                         {\cf19 return} (m_dc[idx+LF]);\par
01118                 {\cf19 else}\par
01119                         {\cf19 return} dig_0();\par
01120         \}\par
01121 \par
01122         {\cf17 inline} {\cf17 constexpr} UINT_T operator()(std::int32_t idx) {\cf17 const} {\cf17 noexcept} \{\par
01123                 {\cf19 return} (m_dc[idx]());\par
01124         \}\par
01125 \par
01126 {\cf20                                                         /****************************/}\par
01127                                                         {\cf20 /*                                                                                                      */}\par
01128                                                         {\cf20 /* OPERADORES ARITMETICOS               */}\par
01129                                                         {\cf20 /*      POSTINCREMENTO ++(int)  */}\par
01130                                                         {\cf20 /*      PREINCREMENTO ++()                */}\par
01131                                                         {\cf20 /*      POSTDECREMENTO --(int)  */}\par
01132                                                         {\cf20 /*      PREDECREMENTO ++()                */}\par
01133                                                         {\cf20 /*                          */}\par
01134 {\cf20                                                         /****************************/}\par
01135 \par
01136         {\cf17 constexpr} {\cf17 inline}\par
01137         {\cf17 const} pfx_rat_reg_digs_t & operator ++ ()\par
01138         noexcept \{\par
01139                 pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
01141                 dig_t carry\{dig_1()\};\par
01143                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF-1 ; ++ix) \{\par
01144                         {\cf19 if} ((m_dc[ix]==dig_Bm1())&&(carry == dig_1())) \{\par
01145                                 m_dc[ix]=dig_0();\par
01146                                 carry = dig_1();\par
01147                         \}\par
01148                         {\cf19 else} {\cf19 if} ((cthis.m_dc[ix]<dig_Bm1())&&(carry == dig_1()))\{\par
01149                                 {\cf19 if} (carry != dig_0()) \{\par
01150                                         ++m_dc[ix];\par
01151                                         {\cf19 break};\par
01152                                 \}\par
01153                         \}\par
01154                 \}\par
01155                 {\cf19 return} cthis;\par
01156         \}\par
01157 \par
01158         {\cf17 constexpr} {\cf17 inline}\par
01159         pfx_rat_reg_digs_t operator ++ ({\cf18 int})\par
01160         {\cf17 noexcept} \{\par
01161                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01162                 ++(*this);\par
01163                 {\cf19 return} cpthis;\par
01164         \}\par
01165 \par
01166         {\cf17 constexpr} {\cf17 inline}\par
01167         {\cf17 const} pfx_rat_reg_digs_t & operator -- ()\par
01168         noexcept \{\par
01169                 pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
01171                 dig_t carry\{dig_0()\};\par
01173                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF-1 ; ++ix) \{\par
01174                                 SIG_UINT_T temp\{cthis(ix)+B-1+carry()\};\par
01175                                 m_dc[ix]=dig_t(temp);\par
01176                                 carry = dig_t(temp/B);\par
01177                 \}\par
01178                 {\cf19 return} cthis;\par
01179         \}\par
01180 \par
01181         {\cf17 constexpr} {\cf17 inline}\par
01182         pfx_rat_reg_digs_t operator -- ({\cf18 int})\par
01183         {\cf17 noexcept} \{\par
01184                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01185                 --(*this);\par
01186                 {\cf19 return} cpthis;\par
01187         \}\par
01188 \par
01189 {\cf20                                                                 /****************************/}\par
01190                                                                 {\cf20 /*                                                                                                      */}\par
01191                                                                 {\cf20 /* OPERADORES ARITMETICOS               */}\par
01192                                                                 {\cf20 /*       C_B()  C_Bm1()                                 */}\par
01193                                                                 {\cf20 /*      mC_B() mC_Bm1()               */}\par
01194                                                                 {\cf20 /*      operator-() operator!() */}\par
01195                                                                 {\cf20 /*                          */}\par
01196 {\cf20                                                                 /****************************/}\par
01197 \par
01198         {\cf17 constexpr} {\cf17 inline}\par
01199         {\cf17 const} pfx_rat_reg_digs_t & mC_Bm1()\par
01200         noexcept \{\par
01201                 pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
01202                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF-1 ; ++ix) \{\par
01203                                 m_dc[ix] = !m_dc[ix];\par
01204                 \}\par
01205                 {\cf19 return} cthis;\par
01206         \}\par
01207 \par
01208         {\cf17 constexpr} {\cf17 inline}\par
01209         {\cf17 const} pfx_rat_reg_digs_t & mC_B()\par
01210         noexcept \{\par
01211                 pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
01212                 cthis.mC_Bm1();\par
01213                 dig_t carry\{dig_1()\};\par
01215                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF-1 ; ++ix) \{\par
01216                         {\cf19 if} ((m_dc[ix]==dig_Bm1())&&(carry != dig_1())) \{\par
01217                                 m_dc[ix]=dig_0();\par
01218                                 carry = dig_1();\par
01219                         \}\par
01220                         {\cf19 else} {\cf19 if} (carry == dig_1())\{\par
01221                                 ++m_dc[ix];\par
01222                                 {\cf19 break};\par
01223                         \}\par
01224                 \}\par
01225                 {\cf19 return} (cthis);\par
01226         \}\par
01227 \par
01228         {\cf17 constexpr} {\cf17 inline}\par
01229         pfx_rat_reg_digs_t C_Bm1() const\par
01230         noexcept\par
01231         \{\par
01232                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01233                 cpthis.mC_Bm1();\par
01234                 {\cf19 return} cpthis;\par
01235         \}\par
01236 \par
01237         {\cf17 constexpr} {\cf17 inline}\par
01238         pfx_rat_reg_digs_t C_B() const\par
01239         noexcept \{\par
01240                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01241                 cpthis.mC_B();\par
01242                 {\cf19 return} cpthis;\par
01243         \}\par
01244 \par
01245         {\cf17 constexpr} {\cf17 inline}\par
01246         pfx_rat_reg_digs_t operator ! () const\par
01247         noexcept \{\par
01248                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01249                 cpthis.mC_Bm1();\par
01250                 {\cf19 return} cpthis;\par
01251         \}\par
01252 \par
01253         {\cf17 constexpr} {\cf17 inline}\par
01254         pfx_rat_reg_digs_t operator - () const\par
01255         noexcept \{\par
01256                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01257                 cpthis.mC_B();\par
01258                 {\cf19 return} cpthis;\par
01259         \}\par
01260 \par
01261 {\cf20                                         /***********************************/}\par
01262                                         {\cf20 /* OPERADORES ARITMETICOS BASICOS        */}\par
01263                                         {\cf20 /*                      pfx_rat_reg_digs_t      @  dig_t                         */}\par
01264                                         {\cf20 /*      pfx_rat_reg_digs_t      @= dig_t       */}\par
01265                                         {\cf20 /*      pfx_rat_reg_digs_t  @  10B^n       */}\par
01266                                         {\cf20 /*      pfx_rat_reg_digs_t  @= 10B^n       */}\par
01267 {\cf20                                         /***********************************/}\par
01268 \par
01269 {\cf20                                         /************************************/}\par
01270                                         {\cf20 /*                                                                                                                              */}\par
01271                                         {\cf20 /*  ARITMETICOS CON ASIGNACION                  */}\par
01272                                         {\cf20 /*                       pfx_rat_reg_digs_t @= dig_t                            */}\par
01273                                         {\cf20 /*                                  */}\par
01274 {\cf20                                         /************************************/}\par
01275 \par
01276         {\cf17 constexpr} {\cf17 inline}\par
01277         {\cf17 const} pfx_rat_reg_digs_t & operator += (dig_t arg)\par
01278         {\cf17 noexcept} \{\par
01279                 pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
01281                 dig_t carry\{arg\};\par
01288                 {\cf19 if} (arg.is_0()) \{\par
01289                         {\cf19 return} (cthis);\par
01290                 \} {\cf19 else} {\cf19 if} (arg.is_1()) \{\par
01291                         {\cf19 return} (++cthis);\par
01292                 \} {\cf19 else} \{\par
01293                         {\cf17 const} dig_t dig_BmArg\{dig_Bm1()-(arg-dig_1())\};\par
01295                         {\cf19 if} (m_dc[0]==dig_BmArg) \{\par
01296                                 m_dc[0] = dig_0();\par
01297                                 carry    = dig_1();\par
01298                         \}\par
01301                         {\cf19 for}(std::size_t ix\{1\} ; ix < LE+LF-1 ; ++ix) \{\par
01302                                 {\cf19 if} (m_dc[ix]==dig_Bm1()&& !(carry.is_0())) \{\par
01303                                         m_dc[ix]=dig_0();\par
01304                                         carry = dig_1();\par
01305                                 \}\par
01306                                 {\cf19 else} {\cf19 if} ((m_dc[ix]<dig_Bm1())&&(carry == dig_1()))\{\par
01307                                         {\cf19 if} (carry != dig_0()) \{\par
01308                                                 ++m_dc[ix];\par
01309                                                 {\cf19 break};\par
01310                                         \}\par
01311                                 \}\par
01312                         \}\par
01313                         {\cf19 return} (cthis);\par
01314                 \}\par
01315         \}\par
01316 \par
01317         {\cf17 constexpr} {\cf17 inline}\par
01318         {\cf17 const} pfx_rat_reg_digs_t & operator -= (dig_t arg)\par
01319         {\cf17 noexcept} \{\par
01320                 pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
01322                 dig_t carry\{arg\};\par
01329                 {\cf19 if} (arg==dig_0()) \{\par
01330                         {\cf19 return} (cthis);\par
01331                 \} {\cf19 else} {\cf19 if} (arg == dig_1()) \{\par
01332                         {\cf19 return} (--cthis);\par
01333                 \} {\cf19 else} \{\par
01334                         {\cf17 const} dig_t dig_CBArg\{arg.C_B()\};\par
01335                         {\cf17 const} dig_t dig_sig_Arg\{dig_Bm1()\};\par
01336 \par
01338                         {\cf19 if} (m_dc[0]())+dig_CBArg()>dig_Bm1()()) \{\par
01339                                 carry = dig_1();\par
01340                         \} {\cf19 else} \{\par
01341                                 carry = dig_0();\par
01342                         \}\par
01343                         m_dc[0] += dig_CBArg;\par
01344 \par
01347                         {\cf19 for}(std::size_t ix\{1\} ; ix < LE+LF-1 ; ++ix) \{\par
01348                                 {\cf19 if} (m_dc[ix].is_0() && carry.is_0()) \{\par
01349                                         m_dc[ix]=dig_Bm1();\par
01350                                         carry = dig_0();\par
01351                                 \}\par
01352                                 {\cf19 else} {\cf19 if} (m_dc[ix].is_0() && !carry.is_0()) \{\par
01353                                         m_dc[ix]=dig_0();\par
01354                                         carry = dig_1();\par
01355                                 \}\par
01356                                 {\cf19 else} {\cf19 if} (m_dc[ix].is_1() && carry.is_0()) \{\par
01357                                         m_dc[ix]=dig_0();\par
01358                                         carry = dig_1();\par
01359                                 \}\par
01360                                 {\cf19 else} \{\par
01361                                         m_dc[ix] += dig_Bm1();\par
01362                                         m_dc[ix] += carry;\par
01363                                         carry = dig_1();\par
01364                                 \}\par
01365                         \}\par
01366                         {\cf19 return} (cthis);\par
01367                 \}\par
01368         \}\par
01369 \par
01372         {\cf17 constexpr} {\cf17 inline}\par
01373         std::array<pfx_rat_reg_digs_t,2> mult(dig_t arg) {\cf17 const}\par
01374         {\cf17 noexcept} \{\par
01375                 pfx_rat_reg_digs_t cpthis(*{\cf17 this});\par
01376                 std::array<pfx_rat_reg_digs_t,2> ret\{\};\par
01377                 {\cf19 if} (arg.is_0()) \{\par
01378                         {\cf19 for} ({\cf17 auto}& elem : ret[0].m_dc)\par
01379                                 elem = dig_0();\par
01380                         {\cf19 for} ({\cf17 auto}& elem : ret[1].m_dc)\par
01381                                 elem = dig_0();\par
01382                         {\cf19 return} ret;\par
01383                 \}\par
01384                 {\cf19 else} {\cf19 if} (arg.is_1()) \{\par
01385                         ret[0] = cpthis;\par
01386                         {\cf19 for} ({\cf17 auto}& elem : ret[1].m_dc)\par
01387                                 elem = dig_0();\par
01388                         {\cf19 return} ret;\par
01389                 \}\par
01390                 {\cf19 else} \{\par
01391                         dig_t carry\{dig_0()\};\par
01392                         {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01393                                 {\cf17 const} {\cf17 auto} res = m_dc[ix].mult(arg);\par
01394                                 {\cf17 const} {\cf17 auto} uds = res[0].add(carry);\par
01395                                 ret[0].m_dc[ix] = m_dc[ix] = uds[0] + carry;\par
01396                                 carry = res[1] + uds[1];\par
01397                         \}\par
01398                         ret[1].m_dc[0]=carry;\par
01399                         {\cf19 return} ret;\par
01400                 \}\par
01401         \}\par
01402 {\cf20 //}\par
01403 {\cf20 //      ///< TO DO REVISAR}\par
01404 {\cf20 //      /// '@' = EUCLID_DIV -> (REM,COC)}\par
01405 {\cf20 //      std::array<pfx_rat_reg_digs_t,2> full_euclid_div(dig_t dsor) \{}\par
01406 {\cf20 //              const pfx_rat_reg_digs_t & dndo\{*this\};}\par
01407 {\cf20 //              std::array<pfx_rat_reg_digs_t,2> ret\{\};}\par
01408 {\cf20 //                                              if (dsor == dig_0()) \{}\par
01409 {\cf20 //                              return ret;}\par
01410 {\cf20 //              \}}\par
01411 {\cf20 //              else    if (dsor == dig_1()) \{}\par
01412 {\cf20 //                      ret[0] = dndo;}\par
01413 {\cf20 //                      ret[1] = regd_0();}\par
01414 {\cf20 //                      return ret;}\par
01415 {\cf20 //              \}}\par
01416 {\cf20 //              else    if (dndo < regd_B()) \{}\par
01417 {\cf20 //                      ret[0] = dndo[0] / dsor;}\par
01418 {\cf20 //                      ret[1] = dndo[0] % dsor;}\par
01419 {\cf20 //                      return ret;}\par
01420 {\cf20 //              \}}\par
01421 {\cf20 //              else \{}\par
01422 {\cf20 //                      pfx_rat_reg_digs_t& coc\{ret[0]\};}\par
01423 {\cf20 //                      pfx_rat_reg_digs_t& rem\{ret[1]\};}\par
01424 {\cf20 //                      for(std::int64_t lx\{L-1\} ; lx > -1 ; --lx) \{}\par
01425 {\cf20 //                              if (dndo[lx]>=dsor) \{}\par
01426 {\cf20 //                                      coc << 1;}\par
01427 {\cf20 //                                      coc[0] = dndo[lx]/dsor;}\par
01428 {\cf20 //                                      rem[0] = dndo[lx]%dsor;}\par
01429 {\cf20 //                                      rem << 1;}\par
01430 {\cf20 //                                      rem[0] = dndo[lx-1];}\par
01431 {\cf20 //                              \}}\par
01432 {\cf20 //                              else \{}\par
01433 {\cf20 //                                      rem << 1;}\par
01434 {\cf20 //                                      rem[0] = dndo[lx-1];}\par
01435 {\cf20 //                                      for (UINT_T int_coc\{0\}; int_coc < B ; ++int_coc) \{}\par
01436 {\cf20 //                                              auto X\{dig_t(int_coc).mult(dsor)\};}\par
01437 {\cf20 //                                              reg_N_digs_t<2> prod\{X[1],X[0]\};}\par
01438 {\cf20 //                                              if (prod >= rem) \{}\par
01439 {\cf20 //                                                      rem -= prod;}\par
01440 {\cf20 //                                                      rem << 1;}\par
01441 {\cf20 //                                                      rem[0] = dndo[lx-2];}\par
01442 {\cf20 //                                                      coc << 1;}\par
01443 {\cf20 //                                                      coc[0] = dig_t(int_coc);}\par
01444 {\cf20 //                                                      break;}\par
01445 {\cf20 //                                              \}}\par
01446 {\cf20 //                                      \}}\par
01447 {\cf20 //                              \}}\par
01448 {\cf20 //                      \}}\par
01449 {\cf20 //                      return ret;}\par
01450 {\cf20 //              \}}\par
01451 {\cf20 //      \}}\par
01452 \par
01454         {\cf17 constexpr} {\cf17 inline}\par
01455         std::array<pfx_rat_reg_digs_t,2> add(dig_t arg) {\cf17 const}\par
01456         {\cf17 noexcept} \{\par
01457                 {\cf17 const} pfx_rat_reg_digs_t& cthis\{*{\cf17 this}\};\par
01458                 std::array<pfx_rat_reg_digs_t,2> result\{dig_0(),cthis\};\par
01459                 dig_t carry\{dig_0()\};\par
01460                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01461                         {\cf17 auto}    temp_result   =      result[0].m_dc[ix].add(arg);\par
01462                         {\cf17 auto}  temp_result_2 = temp_result[0].m_dc[ix].add(carry);\par
01463                         result[0].m_dc[ix] = temp_result_2[0];\par
01464                         result[1].m_dc[ix]  = temp_result_2[1];\par
01465                         carry = result[1].m_dc[0];\par
01466                 \}\par
01467                 {\cf19 for}(std::size_t ix\{1\} ; ix < LE+LF ; ++ix) \{\par
01468                         result[1].m_dc[ix] = dig_0();\par
01469                 \}\par
01470                 {\cf19 return} result;\par
01471         \}\par
01472 \par
01475         {\cf17 constexpr} {\cf17 inline}\par
01476         std::array<pfx_rat_reg_digs_t,2> subst(dig_t arg) {\cf17 const}\par
01477         {\cf17 noexcept} \{\par
01478                 {\cf17 const} pfx_rat_reg_digs_t& cthis\{*{\cf17 this}\};\par
01479                 std::array<pfx_rat_reg_digs_t,2> result\{dig_0(),cthis\};\par
01480                 pfx_rat_reg_digs_t cb_arg\{-arg\};\par
01481                 {\cf19 if} (!(arg.is_0())) \{\par
01482                         {\cf19 for}(std::size_t ix\{1\} ; ix < L ; ++ix) \{\par
01483                                 cb_arg.m_dc[ix] = dig_Bm1();\par
01484                         \}\par
01485                 \}\par
01486                 dig_t carry\{dig_0()\};\par
01487                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01488                         {\cf17 auto}    temp_result   =      result[0].m_dc[ix].add(cb_arg[ix]);\par
01489                         {\cf17 auto}  temp_result_2 =      temp_result[0].add(carry);\par
01490                         result[0].m_dc[ix]  = temp_result_2[0];\par
01491                         result[1].m_dc[ix]  = (temp_result_2[1].add(temp_result_2[1]))[0];\par
01492                         carry = result[1].m_dc[ix];\par
01493                 \}\par
01494                 {\cf19 return} result;\par
01495         \}\par
01496 \par
01497 \par
01498 {\cf20                                 /********************************/}\par
01499                                 {\cf20 /*                                                                                                                      */}\par
01500                                 {\cf20 /*    OPERADORES ARITMETICOS            */}\par
01501                                 {\cf20 /*                       pfx_rat_reg_digs_t @ dig_t     */}\par
01502                                 {\cf20 /*                                                                                                                      */}\par
01503 {\cf20                                 /********************************/}\par
01504 \par
01505         {\cf17 constexpr} {\cf17 inline}\par
01506         {\cf17 auto} operator + (dig_t arg) {\cf17 const}\par
01507         {\cf17 noexcept} \{\par
01508                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
01509                 ret += arg;\par
01510                 {\cf19 return} ret;\par
01511         \}\par
01512 \par
01513         {\cf17 constexpr} {\cf17 inline}\par
01514         {\cf17 auto} operator - (dig_t arg) {\cf17 const}\par
01515         {\cf17 noexcept} \{\par
01516                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
01517                 ret -= arg;\par
01518                 {\cf19 return} ret;\par
01519         \}\par
01520 \par
01521         {\cf17 constexpr} {\cf17 inline}\par
01522         {\cf17 auto} operator * (dig_t arg) {\cf17 const}\par
01523         {\cf17 noexcept} \{\par
01524                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
01525                 ret *= arg;\par
01526                 {\cf19 return} ret;\par
01527         \}\par
01528 \par
01529 {\cf20 //              /// "ARITHMETIC OPERATOR" : COMPLETE EUCLIDEAN DIVISION BY A DIGIT}\par
01530 {\cf20 //              constexpr inline}\par
01531 {\cf20 //              std::array<pfx_rat_reg_digs_t,2> euclid_div (dig_t arg) const}\par
01532 {\cf20 //              noexcept \{}\par
01533 {\cf20 //                      const pfx_rat_reg_digs_t& dndo\{*this\};}\par
01534 {\cf20 //                      const dig_t&      dsor\{arg\};}\par
01535 {\cf20 //                      const pfx_rat_reg_digs_t<UINT_T,B,2> tmp_dsor\{dig_0(),arg\};}\par
01536 {\cf20 //                                              pfx_rat_reg_digs_t<UINT_T,B,2> part_rem\{dig_0(),dndo[L-1]\};}\par
01537 {\cf20 //                                              pfx_rat_reg_digs_t rem\{regd_0()\};}\par
01538 {\cf20 //                                              pfx_rat_reg_digs_t coc\{regd_0()\};}\par
01539 {\cf20 //                      if (dsor == dig_0()) \{}\par
01540 {\cf20 //                              std::array<pfx_rat_reg_digs_t,2> rem_coc\{regd_0(),regd_0()\};}\par
01541 {\cf20 //                              return rem_coc;/// ERROR DIVISION BY 0}\par
01542 {\cf20 //                      \}}\par
01543 {\cf20 //                      else if (dsor == dig_1()) \{}\par
01544 {\cf20 //                              std::array<pfx_rat_reg_digs_t,2> rem_coc\{regd_0(),(*this)\};}\par
01545 {\cf20 //                              return rem_coc;}\par
01546 {\cf20 //                      \}}\par
01547 {\cf20 //                      else if ((dndo == regd_0())||(dndo == regd_1())) \{}\par
01548 {\cf20 //                              std::array<pfx_rat_reg_digs_t,2> rem_coc\{(*this),regd_0()\};}\par
01549 {\cf20 //                              return rem_coc;}\par
01550 {\cf20 //                      \}}\par
01551 {\cf20 //                      else if (dndo < regd_B()) \{}\par
01552 {\cf20 //                                      dig_t retcoc\{dndo[1]/dsor\};}\par
01553 {\cf20 //                                      dig_t retrem\{dndo[1]%dsor\};}\par
01554 {\cf20 //                                      coc[0]=retcoc;}\par
01555 {\cf20 //                                      rem[0]=retrem;}\par
01556 {\cf20 //                                      return std::make_pair(rem,coc);}\par
01557 {\cf20 //                      \}}\par
01558 {\cf20 //                      else \{}\par
01559 {\cf20 //                              pfx_rat_reg_digs_t<UINT_T,B,2> tmp_dsor\{dig_0(),arg\};}\par
01560 {\cf20 //                              std::int64_t ph_dndo\{L-1\};}\par
01561 {\cf20 //                              std::int64_t pl_dndo\{L-1\};}\par
01562 {\cf20 //                              // ph_dndo >= ix >= pl_dndo}\par
01563 {\cf20 //                              while((ph_dndo>-1)&&(pl_dndo>-1)) \{}\par
01564 {\cf20 //                                      if (pl_dndo == L-1) \{}\par
01565 {\cf20 //                                              part_rem[1] = dig_0();}\par
01566 {\cf20 //                                              part_rem[0] = dndo[L-1];}\par
01567 {\cf20 //                                      \}}\par
01568 {\cf20 //                                      else if ((pl_dndo == 0)&&(ph_dndo == 1)) \{}\par
01569 {\cf20 //                                              part_rem[1] = dndo[1];}\par
01570 {\cf20 //                                              part_rem[0] = dndo[0];}\par
01571 {\cf20 //                                      \}}\par
01572 {\cf20 //                                      else if ((pl_dndo == 0)&&(ph_dndo == 0)) \{}\par
01573 {\cf20 //                                              part_rem[1] = dig_0();}\par
01574 {\cf20 //                                              part_rem[0] = dndo[0];}\par
01575 {\cf20 //                                      \}}\par
01576 {\cf20 //                                      else if (ph_dndo > pl_dndo) \{}\par
01577 {\cf20 //                                              part_rem[1] = dndo[ph_dndo];}\par
01578 {\cf20 //                                              part_rem[0] = dndo[pl_dndo];}\par
01579 {\cf20 //                                      \}}\par
01580 {\cf20 //                                      else \{}\par
01581 {\cf20 //                                              part_rem[1] = dig_0();}\par
01582 {\cf20 //                                              part_rem[0] = dndo[pl_dndo];}\par
01583 {\cf20 //                                      \}}\par
01584 {\cf20 //}\par
01585 {\cf20 //                                      coc << 1;}\par
01586 {\cf20 //                                      if (part_rem>=tmp_dsor) \{}\par
01587 {\cf20 //                                              dig_t cocdig\{dig_0()\};}\par
01588 {\cf20 //                                              while(part_rem>=tmp_dsor) \{}\par
01589 {\cf20 //                                                      ++cocdig;}\par
01590 {\cf20 //                                                      part_rem -= tmp_dsor;}\par
01591 {\cf20 //                                              \}}\par
01592 {\cf20 //                                              coc |= cocdig;}\par
01593 {\cf20 //                                              if (ph_dndo > pl_dndo) \{}\par
01594 {\cf20 //                                                      --ph_dndo;}\par
01595 {\cf20 //                                                      --pl_dndo;}\par
01596 {\cf20 //                                              \}}\par
01597 {\cf20 //                                              else \{}\par
01598 {\cf20 //                                                      --pl_dndo;}\par
01599 {\cf20 //                                              \}}\par
01600 {\cf20 //                                      \}}\par
01601 {\cf20 //                                      else \{}\par
01602 {\cf20 //                                              if (ph_dndo > pl_dndo) \{}\par
01603 {\cf20 //                                                      --ph_dndo;}\par
01604 {\cf20 //                                                      --pl_dndo;}\par
01605 {\cf20 //                                              \}}\par
01606 {\cf20 //                                              else \{}\par
01607 {\cf20 //                                                      --pl_dndo;}\par
01608 {\cf20 //                                              \}}\par
01609 {\cf20 //                                      \}}\par
01610 {\cf20 //                              \}}\par
01611 {\cf20 //                              rem[1]=part_rem[1];}\par
01612 {\cf20 //                              rem[0]=part_rem[0];}\par
01613 {\cf20 //                              std::array<pfx_rat_reg_digs_t,2> rem_coc\{std::make_pair(rem,coc)\};}\par
01614 {\cf20 //                              return rem_coc;}\par
01615 {\cf20 //                      \}}\par
01616 {\cf20 //              \}}\par
01617 {\cf20 //              /// DIVISION BY A DIGIT}\par
01618 {\cf20 //              constexpr inline}\par
01619 {\cf20 //              pfx_rat_reg_digs_t operator / (dig_t arg) const}\par
01620 {\cf20 //              noexcept \{}\par
01621 {\cf20 //                      return (this->euclid_div(arg))[0];}\par
01622 {\cf20 //              \}}\par
01623 {\cf20 //              /// REMAINDER BY A DIGIT}\par
01624 {\cf20 //              constexpr inline}\par
01625 {\cf20 //              pfx_rat_reg_digs_t operator % (dig_t arg) const}\par
01626 {\cf20 //              noexcept \{}\par
01627 {\cf20 //                      return (this->euclid_div(arg))[1];}\par
01628 {\cf20 //              \}}\par
01631 {\cf20 }        {\cf17 constexpr} {\cf17 inline}\par
01632         pfx_rat_reg_digs_t operator << (std::size_t n) {\cf17 const}\par
01633         {\cf17 noexcept} \{\par
01634                 {\cf19 if} (n<LE+LF) \{\par
01635                         pfx_rat_reg_digs_t cpthis\{*{\cf17 this}\};\par
01636                         {\cf19 for}(std::int64_t ix\{n-1\} ; ix > -1 ; --ix) \{\par
01637                                 cpthis.m_dc[ix+n] = cpthis.m_dc[ix];\par
01638                                 cpthis.m_dc[ix] = dig_0();\par
01639                         \}\par
01640                         {\cf19 return} cpthis;\par
01641                 \}\par
01642                 {\cf19 else}\par
01643                         {\cf19 return} (pfx_rat_reg_digs_t\{\});\par
01644         \}\par
01645 \par
01646         {\cf17 constexpr} {\cf17 inline}\par
01647         {\cf17 const} pfx_rat_reg_digs_t & operator <<= (std::size_t n)\par
01648         {\cf17 noexcept} \{\par
01649                 pfx_rat_reg_digs_t& cthis\{*{\cf17 this}\};\par
01650                 {\cf19 if} (n < LE+LF) \{\par
01651                         {\cf19 for}(std::int64_t ix\{n-1\} ; ix > -1 ; --ix) \{\par
01652                                 cthis.m_dc[ix+n] = cthis.m_dc[ix];\par
01653                                 cthis.m_dc[ix] = dig_0();\par
01654                         \}\par
01655                 \}\par
01656                 {\cf19 else} \{\par
01657                         cthis = (pfx_rat_reg_digs_t\{\});\par
01658                 \}\par
01659                 {\cf19 return} (*{\cf17 this});\par
01660         \}\par
01661 \par
01663         {\cf17 constexpr} {\cf17 inline}\par
01664         pfx_rat_reg_digs_t operator >> (std::size_t n) {\cf17 const}\par
01665         {\cf17 noexcept} \{\par
01666                 {\cf19 if} (n<LE+LF) \{\par
01667                         pfx_rat_reg_digs_t cpthis\{*{\cf17 this}\};\par
01668                         {\cf19 for}(std::int64_t ix\{0\} ; ix < n ; ++ix) \{\par
01669                                 cpthis.m_dc[ix] = cpthis.m_dc[ix+n];\par
01670                                 cpthis.m_dc[ix+n] = dig_0();\par
01671                         \}\par
01672                         {\cf19 return} cpthis;\par
01673                 \}\par
01674                 {\cf19 else}\par
01675                 {\cf19 return} (pfx_rat_reg_digs_t\{\});\par
01676         \}\par
01677 \par
01678         {\cf17 constexpr} {\cf17 inline}\par
01679         {\cf17 const} pfx_rat_reg_digs_t & operator >>= (std::size_t n)\par
01680         {\cf17 noexcept} \{\par
01681                 pfx_rat_reg_digs_t& cthis\{*{\cf17 this}\};\par
01682                 {\cf19 if} (n < LE+LF) \{\par
01683                         {\cf19 for}(std::int64_t ix\{0\} ; ix < n ; ++ix) \{\par
01684                                 cthis.m_dc[ix] = cthis.m_dc[ix+n];\par
01685                                 cthis.m_dc[ix+n] = dig_0();\par
01686                         \}\par
01687                 \}\par
01688                 {\cf19 else}\par
01689                         cthis = (pfx_rat_reg_digs_t\{\});\par
01690                 {\cf19 return} (*{\cf17 this});\par
01691         \}\par
01692 \par
01694 \par
01697         {\cf17 constexpr} {\cf17 inline}\par
01698         pfx_rat_reg_digs_t rem_B(std::size_t n) {\cf17 const}\par
01699         {\cf17 noexcept} \{\par
01700                 pfx_rat_reg_digs_t ret\{regd_0()\};\par
01701                 {\cf19 if} (n < LE+LF) \{\par
01702                         {\cf19 for}(std::size_t ix\{0\} ; ix < n ; ++ix) \{\par
01703                                 ret.m_dc[ix] = m_dc[ix];\par
01704                         \}\par
01705                 \}\par
01706                 {\cf19 return} ret;\par
01707         \}\par
01708 \par
01709         {\cf17 constexpr} {\cf17 inline}\par
01710         {\cf17 const} pfx_rat_reg_digs_t & m_rem_B(std::size_t n)\par
01711         {\cf17 noexcept} \{\par
01712                 {\cf19 if} (n < LE+LF) \{\par
01713                         {\cf19 for}(std::size_t ix\{n\} ; ix < LE+LF ; ++ix) \{\par
01714                                 m_dc[ix] = dig_0();\par
01715                         \}\par
01716                 \}\par
01717                 {\cf19 else} \{\par
01718                         {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01719                                 m_dc[ix] = dig_0();\par
01720                         \}\par
01721                 \}\par
01722                 {\cf19 return} (*{\cf17 this});\par
01723         \}\par
01726 \par
01728         {\cf17 constexpr} {\cf17 inline}\par
01729         {\cf17 const} pfx_rat_reg_digs_t & operator |= ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
01730         {\cf17 noexcept} \{\par
01731                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01732                         m_dc[ix] |= arg.m_dc[ix];\par
01733                 \}\par
01734                 {\cf19 return} (*{\cf17 this});\par
01735         \}\par
01736 \par
01737         {\cf17 constexpr} {\cf17 inline}\par
01738         pfx_rat_reg_digs_t operator | ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
01739         {\cf17 noexcept} \{\par
01740                 pfx_rat_reg_digs_t ret\{*{\cf17 this}\};\par
01741                 ret |= arg;\par
01742                 {\cf19 return} ret;\par
01743         \}\par
01744 \par
01745         {\cf17 constexpr} {\cf17 inline}\par
01746         {\cf17 const} pfx_rat_reg_digs_t & operator &= ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
01747         {\cf17 noexcept} \{\par
01748                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01749                         m_dc[ix] &= arg.m_dc[ix];\par
01750                 \}\par
01751                 {\cf19 return} (*{\cf17 this});\par
01752         \}\par
01753 \par
01754         {\cf17 constexpr} {\cf17 inline}\par
01755         pfx_rat_reg_digs_t operator & ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
01756         {\cf17 noexcept} \{\par
01757                 pfx_rat_reg_digs_t ret\{*{\cf17 this}\};\par
01758                 ret &= arg;\par
01759                 {\cf19 return} ret;\par
01760         \}\par
01761 \par
01763 \par
01764 {\cf20                                                                 /***********************************/}\par
01765                                                                 {\cf20 /*                                                                                                                       */}\par
01766                                                                 {\cf20 /* OPERADORES ARITMETICOS                                */}\par
01767                                                                 {\cf20 /* pfx_rat_reg_digs_t @ pfx_rat_reg_digs_t */}\par
01768                                                                 {\cf20 /*                                       */}\par
01769 {\cf20                                                                 /***********************************/}\par
01770 \par
01771         {\cf17 constexpr} {\cf17 inline}\par
01772         std::pair<dig_t,pfx_rat_reg_digs_t> operator + ({\cf17 const} pfx_rat_reg_digs_t & arg) {\cf17 const}\par
01773         {\cf17 noexcept} \{\par
01774                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
01776                 UINT_T carry\{0\};\par
01778                 reg_ints_t<LE+LF> retints\{\};\par
01779                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01780                         retints[ix] = ret(ix);\par
01781                 \}\par
01783                 reg_ints_t<LE+LF> argints\{\};\par
01784                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01785                         argints[ix] = arg(ix);\par
01786                 \}\par
01788                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF-1 ; ++ix) \{\par
01789                         retints[ix] += (argints[ix]+carry);\par
01790                         carry = retints[ix]/B;\par
01791                         ret.m_dc[ix] = dig_t(retints[ix]);\par
01792                 \}\par
01794                 {\cf17 auto} retpair = std::make_pair(dig_t(carry),ret);\par
01795                 {\cf19 return} ret;\par
01796         \}\par
01797 \par
01798         {\cf17 constexpr} {\cf17 inline}\par
01799         std::pair<dig_t,pfx_rat_reg_digs_t> operator - ({\cf17 const} pfx_rat_reg_digs_t & arg) {\cf17 const}\par
01800         {\cf17 noexcept} \{\par
01801                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
01803                 UINT_T carry_CB\{1\};\par
01804                 UINT_T carry_add\{0\};\par
01805 \par
01806                 reg_ints_t<LE+LF> retints\{\};\par
01807                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01808                         retints[ix] = ret(ix);\par
01809                 \}\par
01810 \par
01811                 reg_ints_t<LE+LF> argints\{\};\par
01812                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01814                         argints[ix] = (B-1)-arg(ix);\par
01815                 \}\par
01818                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01819                                 argints[ix] = argints[ix]+carry_CB;\par
01820                                 carry_CB = argints[ix]/B;\par
01821                 \}\par
01823 \par
01825                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01826                         retints[ix] += (argints[ix]+carry_add);\par
01827                         carry_add = retints[ix]/B;\par
01828                         ret.m_dc[ix] = dig_t(retints[ix]);\par
01829                 \}\par
01830                 {\cf17 auto} pairret = std::make_pair(dig_t(carry_add),ret);\par
01831                 {\cf19 return} pairret;\par
01832         \}\par
01833 \par
01834         {\cf17 constexpr} {\cf17 inline}\par
01835         std::array<pfx_rat_reg_digs_t,2> operator* ({\cf17 const} pfx_rat_reg_digs_t & arg) {\cf17 const}\par
01836         {\cf17 noexcept} \{\par
01837                 {\cf17 const} pfx_rat_reg_digs_t & cthis\{*{\cf17 this}\};\par
01839                 reg_ints_t<LE+LF> actints\{\};\par
01840                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01841                         actints[ix] = cthis(ix);\par
01842                 \}\par
01843                 reg_ints_t<LE+LF> argints\{\};\par
01844                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix)\{\par
01845                         argints[ix] = arg(ix);\par
01846                 \}\par
01847                 reg_ints_t<2*(LE+LF)> carryints\{\};\par
01848                 {\cf19 for}(std::size_t iy\{0\} ; iy < 2*(LE+LF) ; ++iy) \{\par
01849                         carryints[iy]=0;\par
01850                 \}\par
01851                 std::array<reg_suints_t<2*(LE+LF)>,LE+LF> retints\{\};\par
01852                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01853                         {\cf19 for}(std::size_t iy\{0\} ; iy < 2*(LE+LF) ; ++iy) \{\par
01854                                 retints[ix][iy]   =             0;\par
01855                         \}\par
01856                 \}\par
01858 \par
01861                 {\cf19 for}(std::size_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01862                         {\cf19 for}(std::size_t iy\{0\} ; ix+iy < 2*(LE+LF) ; ++iy) \{\par
01863                                 retints[ix][ix+iy]      =               (       {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(actints[ix])    *\par
01864                                                                                                                                                 {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(argints[iy])     )+\par
01865                                                                                                                                                 {\cf17 static_cast<}SIG_UINT_T{\cf17 >}(carryints[iy]);\par
01866                                 carryints[iy]                           =       retints[ix][ix+iy]/B;\par
01867                                 retints[ix][ix+iy]   %=         B;\par
01868                         \}\par
01869                 \}\par
01872 \par
01874                 std::array<pfx_rat_reg_digs_t,LE+LF> rets\{\};\par
01875                 {\cf19 for}(std::size_t iz\{0\} ; iz < LE+LF ; ++iz) \{\par
01876                                 rets.m_dc[iz] = pfx_rat_reg_digs_t(retints[iz]);\par
01877                 \}\par
01878                 {\cf19 for}(std::size_t iw\{1\} ; iw < LE+LF ; ++iw) \{\par
01879                                 rets.m_dc[0] += rets.m_dc[iw];\par
01880                                 {\cf20 // no hace falta que la suma sea de tamano L+1}\par
01881                 \}\par
01884                 std::array<pfx_rat_reg_digs_t,2> retpair\{\};\par
01885                 {\cf19 for}(std::size_t ix\{0\} ; ix < 2*LF ; ++ix) \{\par
01886                                 retpair[0].m_dc[ix] = rets[0].m_dc[ix];\par
01887                 \}\par
01888                 {\cf19 for}(std::size_t ix\{2*LF\} ; ix < 2*(LE+LF) ; ++ix) \{\par
01889                                 retpair[1].m_dc[ix-2*LF] = rets[0].m_dc[ix];\par
01890                 \}\par
01892                 {\cf19 return} retpair;\par
01893         \}\par
01894 \par
01895         {\cf17 constexpr} {\cf17 inline} {\cf17 static}\par
01896         std::size_t cuenta_0s_desde_IZDA({\cf17 const} reg_ints_t<LE+LF>& arg)\par
01897         {\cf17 noexcept} \{\par
01898                 std::size_t ret\{0\};\par
01899                 {\cf19 for}(std::int64_t ix\{LE+LF-1\} ; ix > -1 ; --ix) \{\par
01900                         {\cf19 if} (arg[ix]==0) \{\par
01901                                 ++ret;\par
01902                         \}\par
01903                         {\cf19 else} \{\par
01904                                 {\cf19 return} ret;\par
01905                         \}\par
01906                 \}\par
01907                 {\cf19 return} LE+LF;\par
01908         \}\par
01909 \par
01910         {\cf17 constexpr} {\cf17 inline} {\cf17 static}\par
01911         std::size_t cuenta_0s_desde_DRCHA({\cf17 const} reg_ints_t<LE+LF>& arg)\par
01912         {\cf17 noexcept} \{\par
01913                 std::size_t ret\{0\};\par
01914                 {\cf19 for}(std::int64_t ix\{0\} ; ix < LE+LF ; ++ix) \{\par
01915                         {\cf19 if} (arg[ix]==0) \{\par
01916                                 ++ret;\par
01917                         \}\par
01918                         {\cf19 else} \{\par
01919                                 {\cf19 return} ret;\par
01920                         \}\par
01921                 \}\par
01922                 {\cf19 return} LE+LF;\par
01923         \}\par
01924 \par
01925 {\cf20 //              constexpr inline}\par
01926 {\cf20 //              pfx_rat_reg_digs_t operator / (const pfx_rat_reg_digs_t & arg) const}\par
01927 {\cf20 //              noexcept \{}\par
01928 {\cf20 //                      const pfx_rat_reg_digs_t& dndo\{*this\};}\par
01929 {\cf20 //                      const pfx_rat_reg_digs_t& dsor\{arg\};}\par
01930 {\cf20 //                      const std::int64_t num_0s_IZDA_dsor\{cuenta_0s_desde_IZDA(dsor)\};}\par
01931 {\cf20 //                      const std::int64_t num_0s_IZDA_dndo\{cuenta_0s_desde_IZDA(dndo)\};}\par
01932 {\cf20 //                      const std::int64_t MSDig_dsor\{L-1-num_0s_IZDA_dsor\};}\par
01933 {\cf20 //                      const std::int64_t MSDig_dndo\{L-1-num_0s_IZDA_dndo\};}\par
01934 {\cf20 //                      pfx_rat_reg_digs_t rem\{regd_0()\};}\par
01935 {\cf20 //                      pfx_rat_reg_digs_t coc\{regd_0()\};}\par
01936 {\cf20 //                      for(std::int64_t num_loops\{0\} ;}\par
01937 {\cf20 //                                                                                      num_loops < std::abs(MSDig_dndo-MSDig_dndo)}\par
01938 {\cf20 //                                                                                                                                       ; ++num_loops)}\par
01939 {\cf20 //                      \{}\par
01940 {\cf20 //                              if (MSDig_dsor > MSDig_dndo) \{}\par
01941 {\cf20 //                                      return regd_0();}\par
01942 {\cf20 //                              \}}\par
01943 {\cf20 //                              else if (MSDig_dsor == MSDig_dndo) \{}\par
01944 {\cf20 //                                      for(std::int64_t ix\{MSDig_dsor\} ; ix > -1 ; --ix) \{}\par
01945 {\cf20 //                                                      if (dsor[ix] > dndo[ix]) \{}\par
01946 {\cf20 //                                                              return regd_0();// DEVUELVE COCIENTE := 0 Y RESTO := DNDO}\par
01947 {\cf20 //                                                      \}}\par
01948 {\cf20 //                                                      else if (dsor[ix] == dndo[ix]) \{}\par
01949 {\cf20 //                                                              if (ix == 0)}\par
01950 {\cf20 //                                                                      return regd_1();// DEVUELVE COCIENTE := 1 Y RESTO := 0}\par
01951 {\cf20 //                                                              else}\par
01952 {\cf20 //                                                                      continue;}\par
01953 {\cf20 //                                                      \}}\par
01954 {\cf20 //                                                      else \{}\par
01955 {\cf20 //                                                              pfx_rat_reg_digs_t coc\{0\};}\par
01956 {\cf20 //                                                              pfx_rat_reg_digs_t idndo\{dndo\};}\par
01957 {\cf20 //                                                              pfx_rat_reg_digs_t idsor\{dsor\};}\par
01958 {\cf20 //                                                              while (idndo >= idsor) \{}\par
01959 {\cf20 //                                                                      idndo -= idsor;}\par
01960 {\cf20 //                                                                      ++coc[0];}\par
01961 {\cf20 //                                                              \}}\par
01962 {\cf20 //                                                              return coc; // DEVUELVE COCIENTE := 000...L-1...0D}\par
01963 {\cf20 //                                                                                                              // SIENDO D EL DIGITO 0 (Y EL VALOR DE COCIENTE)}\par
01964 {\cf20 //                                                                                                              // DEVUELVE RESTO    := DNDO - DSOR * D}\par
01965 {\cf20 //                                                      \}}\par
01966 {\cf20 //                                      \}}\par
01967 {\cf20 //                              \}}\par
01968 {\cf20 //                              else if (dsor == regd_1()) \{}\par
01969 {\cf20 //                                      return (*this);// DEVUELVE COCIENTE := DNDO Y RESTO := 0}\par
01970 {\cf20 //                              \}}\par
01971 {\cf20 //                              else if (dsor == regd_0()) \{}\par
01972 {\cf20 //                                      return (*this);/// ERROR DIVISION BY 0}\par
01973 {\cf20 //                              \}}\par
01974 {\cf20 //                              else \{}\par
01975 {\cf20 //                                      std::int64_t pl_dndo\{MSDig_dsor\};}\par
01976 {\cf20 //                                      std::int64_t ph_dndo\{MSDig_dndo\};}\par
01977 {\cf20 //}\par
01978 {\cf20 //                                      // ph_dndo >= ix > pl_dndo}\par
01979 {\cf20 //                                      for(std::int64_t ix\{pl_dndo\} ; ix <= ph_dndo ; ++ix) \{}\par
01980 {\cf20 //                                              rem[ix-pl_dndo] = dndo[ix];}\par
01981 {\cf20 //                                      \}}\par
01982 {\cf20 //}\par
01983 {\cf20 //                                      if (rem == dsor) \{}\par
01984 {\cf20 //                                              return regd_1();// DEVUELVE COCIENTE:=1 Y RESTO:=0}\par
01985 {\cf20 //                                      \}}\par
01986 {\cf20 //                                      else if (rem > dsor) \{}\par
01987 {\cf20 //                                              dig_t coc_dig\{dig_0()\};}\par
01988 {\cf20 //                                              while(rem > dsor) \{}\par
01989 {\cf20 //                                                      ++coc_dig;}\par
01990 {\cf20 //                                                      rem -= dsor;}\par
01991 {\cf20 //                                              \}}\par
01992 {\cf20 //                                              coc *= regd_B();        // coc = coc * B}\par
01993 {\cf20 //                                              coc[0] = coc_dig; // coc = coc + D  ; B-1 >= D > 1}\par
01994 {\cf20 //                                              --pl_dndo;}\par
01995 {\cf20 //                                              for(std::int64_t ix\{ph_dndo\} ; ix > pl_dndo ; --ix) \{}\par
01996 {\cf20 //                                                      rem[ix-pl_dndo+1] = rem[ix-pl_dndo];}\par
01997 {\cf20 //                                              \}}\par
01998 {\cf20 //                                              rem[pl_dndo] = dndo[pl_dndo];}\par
01999 {\cf20 //                                              --ph_dndo;}\par
02000 {\cf20 //                                      \}}\par
02001 {\cf20 //                                      else \{}\par
02002 {\cf20 //                                              if (pl_dndo != 0) \{}\par
02003 {\cf20 //                                                      --pl_dndo;}\par
02004 {\cf20 //                                                      for(std::int64_t ix\{ph_dndo\} ; ix > pl_dndo ; --ix) \{}\par
02005 {\cf20 //                                                              rem[ix-pl_dndo+1] = rem[ix-pl_dndo];}\par
02006 {\cf20 //                                                      \}}\par
02007 {\cf20 //                                                      rem[pl_dndo] = dndo[pl_dndo];}\par
02008 {\cf20 //                                                      coc *= regd_B(); // coc = coc * B}\par
02009 {\cf20 //                                                      rem -= dsor;    // coc = coc + 0}\par
02010 {\cf20 //                                              \}}\par
02011 {\cf20 //                                              else \{}\par
02012 {\cf20 //                                                      return coc;// DEVOLVEMOS LO CALCULADO EN COC Y EL RESTO ES REM}\par
02013 {\cf20 //                                              \}}\par
02014 {\cf20 //                                      \}}\par
02015 {\cf20 //                              \}}\par
02016 {\cf20 //                      \}}\par
02017 {\cf20 //                      return coc;// NO SE DEBER\'CDA LLEGAR AQUI}\par
02018 {\cf20 //              \}}\par
02019 {\cf20 //}\par
02020 {\cf20 //              constexpr inline}\par
02021 {\cf20 //              pfx_rat_reg_digs_t operator % (const pfx_rat_reg_digs_t & arg) const}\par
02022 {\cf20 //              noexcept \{}\par
02023 {\cf20 //                      pfx_rat_reg_digs_t ret(*this);}\par
02024 {\cf20 //                      UINT_T retuds   = ret.m_dc[0]();}\par
02025 {\cf20 //                      UINT_T retdecs  = ret.m_dc[1]();}\par
02026 {\cf20 //                      UINT_T arguds   = arg.m_dc[0]();}\par
02027 {\cf20 //                      UINT_T argdecs  = arg.m_dc[1]();}\par
02028 {\cf20 //}\par
02029 {\cf20 //                      retuds  += (B*retdecs);}\par
02030 {\cf20 //                      arguds  += (B*argdecs);}\par
02031 {\cf20 //                      retuds  %= arguds;}\par
02032 {\cf20 //                      retdecs  = retuds;}\par
02033 {\cf20 //                      retdecs /= B;}\par
02034 {\cf20 //                      retuds  %= B;}\par
02035 {\cf20 //                      ret.m_dc[1]     = dig_t(retdecs);}\par
02036 {\cf20 //                      ret.m_dc[0]     = dig_t(retuds);}\par
02037 {\cf20 //                      return ret;}\par
02038 {\cf20 //              \}}\par
02039 \par
02040 {\cf20                                 /***********************************/}\par
02041                                 {\cf20 /*                                                                                                                       */}\par
02042                                 {\cf20 /*     OPERADORES ARITMETICOS                    */}\par
02043                                 {\cf20 /*                      pfx_rat_reg_digs_t con base_t    */}\par
02044                                 {\cf20 /*                                                                                                                               */}\par
02045 {\cf20                                 /***********************************/}\par
02046 \par
02047         {\cf17 constexpr} {\cf17 inline}\par
02048         pfx_rat_reg_digs_t operator + ({\cf17 const} base_t & arg) {\cf17 const}\par
02049         {\cf17 noexcept} \{\par
02050                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
02051                 pfx_rat_reg_digs_t narg(arg);\par
02052                 ret += narg;\par
02053                 {\cf19 return} ret;\par
02054         \}\par
02055 \par
02056         {\cf17 constexpr} {\cf17 inline}\par
02057         pfx_rat_reg_digs_t operator - ({\cf17 const} base_t & arg) {\cf17 const}\par
02058         {\cf17 noexcept} \{\par
02059                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
02060                 pfx_rat_reg_digs_t narg(arg);\par
02061                 ret -= narg;\par
02062                 {\cf19 return} ret;\par
02063         \}\par
02064 \par
02065         {\cf17 constexpr} {\cf17 inline}\par
02066         pfx_rat_reg_digs_t operator * ({\cf17 const} base_t & arg) {\cf17 const}\par
02067         {\cf17 noexcept} \{\par
02068                 pfx_rat_reg_digs_t ret(*{\cf17 this});\par
02069                 pfx_rat_reg_digs_t narg(arg);\par
02070                 ret *= narg;\par
02071                 {\cf19 return} ret;\par
02072         \}\par
02073 \par
02074 {\cf20 //              constexpr inline}\par
02075 {\cf20 //              pfx_rat_reg_digs_t operator / (const base_t & arg) const}\par
02076 {\cf20 //              noexcept \{}\par
02077 {\cf20 //                      pfx_rat_reg_digs_t ret(*this);}\par
02078 {\cf20 //                      pfx_rat_reg_digs_t narg(arg);}\par
02079 {\cf20 //                      ret /= narg;}\par
02080 {\cf20 //                      return ret;}\par
02081 {\cf20 //                      return ret;}\par
02082 {\cf20 //              \}}\par
02083 {\cf20 //}\par
02084 {\cf20 //              constexpr inline}\par
02085 {\cf20 //              pfx_rat_reg_digs_t operator % (const base_t & arg) const}\par
02086 {\cf20 //              noexcept \{}\par
02087 {\cf20 //                      pfx_rat_reg_digs_t ret(*this);}\par
02088 {\cf20 //                      pfx_rat_reg_digs_t narg(arg);}\par
02089 {\cf20 //                      ret %= narg;}\par
02090 {\cf20 //                      return ret;}\par
02091 {\cf20 //              \}}\par
02092 \par
02093 {\cf20                                 /************************************/}\par
02094                                 {\cf20 /*                                                                                                                      */}\par
02095                                 {\cf20 /*    ARITMETICOS CON ASIGNACION                */}\par
02096                                 {\cf20 /*                       pfx_rat_reg_digs_t con base_t  */}\par
02097                                 {\cf20 /*                                                                                                                                      */}\par
02098 {\cf20                                 /************************************/}\par
02099 \par
02100         {\cf17 constexpr} {\cf17 inline}\par
02101         {\cf17 const} pfx_rat_reg_digs_t & operator += ({\cf17 const} base_t & arg)\par
02102         {\cf17 noexcept} \{\par
02103                                         pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
02104                 {\cf17 const} pfx_rat_reg_digs_t        narg(arg);\par
02105                 cthis += narg;\par
02106                 {\cf19 return} (cthis);\par
02107         \}\par
02108 \par
02109         {\cf17 constexpr} {\cf17 inline}\par
02110         {\cf17 const} pfx_rat_reg_digs_t & operator -= ({\cf17 const} base_t & arg)\par
02111         {\cf17 noexcept} \{\par
02112                                         pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
02113                 {\cf17 const} pfx_rat_reg_digs_t        narg(arg);\par
02114                 cthis -= narg;\par
02115                 {\cf19 return} (cthis);\par
02116         \}\par
02117 \par
02118         {\cf17 constexpr} {\cf17 inline}\par
02119         {\cf17 const} pfx_rat_reg_digs_t & operator *= ({\cf17 const} base_t & arg)\par
02120         {\cf17 noexcept} \{\par
02121                                         pfx_rat_reg_digs_t& cthis(*{\cf17 this});\par
02122                 {\cf17 const} pfx_rat_reg_digs_t        narg(arg);\par
02123                 cthis *= narg;\par
02124                 {\cf19 return} (cthis);\par
02125         \}\par
02126 \par
02127         {\cf17 constexpr} {\cf17 inline}\par
02128         {\cf17 const} pfx_rat_reg_digs_t & operator += ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
02129         {\cf17 noexcept} \{\par
02130                 (*this)+=arg.m_dc;\par
02131                 {\cf19 return} (*{\cf17 this});\par
02132         \}\par
02133 \par
02134         {\cf17 constexpr} {\cf17 inline}\par
02135         {\cf17 const} pfx_rat_reg_digs_t & operator -= ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
02136         {\cf17 noexcept} \{\par
02137                 (*this)-=arg.m_dc;\par
02138                 {\cf19 return} (*{\cf17 this});\par
02139         \}\par
02140 \par
02141         {\cf17 constexpr} {\cf17 inline}\par
02142         {\cf17 const} pfx_rat_reg_digs_t & operator *= ({\cf17 const} pfx_rat_reg_digs_t & arg)\par
02143         {\cf17 noexcept} \{\par
02144                 (*this)*=arg.m_dc;\par
02145                 {\cf19 return} (*{\cf17 this});\par
02146         \}\par
02147 \par
02148 {\cf20 //      constexpr inline}\par
02149 {\cf20 //      const pfx_rat_reg_digs_t & operator /= (const pfx_rat_reg_digs_t & arg)}\par
02150 {\cf20 //      noexcept \{}\par
02151 {\cf20 //              pfx_rat_reg_digs_t & ret = (*this);}\par
02152 {\cf20 //              /// TO DO}\par
02153 {\cf20 //              return (*this);}\par
02154 {\cf20 //      \}}\par
02155 {\cf20 //}\par
02156 {\cf20 //      constexpr inline}\par
02157 {\cf20 //      const pfx_rat_reg_digs_t & operator %= (const pfx_rat_reg_digs_t & arg)}\par
02158 {\cf20 //      noexcept \{}\par
02159 {\cf20 //              pfx_rat_reg_digs_t & cthis\{*this\};}\par
02160 {\cf20 //              /// TO DO}\par
02161 {\cf20 //              return (*this);}\par
02162 {\cf20 //      \}}\par
02163 \};\par
02164 \par
02165 \par
02166 {\cf20                                         /****************************/}\par
02167                                         {\cf20 /*                                                                                                      */}\par
02168                                         {\cf20 /*         ISTREAM Y OSTREAM            */}\par
02169                                         {\cf20 /*                                                                                                      */}\par
02170 {\cf20                                         /****************************/}\par
02171 \par
02172         {\cf17 template}<type_traits::allowable_base_type_c Int_Type,\par
02173                                         Int_Type Base,\par
02174                                         std::size_t Length>\par
02175                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))\par
02176         std::istream &\par
02177         operator >> (std::istream & is,pfx_rat_reg_digs_t<Int_Type,Base,Length> & arg) \{\par
02178                 {\cf17 enum} estado_e \{\par
02179                         e0ini   , e1r           , e1e           , e1g                   , e1sep         ,\par
02180                         e1d             , e1i           , e2g           , e2start       , e2dig         ,\par
02181                         e2dp    , e2end , e2B           , e3dig         , e0fin\par
02182                 \};\par
02184                 std::string sds;\par
02186                 {\cf17 using }inttype = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
02187                 {\cf17 using }dig_t = dig_t<Int_Type,Base>;\par
02188                 {\cf17 using }pfx_rat_reg_digs_t = pfx_rat_reg_digs_t<Int_Type,Base,Length>;\par
02190                 std::size_t     indice\{0\};\par
02192                 Int_Type                digito\{0\};\par
02193                 std::size_t longitud\{0\};\par
02194                 inttype                 numero_base_recogido\{0\};\par
02196                 pfx_rat_reg_digs_t& numero_ret\{arg\};\par
02198                 estado_e est_act = e0ini;\par
02200                 {\cf18 char} c\{{\cf23 '\\0'}\};\par
02202                 is >> sds;\par
02204                 {\cf19 do} \{\par
02205                         c = sds[indice];\par
02206                         {\cf19 switch}(est_act) \{\par
02207                                 {\cf19 case} e0ini :\par
02208                                         \{\par
02209                                                 {\cf19 if} (c=={\cf23 'r'}) \{\par
02210                                                         est_act = e1r;\par
02211                                                 \} {\cf19 else} \{\par
02212                                                         est_act = e0ini;\par
02213                                                 \}\par
02214                                         \}\par
02215                                         {\cf19 break};\par
02216                                 {\cf19 case} e1r :\par
02217                                         \{\par
02218                                                 \{\par
02219                                                         {\cf19 if} (c=={\cf23 'e'}) \{\par
02220                                                                 est_act = e1e;\par
02221                                                         \}\par
02222                                                         {\cf19 else} \{\par
02223                                                                 est_act = e0ini;\par
02224                                                         \}\par
02225                                                 \}\par
02226                                         \}\par
02227                                         {\cf19 break};\par
02228                                 {\cf19 case} e1e :\par
02229                                         \{\par
02230                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
02231                                                         est_act = e1g;\par
02232                                                 \}\par
02233                                                 {\cf19 else}  \{\par
02234                                                         est_act = e0ini;\par
02235                                                 \}\par
02236                                         \}\par
02237                                         {\cf19 break};\par
02238                                 {\cf19 case} e1g :\par
02239                                         \{\par
02240                                                 {\cf19 if} (c=={\cf23 '_'}) \{\par
02241                                                         est_act = e1sep;\par
02242                                                 \}\par
02243                                                 {\cf19 else}  \{\par
02244                                                         est_act = e0ini;\par
02245                                                 \}\par
02246                                         \}\par
02247                                         {\cf19 break};\par
02248                                 {\cf19 case} e1sep :\par
02249                                         \{\par
02250                                                 {\cf19 if} (c=={\cf23 'd'}) \{\par
02251                                                         est_act = e1d;\par
02252                                                 \}\par
02253                                                 {\cf19 else}  \{\par
02254                                                         est_act = e0ini;\par
02255                                                 \}\par
02256                                         \}\par
02257                                         {\cf19 break};\par
02258                                 {\cf19 case} e1d :\par
02259                                         \{\par
02260                                                 {\cf19 if} (c=={\cf23 'i'}) \{\par
02261                                                         est_act = e1i;\par
02262                                                 \}\par
02263                                                 {\cf19 else}  \{\par
02264                                                         est_act = e0ini;\par
02265                                                 \}\par
02266                                         \}\par
02267                                         {\cf19 break};\par
02268                                 {\cf19 case} e1i :\par
02269                                         \{\par
02270                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
02271                                                         est_act = e2g;\par
02272                                                 \}\par
02273                                                 {\cf19 else}  \{\par
02274                                                         est_act = e0ini;\par
02275                                                 \}\par
02276                                         \}\par
02277                                         {\cf19 break};\par
02278                                 {\cf19 case} e2g :\par
02279                                         \{\par
02280                                                 {\cf19 if} (c=={\cf23 '#'}) \{\par
02281                                                         est_act = e2start;\par
02282                                                 \}\par
02283                                                 {\cf19 else}  \{\par
02284                                                         est_act = e0ini;\par
02285                                                 \}\par
02286                                         \}\par
02287                                         {\cf19 break};\par
02288                                 {\cf19 case} e2start :\par
02289                                         \{\par
02290                                                 {\cf19 if} (((c>={\cf23 '0'})&&(c<={\cf23 '9'}))&&(std::abs(c-{\cf23 '0'})<Base)) \{\par
02291                                                         est_act = e2dig;\par
02292                                                         digito = (c-{\cf23 '0'});\par
02293                                                         longitud = 0;\par
02294                                                         numero_base_recogido = 0;\par
02295                                                         numero_ret = pfx_rat_reg_digs_t::regd_0();\par
02296                                                 \}\par
02297                                                 {\cf19 else}  \{\par
02298                                                         est_act = e0ini;\par
02299                                                         digito = 0;\par
02300                                                         longitud = 0;\par
02301                                                         numero_base_recogido = 0;\par
02302                                                         numero_ret = pfx_rat_reg_digs_t::regd_0();\par
02303                                                 \}\par
02304                                         \}\par
02305                                         {\cf19 break};\par
02306                                 {\cf19 case} e2dig :\par
02307                                         \{\par
02308                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
02309                                                 {\cf17 const} {\cf18 bool} dig_lt_Base\{digito<Base\};\par
02310                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{dig_c && dig_lt_Base\};\par
02311                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{c_es_dig_B && (longitud < Length-1)\};\par
02312                                                 {\cf17 const} {\cf18 bool} tt_dig_B_cdl \{(c=={\cf23 ':'})&&dig_lt_Base&&(longitud < Length-1)\};\par
02313                                                 {\cf17 const} {\cf18 bool} tf_dig_B_cdl \{(c=={\cf23 '#'})&&dig_lt_Base&&(longitud == Length-1)\};\par
02314                                                 {\cf19 if} (dig_B_cdl) \{\par
02315                                                         digito *= 10;\par
02316                                                         digito += (c-{\cf23 '0'});\par
02317                                                         est_act = e2dig;\par
02318                                                 \}\par
02319                                                 {\cf19 else} {\cf19 if} (tt_dig_B_cdl) \{\par
02320                                                         est_act = e2dp;\par
02321                                                 \}\par
02322                                                 {\cf19 else} {\cf19 if} (tf_dig_B_cdl) \{\par
02323                                                         est_act = e2end;\par
02324                                                 \}\par
02325                                                 {\cf19 else}  \{\par
02326                                                         est_act = e0ini;\par
02327                                                         digito = 0;\par
02328                                                         longitud = 0;\par
02329                                                         numero_base_recogido = 0;\par
02330                                                         numero_ret = pfx_rat_reg_digs_t::regd_0();\par
02331                                                 \}\par
02332                                         \}\par
02333                                         {\cf19 break};\par
02334                                 {\cf19 case} e2dp :\par
02335                                         \{\par
02336                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
02337                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{(std::abs(c-{\cf23 '0'})<Base) && (digito<Base)\};\par
02338                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{dig_c && c_es_dig_B && (longitud < Length-1)\};\par
02339                                                 {\cf17 const} {\cf18 bool} rdig_B_cdl \{dig_c && c_es_dig_B && dig_B_cdl\};\par
02340                                                 {\cf19 if} (rdig_B_cdl) \{\par
02341                                                         est_act = e2dig;\par
02342                                                         numero_ret.m_dc[Length-1-longitud] = dig_t(digito);\par
02343                                                         ++longitud;\par
02344                                                         digito = c-{\cf23 '0'};\par
02345                                                 \}\par
02346                                                 {\cf19 else}  \{\par
02347                                                         est_act = e0ini;\par
02348                                                         digito = 0;\par
02349                                                         longitud = 0;\par
02350                                                         numero_base_recogido = 0;\par
02351                                                         indice = 0;\par
02352                                                         numero_ret = pfx_rat_reg_digs_t::regd_0();\par
02353                                                 \}\par
02354                                         \}\par
02355                                         {\cf19 break};\par
02356                                 {\cf19 case} e2end :\par
02357                                         \{\par
02358                                                 {\cf17 const} {\cf18 bool} c_es_sepfin \{c == {\cf23 'B'}\};\par
02359                                                 {\cf17 const} {\cf18 bool} d_es_digB \{digito < Base\};\par
02360                                                 {\cf17 const} {\cf18 bool} l_coincide \{longitud == Length-1\};{\cf20 // llega al cero ?}\par
02361                                                 {\cf17 const} {\cf18 bool} rdigB_cdl \{c_es_sepfin && d_es_digB && l_coincide\};\par
02362                                                 {\cf19 if} (rdigB_cdl) \{\par
02363                                                         est_act = e2B;\par
02364                                                         numero_ret.m_dc[Length-1-longitud] = dig_t(digito);\par
02365                                                         digito = 0;\par
02366                                                         longitud = 0;\par
02367                                                 \}\par
02368                                                 {\cf19 else}  \{\par
02369                                                         est_act = e0ini;\par
02370                                                         indice = 0;\par
02371                                                         digito = 0;\par
02372                                                         longitud = 0;\par
02373                                                         numero_ret = pfx_rat_reg_digs_t::regd_0();\par
02374                                                 \}\par
02375                                         \}\par
02376                                         {\cf19 break};\par
02377                                 {\cf19 case} e2B :\par
02378                                         \{\par
02379                                                 {\cf19 if} ((c >= {\cf23 '0'})&&(c <= {\cf23 '9'})) \{\par
02380                                                         est_act = e3dig;\par
02381                                                         numero_base_recogido = c-{\cf23 '0'};\par
02382                                                         digito = 0;\par
02383                                                 \}\par
02384                                                 {\cf19 else}  \{\par
02385                                                         est_act = e0ini;\par
02386                                                         digito = 0;\par
02387                                                         longitud = 0;\par
02388                                                         numero_base_recogido = 0;\par
02389                                                         numero_ret = pfx_rat_reg_digs_t::regd_0();\par
02390                                                 \}\par
02391                                         \}\par
02392                                         {\cf19 break};\par
02393                                 {\cf19 case} e3dig :\par
02394                                         \{\par
02395                                                 {\cf17 const} {\cf18 bool} espacio_c \{c < 16\};\par
02396                                                 {\cf17 const} {\cf18 bool} digito_c \{(c>={\cf23 '0'}) && (c<={\cf23 '9'})\};\par
02397                                                 {\cf17 const} {\cf18 bool} num_base_lt_Base \{numero_base_recogido < Base\};\par
02398                                                 {\cf17 const} {\cf18 bool} num_base_eq_Base \{numero_base_recogido == Base\};\par
02399                                                 {\cf19 if} (digito_c && num_base_lt_Base) \{\par
02400                                                         est_act = e3dig;\par
02401                                                         numero_base_recogido *= 10;\par
02402                                                         numero_base_recogido += (c-{\cf23 '0'});\par
02403                                                 \}\par
02404                                                 {\cf19 else} {\cf19 if} (espacio_c && num_base_eq_Base) \{\par
02405                                                         numero_base_recogido *= 10;\par
02406                                                         numero_base_recogido += (c-{\cf23 '0'});\par
02407                                                                 est_act = e0fin;\par
02408                                                                 numero_base_recogido = 0;\par
02409                                                 \}\par
02410                                                 {\cf19 else}  \{\par
02411                                                         est_act = e0ini;\par
02412                                                         numero_base_recogido = 0;\par
02413                                                 \}\par
02414                                         \}\par
02415                                         {\cf19 break};\par
02416                                 {\cf19 case} e0fin :\par
02417                                         \{\par
02418                                                 est_act = e0fin;\par
02419                                         \}\par
02420                         \}\par
02421                         ++indice;\par
02422                 \} {\cf19 while} (est_act!=e0fin);\par
02423 \par
02424                 {\cf19 return} (is);\par
02425         \}\par
02426 \par
02427         {\cf17 template}<type_traits::allowable_base_type_c Int_Type,Int_Type Base,std::{\cf18 size_t} Long>\par
02428                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>())\par
02429         std::ostream &\par
02430         {\cf17 operator} << (std::ostream & os,{\cf17 const} pfx_rat_reg_digs_t<Int_Type,Base,Long> & arg) \{\par
02431                 {\cf17 using }inttype = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
02432                 os << {\cf22 "reg_dig#"};\par
02433                 {\cf19 for}(std::int64_t ix\{Long-1\} ; ix > 0 ; --ix) \{\par
02434                                 os << static_cast<inttype>(arg(ix));\par
02435                                 os << {\cf23 ':'};\par
02436                 \}\par
02437                 os << static_cast<inttype>(arg(0));\par
02438                 os << {\cf22 "#B"};\par
02439                 os << static_cast<inttype>(Base);\par
02440                 {\cf19 return} (os);\par
02441         \}\par
02442 \par
02443 \}\par
02444 {\cf21 #endif }{\cf20 // NAT_RAT_FIXED_REG_T_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo nat_rat_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_rat_num_t.hpp}
{\xe \v nat_rat_num_t.hpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nat_rat_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_rat_num_t.hpp}
{\xe \v nat_rat_num_t.hpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef NAT_RAT_NUM_T_HPP_INCLUDED}\par
00002 {\cf21 #define NAT_RAT_NUM_T_HPP_INCLUDED}\par
00003 \par
00004 \par
00005 \par
00006 {\cf21 #endif }{\cf20 // NAT_RAT_NUM_T_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo nat_reg_digs_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_reg_digs_t.hpp}
{\xe \v nat_reg_digs_t.hpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "reg_digs_t.hpp"}\par
{\f2 #include "utilities.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para nat_reg_digs_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__reg__digs__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "nat__reg__digs__t_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::nat_reg_digs_t< UINT_T, B, L >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t LE> bool {\b NumRepr::is_nat_reg_digs_type_id} (std::string in)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACIONES PARA NAT_REG_DIGS. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t LE> std::string {\b NumRepr::to_nat_reg_digs_type_string} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t LE> size_t {\b NumRepr::size_of_nat_reg_digs_type_string_idT} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, size_t Length> \par
requires (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))std::istream & {\b NumRepr::operator>>} (std::istream &is, nat_reg_digs_t< Int_Type, Base, Length > &arg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::uint_type_for_radix_c Int_Type, Int_Type Base, size_t Long> \par
requires (type_traits::suitable_base<Int_Type,Base>())std::ostream & {\b NumRepr::operator<<} (std::ostream &os, const nat_reg_digs_t< Int_Type, Base, Long > &arg)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
nat_reg_digs_t.hpp\par \pard\plain 
{\tc\tcl2 \v nat_reg_digs_t.hpp}
{\xe \v nat_reg_digs_t.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef NAT_REG_DIGS_T__HPP__INCLUDED}\par
00002 {\cf21 #define NAT_REG_DIGS_T__HPP__INCLUDED}\par
00003 \par
00004 {\cf21 #include "reg_digs_t.hpp"}\par
00005 {\cf21 #include "utilities.hpp"}\par
00006 \par
00007 {\cf17 namespace }NumRepr \{\par
00008 \par
00009 {\cf17 using }type_traits::uint_type_for_radix_c;\par
00010 {\cf17 using }type_traits::suitable_base;\par
00011 \par
00012 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} L>\par
00013         {\cf17 requires} (suitable_base<UINT_T,B>() && (L>0))\par
00014 {\cf17 struct }nat_reg_digs_t : {\cf17 public} reg_digs_t<UINT_T,B,L> \{\par
00015 \par
00016         {\cf17 using }SIG_UINT_T = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00017         {\cf17 using }SIG_SINT_T = {\cf17 typename} type_traits::sig_SInt_for_UInt_t<UINT_T>;\par
00018 \par
00019         {\cf17 using }dig_t             = dig_t<UINT_T,B>;\par
00020 \par
00021         {\cf17 template}<{\cf18 size_t} N>\par
00022                 {\cf17 requires} (N>0)\par
00023         {\cf17 using} base_N_t          = reg_digs_t<UINT_T,B,N>;\par
00024         {\cf17 using }base_t                                    = base_N_t<L>;\par
00025 \par
00026         {\cf17 template}<binop_e op,{\cf18 size_t} N>\par
00027         {\cf17 using }res_base_N_op_t   =\par
00028                                 {\cf17 typename} auxiliary_types::result_operation_t<base_N_t<N>,op,N>;\par
00029         {\cf17 template}<binop_e op>\par
00030         {\cf17 using }res_base_op_t             =\par
00031                                 {\cf17 typename} auxiliary_types::result_operation_t<base_t,op,L>;\par
00032 \par
00033         {\cf17 template}<{\cf18 size_t} N>\par
00034                 {\cf17 requires} (N>0)\par
00035         {\cf17 using} nat_reg_N_digs_t= nat_reg_digs_t<UINT_T,B,N>;\par
00036 \par
00037         {\cf17 template}<binop_e op,{\cf18 size_t} N>\par
00038         {\cf17 using }res_N_op_t                        =\par
00039                 {\cf17 typename} auxiliary_types::result_operation_t<nat_reg_N_digs_t<N>,op,N>;\par
00040         {\cf17 template}<binop_e op>\par
00041         {\cf17 using }res_op_t                          =\par
00042                 {\cf17 typename} auxiliary_types::result_operation_t<nat_reg_digs_t,op,L>;\par
00043 \par
00044 public :\par
00045 \par
00049         {\cf17 static} {\cf17 consteval}\par
00050         nat_reg_digs_t  regd_0()    noexcept \{\par
00051                 {\cf19 return} nat_reg_digs_t\{base_t::regd_0()\};\par
00052         \}\par
00053 \par
00054         {\cf17 static} {\cf17 consteval}\par
00055         nat_reg_digs_t          regd_1()    noexcept \{\par
00056                 {\cf19 return} nat_reg_digs_t\{base_t::regd_1()\};\par
00057         \}\par
00058 \par
00059         {\cf17 static} {\cf17 consteval}\par
00060         nat_reg_digs_t          regd_Bm1()  noexcept \{\par
00061                 {\cf19 return} nat_reg_digs_t\{base_t::regd_Bm1()\};\par
00062         \}\par
00063 \par
00064         {\cf17 static} {\cf17 consteval}\par
00065         nat_reg_digs_t          regd_B()        noexcept \{\par
00066                 {\cf19 return} nat_reg_digs_t\{base_t::regd_B()\};\par
00067         \}\par
00068 \par
00069         {\cf17 template}<{\cf18 size_t} n>\par
00070                 {\cf17 requires} ((n>=0)&&(n < L))\par
00071         {\cf17 static} {\cf17 consteval}\par
00072         nat_reg_digs_t          regd_pow_n_B()  {\cf17 noexcept} \{\par
00073                 {\cf19 return} nat_reg_digs_t\{base_t::regd_pow_n_B()\};\par
00074         \}\par
00075 \par
00076         {\cf17 template}<{\cf18 size_t} n>\par
00077                 {\cf17 requires} ((n>=0)&&(n < L))\par
00078         {\cf17 static} {\cf17 consteval}\par
00079         nat_reg_digs_t          regd_pow_n_B_m1() {\cf17 noexcept}      \{\par
00080                 {\cf19 return} nat_reg_digs_t\{base_t::regd_pow_n_B_m1()\};\par
00081         \}\par
00082 \par
00083 \par
00084 {\cf20                                 /************************************/}\par
00085                                 {\cf20 /*                                                                                                                                      */}\par
00086                                 {\cf20 /*    CONSTRUIR NUMERO                                          */}\par
00087                                 {\cf20 /*                                                                                                                                      */}\par
00088 {\cf20                                 /************************************/}\par
00089 \par
00090 {\cf17 public}:\par
00091 \par
00093         {\cf17 consteval} {\cf17 inline}\par
00094         nat_reg_digs_t()\par
00095         noexcept : base_t\{dig_t::dig_0()\} \{\}\par
00097         {\cf17 constexpr} {\cf17 inline}\par
00098         nat_reg_digs_t({\cf17 const} std::initializer_list<dig_t> & arg)\par
00099         noexcept : base_t\{arg\} \{\}\par
00101         {\cf17 template}<{\cf17 typename} ... Ts>\par
00102                 {\cf17 requires} (std::is_same_v<Ts,dig_t>&&...)\par
00103         {\cf17 constexpr} {\cf17 inline}\par
00104         nat_reg_digs_t({\cf17 const} Ts &... args)\par
00105         noexcept : base_t(args...) \{\}\par
00106 \par
00107 {\cf17 public}:\par
00108         {\cf17 inline} {\cf17 constexpr} {\cf17 const} base_t* {\cf17 const} const_base_this() const noexcept\par
00109         \{ {\cf19 return} {\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this}); \}\par
00110         {\cf17 inline} {\cf17 constexpr} base_t base_cpy_cthis() const noexcept\par
00111         \{ {\cf19 return} base_t(*const_base_this()); \}\par
00112         {\cf17 inline} {\cf17 constexpr} {\cf17 const} base_t& base_const_ref_cthis() const noexcept\par
00113         \{ {\cf19 return} (*const_base_this()); \}\par
00114         {\cf17 inline} {\cf17 constexpr} {\cf17 const} dig_t& const_by_index({\cf18 size_t} ix) {\cf17 const} {\cf17 noexcept}\par
00115         \{ {\cf19 return} (base_const_ref_cthis()[ix]); \}\par
00116         {\cf17 inline} {\cf17 constexpr} dig_t cpy_by_index({\cf18 size_t} ix) {\cf17 const} {\cf17 noexcept}\par
00117         \{ {\cf19 return} dig_t(base_const_ref_cthis()[ix]); \}\par
00118 {\cf17 private}:\par
00119         {\cf17 inline} {\cf17 constexpr} base_t* {\cf17 const} base_this() noexcept\par
00120         \{ {\cf19 return} {\cf17 static_cast<}base_t* const{\cf17 >}({\cf17 this}); \}\par
00121         {\cf17 inline} {\cf17 constexpr} base_t& base_ref_cthis() noexcept\par
00122         \{ {\cf19 return} (*base_this); \}\par
00123         {\cf17 inline} {\cf17 constexpr} {\cf17 const} dig_t& by_index({\cf18 size_t} ix) {\cf17 noexcept}\par
00124         \{ {\cf19 return} (base_ref_cthis()[ix]); \}\par
00125 {\cf17 public}:\par
00126 \par
00127 \par
00131         {\cf17 template}<{\cf18 size_t} N>\par
00132                 {\cf17 requires} (N>0)\par
00133         {\cf17 constexpr} {\cf17 inline}\par
00134         {\cf18 void} copy_arg_N({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept} \{\par
00136 \par
00137                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(N,L)\};\par
00138                 {\cf17 constexpr} {\cf17 auto} W\{std::max(N,L)\};\par
00139                 {\cf19 if} {\cf17 constexpr} (Z==L) \{\par
00140                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00141                                 by_index(ix)=arg[ix];\par
00142                 \}\par
00143                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (W==L) \{\par
00144                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00145                                 by_index(ix)=arg[ix];\par
00146                         {\cf19 for}({\cf18 size_t} ix\{Z\} ; ix < W ; ++ix)\par
00147                                 by_index(ix)=dig_t::dig_0();\par
00148                 \}\par
00149                 {\cf19 else} \{\par
00150                         base_ref_cthis() = arg;\par
00151                 \}\par
00152         \}\par
00153 \par
00156         {\cf17 template}<{\cf18 size_t} N>\par
00157                 {\cf17 requires} (N>0)\par
00158         {\cf17 constexpr} {\cf17 inline}\par
00159         {\cf18 void} move_arg_N(base_N_t<N>&& arg) {\cf17 noexcept} \{\par
00161                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(N,L)\};\par
00162                 {\cf17 constexpr} {\cf17 auto} W\{std::max(N,L)\};\par
00163                 {\cf19 if} {\cf17 constexpr} (Z==L) \{\par
00164                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00165                                 by_index(ix)=std::move(arg[ix]);\par
00166                 \}\par
00167                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (W==L) \{\par
00168                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00169                                 by_index(ix)=std::move(arg[ix]);\par
00170                         {\cf19 for}({\cf18 size_t} ix\{Z\} ; ix < W ; ++ix)\par
00171                                 by_index(ix)=std::move(dig_t::dig_0());\par
00172                 \}\par
00173                 {\cf19 else} \{\par
00174       base_ref_cthis()=std::move(arg);\par
00175                 \}\par
00176         \}\par
00177 \par
00180         {\cf17 template}<{\cf18 size_t} N>\par
00181                 {\cf17 requires} (N>0)\par
00182         {\cf17 constexpr} {\cf17 inline}\par
00183         {\cf18 void} copy_arg_N({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 noexcept} \{\par
00184                 base_ref_cthis() = arg.base_const_ref_cthis();\par
00185         \}\par
00186 \par
00189         {\cf17 template}<{\cf18 size_t} N>\par
00190                 {\cf17 requires} (N>0)\par
00191         {\cf17 constexpr} {\cf17 inline}\par
00192         {\cf18 void} move_arg_N(nat_reg_N_digs_t<N>&& arg) {\cf17 noexcept} \{\par
00193                 base_ref_cthis() = std::move(arg.base_const_ref_cthis());\par
00194         \}\par
00195 \par
00196 {\cf17 public}:\par
00197 \par
00199         {\cf17 template}<{\cf18 size_t} N>\par
00200                 {\cf17 requires} (N>0)\par
00201         {\cf17 constexpr} {\cf17 inline}\par
00202         nat_reg_digs_t({\cf17 const} base_N_t<N> & arg)\par
00203         noexcept : base_t\{copy_arg_N<N>(arg)\} \{\}\par
00204 \par
00206         {\cf17 template}<{\cf18 size_t} N>\par
00207                 {\cf17 requires} (N>0)\par
00208         {\cf17 constexpr} {\cf17 inline}\par
00209         nat_reg_digs_t({\cf17 const} base_N_t<N> && arg)\par
00210         noexcept : base_t\{move_arg_N<N>(std::move(arg))\} \{\}\par
00212 \par
00213 {\cf17 public}:\par
00214 \par
00216         {\cf17 template}<type_traits::integral_c ... Ints_type>\par
00217         {\cf17 constexpr} {\cf17 inline} nat_reg_digs_t(Ints_type ... dig_pow_i) noexcept :\par
00218                 base_t\{normalize<Ints_type...>(dig_pow_i...)\} \{\}\par
00219 \par
00221         {\cf17 template}<{\cf18 size_t} N>\par
00222                 {\cf17 requires} (N>0)\par
00223         {\cf17 constexpr} {\cf17 inline} nat_reg_digs_t({\cf17 const} nat_reg_N_digs_t<N> & arg) noexcept :\par
00224                 base_t\{copy_arg_N<N>(arg.base_const_ref_cthis())\} \{\}\par
00225 \par
00227         {\cf17 template}<{\cf18 size_t} N>\par
00228                 {\cf17 requires} (N>0)\par
00229         {\cf17 constexpr} {\cf17 inline} nat_reg_digs_t(nat_reg_N_digs_t<N> && arg) noexcept :\par
00230                 base_t\{move_arg_N(std::move(*(arg.base_this())))\} \{\}\par
00231 \par
00233         {\cf17 template}<{\cf18 size_t} N>\par
00234                 {\cf17 requires} (N>0)\par
00235         {\cf17 constexpr} {\cf17 inline}\par
00236         {\cf17 const} nat_reg_digs_t & {\cf17 operator} = ({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept}\par
00237         \{\par
00238                 {\cf19 if} (base_this() != &arg)\par
00239                         copy_arg_N<N>(arg);\par
00240                 {\cf19 return} (*{\cf17 this});\par
00241         \}\par
00242 \par
00244         {\cf17 template}<{\cf18 size_t} N>\par
00245                 {\cf17 requires} (N>0)\par
00246         {\cf17 constexpr} {\cf17 inline}\par
00247         nat_reg_digs_t & {\cf17 operator} = (base_N_t<N> & arg) {\cf17 noexcept}\par
00248         \{\par
00249                 {\cf19 if} (const_base_this() != &arg)\par
00250                         copy_arg_N<N>(arg);\par
00251                 {\cf19 return} (*{\cf17 this});\par
00252         \}\par
00253 \par
00255         {\cf17 template}<{\cf18 size_t} N>\par
00256                 {\cf17 requires} (N>0)\par
00257         {\cf17 constexpr} {\cf17 inline}\par
00258         {\cf17 const} nat_reg_digs_t & {\cf17 operator} = (base_N_t<N>&& arg) {\cf17 noexcept}\par
00259         \{\par
00260                 {\cf19 if} (const_base_this() != &arg)\par
00261                         move_arg_N<N>(std::move(arg));\par
00262                 {\cf19 return} (*{\cf17 this});\par
00263         \}\par
00264 \par
00266         {\cf17 template}<{\cf18 size_t} N>\par
00267                 {\cf17 requires} (N>0)\par
00268         {\cf17 constexpr} {\cf17 inline}\par
00269         nat_reg_digs_t & {\cf17 operator} = ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
00270         \{\par
00271                 {\cf19 if} ({\cf17 this} != &arg)\par
00272                         (*base_this()) = arg.base_const_ref_cthis();\par
00273                 {\cf19 return} (*{\cf17 this});\par
00274         \}\par
00275 \par
00277         {\cf17 template}<{\cf18 size_t} N>\par
00278                 {\cf17 requires} (N>0)\par
00279         {\cf17 constexpr} {\cf17 inline}\par
00280         nat_reg_digs_t & {\cf17 operator} = (nat_reg_N_digs_t<N> && arg) {\cf17 noexcept}\par
00281         \{\par
00282                 {\cf19 if} ({\cf17 this} != &arg)\par
00283                         (*base_this()) = std::move(*(arg.base_this()));\par
00284                 {\cf19 return} (*{\cf17 this});\par
00285         \}\par
00286 \par
00288         {\cf17 template}<{\cf18 size_t} N>\par
00289                 {\cf17 requires} (N>0)\par
00290         {\cf17 constexpr} {\cf17 inline}\par
00291         {\cf17 const} nat_reg_digs_t & {\cf17 operator} = ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
00292         \{\par
00293                 {\cf19 if} ({\cf17 this} != &arg)\par
00294                         (*base_this()) = arg.base_const_ref_cthis();\par
00295                 {\cf19 return} (*{\cf17 this});\par
00296         \}\par
00297 {\cf17 private}:\par
00298         {\cf17 template}<{\cf18 size_t} N>\par
00299                 {\cf17 requires} (N>0)\par
00300         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00301         {\cf18 void} set_0(base_N_t<N>& arg) {\cf17 noexcept}\par
00302         \{\par
00303                 {\cf19 for} (dig_t& dig : arg)\par
00304                         dig = dig_t::dig_0();\par
00305         \}\par
00306 \par
00307         {\cf17 template}<{\cf18 size_t} N>\par
00308                 {\cf17 requires} (N>0)\par
00309         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00310         {\cf18 void} set_1(base_N_t<N>& arg) {\cf17 noexcept}\par
00311         \{\par
00312                 arg[0].set_1();\par
00313                 {\cf19 for} ({\cf18 size_t} ix\{1\} ; ix < N ; ++ix )\par
00314                         arg[ix] = dig_t::dig_0();\par
00315         \}\par
00316 \par
00317         {\cf17 template}<{\cf18 size_t} N>\par
00318                 {\cf17 requires} (N>0)\par
00319         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00320         {\cf18 void} set_Bm1(base_N_t<N>& arg) {\cf17 noexcept}\par
00321         \{\par
00322                 arg[0].set_Bm1();\par
00323                 {\cf19 for} ({\cf18 size_t} ix\{1\} ; ix < N ; ++ix )\par
00324                         arg[ix] = dig_t::dig_0();\par
00325         \}\par
00326 \par
00327         {\cf17 template}<{\cf18 size_t} N>\par
00328                 {\cf17 requires} (N>0)\par
00329         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00330         {\cf18 void} set_dig(base_N_t<N>& larg,dig_t d) {\cf17 noexcept}\par
00331         \{\par
00332                 larg[0] = d;\par
00333                 {\cf19 for} ({\cf18 size_t} ix\{1\} ; ix < N ; ++ix )\par
00334                         larg[ix] = dig_t::dig_0();\par
00335         \}\par
00336 \par
00337         {\cf17 template}<{\cf18 size_t} N>\par
00338                 {\cf17 requires} (N>0)\par
00339         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00340         {\cf18 void} set_fill_dig(base_N_t<N>& larg,dig_t d) {\cf17 noexcept}\par
00341         \{\par
00342                 {\cf19 for} ({\cf17 auto} & elem : larg)\par
00343                         elem = d;\par
00344         \}\par
00345 \par
00346         {\cf17 template}<{\cf18 size_t} N>\par
00347                 {\cf17 requires} (N>0)\par
00348         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00349         {\cf18 void} set_fill_1(base_N_t<N>& larg) {\cf17 noexcept}\par
00350         \{\par
00351                 {\cf19 for} ({\cf17 auto} & elem : larg)\par
00352                         elem.set_1();\par
00353         \}\par
00354 \par
00355         {\cf17 template}<{\cf18 size_t} N>\par
00356                 {\cf17 requires} (N>0)\par
00357         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00358         {\cf18 void} set_fill_Bm1(base_N_t<N>& larg) {\cf17 noexcept}\par
00359         \{\par
00360                 {\cf19 for} ({\cf17 auto} & elem : larg)\par
00361                         elem.set_Bm1();\par
00362         \}\par
00363 \par
00366         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} N_i,{\cf18 size_t} N_pf>       {\cf20 // i  es inicio}\par
00367                                                                                                                                                                                         {\cf20 // pf es pasado el final}\par
00368                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= N)&&(N>0))\par
00369         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00370         {\cf18 void} set_interval_0(base_N_t<N>& larg) {\cf17 noexcept} \{\par
00371                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00372                         larg[ix] = dig_t::dig_0();\par
00373         \}\par
00374 \par
00377         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} N_i,{\cf18 size_t} N_pf>       {\cf20 // i  es inicio}\par
00378                                                                                                                                                                                         {\cf20 // pf es pasado el final}\par
00379                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= N)&&(N>0))\par
00380         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00381         {\cf18 void} set_interval_Bm1(base_N_t<N>& larg) {\cf17 noexcept} \{\par
00382                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00383                         larg[ix] = dig_t::dig_Bm1();\par
00384         \}\par
00385 \par
00388         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} N_i,{\cf18 size_t} N_pf> {\cf20 // i  es inicio}\par
00389                                                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00390                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= N)&&(N>0))\par
00391         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00392         {\cf18 void} set_interval_dig(base_N_t<N>& larg,dig_t dig) {\cf17 noexcept} \{\par
00393                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00394                         larg[ix] = dig;\par
00395         \}\par
00396 \par
00400         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i  es inicio}\par
00401                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00402                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00403         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00404         {\cf18 void} set_interval_0(base_t& larg) {\cf17 noexcept} \{\par
00405                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00406                         larg[ix] = dig_t::dig_0();\par
00407         \}\par
00408 \par
00412         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i  es inicio}\par
00413                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00414                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00415         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00416         {\cf18 void} set_interval_Bm1(base_t& larg) {\cf17 noexcept} \{\par
00417                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00418                         larg[ix] = dig_t::dig_Bm1();\par
00419         \}\par
00420 \par
00424         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i  es inicio}\par
00425                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00426                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00427         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00428         {\cf18 void} set_interval_dig(base_t& larg,dig_t dig) {\cf17 noexcept} \{\par
00429                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00430                         larg[ix] = dig;\par
00431         \}\par
00432 \par
00433 {\cf17 public}:\par
00435         {\cf17 constexpr} {\cf17 inline}\par
00436         {\cf18 void} set_0() noexcept \{\par
00437                 set_0(base_ref_cthis());\par
00438         \}\par
00439 \par
00441         {\cf17 constexpr} {\cf17 inline}\par
00442         {\cf18 void} set_Bm1() noexcept \{\par
00443                 set_Bm1(base_ref_cthis());\par
00444         \}\par
00445 \par
00447         {\cf17 constexpr} {\cf17 inline}\par
00448         {\cf18 void} set_dig(dig_t arg) {\cf17 noexcept} \{\par
00449                 set_dig(base_ref_cthis(),arg);\par
00450         \}\par
00451 \par
00453         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i es inicio}\par
00454                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00455                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00456         {\cf17 constexpr} {\cf17 inline}\par
00457         {\cf18 void} set_interval_0() {\cf17 noexcept} \{\par
00458                 set_interval_0<N_i,N_pf>(base_ref_cthis());\par
00459         \}\par
00461         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i es inicio}\par
00462                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00463                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00464         {\cf17 constexpr} {\cf17 inline}\par
00465         {\cf18 void} set_interval_Bm1() {\cf17 noexcept} \{\par
00466                 set_interval_Bm1<N_i,N_pf>(base_ref_cthis());\par
00467         \}\par
00469         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i es inicio}\par
00470                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00471                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00472         {\cf17 constexpr} {\cf17 inline}\par
00473         {\cf18 void} set_interval_dig(dig_t dig) {\cf17 noexcept} \{\par
00474                 set_interval_0<N_i,N_pf>(base_ref_cthis(),dig);\par
00475         \}\par
00476 \par
00478         {\cf17 constexpr} {\cf17 inline}\par
00479         nat_reg_digs_t & operator = ({\cf17 const} dig_t & arg)\par
00480         {\cf17 noexcept} \{\par
00481                 {\cf19 if} (&const_by_index(0) != &arg) \{\par
00482                         set_0();\par
00483                         by_index(0) = arg;\par
00484                 \}\par
00485                 {\cf19 return} (*{\cf17 this});\par
00486         \}\par
00487 \par
00489         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00490         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00491         {\cf17 const} base_t& assign(base_t& larg,Int_Type arg) {\cf17 noexcept} \{\par
00492                 {\cf17 using }type_traits::maxbase;\par
00493                 {\cf17 constexpr} sint128_t B_128t_v\{{\cf17 static_cast<}sint128_t{\cf17 >}(B)\};\par
00494                 {\cf17 constexpr} {\cf18 bool} puede_multiplicarse\{\par
00495                                 (maxbase<sint128_t>()/B_128t_v) > 0\par
00496                 \};\par
00497                 {\cf19 if} ((&larg)!=(&arg)) \{\par
00498                         sint128_t creg_g\{{\cf17 static_cast<}sint128_t{\cf17 >}(arg)\};\par
00499                         sint128_t BasePowIx\{B_128t_v\};\par
00500                         {\cf19 for}({\cf18 size_t} k\{1u\} ; k < L ; ++k) \{\par
00501                                 {\cf19 if} {\cf17 constexpr} (puede_multiplicarse)\par
00502                                         BasePowIx *= B_128t_v;\par
00503                                 {\cf19 else}\par
00504                                         {\cf19 break};\par
00505                         \}\par
00506                         {\cf19 while} (creg_g < 0) \{\par
00507                                 creg_g += BasePowIx;\par
00508                         \}\par
00509                         {\cf19 for}({\cf18 size_t} k\{0u\} ; k < L ; ++k)\{\par
00510                                 larg[k] = dig_t(creg_g%B_128t_v);\par
00511                                 creg_g /= B_128t_v;\par
00512                         \}\par
00513                 \}\par
00514                 {\cf19 return} (larg);\par
00515         \}\par
00516 \par
00519         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00520         {\cf17 constexpr} {\cf17 inline} nat_reg_digs_t & operator = (Int_Type arg) {\cf17 noexcept} \{\par
00521                 {\cf17 using }UInt_Type = std::conditional_t<\par
00522                                                                                                 std::is_signed_v<Int_Type>,\par
00523                                                                                                         std::conditional_t<\par
00524                                                                                                                 type_traits::ge_sz_v<\par
00525                                                                                                                                 UINT_T,\par
00526                                                                                                                                 type_traits::sig_UInt_for_SInt_t<Int_Type>\par
00527                                                                                                                 >,\par
00528                                                                                                                         UINT_T,\par
00529                                                                                                                         type_traits::sig_UInt_for_SInt_t<Int_Type>\par
00530                                                                                                         >,\par
00531                                                                                                         std::conditional_t<\par
00532                                                                                                                 type_traits::ge_sz_v<\par
00533                                                                                                                                 UINT_T,\par
00534                                                                                                                                 Int_Type\par
00535                                                                                                                 >,\par
00536                                                                                                                         UINT_T,\par
00537                                                                                                                         Int_Type\par
00538                                                                                                         >\par
00539                                                                                         >;\par
00540                 UInt_Type argc = {\cf17 static_cast<}UInt_Type{\cf17 >}((arg<0)?-arg:arg);\par
00541                 {\cf17 constexpr} UInt_Type Bc = {\cf17 static_cast<}UInt_Type{\cf17 >}(B);\par
00542 \par
00543                 {\cf18 size_t} ix\{0\};\par
00544                 UInt_Type quotient = argc / Bc;\par
00545                 UInt_Type remainder = argc % Bc;\par
00546                 {\cf19 do} \{\par
00547                         by_index(ix) = remainder;\par
00548 \par
00549                         argc = quotient;\par
00550                         quotient = argc / Bc;\par
00551                         remainder = argc % Bc;\par
00552 \par
00553                         ++ix;\par
00554                 \} {\cf19 while}( argc != 0 );\par
00555 \par
00556                 {\cf19 if} (ix < L-1)\par
00557                         {\cf19 for}( ; ix < L ; ++ix)\par
00558                                 by_index(ix) = dig_t::dig_0();\par
00559 \par
00560                 {\cf19 return} (*{\cf17 this});\par
00561         \}\par
00562 \par
00563 {\cf17 public}:\par
00564 \par
00569 \par
00571 \par
00572         {\cf17 template}<{\cf18 size_t} N>\par
00573                 {\cf17 requires} (N>0)\par
00574         {\cf17 constexpr} {\cf17 inline}\par
00575         nat_reg_N_digs_t<N+L> cat({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
00576         \{       {\cf19 return} (concat<L,N>(base_cpy_cthis(),arg));     \}\par
00577 \par
00578         {\cf17 constexpr} {\cf17 inline}\par
00579         nat_reg_N_digs_t<L+1> cat(dig_t arg) {\cf17 const}\par
00580         {\cf17 noexcept} \{      {\cf19 return} (concat<L>(base_cpy_cthis(),arg));       \}\par
00581 \par
00582         {\cf17 template}<{\cf18 size_t} N>\par
00583                 {\cf17 requires} (N>0)\par
00584         {\cf17 constexpr} {\cf17 inline}\par
00585         nat_reg_N_digs_t<N+L> cat_inv({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
00586         \{       {\cf19 return} (concat<N,L>(arg,base_cpy_cthis()));     \}\par
00587 \par
00588         {\cf17 constexpr} {\cf17 inline}\par
00589         nat_reg_N_digs_t<L+1> cat_inv(dig_t arg) {\cf17 const} {\cf17 noexcept}\par
00590         \{       {\cf19 return} (concat<L>(arg,base_cpy_cthis()));       \}\par
00591 \par
00592         {\cf17 template}<{\cf18 size_t} ibegin,{\cf18 size_t} iend>\par
00593                 {\cf17 requires} ((iend <= L)&&(ibegin < iend))\par
00594         {\cf17 constexpr} {\cf17 inline}\par
00595         nat_reg_N_digs_t<iend-ibegin> subrepr() {\cf17 const} {\cf17 noexcept}\par
00596         \{       {\cf19 return} subregister<L,ibegin,iend>(base_cpy_cthis());    \}\par
00597 \par
00598 {\cf20                                 /****************************************/}\par
00599                                 {\cf20 /*                                                                                                              */}\par
00600                                 {\cf20 /*       Algunas Conversiones                                   */}\par
00601                                 {\cf20 /*                                                                                                                              */}\par
00602 {\cf20                                 /****************************************/}\par
00603 \par
00604         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00605         {\cf17 constexpr} {\cf17 inline} {\cf17 operator} Int_Type() const noexcept \{\par
00606                 {\cf17 using }type_traits::maxbase;\par
00607                 uint64_t retInt\{0\};\par
00608                 uint64_t BasePowIx\{1\};\par
00609                 {\cf19 for}({\cf18 size_t} k\{0\} ; k < L ; ++k) \{\par
00610                         retInt += const_by_index(k)*BasePowIx;\par
00611                         BasePowIx *= B;\par
00612                         {\cf19 if}(     (k+1 < L)\par
00613                                                 &&\par
00614                                         ( maxbase<Int_Type>() < (retInt+(const_by_index(k+1)*BasePowIx)) )      )\par
00615                         \{       {\cf19 return} retInt; \}\par
00616                 \}\par
00617                 {\cf19 return} retInt;\par
00618         \}\par
00619 \par
00620 {\cf17 public}:\par
00621 \par
00622 {\cf20                                 /****************************************************/}\par
00623                                 {\cf20 /*                                                                                                                                                                                      */}\par
00624                                 {\cf20 /* OPERADORES COMPARATIVOS                                                                                                      */}\par
00625                                 {\cf20 /*                                                                                                                                                                                      */}\par
00626 {\cf20                                 /****************************************************/}\par
00627 \par
00629         {\cf17 template}<{\cf18 size_t} N>\par
00630                 {\cf17 requires} (N>0)\par
00631         {\cf17 constexpr} {\cf17 inline}\par
00632         std::strong_ordering operator <=> ({\cf17 const} nat_reg_N_digs_t<N>& arg)\par
00633         {\cf17 const} {\cf17 noexcept} \{\par
00634                 {\cf19 return} (base_const_ref_cthis() <=> arg.base_const_ref_cthis());\par
00635         \}\par
00636 \par
00638         {\cf17 template}<{\cf18 size_t} N>\par
00639                 {\cf17 requires} (N>0)\par
00640         {\cf17 constexpr} {\cf17 inline}\par
00641         std::weak_ordering operator <=> ({\cf17 const} base_N_t<N>& arg) {\cf17 const}\par
00642         {\cf17 noexcept} \{\par
00643                 {\cf19 return} (base_const_ref_cthis() <=> arg);\par
00644         \}\par
00645 \par
00647         {\cf17 constexpr} {\cf17 inline}\par
00648         std::weak_ordering operator <=> ({\cf17 const} dig_t & arg) {\cf17 const} {\cf17 noexcept}\par
00649         \{       {\cf19 return} (base_const_ref_cthis() <=> arg); \}\par
00650 \par
00651 {\cf20                                 /********************************/}\par
00652                                 {\cf20 /*                                                                                                              */}\par
00653                                 {\cf20 /*                PRIMER DIGITO                                 */}\par
00654                                 {\cf20 /*                SEGUNDO DIGITO                                        */}\par
00655                                 {\cf20 /*                                                                                                              */}\par
00656 {\cf20                                 /********************************/}\par
00657 \par
00658         {\cf17 inline} {\cf17 constexpr}\par
00659         dig_t operator[]({\cf18 size_t} idx) {\cf17 const} {\cf17 noexcept}\par
00660         \{\par
00661                 {\cf19 return} (cpy_by_index(idx));\par
00662         \}\par
00663 \par
00664         {\cf17 inline} {\cf17 constexpr}\par
00665         dig_t& operator[]({\cf18 size_t} idx) {\cf17 noexcept}\par
00666         \{\par
00667                 {\cf19 return} (by_index(idx));\par
00668         \}\par
00669 \par
00670         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type=UINT_T>\par
00671         {\cf17 inline} {\cf17 constexpr} Int_Type operator()({\cf18 size_t} idx) {\cf17 const} {\cf17 noexcept}\par
00672         \{\par
00673                 {\cf19 return} {\cf17 static_cast<}Int_Type{\cf17 >}(cpy_by_index(idx)());\par
00674         \}\par
00675 \par
00676 {\cf20                                                                 /****************************/}\par
00677                                                                 {\cf20 /*                                                                                                      */}\par
00678                                                                 {\cf20 /* OPERADORES ARITMETICOS               */}\par
00679                                                                 {\cf20 /*      POSTINCREMENTO ++(int)  */}\par
00680                                                                 {\cf20 /*      PREINCREMENTO ++()                      */}\par
00681                                                                 {\cf20 /*      POSTDECREMENTO --(int)  */}\par
00682                                                                 {\cf20 /*      PREDECREMENTO ++()                      */}\par
00683                                                                 {\cf20 /*                          */}\par
00684 {\cf20                                                                 /****************************/}\par
00685 {\cf17 private}:\par
00690 \par
00698 \par
00699         {\cf17 template}<{\cf18 bool} with_result_type>\par
00700         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00701         {\cf17 auto}    preincrement (base_t& arg)  {\cf17 noexcept} ->\par
00702                         std::conditional_t<\par
00703                                         with_result_type,\par
00704                                                 res_base_op_t<binop_e::add>,\par
00705                                                 {\cf17 const} base_t &\par
00706                         >\par
00707         \{\par
00708                 {\cf19 if} {\cf17 constexpr} (with_result_type) \{ \par
00710                         res_base_op_t<binop_e::add> ret\{\par
00711                                 .result_content_low = {\cf17 static_cast<}base_t{\cf17 >}(arg),\par
00712                                 .carry                                                  =       dig_t::dig_0(),\par
00713                                 .good_result                            =       {\cf17 true}\par
00714                         \};\par
00716                         dig_t& carry\{ret.carry\};\par
00718                         {\cf17 auto}&  result\{ret.result_content_low\};\par
00720                         {\cf18 bool}&  good\{ret.good_result\};\par
00722                         {\cf19 if} (arg[0].is_Bm1()) \{\par
00723                                 result[0] = dig_t::dig_0();\par
00724                                 carry           = dig_t::dig_1();\par
00725                         \}\par
00726                         {\cf19 else} \{\par
00727                                 ++result[0];\par
00728                                 carry   = dig_t::dig_0();\par
00729                                 {\cf19 return} ret;\par
00730                         \}\par
00732                         {\cf19 if} (carry.is_not_0()) \{\par
00733                                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
00734                                         {\cf19 if} (carry.is_not_0()) \{\par
00735                                                 {\cf19 if} (arg[ix] == dig_t::dig_Bm1()) \{\par
00736                                                         result[ix] = dig_t::dig_0();\par
00737                                                         carry = dig_t::dig_1();\par
00738                                                         {\cf19 continue};\par
00739                                                 \}\par
00740                                                 {\cf19 else} \{\par
00741                                                         ++result[ix];\par
00742                                                         carry = dig_t::dig_0();\par
00743                                                         {\cf19 return} ret;\par
00744                                                 \}\par
00745                                         \}\par
00746                                 \}\par
00747                         \}\par
00748                         {\cf19 if} (carry.is_not_0()) \{\par
00749                                 good = {\cf17 false};\par
00750                         \}\par
00751                         {\cf19 return} ret;\par
00752                 \}\par
00753                 {\cf19 else} \{\par
00755                         dig_t carry\{dig_t::dig_0()\};\par
00757                         {\cf19 if} (arg[0].is_Bm1()) \{\par
00758                                 arg[0] = dig_t::dig_0();\par
00759                                 carry = dig_t::dig_1();\par
00760                         \}\par
00761                         {\cf19 else} \{\par
00762                                 ++arg[0];\par
00763                                 {\cf19 return} (arg);\par
00764                         \}\par
00766                         {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
00767                                 {\cf19 if} (carry.is_1()) \{\par
00768                                         {\cf19 if} (arg[ix].is_Bm1()) \{\par
00769                                                 arg[ix]         = dig_t::dig_0();\par
00770                                                 carry           = dig_t::dig_1();\par
00771                                                 {\cf19 continue};\par
00772                                         \}\par
00773                                         {\cf19 else} \{\par
00774                                                 ++arg[ix];\par
00775                                                 {\cf19 return} (arg);\par
00776                                         \}\par
00777                                 \}\par
00778                         \}\par
00779                         {\cf19 return} (arg);\par
00780                 \}\par
00781         \}\par
00782 \par
00783 public :\par
00784 \par
00785         {\cf17 constexpr} {\cf17 inline}\par
00786         {\cf17 const} nat_reg_digs_t & operator ++ () noexcept\par
00787         \{\par
00788                 preincrement<false>(base_ref_cthis());\par
00789                 {\cf19 return} (*{\cf17 this});\par
00790         \}\par
00791 \par
00792 {\cf17 private}:\par
00793 \par
00794         {\cf17 template}<{\cf18 bool} with_result_type>\par
00795         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00796         {\cf17 auto} postincrement (base_t& arg) {\cf17 noexcept} ->\par
00797                         std::conditional<\par
00798                                         with_result_type,\par
00799                                                         res_base_op_t<binop_e::add>,\par
00800                                                         {\cf17 const} base_t &\par
00801                         >\par
00802         \{\par
00803                 base_t cparg\{{\cf17 static_cast<}base_t{\cf17 >}(arg)\};\par
00804                 {\cf19 if} {\cf17 constexpr} (with_result_type) \{\par
00805                         {\cf17 auto} ret\{preincrement<true>(arg)\};\par
00806                         ret.result_content_low = cparg;\par
00807                         {\cf19 return} std::move(ret);\par
00808                 \}\par
00809                 {\cf19 else} \{\par
00810                         preincrement<false>(arg);\par
00811                         {\cf19 return} (cparg);\par
00812                 \}\par
00813         \}\par
00814 \par
00815 public :\par
00816 \par
00817         {\cf17 constexpr} {\cf17 inline}\par
00818         {\cf17 const} nat_reg_digs_t& operator ++ ({\cf18 int}) {\cf17 noexcept}\par
00819         \{\par
00820                 postincrement<false>(base_ref_cthis);\par
00821                 {\cf19 return} (*{\cf17 this});\par
00822         \}\par
00823 \par
00824 private :\par
00825 \par
00826         {\cf17 template}<{\cf18 bool} with_result_type>\par
00827         {\cf17 constexpr} {\cf17 inline}\par
00828         {\cf17 auto} predecrement (base_t& arg) {\cf17 noexcept} ->\par
00829                 std::conditional<\par
00830                                 with_result_type,\par
00831                                                 res_base_op_t<binop_e::sub>,\par
00832                                                 {\cf17 const} base_t&\par
00833                                 >\par
00834         \{\par
00835                 {\cf19 if} {\cf17 constexpr} (!with_result_type) \{\par
00837                         dig_t borrow\{dig_t::dig_0()\};\par
00839                         {\cf19 if} (arg[0].is_not_0()) \{\par
00840                                 --arg[0];\par
00841                                 {\cf19 return} (arg);\par
00842                         \} {\cf19 else} \{\par
00843                                 arg[0] = dig_t::dig_Bm1();\par
00844                                 borrow = dig_t::dig_1();\par
00845                         \}\par
00847                         {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
00848                                 {\cf19 if} (borrow.is_not_0()) \{\par
00849                                         {\cf19 if} (arg[ix].is_not_0()) \{\par
00850                                                 --arg[ix];\par
00851                                                 {\cf19 return} (arg);\par
00852                                         \}\par
00853                                         {\cf19 else} {\cf19 if} (arg[ix].is_0()) \{\par
00854                                                 arg[ix] = dig_t::dig_Bm1();\par
00855                                                 borrow = dig_t::dig_1();\par
00856                                         \}\par
00857                                 \}\par
00858                         \}\par
00859                         {\cf19 return} (arg);\par
00860                 \}\par
00861                 {\cf19 else} \{\par
00863                         res_base_op_t<binop_e::sub> ret\{\par
00864                                 .result_content_low     =       arg,\par
00865                                 .borrow                                                 =       dig_t::dig_0(),\par
00866                                 .good_result                            =       {\cf17 true}\par
00867                         \};\par
00869                         {\cf17 auto}& result\{ret.result_content_low\};\par
00871                         dig_t& borrow\{ret.borrow\};\par
00873                         {\cf18 bool}& good\{ret.good_result\};\par
00875                         {\cf19 if} (arg[0].is_not_0()) \{\par
00876                                 --result[0];\par
00877                                 borrow          = dig_t::dig_0();\par
00878                                 {\cf19 return} std::move(ret);\par
00879                         \} {\cf19 else} \{\par
00880                                 result[0] = dig_t::dig_Bm1();\par
00881                                 borrow          = dig_t::dig_1();\par
00882                         \}\par
00885                         {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
00886                                 {\cf19 if} (borrow.is_not_0()) \{\par
00887                                         {\cf19 if} (arg[ix].is_not_0()) \{\par
00888                                                 --result[ix];\par
00889                                                 borrow = dig_t::dig_0();\par
00890                                                 {\cf19 return} std::move(ret);\par
00891                                         \}\par
00892                                         {\cf19 else} \{\par
00893                                                 result[ix] = dig_t::dig_Bm1();\par
00894                                                 borrow = dig_t::dig_1();\par
00895                                                 {\cf19 continue};\par
00896                                         \}\par
00897                                 \}\par
00898                         \}\par
00899                         {\cf19 if} (borrow.is_not_0()) \{\par
00900                                 good = {\cf17 false};\par
00901                         \}\par
00902                         {\cf19 return} std::move(ret);\par
00903                 \}\par
00904         \}\par
00905 \par
00906 public :\par
00907 \par
00908         {\cf17 constexpr} {\cf17 inline}\par
00909         {\cf17 const} nat_reg_digs_t & operator -- () noexcept\par
00910         \{\par
00911                 predecrement<false>(base_ref_cthis);\par
00912                 {\cf19 return} (*{\cf17 this});\par
00913         \}\par
00914 \par
00915 private :\par
00916 \par
00917         {\cf17 template}<{\cf18 bool} with_result_type>\par
00918         {\cf17 constexpr} {\cf17 inline}\par
00919         {\cf17 auto} postdecrement(base_t& arg) {\cf17 noexcept} ->\par
00920                 std::conditional<\par
00921                                 with_result_type,\par
00922                                                 res_base_op_t<binop_e::sub>,\par
00923                                                 {\cf17 const} base_t&\par
00924                                 >\par
00925         \{\par
00926                 base_t cparg\{{\cf17 static_cast<}base_t{\cf17 >}(arg)\};\par
00927                 {\cf19 if} {\cf17 constexpr} (with_result_type) \{\par
00928                         res_base_op_t<binop_e::sub> ret\{predecrement<true>(arg)\};\par
00929                         ret.result_content_low = std::move(cparg);\par
00930                         {\cf19 return} std::move(ret);\par
00931                 \}\par
00932                 {\cf19 else} \{\par
00933                         predecrement<false>(arg);\par
00934                         {\cf19 return} (cparg);\par
00935                 \}\par
00936         \}\par
00937 \par
00938 public :\par
00939 \par
00940         {\cf17 constexpr} {\cf17 inline}\par
00941         {\cf17 const} nat_reg_digs_t & operator -- ({\cf18 int}) {\cf17 noexcept}\par
00942         \{\par
00943                 postdecrement<false>(base_ref_cthis);\par
00944                 {\cf19 return} (*{\cf17 this});\par
00945         \}\par
00946 \par
00947 {\cf20                                                                 /****************************/}\par
00948                                                                 {\cf20 /*                                                                                                      */}\par
00949                                                                 {\cf20 /* OPERADORES ARITMETICOS               */}\par
00950                                                                 {\cf20 /*       C_B()  C_Bm1()                                 */}\par
00951                                                                 {\cf20 /*      mC_B() mC_Bm1()                 */}\par
00952                                                                 {\cf20 /*      operator!() operator-() */}\par
00953                                                                 {\cf20 /*                          */}\par
00954 {\cf20                                                                 /****************************/}\par
00955 \par
00956 {\cf20 //}\par
00957 {\cf20 //public :}\par
00958 {\cf20 //}\par
00959 {\cf20 //      constexpr inline}\par
00960 {\cf20 //      const nat_reg_digs_t & mC_B() noexcept}\par
00961 {\cf20 //      \{}\par
00962 {\cf20 //              mC_B(base_ref_cthis);}\par
00963 {\cf20 //              return (*this);}\par
00964 {\cf20 //      \}}\par
00965 {\cf20 //}\par
00966 {\cf20 //      constexpr inline}\par
00967 {\cf20 //      const nat_reg_digs_t & mC_Bm1() noexcept}\par
00968 {\cf20 //      \{}\par
00969 {\cf20 //              mC_Bm1(base_ref_cthis);}\par
00970 {\cf20 //              return (*this);}\par
00971 {\cf20 //      \}}\par
00972 {\cf20 //}\par
00973 {\cf20 //      constexpr inline}\par
00974 {\cf20 //      nat_reg_digs_t C_Bm1() const noexcept}\par
00975 {\cf20 //      \{}\par
00976 {\cf20 //              return nat_reg_digs_t\{C_Bm1(base_ref_cthis())\};}\par
00977 {\cf20 //      \}}\par
00978 {\cf20 //}\par
00979 {\cf20 //      constexpr inline}\par
00980 {\cf20 //      nat_reg_digs_t C_B() const noexcept}\par
00981 {\cf20 //      \{}\par
00982 {\cf20 //              return nat_reg_digs_t\{C_B(base_const_ref_cthis())\};}\par
00983 {\cf20 //      \}}\par
00984 {\cf20 //}\par
00985 {\cf20 //      constexpr inline}\par
00986 {\cf20 //      nat_reg_digs_t operator !() const noexcept}\par
00987 {\cf20 //      \{}\par
00988 {\cf20 //              return C_Bm1();}\par
00989 {\cf20 //      \}}\par
00990 {\cf20 //}\par
00991 {\cf20 //      constexpr inline}\par
00992 {\cf20 //      nat_reg_digs_t operator -() const noexcept}\par
00993 {\cf20 //      \{}\par
00994 {\cf20 //              return C_B();}\par
00995 {\cf20 //      \}}\par
00996 \par
00997 \par
00999 \par
01004 \par
01005 private :\par
01006 \par
01007         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01008         base_t rem_B({\cf17 const} base_t & larg,{\cf18 size_t} n) {\cf17 noexcept}\par
01009         \{\par
01010                 base_t ret\{larg\};\par
01011                 ret <<= L-n;\par
01012                 {\cf19 return} std::move(ret);\par
01013         \}\par
01014 \par
01015         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01016         {\cf17 const} base_t & m_rem_B(base_t& larg,{\cf18 size_t} n) {\cf17 noexcept}\par
01017         \{\par
01018                 larg <<= L-n;\par
01019                 {\cf19 return} (larg);\par
01020         \}\par
01021 \par
01022 \par
01023         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01024         base_t mer_B({\cf17 const} base_t & larg,{\cf18 size_t} n) {\cf17 noexcept}\par
01025         \{\par
01026                 base_t ret\{larg\};\par
01027                 ret >>= L-n;\par
01028                 {\cf19 return} std::move(ret);\par
01029         \}\par
01030 \par
01031         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01032         {\cf17 const} base_t & m_mer_B(base_t& larg,{\cf18 size_t} n) {\cf17 noexcept}\par
01033         \{\par
01034                 larg >>= L-n;\par
01035                 {\cf19 return} (larg);\par
01036         \}\par
01037 \par
01038 \par
01039 public :\par
01040 \par
01041         {\cf17 constexpr} {\cf17 inline}\par
01042         nat_reg_digs_t operator << ({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept}\par
01043         \{\par
01044                 nat_reg_digs_t cpthis\{*{\cf17 this}\};\par
01045                 cpthis.ref_data() <<= n;\par
01046                 {\cf19 return} std::move(cpthis);\par
01047         \}\par
01048 \par
01049         {\cf17 constexpr} {\cf17 inline}\par
01050         {\cf17 const} nat_reg_digs_t & operator <<= ({\cf18 size_t} n) {\cf17 noexcept}\par
01051         \{\par
01052                 base_ref_cthis() <<= n;\par
01053                 {\cf19 return} (*{\cf17 this});\par
01054         \}\par
01055 \par
01056         {\cf17 constexpr} {\cf17 inline}\par
01057         nat_reg_digs_t operator >> ({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept}\par
01058         \{\par
01059                 {\cf19 return} (nat_reg_digs_t\{*{\cf17 this}\}.ref_data() >>= n);\par
01060         \}\par
01061 \par
01062         {\cf17 constexpr} {\cf17 inline}\par
01063         {\cf17 const} nat_reg_digs_t & operator >>= ({\cf18 size_t} n) {\cf17 noexcept}\par
01064         \{\par
01065                 base_ref_cthis >>= n;\par
01066                 {\cf19 return} (*{\cf17 this});\par
01067         \}\par
01068 \par
01069         {\cf17 constexpr} {\cf17 inline}\par
01070         nat_reg_digs_t rem_B({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept}\par
01071         \{\par
01072                 nat_reg_digs_t ret\{rem_B(base_ref_cthis,n)\};\par
01073                 {\cf19 return} ret;\par
01074         \}\par
01075 \par
01076         {\cf17 constexpr} {\cf17 inline}\par
01077         {\cf17 const} nat_reg_digs_t & m_rem_B({\cf18 size_t} n) {\cf17 noexcept}\par
01078         \{\par
01079                 m_rem_B(base_ref_cthis(),n);\par
01080                 {\cf19 return} (*{\cf17 this});\par
01081         \}\par
01082 \par
01083         {\cf17 constexpr} {\cf17 inline}\par
01084         nat_reg_digs_t mer_B({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept}\par
01085         \{\par
01086                 nat_reg_digs_t ret\{mer_B(base_ref_cthis(),n)\};\par
01087                 {\cf19 return} std::move(ret);\par
01088         \}\par
01089 \par
01090         {\cf17 constexpr} {\cf17 inline}\par
01091         {\cf17 const} nat_reg_digs_t & m_mer_B({\cf18 size_t} n) {\cf17 noexcept}\par
01092         \{\par
01093                 m_mer_B(base_ref_cthis(),n);\par
01094                 {\cf19 return} (*{\cf17 this});\par
01095         \}\par
01096 \par
01098 \par
01100 \par
01101 public :\par
01102 \par
01103         {\cf17 constexpr} {\cf17 inline}\par
01104         {\cf17 const} nat_reg_digs_t & operator |= ({\cf17 const} nat_reg_digs_t & arg) {\cf17 noexcept}\par
01105         \{\par
01106                 base_ref_cthis() |= arg.base_const_ref_cthis();\par
01107                 {\cf19 return} (*{\cf17 this});\par
01108         \}\par
01109 \par
01110         {\cf17 constexpr} {\cf17 inline}\par
01111         nat_reg_digs_t operator | ({\cf17 const} nat_reg_digs_t & arg) {\cf17 noexcept}\par
01112         \{\par
01113                 nat_reg_digs_t ret\{*{\cf17 this}\};\par
01114                 ret |= arg;\par
01115                 {\cf19 return} std::move(ret);\par
01116         \}\par
01117 \par
01118         {\cf17 constexpr} {\cf17 inline}\par
01119         {\cf17 const} nat_reg_digs_t & operator &= ({\cf17 const} nat_reg_digs_t & arg) {\cf17 noexcept}\par
01120         \{\par
01121                 base_ref_cthis() &= arg.base_const_ref_cthis();\par
01122                 {\cf19 return} (*{\cf17 this});\par
01123         \}\par
01124 \par
01125         {\cf17 constexpr} {\cf17 inline}\par
01126         nat_reg_digs_t operator & ({\cf17 const} nat_reg_digs_t & arg) {\cf17 noexcept}\par
01127         \{\par
01128                 nat_reg_digs_t ret\{*{\cf17 this}\};\par
01129                 ret &= arg;\par
01130                 {\cf19 return} std::move(ret);\par
01131         \}\par
01132 \par
01134 \par
01135 \par
01136 {\cf20                                         /************************************/}\par
01137                                         {\cf20 /* OPERADORES ARITMETICOS BASICOS               */}\par
01138                                         {\cf20 /*                      nat_reg_digs_t  @  dig_t                */}\par
01139                                         {\cf20 /*      nat_reg_digs_t  @= dig_t    */}\par
01140                                         {\cf20 /*      nat_reg_digs_t  @  10B^n    */}\par
01141                                         {\cf20 /*      nat_reg_digs_t  @= 10B^n    */}\par
01142 {\cf20                                         /************************************/}\par
01143 \par
01144 {\cf20                                         /************************************/}\par
01145                                         {\cf20 /*                                                                                                                              */}\par
01146                                         {\cf20 /*  ARITMETICOS CON ASIGNACION                  */}\par
01147                                         {\cf20 /*              nat_reg_digs_t @= dig_t                         */}\par
01148                                         {\cf20 /*                                  */}\par
01149 {\cf20                                         /************************************/}\par
01150 \par
01155         {\cf17 template}<{\cf18 bool} with_result_type>\par
01156         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01157         {\cf17 auto} m_add (base_t & larg,{\cf17 const} dig_t & rarg) {\cf17 noexcept} ->\par
01158                 {\cf17 typename} std::conditional_t<\par
01159                         with_result_type,\par
01160                                 res_base_op_t<binop_e::add>,\par
01161                                 base_t\par
01162                 >\par
01163         \{\par
01164                 {\cf17 using namespace }type_traits;\par
01165                 {\cf17 constexpr} UINT_T middle_max\{std::numeric_limits<UINT_T>::max()/2\};\par
01166                 {\cf17 using }SIG_UINT_T = sig_UInt_for_UInt_t<UINT_T>;\par
01167                 {\cf17 using }uint_type = std::conditional_t<B<=middle_max,UINT_T,SIG_UINT_T>;\par
01168                 {\cf17 using }dig_t = {\cf17 typename} NumRepr::dig_t<uint_type,B>::dig_t;\par
01169                 {\cf19 if} {\cf17 constexpr} (! with_result_type) \{\par
01171                         dig_t carry\{dig_t::dig_0()\};\par
01173                         {\cf19 if} (larg[0] <= dig_t::dig_Bm1()-rarg) \{\par
01174                                 larg[0] += rarg;\par
01175                                 {\cf19 return} (larg);\par
01176                         \}\par
01177                         {\cf19 else} \{\par
01178                                 larg[0] -= (dig_t::dig_Bm1()-rarg+1);\par
01179                                 carry = dig_t::dig_1();\par
01180                         \}\par
01182                         {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
01183                                 {\cf19 if} (carry.is_1()) \{\par
01184                                         {\cf19 if} (larg[ix].is_Bm1()) \{\par
01185                                                 larg[ix] = dig_t::dig_0();\par
01186                                                 carry = dig_t::dig_1();\par
01187                                         \}\par
01188                                         {\cf19 else} \{\par
01189                                                 ++larg[ix];\par
01190                                                 {\cf19 return} (larg);\par
01191                                         \}\par
01192                                 \}\par
01193                         \}\par
01194                         {\cf19 return} (larg);\par
01195                 \}\par
01196                 {\cf19 else} \{\par
01198                         res_base_op_t<binop_e::add> ret\{\par
01199                                 .result_content_low             =               larg,\par
01200                                 .carry                                                          =               dig_t::dig_0(),\par
01201                                 .good_result                                    =               {\cf17 true}\par
01202                         \};\par
01204                         {\cf17 auto}&           result\{ret.result_content_low\};\par
01206                         dig_t&  carry\{ret.carry\};\par
01208                         {\cf18 bool}&           good\{ret.good_result\};\par
01210                         {\cf19 if} (larg[0] <= dig_t::dig_Bm1()-rarg) \{\par
01211                                 result[0]       +=      rarg;\par
01212                                 carry                                            =      dig_t::dig_0();\par
01213                                 {\cf19 return} std::move(ret);\par
01214                         \}\par
01215                         {\cf19 else} \{\par
01216                                 ret.result_content[0]   -= (dig_t::dig_Bm1()+dig_t::dig_1()-rarg);\par
01217                                 carry                    = dig_t::dig_1();\par
01218                         \}\par
01220                         {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
01221                                 {\cf19 if} (carry.is_not_0()) \{\par
01222                                         {\cf19 if} (result[ix].is_Bm1()) \{\par
01223                                                 result[ix]  = dig_t::dig_0();\par
01224                                                 carry       = dig_t::dig_1();\par
01225                                         \}\par
01226                                         {\cf19 else} \{\par
01227                                                 ++result[ix];\par
01228                                                 carry = dig_t::dig_0();\par
01229                                         \}\par
01230                                 \}\par
01231                         \}\par
01232                         {\cf19 if} (carry.is_not_0())\par
01233                                 good = {\cf17 false};\par
01234                         {\cf19 return} std::move(ret);\par
01235                 \}\par
01236         \}\par
01237 \par
01239         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01240         {\cf17 const} base_t & m_sub(base_t & larg,{\cf17 const} dig_t & rarg) {\cf17 noexcept}\par
01241         \{\par
01243                 dig_t cprarg\{rarg\};\par
01245                 dig_t borrow\{dig_t::dig_0()\};\par
01247                 {\cf19 if} (larg[0] >= rarg) \{\par
01248                         larg[0] -= rarg;\par
01249                         borrow = dig_t::dig_0();\par
01250                         {\cf19 return} (larg);\par
01251                 \}\par
01252                 {\cf19 else} \{\par
01253                         cprarg -= larg[0];\par
01254                         larg[0] = cprarg.C_B();\par
01255                         borrow  = dig_t::dig_1();\par
01256                 \}\par
01258                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix) \{\par
01259                         {\cf19 if} (borrow.is_1()) \{\par
01260                                 {\cf19 if} (larg[ix].is_0()) \{\par
01261                                         larg[ix] = dig_t::dig_Bm1();\par
01262                                         borrow  = dig_t::dig_1();\par
01263                                         {\cf19 continue};\par
01264                                 \}\par
01265                                 {\cf19 else} \{\par
01266                                         --larg[ix];\par
01267                                         borrow = dig_t::dig_0();\par
01268                                         {\cf19 return} (larg);\par
01269                                 \}\par
01270                         \}\par
01271                 \}\par
01272                 {\cf19 return} (larg);\par
01273         \}\par
01274 \par
01275         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01276         base_t add ({\cf17 const} base_t & larg,{\cf17 const} dig_t & rarg) {\cf17 noexcept}\par
01277         \{\par
01278                 {\cf19 return} m_add<false>(larg,rarg);\par
01279         \}\par
01280 \par
01281         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01282         base_t sub ({\cf17 const} base_t & larg,{\cf17 const} dig_t & rarg) {\cf17 noexcept}\par
01283         \{\par
01284                 {\cf19 return} m_sub<false>(larg,rarg);\par
01285         \}\par
01286 \par
01287 public :\par
01288 \par
01289         {\cf17 constexpr} {\cf17 inline}\par
01290         {\cf17 const} nat_reg_digs_t & operator += ({\cf17 const} dig_t& rarg) {\cf17 noexcept}\par
01291         \{\par
01292                 m_add<false>(base_ref_cthis(),rarg);\par
01293                 {\cf19 return} (*{\cf17 this});\par
01294         \}\par
01295 \par
01296         {\cf17 constexpr} {\cf17 inline}\par
01297         {\cf17 const} nat_reg_digs_t & operator -= ({\cf17 const} dig_t& rarg) {\cf17 noexcept}\par
01298         \{\par
01299                 m_sub<false>(base_ref_cthis(),rarg);\par
01300                 {\cf19 return} (*{\cf17 this});\par
01301         \}\par
01302 \par
01303         {\cf17 constexpr} {\cf17 inline}\par
01304         nat_reg_digs_t operator + ({\cf17 const} dig_t& rarg) {\cf17 noexcept}\par
01305         \{\par
01306                 {\cf19 return} nat_reg_digs_t\{add(base_const_ref_cthis(),rarg)\};\par
01307         \}\par
01308 \par
01309         {\cf17 constexpr} {\cf17 inline}\par
01310         nat_reg_digs_t operator - ({\cf17 const} dig_t& rarg) {\cf17 noexcept}\par
01311         \{\par
01312                 {\cf19 return} nat_reg_digs_t\{sub(base_const_ref_cthis(),rarg)\};\par
01313         \}\par
01314 \par
01315 private :\par
01316 \par
01319         {\cf17 template}<{\cf18 bool} with_result_type>\par
01320         {\cf17 constexpr} {\cf17 inline}\par
01321         {\cf17 auto} mult(dig_t arg) {\cf17 const} {\cf17 noexcept} ->\par
01322                 std::conditional_t<\par
01323                         with_result_type,\par
01324                                 res_base_op_t<binop_e::mult>,\par
01325                                 {\cf17 const} base_t &\par
01326                 >\par
01327         \{\par
01328                 nat_reg_digs_t cpthis(*{\cf17 this});\par
01329                 {\cf19 if} {\cf17 constexpr} (with_result_type) \{\par
01330                         res_base_op_t<binop_e::mult> ret\{\par
01331                                 .result_content_low     = base_const_ref_cthis(),\par
01332                                 .result_content_high    = regd_0(),\par
01333                                 .good_result                                    = {\cf17 true}\par
01334                         \};\par
01335                         base_t & res_low \{ret.result_content_low \};\par
01336                         base_t & res_high\{ret.result_content_high\};\par
01337                         {\cf18 bool}   & good\{ret.good_result\};\par
01338                         {\cf19 if} (arg.is_0()) \{\par
01339                                 res_low         = regd_0();\par
01340                                 {\cf19 return} std::move(ret);\par
01341                         \}\par
01342                         {\cf19 else} {\cf19 if} (nat_reg_digs_t::is_0()) \{\par
01343                                 {\cf19 return} std::move(ret);\par
01344                         \}\par
01345                         {\cf19 else} {\cf19 if} (arg.is_1()) \{\par
01346                                 {\cf19 return} std::move(ret);\par
01347                         \}\par
01348                         {\cf19 else} {\cf19 if} (nat_reg_digs_t::is_1()) \{\par
01349                                 res_low.set_0();\par
01350                                 res_low[0] = arg;\par
01351                                 {\cf19 return} std::move(ret);\par
01352                         \}\par
01353                         {\cf19 else} \{\par
01354                                 {\cf17 constexpr} UINT_T sqrt_max\{type_traits::sqrt_max<UINT_T>()\};\par
01355                                 {\cf17 using }uint_type = std::conditional_t<\par
01356                                         B <= sqrt_max ,\par
01357                                                 UINT_T,\par
01358                                                 SIG_UINT_T\par
01359                                 >;\par
01360                                 {\cf17 constexpr} uint_type Bc\{B\};\par
01361                                 uint_type carry\{0\};\par
01362                                 uint_type cparg\{arg()\};\par
01363                                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\{\par
01364                                         uint_type digint\{const_by_index(ix)\};\par
01365                                         digint *= cparg;\par
01366                                         uint_type unds\{digint % Bc\};\par
01367                                         uint_type decs\{digint / Bc\};\par
01368                                         {\cf19 if} (unds < (Bc-1)-carry) \{\par
01369                                                 unds += carry;\par
01370                                                 carry = 0;\par
01371                                         \}\par
01372                                         {\cf19 else} \{\par
01373                                                 {\cf17 const} uint_type raw_sum\{unds+carry\};\par
01374                                                 decs += raw_sum/Bc;\par
01375                                                 unds    = raw_sum%Bc;\par
01376                                                 carry = decs;\par
01377                                         \}\par
01378                                         res_low[ix] = unds;\par
01379                                 \}\par
01380                                 {\cf19 if} (carry != 0) \{\par
01381                                         res_high[0] = dig_t(carry);\par
01382                                         good = {\cf17 false};\par
01383                                 \}\par
01384                                 {\cf19 return} std::move(ret);\par
01385                         \}\par
01386                 \}\par
01387                 {\cf19 else} \{\par
01388                         base_t ret\{base_const_ref_cthis()\};\par
01389                         {\cf19 if} (arg.is_0()) \{                   {\cf20 // ????}\par
01390                                 {\cf19 return} std::move(regd_0());\par
01391                         \}\par
01392                         {\cf19 else} {\cf19 if} (nat_reg_digs_t::is_0()) \{  {\cf20 // ????}\par
01393                                 {\cf19 return} std::move(regd_0());\par
01394                         \}\par
01395                         {\cf19 else} {\cf19 if} (arg.is_1()) \{\par
01396                                 {\cf19 return} std::move(ret);\par
01397                         \}\par
01398                         {\cf19 else} {\cf19 if} (nat_reg_digs_t::is_1()) \{ {\cf20 //?????}\par
01399                                 ret.set_0();\par
01400                                 ret[0] = arg;\par
01401                                 {\cf19 return} std::move(ret);\par
01402                         \}\par
01403                         {\cf19 else} \{\par
01404                                 {\cf17 constexpr} UINT_T sqrt_max\{type_traits::sqrt_max<UINT_T>()\};\par
01405                                 {\cf17 using }uint_type = std::conditional_t<\par
01406                                         B <= sqrt_max ,\par
01407                                                 UINT_T,\par
01408                                                 SIG_UINT_T\par
01409                                 >;\par
01410                                 {\cf17 constexpr} uint_type Bc\{B\};\par
01411                                 uint_type carry\{0\};\par
01412                                 uint_type cparg\{arg()\};\par
01413                                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\{\par
01414                                         uint_type digint\{const_by_index(ix)\};\par
01415                                         digint *= cparg;\par
01416                                         uint_type unds\{digint % B\};\par
01417                                         uint_type decs\{digint / B\};\par
01418                                         {\cf19 if} (unds < (Bc-1)-carry) \{\par
01419                                                 unds += carry;\par
01420                                         \}\par
01421                                         {\cf19 else} \{\par
01422                                                 decs += (unds+carry)/Bc;\par
01423                                                 unds    = (unds+carry)%Bc;\par
01424                                                 carry = decs;\par
01425                                         \}\par
01426                                         ret[ix] = unds;\par
01427                                 \}\par
01428                                 {\cf19 return} std::move(ret);\par
01429                         \}\par
01430                 \}\par
01431         \}\par
01432 \par
01433 {\cf20 //  /// TO DO REPASAR}\par
01434 {\cf20 //      /// '@' = '+'}\par
01435 {\cf20 //      constexpr inline}\par
01436 {\cf20 //      std::array<nat_reg_digs_t,2> add(dig_t arg) const}\par
01437 {\cf20 //      noexcept \{}\par
01438 {\cf20 //              const nat_reg_digs_t& cthis\{*this\};}\par
01439 {\cf20 //              std::array<nat_reg_digs_t,2> result\{dig_t::dig_0(),cthis\};}\par
01440 {\cf20 //              dig_t carry\{dig_t::dig_0()\};}\par
01441 {\cf20 //              for(size_t ix\{0\} ; ix < L ; ++ix) \{}\par
01442 {\cf20 //                      auto    temp_result   =      result[0][ix].add(arg);}\par
01443 {\cf20 //                      auto  temp_result_2 = temp_result[0][ix].add(carry);}\par
01444 {\cf20 //                      result[0][ix] = temp_result_2[0];}\par
01445 {\cf20 //                      result[1][0]  = temp_result_2[1];}\par
01446 {\cf20 //                      carry = result[1][0];}\par
01447 {\cf20 //              \}}\par
01448 {\cf20 //              for(size_t ix\{1\} ; ix < L ; ++ix) \{}\par
01449 {\cf20 //                      result[1][ix] = dig_t::dig_0();}\par
01450 {\cf20 //              \}}\par
01451 {\cf20 //              return result;}\par
01452 {\cf20 //      \}}\par
01453 {\cf20 //}\par
01454 {\cf20 //      /// TO DO REPASAR}\par
01455 {\cf20 //      /// '@' = '-'}\par
01456 {\cf20 //      constexpr inline}\par
01457 {\cf20 //      std::array<nat_reg_digs_t,2> sub(dig_t arg) const}\par
01458 {\cf20 //      noexcept \{}\par
01459 {\cf20 //              const nat_reg_digs_t& cthis\{*this\};}\par
01460 {\cf20 //              std::array<nat_reg_digs_t,2> result\{dig_t::dig_0(),cthis\};}\par
01461 {\cf20 //              nat_reg_digs_t cb_arg\{-arg\};}\par
01462 {\cf20 //              if (!(arg.is_0())) \{}\par
01463 {\cf20 //                      for(size_t ix\{1\} ; ix < L ; ++ix) \{}\par
01464 {\cf20 //                              cb_arg[ix] = dig_t::dig_Bm1();}\par
01465 {\cf20 //                      \}}\par
01466 {\cf20 //              \}}\par
01467 {\cf20 //              dig_t carry\{dig_t::dig_0()\};}\par
01468 {\cf20 //              for(size_t ix\{0\} ; ix < L ; ++ix) \{}\par
01469 {\cf20 //                      auto    temp_result   =      result[0][ix].add(cb_arg[ix]);}\par
01470 {\cf20 //                      auto  temp_result_2 =     temp_result[0].add(carry);}\par
01471 {\cf20 //                      result[0][ix]  = temp_result_2[0];}\par
01472 {\cf20 //                      result[1][ix]  = (temp_result_2[1].add(temp_result_2[1]))[0];}\par
01473 {\cf20 //                      carry = result[1][ix];}\par
01474 {\cf20 //              \}}\par
01475 {\cf20 //              return result;}\par
01476 {\cf20 //      \}}\par
01477 \par
01478 \par
01479 {\cf20                                         /********************************/}\par
01480                                         {\cf20 /*                                                                                                                      */}\par
01481                                         {\cf20 /*    OPERADORES ARITMETICOS            */}\par
01482                                         {\cf20 /*              nat_reg_digs_t @ dig_t          */}\par
01483                                         {\cf20 /*                                                                                                                      */}\par
01484 {\cf20                                         /********************************/}\par
01485 \par
01486 public :\par
01487 \par
01488                 {\cf17 constexpr} {\cf17 inline}\par
01489                 {\cf17 auto} operator + (dig_t arg) {\cf17 const} {\cf17 noexcept}\par
01490                 \{\par
01491                         nat_reg_digs_t ret(*{\cf17 this});\par
01492                         ret += arg;\par
01493                         {\cf19 return} ret;\par
01494                 \}\par
01495 \par
01496                 {\cf17 constexpr} {\cf17 inline}\par
01497                 {\cf17 auto} operator - (dig_t arg) {\cf17 const} {\cf17 noexcept}\par
01498                 \{\par
01499                         nat_reg_digs_t ret(*{\cf17 this});\par
01500                         ret -= arg;\par
01501                         {\cf19 return} ret;\par
01502                 \}\par
01503 \par
01504                 {\cf17 constexpr} {\cf17 inline}\par
01505                 {\cf17 auto} operator * (dig_t arg) {\cf17 const} {\cf17 noexcept}\par
01506                 \{\par
01507                         nat_reg_digs_t ret(*{\cf17 this});\par
01508                         ret *= arg;\par
01509                         {\cf19 return} ret;\par
01510                 \}\par
01511 \par
01512 {\cf20 //              template<size_t N>}\par
01513 {\cf20 //              static constexpr inline}\par
01514 {\cf20 //              auto fediv<N,1>(const base_N_t<N>& larg,const base_N_t<1>& rarg)}\par
01515 {\cf20 //              noexcept -> res_base_N_op_t<binop_e::fediv,N> \{}\par
01516 {\cf20 //                      const dig_t & arg\{rarg[0]\};}\par
01517 {\cf20 //                      return fediv<N>(larg,arg);}\par
01518 {\cf20 //              \}}\par
01519 \par
01521                 {\cf17 constexpr} {\cf17 inline}\par
01522                 nat_reg_digs_t operator / (dig_t arg) {\cf17 const} {\cf17 noexcept}\par
01523                 \{\par
01524                         {\cf19 return} ((this->fediv(arg)).result_content_quotient);\par
01525                 \}\par
01526 \par
01528                 {\cf17 constexpr} {\cf17 inline}\par
01529                 nat_reg_digs_t operator % (dig_t arg) {\cf17 const} {\cf17 noexcept}\par
01530                 \{\par
01531                         {\cf19 return} ((this->fediv(arg)).result_content_remainder);\par
01532                 \}\par
01533 \par
01534 {\cf20                                                                 /****************************************/}\par
01535                                                                 {\cf20 /*                                                                                                                                      */}\par
01536                                                                 {\cf20 /* OPERADORES ARITMETICOS                                                       */}\par
01537                                                                 {\cf20 /* nat_reg_digs_t @ nat_reg_digs_t                      */}\par
01538                                                                 {\cf20 /*                                                              */}\par
01539 {\cf20                                                                 /****************************************/}\par
01540 \par
01541         {\cf17 template}<{\cf18 size_t} N>\par
01542                 {\cf17 requires} (N>0)\par
01543         {\cf17 constexpr} {\cf17 inline}\par
01544         {\cf17 const} nat_reg_digs_t & {\cf17 operator} += ({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept}\par
01545         \{\par
01546                 nat_reg_digs_t & cthis = (*this);\par
01547                 dig_t                           carry\{0\};\par
01548                 {\cf19 if} {\cf17 constexpr} (N < L) \{\par
01549                         {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < N ; ++ix) \{\par
01550                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01551                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01552                                 {\cf17 const} dig_t     cparg\{arg[ix]\};\par
01553                                 cthis += cparg;\par
01554                                 cthis += carry;\par
01555                                 {\cf19 if} ((cthis < cpthis) || (cparg < cpthis))\par
01556                                         carry = dig_t::dig_1();\par
01557                         \}\par
01558                         {\cf19 for} ({\cf18 size_t} ix\{N\} ; ix < L ; ++ix) \{\par
01559                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01560                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01561                                 cthis += carry;\par
01562                                 {\cf19 if} (cthis < cpthis)\par
01563                                         carry = dig_t::dig_1();\par
01564                         \}\par
01565                 \}\par
01566                 {\cf19 else} \{\par
01567                         {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < L ; ++ix) \{\par
01568                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01569                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01570                                 {\cf17 const} dig_t     cparg\{arg[ix]\};\par
01571                                 cthis += cparg;\par
01572                                 cthis += carry;\par
01573                                 {\cf19 if} ((cthis < cpthis) || (cparg < cpthis))\par
01574                                         carry = dig_t::dig_1();\par
01575                         \}\par
01576                 \}\par
01577                 {\cf19 return} (cthis);\par
01578         \}\par
01579 \par
01580         {\cf17 template}<{\cf18 size_t} N>\par
01581                 {\cf17 requires} (N>0)\par
01582         {\cf17 constexpr} {\cf17 inline}\par
01583         {\cf17 const} nat_reg_digs_t & {\cf17 operator} += ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
01584         \{\par
01585                 (*this)+= arg.m_dc;\par
01586                 {\cf19 return} (*{\cf17 this});\par
01587         \}\par
01588 \par
01589         {\cf17 template}<{\cf18 size_t} N>\par
01590                 {\cf17 requires} (N>0)\par
01591         {\cf17 constexpr} {\cf17 inline}\par
01592         {\cf17 const} nat_reg_digs_t & {\cf17 operator} -= ({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept}\par
01593         \{\par
01594                 nat_reg_digs_t & cthis\{*{\cf17 this}\};\par
01595                 base_N_t<N> cparg\{arg\};\par
01597                         {\cf20 // begin}\par
01598                         {\cf19 for}({\cf17 auto} & elem_dig : cparg) \{\par
01599                                 elem_dig = dig_t(B-1)-elem_dig;\par
01600                         \}\par
01601                         dig_t                   carry\{0\};\par
01602                         {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < N ; ++ix) \{\par
01603                                 dig_t&                          cthis\{cthis.m_dc[ix]\};\par
01604                                 {\cf17 const} dig_t     cpthis\{cthis.m_dc[ix]\};\par
01605                                 cthis += carry;\par
01606                                 {\cf19 if} (cthis < cpthis)\par
01607                                         carry = dig_t::dig_1();\par
01608                         \}\par
01609                         {\cf20 // end}\par
01610                 cthis += cparg;\par
01611                 {\cf19 return} (cthis);\par
01612         \}\par
01613 \par
01614         {\cf17 template}<{\cf18 size_t} N>\par
01615                 {\cf17 requires} (N>0)\par
01616         {\cf17 constexpr} {\cf17 inline}\par
01617         {\cf17 const} nat_reg_digs_t & {\cf17 operator} -= ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
01618         \{\par
01619                 (*this)-= arg.m_dc;\par
01620                 {\cf19 return} (*{\cf17 this});\par
01621         \}\par
01622 \par
01623         {\cf17 template}<{\cf18 size_t} N>\par
01624                 {\cf17 requires} (N>0)\par
01625         {\cf17 constexpr} {\cf17 inline}\par
01626         {\cf17 const} nat_reg_digs_t & {\cf17 operator} *= ({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept}\par
01627         \{\par
01628                 nat_reg_digs_t cpthis\{*{\cf17 this}\};\par
01629                 nat_reg_digs_t& cthis\{0\};\par
01630                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < N ; ++ix) \{\par
01631                         cthis += (cpthis*arg[ix]);\par
01632                         cpthis <<= 1;\par
01633                 \}\par
01634                 {\cf19 return} (cthis);\par
01635         \}\par
01636 \par
01637         {\cf17 template}<{\cf18 size_t} N>\par
01638                 {\cf17 requires} (N>0)\par
01639         {\cf17 constexpr} {\cf17 inline}\par
01640         {\cf17 const} nat_reg_digs_t & {\cf17 operator} *= ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
01641         \{\par
01642                 (*this)*= arg.m_dc;\par
01643                 {\cf19 return} (*{\cf17 this});\par
01644         \}\par
01645 \par
01647 {\cf20 //      constexpr inline}\par
01648 {\cf20 //      const nat_reg_digs_t & operator /= (const nat_reg_digs_t & arg)}\par
01649 {\cf20 //      noexcept \{}\par
01650 {\cf20 //              nat_reg_digs_t & ret = (*this);}\par
01651 {\cf20 //              /// TO DO}\par
01652 {\cf20 //              return (*this);}\par
01653 {\cf20 //      \}}\par
01655 {\cf20 }{\cf20 //      constexpr inline}\par
01656 {\cf20 //      const nat_reg_digs_t & operator %= (const nat_reg_digs_t & arg)}\par
01657 {\cf20 //      noexcept \{}\par
01658 {\cf20 //              nat_reg_digs_t & cthis\{*this\};}\par
01659 {\cf20 //              /// TO DO}\par
01660 {\cf20 //              return (*this);}\par
01661 {\cf20 //      \}}\par
01662 \par
01663         {\cf17 template}<{\cf18 size_t} N>\par
01664         {\cf17 constexpr} {\cf17 inline}\par
01665         nat_reg_digs_t operator + ({\cf17 const} base_N_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
01666         \{\par
01667                 nat_reg_digs_t ret(*{\cf17 this});\par
01668                 ret += arg;\par
01669                 {\cf19 return} std::move(ret);\par
01670         \}\par
01671 \par
01672         {\cf17 template}<{\cf18 size_t} N>\par
01673         {\cf17 constexpr} {\cf17 inline}\par
01674         nat_reg_digs_t operator - ({\cf17 const} base_N_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
01675         \{\par
01676                 nat_reg_digs_t ret(*{\cf17 this});\par
01677                 ret -= arg;\par
01678                 {\cf19 return} ret;\par
01679         \}\par
01680 \par
01681         {\cf17 template}<{\cf18 size_t} N>\par
01682         {\cf17 constexpr} {\cf17 inline}\par
01683         nat_reg_digs_t operator * ({\cf17 const} base_N_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
01684         \{\par
01685                 nat_reg_digs_t ret(*{\cf17 this});\par
01686                 ret *= arg;\par
01687                 {\cf19 return} ret;\par
01688         \}\par
01689 \par
01690         {\cf17 template}<{\cf18 size_t} N>\par
01691         {\cf17 constexpr} {\cf17 inline}\par
01692         nat_reg_digs_t operator + ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
01693         \{\par
01694                 nat_reg_digs_t ret(*{\cf17 this});\par
01695                 ret += arg;\par
01696                 {\cf19 return} ret;\par
01697         \}\par
01698 \par
01699         {\cf17 template}<{\cf18 size_t} N>\par
01700         {\cf17 constexpr} {\cf17 inline}\par
01701         nat_reg_digs_t operator - ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
01702         \{\par
01703                 nat_reg_digs_t ret(*{\cf17 this});\par
01704                 ret -= arg;\par
01705                 {\cf19 return} ret;\par
01706         \}\par
01707 \par
01708         {\cf17 template}<{\cf18 size_t} N>\par
01709         {\cf17 constexpr} {\cf17 inline}\par
01710         nat_reg_digs_t operator * ({\cf17 const} nat_reg_N_digs_t<N> & arg) {\cf17 const} {\cf17 noexcept}\par
01711         \{\par
01712                 nat_reg_digs_t ret(*{\cf17 this});\par
01713                 ret *= arg;\par
01714                 {\cf19 return} ret;\par
01715         \}\par
01716 \par
01717         {\cf17 constexpr} {\cf17 inline}\par
01718         nat_reg_digs_t operator % ({\cf17 const} nat_reg_digs_t & arg) {\cf17 const} {\cf17 noexcept}\par
01719         \{\par
01720                 nat_reg_digs_t ret(*{\cf17 this});\par
01721                 UINT_T retuds   = ret(0);\par
01722                 UINT_T retdecs  = ret(1);\par
01723                 UINT_T arguds   = arg(0);\par
01724                 UINT_T argdecs  = arg(1);\par
01725 \par
01726                 retuds  += (B*retdecs);\par
01727                 arguds  += (B*argdecs);\par
01728                 retuds  %= arguds;\par
01729                 retdecs  = retuds;\par
01730                 retdecs /= B;\par
01731                 retuds  %= B;\par
01732                 ret.m_dc[1]     = dig_t(retdecs);\par
01733                 ret.m_dc[0]     = dig_t(retuds);\par
01734                 {\cf19 return} ret;\par
01735         \}\par
01736 \par
01737 \};\par
01738 \par
01739 \par
01740 {\cf20                                         /****************************/}\par
01741                                         {\cf20 /*                                                                                                      */}\par
01742                                         {\cf20 /*         ISTREAM Y OSTREAM            */}\par
01743                                         {\cf20 /*                                                                                                      */}\par
01744 {\cf20                                         /****************************/}\par
01745 \par
01747   {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} LE>\par
01748   {\cf18 bool} is_nat_reg_digs_type_id(std::string in)\par
01749   \{   {\cf19 return}(\par
01750       (in == {\cf22 "nat_reg_digs"})||\par
01751       (in == {\cf22 "nat_reg_dig"})||\par
01752       (in == {\cf22 "nat_reg_di"})||\par
01753       (in == {\cf22 "nat_reg_d"})||\par
01754       (in == {\cf22 "nat_reg_"})||\par
01755       (in == {\cf22 "nat_reg"})||\par
01756       (in == {\cf22 "nat_re"})||\par
01757       (in == {\cf22 "nat_r"})||\par
01758       (in == {\cf22 "nat_"})||\par
01759       (in == {\cf22 "nat"})||\par
01760       (in == {\cf22 "na"})||\par
01761       (in == {\cf22 "n"})\par
01762     );\par
01763   \}\par
01764 \par
01765   {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} LE>\par
01766   std::string to_nat_reg_digs_type_string()\par
01767   \{   {\cf19 return} std::string\{{\cf22 "nat_reg_digs"}\};               \}\par
01768 \par
01769   {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} LE>\par
01770   {\cf18 size_t} size_of_nat_reg_digs_type_string_idT()\par
01771   \{     {\cf19 return} (to_nat_reg_digs_type_string<UInt_t,B,LE>()).size();     \}\par
01772 \par
01776         {\cf17 template}<type_traits::uint_type_for_radix_c Int_Type,\par
01777                                         Int_Type Base,\par
01778                                         {\cf18 size_t} Length>\par
01779                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))\par
01780         std::istream &\par
01781         operator >> (std::istream & is,nat_reg_digs_t<Int_Type,Base,Length> & arg) \{\par
01782                 {\cf17 enum} estado_e \{\par
01783                         e0ini   , e1r           , e1e           , e1g                   , e1sep         ,\par
01784                         e1d             , e1i           , e2g           , e2start       , e2dig         ,\par
01785                         e2dp    , e2end , e2B           , e3dig         , e0fin\par
01786                 \};\par
01788                 std::string sds;\par
01790                 {\cf17 using }inttype = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
01791                 {\cf17 using }dig_t = dig_t<Int_Type,Base>;\par
01792                 {\cf17 using }nat_reg_digs_t = nat_reg_digs_t<Int_Type,Base,Length>;\par
01794                 {\cf18 size_t}  indice\{0\};\par
01796                 Int_Type                digito\{0\};\par
01797                 {\cf18 size_t} longitud\{0\};\par
01798                 inttype                 numero_base_recogido\{0\};\par
01800                 nat_reg_digs_t& numero_ret\{arg\};\par
01802                 estado_e est_act = e0ini;\par
01804                 {\cf18 char} c\{{\cf23 '\\0'}\};\par
01806                 is >> sds;\par
01808                 {\cf19 do} \{\par
01809                         c = sds[indice];\par
01810                         {\cf19 switch}(est_act) \{\par
01811                                 {\cf19 case} e0ini :\par
01812                                         \{\par
01813                                                 {\cf19 if} (c=={\cf23 'r'}) \{\par
01814                                                         est_act = e1r;\par
01815                                                 \} {\cf19 else} \{\par
01816                                                         est_act = e0ini;\par
01817                                                 \}\par
01818                                         \}\par
01819                                         {\cf19 break};\par
01820                                 {\cf19 case} e1r :\par
01821                                         \{\par
01822                                                 \{\par
01823                                                         {\cf19 if} (c=={\cf23 'e'}) \{\par
01824                                                                 est_act = e1e;\par
01825                                                         \}\par
01826                                                         {\cf19 else} \{\par
01827                                                                 est_act = e0ini;\par
01828                                                         \}\par
01829                                                 \}\par
01830                                         \}\par
01831                                         {\cf19 break};\par
01832                                 {\cf19 case} e1e :\par
01833                                         \{\par
01834                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
01835                                                         est_act = e1g;\par
01836                                                 \}\par
01837                                                 {\cf19 else}  \{\par
01838                                                         est_act = e0ini;\par
01839                                                 \}\par
01840                                         \}\par
01841                                         {\cf19 break};\par
01842                                 {\cf19 case} e1g :\par
01843                                         \{\par
01844                                                 {\cf19 if} (c=={\cf23 '_'}) \{\par
01845                                                         est_act = e1sep;\par
01846                                                 \}\par
01847                                                 {\cf19 else}  \{\par
01848                                                         est_act = e0ini;\par
01849                                                 \}\par
01850                                         \}\par
01851                                         {\cf19 break};\par
01852                                 {\cf19 case} e1sep :\par
01853                                         \{\par
01854                                                 {\cf19 if} (c=={\cf23 'd'}) \{\par
01855                                                         est_act = e1d;\par
01856                                                 \}\par
01857                                                 {\cf19 else}  \{\par
01858                                                         est_act = e0ini;\par
01859                                                 \}\par
01860                                         \}\par
01861                                         {\cf19 break};\par
01862                                 {\cf19 case} e1d :\par
01863                                         \{\par
01864                                                 {\cf19 if} (c=={\cf23 'i'}) \{\par
01865                                                         est_act = e1i;\par
01866                                                 \}\par
01867                                                 {\cf19 else}  \{\par
01868                                                         est_act = e0ini;\par
01869                                                 \}\par
01870                                         \}\par
01871                                         {\cf19 break};\par
01872                                 {\cf19 case} e1i :\par
01873                                         \{\par
01874                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
01875                                                         est_act = e2g;\par
01876                                                 \}\par
01877                                                 {\cf19 else}  \{\par
01878                                                         est_act = e0ini;\par
01879                                                 \}\par
01880                                         \}\par
01881                                         {\cf19 break};\par
01882                                 {\cf19 case} e2g :\par
01883                                         \{\par
01884                                                 {\cf19 if} (c=={\cf23 '#'}) \{\par
01885                                                         est_act = e2start;\par
01886                                                 \}\par
01887                                                 {\cf19 else}  \{\par
01888                                                         est_act = e0ini;\par
01889                                                 \}\par
01890                                         \}\par
01891                                         {\cf19 break};\par
01892                                 {\cf19 case} e2start :\par
01893                                         \{\par
01894                                                 {\cf19 if} (((c>={\cf23 '0'})&&(c<={\cf23 '9'}))&&(std::abs(c-{\cf23 '0'})<Base)) \{\par
01895                                                         est_act = e2dig;\par
01896                                                         digito = (c-{\cf23 '0'});\par
01897                                                         longitud = 0;\par
01898                                                         numero_base_recogido = 0;\par
01899                                                         numero_ret = nat_reg_digs_t::regd_0();\par
01900                                                 \}\par
01901                                                 {\cf19 else}  \{\par
01902                                                         est_act = e0ini;\par
01903                                                         digito = 0;\par
01904                                                         longitud = 0;\par
01905                                                         numero_base_recogido = 0;\par
01906                                                         numero_ret = nat_reg_digs_t::regd_0();\par
01907                                                 \}\par
01908                                         \}\par
01909                                         {\cf19 break};\par
01910                                 {\cf19 case} e2dig :\par
01911                                         \{\par
01912                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
01913                                                 {\cf17 const} {\cf18 bool} dig_lt_Base\{digito<Base\};\par
01914                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{dig_c && dig_lt_Base\};\par
01915                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{c_es_dig_B && (longitud < Length-1)\};\par
01916                                                 {\cf17 const} {\cf18 bool} tt_dig_B_cdl \{(c=={\cf23 ':'})&&dig_lt_Base&&(longitud < Length-1)\};\par
01917                                                 {\cf17 const} {\cf18 bool} tf_dig_B_cdl \{(c=={\cf23 '#'})&&dig_lt_Base&&(longitud == Length-1)\};\par
01918                                                 {\cf19 if} (dig_B_cdl) \{\par
01919                                                         digito *= 10;\par
01920                                                         digito += (c-{\cf23 '0'});\par
01921                                                         est_act = e2dig;\par
01922                                                 \}\par
01923                                                 {\cf19 else} {\cf19 if} (tt_dig_B_cdl) \{\par
01924                                                         est_act = e2dp;\par
01925                                                 \}\par
01926                                                 {\cf19 else} {\cf19 if} (tf_dig_B_cdl) \{\par
01927                                                         est_act = e2end;\par
01928                                                 \}\par
01929                                                 {\cf19 else}  \{\par
01930                                                         est_act = e0ini;\par
01931                                                         digito = 0;\par
01932                                                         longitud = 0;\par
01933                                                         numero_base_recogido = 0;\par
01934                                                         numero_ret = nat_reg_digs_t::regd_0();\par
01935                                                 \}\par
01936                                         \}\par
01937                                         {\cf19 break};\par
01938                                 {\cf19 case} e2dp :\par
01939                                         \{\par
01940                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
01941                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{(std::abs(c-{\cf23 '0'})<Base) && (digito<Base)\};\par
01942                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{dig_c && c_es_dig_B && (longitud < Length-1)\};\par
01943                                                 {\cf17 const} {\cf18 bool} rdig_B_cdl \{dig_c && c_es_dig_B && dig_B_cdl\};\par
01944                                                 {\cf19 if} (rdig_B_cdl) \{\par
01945                                                         est_act = e2dig;\par
01946                                                         numero_ret[Length-1-longitud] = dig_t(digito);\par
01947                                                         ++longitud;\par
01948                                                         digito = c-{\cf23 '0'};\par
01949                                                 \}\par
01950                                                 {\cf19 else}  \{\par
01951                                                         est_act = e0ini;\par
01952                                                         digito = 0;\par
01953                                                         longitud = 0;\par
01954                                                         numero_base_recogido = 0;\par
01955                                                         indice = 0;\par
01956                                                         numero_ret = nat_reg_digs_t::regd_0();\par
01957                                                 \}\par
01958                                         \}\par
01959                                         {\cf19 break};\par
01960                                 {\cf19 case} e2end :\par
01961                                         \{\par
01962                                                 {\cf17 const} {\cf18 bool} c_es_sepfin \{c == {\cf23 'B'}\};\par
01963                                                 {\cf17 const} {\cf18 bool} d_es_digB \{digito < Base\};\par
01964                                                 {\cf17 const} {\cf18 bool} l_coincide \{longitud == Length-1\};{\cf20 // llega al cero ?}\par
01965                                                 {\cf17 const} {\cf18 bool} rdigB_cdl \{c_es_sepfin && d_es_digB && l_coincide\};\par
01966                                                 {\cf19 if} (rdigB_cdl) \{\par
01967                                                         est_act = e2B;\par
01968                                                         numero_ret[Length-1-longitud] = dig_t(digito);\par
01969                                                         digito = 0;\par
01970                                                         longitud = 0;\par
01971                                                 \}\par
01972                                                 {\cf19 else}  \{\par
01973                                                         est_act = e0ini;\par
01974                                                         indice = 0;\par
01975                                                         digito = 0;\par
01976                                                         longitud = 0;\par
01977                                                         numero_ret = nat_reg_digs_t::regd_0();\par
01978                                                 \}\par
01979                                         \}\par
01980                                         {\cf19 break};\par
01981                                 {\cf19 case} e2B :\par
01982                                         \{\par
01983                                                 {\cf19 if} ((c >= {\cf23 '0'})&&(c <= {\cf23 '9'})) \{\par
01984                                                         est_act = e3dig;\par
01985                                                         numero_base_recogido = c-{\cf23 '0'};\par
01986                                                         digito = 0;\par
01987                                                 \}\par
01988                                                 {\cf19 else}  \{\par
01989                                                         est_act = e0ini;\par
01990                                                         digito = 0;\par
01991                                                         longitud = 0;\par
01992                                                         numero_base_recogido = 0;\par
01993                                                         numero_ret = nat_reg_digs_t::regd_0();\par
01994                                                 \}\par
01995                                         \}\par
01996                                         {\cf19 break};\par
01997                                 {\cf19 case} e3dig :\par
01998                                         \{\par
01999                                                 {\cf17 const} {\cf18 bool} espacio_c \{c < 16\};\par
02000                                                 {\cf17 const} {\cf18 bool} digito_c \{(c>={\cf23 '0'}) && (c<={\cf23 '9'})\};\par
02001                                                 {\cf17 const} {\cf18 bool} num_base_lt_Base \{numero_base_recogido < Base\};\par
02002                                                 {\cf17 const} {\cf18 bool} num_base_eq_Base \{numero_base_recogido == Base\};\par
02003                                                 {\cf19 if} (digito_c && num_base_lt_Base) \{\par
02004                                                         est_act = e3dig;\par
02005                                                         numero_base_recogido *= 10;\par
02006                                                         numero_base_recogido += (c-{\cf23 '0'});\par
02007                                                 \}\par
02008                                                 {\cf19 else} {\cf19 if} (espacio_c && num_base_eq_Base) \{\par
02009                                                         numero_base_recogido *= 10;\par
02010                                                         numero_base_recogido += (c-{\cf23 '0'});\par
02011                                                                 est_act = e0fin;\par
02012                                                                 numero_base_recogido = 0;\par
02013                                                 \}\par
02014                                                 {\cf19 else}  \{\par
02015                                                         est_act = e0ini;\par
02016                                                         numero_base_recogido = 0;\par
02017                                                 \}\par
02018                                         \}\par
02019                                         {\cf19 break};\par
02020                                 {\cf19 case} e0fin :\par
02021                                         \{\par
02022                                                 est_act = e0fin;\par
02023                                         \}\par
02024                         \}\par
02025                         ++indice;\par
02026                 \} {\cf19 while} (est_act!=e0fin);\par
02027 \par
02028                 {\cf19 return} (is);\par
02029         \}\par
02030 \par
02031         {\cf17 template}<type_traits::u{\cf18 int}_type_for_radix_c Int_Type,Int_Type Base,{\cf18 size_t} Long>\par
02032                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>())\par
02033         std::ostream &\par
02034         {\cf17 operator} << (std::ostream & os,{\cf17 const} nat_reg_digs_t<Int_Type,Base,Long> & arg) \{\par
02035                 {\cf17 using }inttype = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
02036                 os << {\cf22 "reg_dig#"};\par
02037                 {\cf19 for}(int32_t ix\{Long-1\} ; ix > 0 ; --ix) \{\par
02038                                 os << static_cast<inttype>(arg(ix));\par
02039                                 os << {\cf23 ':'};\par
02040                 \}\par
02041                 os << static_cast<inttype>(arg(0));\par
02042                 os << {\cf22 "#B"};\par
02043                 os << static_cast<inttype>(Base);\par
02044                 {\cf19 return} (os);\par
02045         \}\par
02046 \par
02047 \}\par
02048 {\cf21 #endif }{\cf20 //NAT_REG_DIGS_T__HPP__INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo pruebas_dig_t.cpp\par \pard\plain 
{\tc\tcl2 \v pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "utilities.hpp"}\par
{\f2 #include "nat_reg_digs_t.hpp"}\par
{\f2 #include <typeinfo>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para pruebas_dig_t.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pruebas__dig__t_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b trisums_t} = std::tuple< std::int64_t, std::int64_t, std::int64_t >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b result_test_binop_con_asignacion} = std::vector< {\b trisums_t} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b retorno_de_test_t} = std::tuple< bool, {\b result_test_binop_con_asignacion}, {\b result_test_binop_con_asignacion} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<size_t B, size_t L> constexpr {\b NumRepr::uint128_t} {\b conversion_to_int} ({\b NumRepr::register_of_digits_t}< B, L > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::ullint_t} Base, {\b NumRepr::ullint_t} Longitud> {\b retorno_de_test_t} {\b test_suma_con_asignacion} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de los 'typedefs'\par
\pard\plain 
{\xe \v result_test_binop_con_asignacion\:pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp\:result_test_binop_con_asignacion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b result_test_binop_con_asignacion} =  std::vector<{\b trisums_t}>}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 29} del archivo {\b pruebas_dig_t.cpp}.}\par
}
{\xe \v retorno_de_test_t\:pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp\:retorno_de_test_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b retorno_de_test_t} =  std::tuple< bool, {\b result_test_binop_con_asignacion}, {\b result_test_binop_con_asignacion}>}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 31} del archivo {\b pruebas_dig_t.cpp}.}\par
}
{\xe \v trisums_t\:pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp\:trisums_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b trisums_t} =  std::tuple<std::int64_t,std::int64_t,std::int64_t>}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 27} del archivo {\b pruebas_dig_t.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Documentaci\'F3n de las funciones\par
\pard\plain 
{\xe \v conversion_to_int\:pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp\:conversion_to_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<size_t B, size_t L> constexpr {\b NumRepr::uint128_t} conversion_to_int ({\b NumRepr::register_of_digits_t}< B, L > &  {\i arg}){\f2 [inline]}, {\f2 [constexpr]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 21} del archivo {\b pruebas_dig_t.cpp}.}\par
}
{\xe \v main\:pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
digit_t{\b  reg_digs_t<B,L>} \par
{\b PRUEBAS SOBRE LA DIVISION FUNCION AUXILIAR aprox_units_divB} \par
{\b } \par
}{
Definici\'F3n en la l\'EDnea {\b 78} del archivo {\b pruebas_dig_t.cpp}.}\par
}
{\xe \v test_suma_con_asignacion\:pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp\:test_suma_con_asignacion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b NumRepr::ullint_t} Base, {\b NumRepr::ullint_t} Longitud> {\b retorno_de_test_t} test_suma_con_asignacion ()}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definici\'F3n en la l\'EDnea {\b 36} del archivo {\b pruebas_dig_t.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
pruebas_dig_t.cpp\par \pard\plain 
{\tc\tcl2 \v pruebas_dig_t.cpp}
{\xe \v pruebas_dig_t.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "utilities.hpp"}\par
00002 {\cf21 #include "nat_reg_digs_t.hpp"}\par
00003 {\cf21 #include <typeinfo>}\par
00004 \par
00005 {\cf20 //template<NumRepr::uint128_t B,NumRepr::uint128_t L>}\par
00006 {\cf20 //consteval inline}\par
00007 {\cf20 //NumRepr::uint128_t Base_pow_to_Size() noexcept \{}\par
00008 {\cf20 //      if constexpr (L==0)}\par
00009 {\cf20 //              return static_cast<NumRepr::uint128_t>(1);}\par
00010 {\cf20 //      else if constexpr (L==1)}\par
00011 {\cf20 //              return static_cast<NumRepr::uint128_t>(B);}\par
00012 {\cf20 //      else if constexpr (L==2)}\par
00013 {\cf20 //              return static_cast<NumRepr::uint128_t>(B)*static_cast<NumRepr::uint128_t>(B);}\par
00014 {\cf20 //      else}\par
00015 {\cf20 //              return (static_cast<NumRepr::uint128_t>(B)*Base_pow_to_Size<B,L-1>());}\par
00016 {\cf20 //\}}\par
00017 \par
00018 {\cf17 template}<{\cf18 size_t} B,{\cf18 size_t} L>\par
00019 {\cf17 constexpr} {\cf17 inline}\par
00020 NumRepr::uint128_t\par
00021 conversion_to_int(NumRepr::register_of_digits_t<B,L> & arg) {\cf17 noexcept} \{\par
00022         {\cf17 namespace }NR = NumRepr;\par
00023         {\cf17 namespace }us = utilities::special;\par
00024         {\cf19 return} us::conversion_to_int<B,L,NR::register_of_digits_t<B,L>>(arg);\par
00025 \}\par
00026 \par
00027 {\cf17 using }trisums_t = std::tuple<std::int64_t,std::int64_t,std::int64_t>;\par
00028 \par
00029 {\cf17 using }result_test_binop_con_asignacion = std::vector<trisums_t>;\par
00030 \par
00031 {\cf17 using }retorno_de_test_t = std::tuple<   bool,\par
00032                                                                                                                                                         result_test_binop_con_asignacion,\par
00033                                                                                                                                                         result_test_binop_con_asignacion>;\par
00034 \par
00035 {\cf17 template}<NumRepr::ull{\cf18 int}_t Base,NumRepr::ull{\cf18 int}_t Longitud>\par
00036 retorno_de_test_t test_suma_con_asignacion() \{\par
00037         {\cf17 using }rd_t = NumRepr::register_of_digits_t<Base,Longitud>;\par
00038         {\cf17 using }d_t  = NumRepr::digit_t<Base>;\par
00039         {\cf17 namespace }us = utilities::special;\par
00040         {\cf17 namespace }NR = NumRepr;\par
00041         {\cf18 bool} todo_correcto = {\cf17 true};\par
00042 \par
00043         {\cf17 constexpr} NR::uint128_t B2L\{us::Base_pow_to_Size<Base,Longitud>()\};\par
00044 \par
00045         std::vector<trisums_t> correctos\{\};\par
00046         correctos.reserve(B2L*B2L);\par
00047         std::vector<trisums_t> errores\{\};\par
00048         errores.reserve(B2L*B2L);\par
00049 \par
00050         rd_t rd_x\{\};\par
00051         rd_x.fill(d_t\{0\});\par
00052         rd_t rd_y\{\};\par
00053         rd_y.fill(d_t\{0\});\par
00054         {\cf19 for}(std::uint64_t ix\{0\} ; ix < B2L ; ++ix) \{\par
00055                 {\cf19 for}(std::uint64_t iy\{0\} ; iy < B2L ; ++iy) \{\par
00056                         rd_t rd_z\{rd_x\};\par
00057                         NR::m_sum(rd_z,rd_y);\par
00058                         {\cf17 const} std::uint64_t iz = conversion_to_int<Base,Longitud>(rd_z);\par
00059                         {\cf17 const} std::uint64_t iw = (ix+iy)%B2L;\par
00060                         {\cf17 const} {\cf18 bool} bien \{iz==iw\};\par
00061                         {\cf17 const} trisums_t trio\{ix,iy,iz\};\par
00062                         {\cf19 if} (!bien) \{\par
00063                                 rd_t rd_w\{rd_x\};\par
00064                                 NR::m_sum(rd_w,rd_y);\par
00065                                 errores.push_back(trio);\par
00066                         \} {\cf19 else} \{\par
00067                                 correctos.push_back(trio);\par
00068                         \}\par
00069                         todo_correcto = todo_correcto && bien;\par
00070                         m_incr(rd_y);\par
00071                 \}\par
00072                 m_incr(rd_x);\par
00073         \}\par
00074         {\cf19 return} retorno_de_test_t\{todo_correcto,correctos,errores\};\par
00075 \}\par
00076 \par
00077 \par
00078 {\cf18 int} main() \{\par
00081         {\cf17 using namespace }NumRepr;\par
00082 {\cf20 //      constexpr ullint_t B\{10u\};}\par
00083 {\cf20 //      //constexpr ullint_t Bm1\{B-1\};}\par
00084 {\cf20 //      constexpr size_t L\{5\};}\par
00085 {\cf20 //      using rd_t = register_of_digits_t<B,L>;}\par
00086         {\cf20 //using d_t = digit_t<B>;}\par
00089 {\cf20 }{\cf20 //      rd_t opndo\{1,3,5,2,6\};}\par
00090 {\cf20 //      std::cout << opndo << std::endl;}\par
00091 {\cf20 //      std::cout << opndo.index_of_MSDig() << std::endl;}\par
00092 {\cf20 //      opndo >>= 1;}\par
00093 {\cf20 //      std::cout << opndo << std::endl;}\par
00094 {\cf20 //      std::cout << opndo.index_of_MSDig() << std::endl;}\par
00095 {\cf20 //      opndo >>= 1;}\par
00096 {\cf20 //      std::cout << opndo << std::endl;}\par
00097 {\cf20 //      std::cout << opndo.index_of_MSDig() << std::endl;}\par
00098 {\cf20 //      opndo >>= 1;}\par
00099 {\cf20 //      std::cout << opndo << std::endl;}\par
00100 {\cf20 //      std::cout << opndo.index_of_MSDig() << std::endl;}\par
00101 {\cf20 //      opndo >>= 1;}\par
00102 {\cf20 //      std::cout << opndo << std::endl;}\par
00103 {\cf20 //      std::cout << opndo.index_of_MSDig() << std::endl;}\par
00104 {\cf20 //      opndo >>= 1;}\par
00105 {\cf20 //      std::cout << opndo << std::endl;}\par
00106 {\cf20 //      std::cout << opndo.index_of_MSDig() << std::endl;}\par
00107 {\cf20 //      opndo = rd_t\{6,6,7,9,5\};}\par
00108 {\cf20 //      std::cout << "aprox to units of " << opndo << " is " << (opndo=aprox_units_divB(opndo)) << std::endl;}\par
00109 {\cf20 //      std::cout << "aprox to units of " << opndo << " is " << (opndo=aprox_units_divB(opndo)) << std::endl;}\par
00110 {\cf20 //      std::cout << "aprox to units of " << opndo << " is " << (opndo=aprox_units_divB(opndo)) << std::endl;}\par
00111 {\cf20 //      std::cout << "aprox to units of " << opndo << " is " << (opndo=aprox_units_divB(opndo)) << std::endl;}\par
00112 {\cf20 //      std::cout << "aprox to units of " << opndo << " is " << (opndo=aprox_units_divB(opndo)) << std::endl;}\par
00113 {\cf20 //      rd_t lopndo\{9,9,8,2,5\};}\par
00114 {\cf20 //      rd_t ropndo\{0,0,5,8,7\};}\par
00115 {\cf20 //      std::cout << " aprox of " << lopndo  <<  " is " << aprox_units_divB_n<uchint_t,10,5,4>(lopndo) << std::endl;}\par
00116 {\cf20 //      std::cout << " aprox of " << lopndo  <<  " is " << aprox_units_divB_n<uchint_t,10,5,3>(lopndo) << std::endl;}\par
00117 {\cf20 //      std::cout << " aprox of " << lopndo  <<  " is " << aprox_units_divB_n<uchint_t,10,5,2>(lopndo) << std::endl;}\par
00118 {\cf20 //      std::cout << " aprox of " << lopndo  <<  " is " << aprox_units_divB_n<uchint_t,10,5,1>(lopndo) << std::endl;}\par
00119 \par
00120         {\cf17 constexpr} ullint_t B2\{2u\};\par
00121         {\cf17 constexpr} {\cf18 size_t} L2\{10\};\par
00122         \{\par
00123                 std::cout << std::boolalpha;\par
00124                 {\cf17 auto} resultado\{test_suma_con_asignacion<B2,L2>()\};\par
00125                 {\cf17 auto} todo_correcto\{std::get<0>(resultado)\};\par
00126                 {\cf17 auto} correctos\{std::get<1>(resultado)\};\par
00127                 {\cf17 auto} errores\{std::get<2>(resultado)\};\par
00128                 std::cout << {\cf22 "TEST para la suma y asignacion sobre el tipo register_of_digits_t<"}\par
00129                                                         << int(B2) << {\cf22 ","} << int(L2) << {\cf22 ">"} << std::endl;\par
00130                 std::cout << {\cf22 "El vector \\"correctos\\" tiene "} << correctos.size() << {\cf22 " elementos "} << std::endl;\par
00131                 std::cout << {\cf22 "El vector \\"errores  \\" tiene "} << errores.size() << {\cf22 " elementos "} << std::endl;\par
00132                 std::cout << {\cf22 "Todo ha ido bien : "} << todo_correcto << std::endl;\par
00133         \}\par
00134         {\cf17 constexpr} ullint_t B1\{10u\};\par
00135         {\cf17 constexpr} {\cf18 size_t} L1\{3\};\par
00136         \{\par
00137                 std::cout << std::boolalpha;\par
00138                 {\cf17 auto} resultado\{test_suma_con_asignacion<B1,L1>()\};\par
00139                 {\cf17 auto} todo_correcto\{std::get<0>(resultado)\};\par
00140                 {\cf17 auto} correctos\{std::get<1>(resultado)\};\par
00141                 {\cf17 auto} errores\{std::get<2>(resultado)\};\par
00142                 std::cout << {\cf22 "TEST para la suma y asignacion sobre el tipo register_of_digits_t<"}\par
00143                                                         << int(B1) << {\cf22 ","} << int(L1) << {\cf22 ">"} << std::endl;\par
00144                 std::cout << {\cf22 "El vector \\"correctos\\" tiene "} << correctos.size() << {\cf22 " elementos "} << std::endl;\par
00145                 std::cout << {\cf22 "El vector \\"errores  \\" tiene "} << errores.size() << {\cf22 " elementos "} << std::endl;\par
00146                 std::cout << {\cf22 "Todo ha ido bien : "} << todo_correcto << std::endl;\par
00147         \}\par
00148 \par
00149         {\cf19 return} 0;\par
00150 \}\par
00151 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo rat_fixed_reg_t.hpp\par \pard\plain 
{\tc\tcl2 \v rat_fixed_reg_t.hpp}
{\xe \v rat_fixed_reg_t.hpp}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rat_fixed_reg_t.hpp\par \pard\plain 
{\tc\tcl2 \v rat_fixed_reg_t.hpp}
{\xe \v rat_fixed_reg_t.hpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef RAT_FIXED_REG_T_HPP_INCLUDED}\par
00002 {\cf21 #define RAT_FIXED_REG_T_HPP_INCLUDED}\par
00003 \par
00004 \par
00005 {\cf21 #endif }{\cf20 // RAT_FIXED_REG_T_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo rat_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v rat_num_t.hpp}
{\xe \v rat_num_t.hpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
rat_num_t.hpp\par \pard\plain 
{\tc\tcl2 \v rat_num_t.hpp}
{\xe \v rat_num_t.hpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef RAT_NUM_T_HPP_INCLUDED}\par
00002 {\cf21 #define RAT_NUM_T_HPP_INCLUDED}\par
00003 \par
00004 \par
00005 \par
00006 {\cf21 #endif }{\cf20 // RAT_NUM_T_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo reg_digs_t.hpp\par \pard\plain 
{\tc\tcl2 \v reg_digs_t.hpp}
{\xe \v reg_digs_t.hpp}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "dig_t.hpp"}\par
{\f2 #include "utilities.hpp"}\par
{\f2 #include "lexer_parser.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para reg_digs_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "reg__digs__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "reg__digs__t_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b NumRepr::reg_digs_t< UINT_T, B, L >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> register_of_digits_t\{\};. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint128_t B, size_t L> using {\b NumRepr::register_of_digits_t} = reg_digs_t< type_traits::TypeFromIntNumber_t< B >, static_cast< type_traits::TypeFromIntNumber_t< B > >(B), L >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint128_t B, size_t L> using {\b NumRepr::register_digs_t} = reg_digs_t< TypeFromIntNumber_t< static_cast< uint128_t >(B)>, static_cast< TypeFromIntNumber_t< static_cast< uint128_t >(B)> >(static_cast< uint128_t >(B)), L >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t N> \par
requires (N>0)constexpr reg_digs_t< UInt_t, B, N > {\b NumRepr::concat} (const reg_digs_t< UInt_t, B, N > &larg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N> CONCAT(BASE_N_T<N>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t N, size_t M> \par
requires ((N>0)&&(M>0))constexpr reg_digs_t< UInt_t, B, N+M > {\b NumRepr::concat} (const reg_digs_t< UInt_t, B, N > &larg, const reg_digs_t< UInt_t, B, M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+M> CONCAT(BASE_N_T<N>,BASE_N_T<M>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t N> \par
requires (N > 0)constexpr reg_digs_t< UInt_t, B, N+1 > {\b NumRepr::concat} (const reg_digs_t< UInt_t, B, N > &larg, dig_t< UInt_t, B > rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<N+1> CONCAT(BASE_N_T<N>,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t M> \par
requires (M > 0)constexpr reg_digs_t< UInt_t, B, 1+M > {\b NumRepr::concat} (dig_t< UInt_t, B > larg, const reg_digs_t< UInt_t, B, M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1+M> CONCAT(DIG_T,BASE_N_T<M>) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B> constexpr reg_digs_t< UInt_t, B, 1 > {\b NumRepr::concat} (dig_t< UInt_t, B > larg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1> CONCAT(DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B> constexpr reg_digs_t< UInt_t, B, 2 > {\b NumRepr::concat} (dig_t< UInt_t, B > larg, dig_t< UInt_t, B > rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
STATIC BASE_N_T<1+1> CONCAT(DIG_T,DIG_T) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, typename T0 , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&...) && (std::is_same_v<T0,dig_t<UInt_t,B>>) )constexpr reg_digs_t< UInt_t, B, 1+(sizeof ...(Ts))> {\b NumRepr::concat} (T0 dig0, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t N, typename T , typename ... Ts> \par
requires (((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&...)&&(std::is_same_v<T,dig_t<UInt_t,B>>)&&(N>0))constexpr reg_digs_t< UInt_t, B, N+1+(sizeof ...(Ts))> {\b NumRepr::concat} (reg_digs_t< UInt_t, B, N > larg, T dig, Ts ... dig_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t M, typename T , typename ... Ts> \par
requires ( ((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&...) && (std::is_same_v<T,dig_t<UInt_t,B>>) && (M>0) )constexpr reg_digs_t< UInt_t, B, M+1+(sizeof ...(Ts))> {\b NumRepr::concat} (T dig, Ts ... dig_pack, reg_digs_t< UInt_t, B, M > rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UInt_t , UInt_t B, size_t N, size_t ... N_pack> \par
requires ((N>0)&&((N_pack>0)&&...))constexpr reg_digs_t< UInt_t, B, N+(...+(N_pack))> {\b NumRepr::concat} (reg_digs_t< UInt_t, B, N > larg, reg_digs_t< UInt_t, B, N_pack > ... rarg_pack) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::operator<<} (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & {\b NumRepr::operator<<=} (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & {\b NumRepr::operator>>=} (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::operator>>} (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::rem_B} (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & {\b NumRepr::m_rem_B} (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::mer_B} (const reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & {\b NumRepr::m_mer_B} (reg_digs_t< UINT_T, B, N > &larg, size_t n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & {\b NumRepr::operator|=} (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::operator|} (const reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr const reg_digs_t< UINT_T, B, N > & {\b NumRepr::operator&=} (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<uint_type_for_radix_c UINT_T, UINT_T B, size_t N> \par
requires ((suitable_base<UINT_T,B>())&&(N > 0))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::operator&} (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N> constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::m_incr} (reg_digs_t< UINT_T, B, N > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TODO 31/12/2022. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> constexpr dig_t< UINT_T, B > {\b NumRepr::m_sum_digs_carryin1} (dig_t< UINT_T, B > &left, dig_t< UINT_T, B > right) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B> constexpr dig_t< UINT_T, B > {\b NumRepr::m_sum_digs_carryin0} (dig_t< UINT_T, B > &left, dig_t< UINT_T, B > right) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N> constexpr dig_t< UINT_T, B > {\b NumRepr::m_sum} (reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, N > &rarg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N> \par
requires (N>1)constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::aprox_units_divB} (const reg_digs_t< UINT_T, B, N > &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< PRECONDITIONS : ARG != 0 AND ARG != 1 > }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N, size_t n> \par
requires ((n > 0) && (n < N) && (N > 1))constexpr reg_digs_t< UINT_T, B, N > {\b NumRepr::aprox_units_divB_n} (const reg_digs_t< UINT_T, B, N > &arg) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N> \par
requires (N > 0)constexpr std::array< type_traits::sig_UInt_for_UInt_t< UINT_T >, 2 > {\b NumRepr::aprox_coc_rem} (const reg_digs_t< UINT_T, B, N > &rem, const reg_digs_t< UINT_T, B, N > &dsor) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N> \par
requires (N > 0)constexpr std::array< type_traits::sig_UInt_for_UInt_t< UINT_T >, 2 > {\b NumRepr::aprox_coc_rem} (const reg_digs_t< UINT_T, B, N > &rem, const reg_digs_t< UINT_T, B, N > &dsor, type_traits::sig_UInt_for_UInt_t< UINT_T > coc_calculado, type_traits::sig_UInt_for_UInt_t< UINT_T > rem_calculado) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename UINT_T , UINT_T B, size_t N, size_t M> \par
requires (N > 0)&&(M > 0)constexpr std::array< reg_digs_t< UINT_T, B, std::max(N, M)>, 2 > {\b NumRepr::fediv} (const reg_digs_t< UINT_T, B, N > &larg, const reg_digs_t< UINT_T, B, M > &rarg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c UINT_T, UINT_T B> bool {\b NumRepr::get_digit_token} (std::istream &is, dig_t< UINT_T, B > &dig_value)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN DIGITO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c T, T B> bool {\b NumRepr::get_radix_token} (std::istream &is)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FUNCION QUE CONSIGUE EL TOKEN BASE. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c T, T B, size_t L> bool {\b NumRepr::get_digit_loop_token} (std::istream &is, reg_digs_t< T, B, L > &value) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::unsigned_integral_c T, T B, size_t L> bool {\b NumRepr::read} (std::istream &is, reg_digs_t< T, B, L > &value) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
DEFINCION DE template<uint128_t Radix> digito_t\{\};. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_Type , Int_Type Base, size_t Length> \par
requires (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))std::istream & {\b NumRepr::operator>>} (std::istream &is, reg_digs_t< Int_Type, Base, Length > &arg)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
SOBRECARGA DE ISTREAM Y OSTREAM CON LOS OPERADORES DE DESPLAZAMEINTO. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Int_Type , Int_Type Base, size_t Long> \par
requires (type_traits::suitable_base<Int_Type,Base>())std::ostream & {\b NumRepr::operator<<} (std::ostream &os, const reg_digs_t< Int_Type, Base, Long > &arg)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
reg_digs_t.hpp\par \pard\plain 
{\tc\tcl2 \v reg_digs_t.hpp}
{\xe \v reg_digs_t.hpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef REG_DIGS_T_HPP_INCLUDED}\par
00002 {\cf21 #define REG_DIGS_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "dig_t.hpp"}\par
00005 {\cf21 #include "utilities.hpp"}\par
00006 {\cf21 #include "lexer_parser.hpp"}\par
00007 \par
00008 {\cf17 namespace }NumRepr \{\par
00009 \par
00010 {\cf17 using }type_traits::uint_type_for_radix_c;\par
00011 {\cf17 using }type_traits::suitable_base;\par
00012 \par
00013 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} L>\par
00014   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(L > 0))\par
00015 {\cf17 struct} reg_digs_t : {\cf17 public} std::array<dig_t<UINT_T,B>,L> \{\par
00016 public :\par
00017 \par
00018         {\cf17 using }dig_t                             = dig_t<UINT_T,B>;\par
00019 \par
00020         {\cf17 template}<{\cf18 size_t} N>\par
00021                 {\cf17 requires} (N>0)\par
00022         {\cf17 using} base_N_t      = std::array<dig_t,N>;\par
00023 \par
00024         {\cf17 using }base_t                            = base_N_t<L>;\par
00025 \par
00026         {\cf17 template}<{\cf18 size_t} N>\par
00027         {\cf17 using }reg_N_digs_t  = reg_digs_t<UINT_T,B,N>;\par
00028 \par
00030         {\cf17 inline} {\cf17 const} base_t* {\cf17 const} const_base_this() const noexcept \{\par
00031                 {\cf19 return} {\cf17 static_cast<}{\cf17 const }base_t* const{\cf17 >}({\cf17 this});\par
00032         \}\par
00033 \par
00034         {\cf17 inline} base_t* base_this() noexcept \{\par
00035                 {\cf19 return} {\cf17 static_cast<}base_t*{\cf17 >}({\cf17 this});\par
00036         \}\par
00038         {\cf17 inline} base_t& r_base_cthis() noexcept \{\par
00039                 {\cf19 return} (*base_this());\par
00040         \}\par
00042         {\cf17 inline} {\cf17 const} base_t& cr_base_cthis() const noexcept \{\par
00043                 {\cf19 return} ({\cf17 static_cast<}{\cf17 const }base_t&{\cf17 >}(*const_base_this()));\par
00044         \}\par
00045 \par
00046         {\cf17 inline} base_t cp_base_cthis() const noexcept \{\par
00047                 {\cf19 return} std::move(base_t\{*(cr_base_cthis())\});\par
00048         \}\par
00050         {\cf17 inline} reg_digs_t & r_cthis() noexcept \{\par
00051                 {\cf19 return} (*{\cf17 this});\par
00052         \}\par
00053 \par
00054         {\cf17 inline} {\cf17 const} reg_digs_t & cr_cthis() const noexcept \{\par
00055                 {\cf19 return} (*{\cf17 this});\par
00056         \}\par
00058         {\cf17 inline} reg_digs_t cp_cthis() const noexcept \{\par
00059                 {\cf19 return} reg_digs_t\{*{\cf17 this}\};\par
00060         \}\par
00062         {\cf17 inline} dig_t cp_cthis_at({\cf18 size_t} k) {\cf17 const} {\cf17 noexcept} \{\par
00063                 {\cf19 return} cp_base_cthis()[k];\par
00064         \}\par
00065 \par
00066         {\cf17 inline} dig_t & r_cthis_at({\cf18 size_t} k) {\cf17 noexcept} \{\par
00067                 {\cf19 return} (r_base_cthis()[k]);\par
00068         \}\par
00069 \par
00070         {\cf17 inline} {\cf17 const} dig_t & cr_cthis_at({\cf18 size_t} k) {\cf17 const} {\cf17 noexcept} \{\par
00071                 {\cf19 return} (cr_base_cthis()[k]);\par
00072         \}\par
00073 \par
00074 \par
00075 public :\par
00076 \par
00077         {\cf17 using }SIG_UINT_T = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
00078         {\cf17 using }SIG_SINT_T = {\cf17 typename} type_traits::sig_SInt_for_UInt_t<UINT_T>;\par
00079 \par
00080         {\cf17 template}<binop_e op,{\cf18 size_t} N>\par
00081         {\cf17 using }res_base_N_op_t   =\par
00082                 {\cf17 typename} auxiliary_types::result_operation_t<base_N_t<N>,op,N>;\par
00083 \par
00084         {\cf17 template}<binop_e op>\par
00085         {\cf17 using }res_base_op_t             =\par
00086                 {\cf17 typename} auxiliary_types::result_operation_t<base_t,op,L>;\par
00087 \par
00088         {\cf17 static} {\cf17 consteval} dig_t          dig_0()                 noexcept\par
00089         \{{\cf19 return} dig_t::dig_0();\}\par
00090         {\cf17 static} {\cf17 consteval} dig_t          dig_1()                 noexcept\par
00091         \{{\cf19 return} dig_t::dig_1();\}\par
00092         {\cf17 static} {\cf17 consteval} dig_t          dig_Bm1()               noexcept\par
00093         \{{\cf19 return} dig_t::dig_Bm1();\}\par
00094         {\cf17 static} {\cf17 consteval} dig_t          dig_Bm2()               noexcept\par
00095         \{{\cf19 return} dig_t::dig_Bm2();\}\par
00096         {\cf17 static} {\cf17 consteval} UINT_T         ui_0()                  noexcept\par
00097         \{{\cf19 return} dig_t::ui_0();\}\par
00098         {\cf17 static} {\cf17 consteval} UINT_T         ui_1()                  noexcept\par
00099         \{{\cf19 return} dig_t::ui_1();\}\par
00100         {\cf17 static} {\cf17 consteval} UINT_T         ui_Bm1()                noexcept\par
00101         \{{\cf19 return} B-1;\}\par
00102         {\cf17 static} {\cf17 consteval} UINT_T         ui_B()                  noexcept\par
00103         \{{\cf19 return} B;\}\par
00104         {\cf17 static} {\cf17 consteval} SIG_UINT_T     sui_0()         noexcept\par
00105         \{{\cf19 return} dig_t::sui_0();\}\par
00106         {\cf17 static} {\cf17 consteval} SIG_UINT_T     sui_1()         noexcept\par
00107         \{{\cf19 return} dig_t::sui_1();\}\par
00108         {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_Bm1() noexcept\par
00109         \{{\cf19 return} dig_t::sui_B()-1;\}\par
00110         {\cf17 static} {\cf17 consteval} SIG_UINT_T     sui_B()         noexcept\par
00111         \{{\cf19 return} dig_t::sui_B();\}\par
00112         {\cf17 static} {\cf17 consteval} SIG_UINT_T sui_Bp1() noexcept\par
00113         \{{\cf19 return} dig_t::sui_B()+1;\}\par
00114         {\cf17 static} {\cf17 consteval} SIG_SINT_T     ssi_0()         noexcept\par
00115         \{{\cf19 return} dig_t::ssi_0();\}\par
00116         {\cf17 static} {\cf17 consteval} SIG_SINT_T     ssi_1()         noexcept\par
00117         \{{\cf19 return} dig_t::ssi_1();\}\par
00118         {\cf17 static} {\cf17 consteval} SIG_SINT_T ssi_Bm1() noexcept\par
00119         \{{\cf19 return} dig_t::ssi_B()-1;\}\par
00120         {\cf17 static} {\cf17 consteval} SIG_SINT_T     ssi_B()         noexcept\par
00121         \{{\cf19 return} dig_t::ssi_B();\}\par
00122         {\cf17 static} {\cf17 consteval} SIG_SINT_T ssi_Bp1() noexcept\par
00123         \{{\cf19 return} dig_t::ssi_B()+1;\}\par
00124 \par
00129 \par
00130         {\cf17 template}<{\cf18 size_t} N>\par
00131         {\cf17 static} {\cf17 consteval}\par
00132         base_N_t<N>     regd_base_N_0() noexcept \{\par
00133                 base_N_t<N> ret;\par
00134                 {\cf19 for}(dig_t& dig : ret) \{\par
00135                         dig = dig_0();\par
00136                 \}\par
00137                 {\cf19 return} ret;\par
00138         \}\par
00139 \par
00140         {\cf17 template}<{\cf18 size_t} N>\par
00141         {\cf17 static} {\cf17 consteval}\par
00142         base_N_t<N>     regd_base_N_1() noexcept \{\par
00143                 base_N_t<N> ret\{regd_base_N_0<N>()\};\par
00144                 ret[0] = dig_1();\par
00145                 {\cf19 return} ret;\par
00146         \}\par
00147 \par
00148         {\cf17 template}<{\cf18 size_t} N>\par
00149         {\cf17 static} {\cf17 consteval}\par
00150         base_N_t<N>     regd_base_N_Bm1() noexcept \{\par
00151                 base_N_t<N> ret\{regd_base_N_0<N>()\};\par
00152                 ret[0] = dig_Bm1();\par
00153                 {\cf19 return} ret;\par
00154         \}\par
00155 \par
00156         {\cf17 template}<{\cf18 size_t} N>\par
00157         {\cf17 static} {\cf17 consteval}\par
00158         base_N_t<N>     regd_base_N_B() noexcept \{\par
00159                 base_N_t<N> ret\{regd_base_N_0<N>()\};\par
00160                 ret[1] = dig_1();\par
00161                 {\cf19 return} ret;\par
00162         \}\par
00163 \par
00164         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} n>\par
00165                 {\cf17 requires} ((n>=0)&&(n < N))\par
00166         {\cf17 static} {\cf17 consteval}\par
00167         base_N_t<N>     regd_base_N_pow_n_B() {\cf17 noexcept} \{\par
00168                 base_N_t<N> ret\{regd_base_N_0<N>()\};\par
00169                 ret[n] = dig_1();\par
00170                 {\cf19 return} ret;\par
00171         \}\par
00172 \par
00173         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} n>\par
00174                 {\cf17 requires} ((n>=0)&&(n < N))\par
00175         {\cf17 static} {\cf17 consteval}\par
00176         base_N_t<N>     regd_base_N_pow_n_B_m1() {\cf17 noexcept} \{\par
00177                 base_N_t<N> ret\{\};\par
00178                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < n ; ++ix) \{\par
00179                         ret[ix] = dig_Bm1();\par
00180                 \}\par
00181                 {\cf19 for}({\cf18 size_t} ix\{n\} ; ix < N ; ++ix) \{\par
00182                         ret[ix] = dig_0();\par
00183                 \}\par
00184                 {\cf19 return} ret;\par
00185         \}\par
00186 \par
00193 \par
00194         {\cf17 static} {\cf17 consteval}\par
00195         base_t regd_base_0() noexcept \{\par
00196                 {\cf19 return} base_t\{regd_base_N_0<L>()\};\par
00197         \}\par
00198 \par
00199         {\cf17 static} {\cf17 consteval}\par
00200         base_t  regd_base_1() noexcept \{\par
00201                 {\cf19 return} base_t\{regd_base_N_1<L>()\};\par
00202         \}\par
00203 \par
00204         {\cf17 static} {\cf17 consteval}\par
00205         base_t  regd_base_Bm1() noexcept \{\par
00206                 {\cf19 return} base_t\{regd_base_N_Bm1<L>()\};\par
00207         \}\par
00208 \par
00209         {\cf17 static} {\cf17 consteval}\par
00210         base_t  regd_base_B() noexcept \{\par
00211                 {\cf19 return} base_t\{regd_base_N_B<L>()\};\par
00212         \}\par
00213 \par
00214         {\cf17 static} {\cf17 consteval}\par
00215         base_t  regd_base_pow_n_B()     noexcept \{\par
00216                 {\cf19 return} base_t\{regd_base_N_pow_n_B<L>()\};\par
00217         \}\par
00218 \par
00219         {\cf17 static} {\cf17 consteval}\par
00220         base_t  regd_base_pow_n_B_m1() noexcept \{\par
00221                 {\cf19 return} base_t\{regd_base_N_pow_n_B_m1<L>()\};\par
00222         \}\par
00223 \par
00228 \par
00229         {\cf17 static} {\cf17 consteval}\par
00230         reg_digs_t regd_0() noexcept \{\par
00231                 {\cf19 return} reg_digs_t\{regd_base_N_0<L>()\};\par
00232         \}\par
00233 \par
00234         {\cf17 static} {\cf17 consteval}\par
00235         reg_digs_t      regd_1() noexcept \{\par
00236                 {\cf19 return} reg_digs_t\{regd_base_1()\};\par
00237         \}\par
00238 \par
00239         {\cf17 static} {\cf17 consteval}\par
00240         reg_digs_t      regd_Bm1() noexcept \{\par
00241                 {\cf19 return} reg_digs_t\{regd_base_Bm1()\};\par
00242         \}\par
00243 \par
00244         {\cf17 static} {\cf17 consteval}\par
00245         reg_digs_t      regd_B() noexcept \{\par
00246                 {\cf19 return} reg_digs_t\{regd_base_B()\};\par
00247         \}\par
00248 \par
00249         {\cf17 static} {\cf17 consteval}\par
00250         reg_digs_t      regd_pow_n_B()  noexcept \{\par
00251                 {\cf19 return} reg_digs_t\{regd_base_pow_n_B()\};\par
00252         \}\par
00253 \par
00254         {\cf17 static} {\cf17 consteval}\par
00255         reg_digs_t      regd_pow_n_B_m1() noexcept      \{\par
00256                 {\cf19 return} reg_digs_t\{regd_base_pow_n_B_m1()\};\par
00257         \}\par
00258 \par
00259 public :\par
00267         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})begin()                                 {\cf17 noexcept}\par
00268         \{ {\cf19 return} base_t::begin(); \}\par
00269         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})cbegin()        {\cf17 const}   {\cf17 noexcept}\par
00270         \{ {\cf19 return} base_t::cbegin(); \}\par
00271         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})end()                                           {\cf17 noexcept}\par
00272         \{ {\cf19 return} base_t::end(); \}\par
00273         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})cend()          {\cf17 const}   {\cf17 noexcept}\par
00274         \{ {\cf19 return} base_t::cend(); \}\par
00275         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})rbegin()                                {\cf17 noexcept}\par
00276         \{ {\cf19 return} base_t::rbegin(); \}\par
00277         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})crbegin()       {\cf17 const}   {\cf17 noexcept}\par
00278         \{ {\cf19 return} base_t::crbegin(); \}\par
00279         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})rend()                                  {\cf17 noexcept}\par
00280         \{ {\cf19 return} base_t::rend(); \}\par
00281         {\cf17 constexpr} {\cf17 decltype}({\cf17 auto})crend()         {\cf17 const}   {\cf17 noexcept}\par
00282         \{ {\cf19 return} base_t::crend(); \}\par
00283 \par
00284         {\cf17 constexpr} {\cf18 size_t}        size()          const   noexcept\par
00285         \{ {\cf19 return} base_t::size(); \}\par
00286         {\cf17 constexpr} {\cf18 size_t}        max_size()const noexcept\par
00287         \{ {\cf19 return} base_t::max_size(); \}\par
00288         {\cf17 constexpr} {\cf18 bool}  empty()                 const   noexcept\par
00289         \{ {\cf19 return} base_t::empty(); \}\par
00290 \par
00291         {\cf17 constexpr} dig_t front() noexcept\par
00292         \{ {\cf19 return} (this->base_t::front()); \}\par
00293         {\cf17 constexpr} dig_t {\cf17 const}&  front() const   noexcept\par
00294         \{ {\cf19 return} (this->base_t::front()); \}\par
00295         {\cf17 constexpr} dig_t back()  noexcept\par
00296         \{ {\cf19 return} (this->base_t::back()); \}\par
00297         {\cf17 constexpr} dig_t {\cf17 const}&  back()  const   noexcept\par
00298         \{ {\cf19 return} (this->base_t::back()); \}\par
00299 \par
00300         {\cf17 constexpr} {\cf18 void}  fill({\cf17 const} dig_t& value)        {\cf17 noexcept}\par
00301         \{ this->base_t::fill(value); \}\par
00302         {\cf17 constexpr} {\cf18 void}  swap(base_t& other)     {\cf17 noexcept}\par
00303         \{ this->base_t::swap(*other.data()); \}\par
00304         {\cf17 constexpr} {\cf18 void}  reverse() noexcept\par
00305         \{ std::reverse(this->begin(),this->end()); \}\par
00306 \par
00316 \par
00317 {\cf17 public}:\par
00318 \par
00322         {\cf17 consteval} {\cf17 inline}\par
00323         reg_digs_t()\par
00324         noexcept : base_t\{regd_base_0()\} \{\}\par
00325 \par
00326 private :\par
00334         {\cf17 static} {\cf17 constexpr} base_t make_base_t({\cf17 const} std::initializer_list<dig_t>& larg) \{\par
00335                 base_t rarg;\par
00336                 {\cf19 if} (larg.size() >= L) \{\par
00337                         {\cf17 auto} itlist\{larg.begin()\};\par
00338                         {\cf17 auto} itcthis\{rarg.begin()\};\par
00339                         {\cf17 const} {\cf17 auto} itcthisend\{rarg.end()\};\par
00340                         {\cf19 while} (itcthis != itcthisend) \{\par
00341                                 *itcthis = *itlist;\par
00342                                 ++itcthis;\par
00343                                 ++itlist;\par
00344                         \}\par
00345                 \}\par
00346                 {\cf19 else} \{\par
00347                         {\cf17 auto} itlist\{larg.begin()\};\par
00348                         {\cf17 auto} itcthis\{rarg.begin()\};\par
00349                         {\cf17 const} {\cf17 auto} itlistend\{larg.end()\};\par
00350                         {\cf17 const} {\cf17 auto} itcthisend\{rarg.end()\};\par
00351                         {\cf19 while} (itcthis != itlistend) \{\par
00352                                 *itcthis = *itlist;\par
00353                                 ++itcthis;\par
00354                                 ++itlist;\par
00355                         \}\par
00356                         {\cf19 while} (itcthis != itcthisend) \{\par
00357                                 *itcthis = dig_0();\par
00358                                 ++itcthis;\par
00359                         \}\par
00360                 \}\par
00361                 std::reverse(rarg.begin(),rarg.end());\par
00362                 {\cf19 return} rarg;\par
00363         \}\par
00364 \par
00365 {\cf17 public}:\par
00369         {\cf17 constexpr} {\cf17 inline}\par
00370         reg_digs_t({\cf17 const} std::initializer_list<dig_t> & arg)\par
00371         noexcept : base_t\{make_base_t(arg)\} \{\}\par
00372 \par
00376         {\cf17 template}<{\cf17 typename} ... Ts>\par
00377                 {\cf17 requires} (std::is_same_v<Ts,dig_t>&&...)\par
00378         {\cf17 constexpr} {\cf17 inline}\par
00379         reg_digs_t({\cf17 const} Ts &... args)\par
00380         noexcept : base_t\{(utilities::pack2array<Ts...>\{\})(args...)\} \{\}\par
00381 \par
00383         {\cf17 constexpr} {\cf17 inline}\par
00384         reg_digs_t({\cf17 const} base_t & rarg) noexcept : base_t\{rarg\} \{\}\par
00386         {\cf17 constexpr} {\cf17 inline}\par
00387         reg_digs_t(base_t && rarg) noexcept : base_t\{std::move(rarg)\} \{\}\par
00388 \par
00393 \par
00394 {\cf17 private}:\par
00395 \par
00404         {\cf17 template}<{\cf18 size_t} N>\par
00405         {\cf17 constexpr} {\cf17 inline}\par
00406         {\cf18 void} copy_arg_N({\cf17 const} base_N_t<N> & arg) {\cf17 noexcept} \{\par
00407                 base_t& cthis\{*({\cf17 static_cast<}base_t*{\cf17 >}({\cf17 this}))\};\par
00409                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(N,L)\};\par
00410                 {\cf17 constexpr} {\cf17 auto} W\{std::max(N,L)\};\par
00411                 {\cf19 if} {\cf17 constexpr} (Z==L) \{\par
00412                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00413                                 cthis[ix]=arg[ix];\par
00414                 \}\par
00415                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (W==L) \{\par
00416                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00417                                 cthis[ix]=arg[ix];\par
00418                         {\cf19 for}({\cf18 size_t} ix\{Z\} ; ix < W ; ++ix)\par
00419                                 cthis[ix]=dig_0();\par
00420                 \}\par
00421                 {\cf19 else} \{\par
00422                         cthis=arg;\par
00423                 \}\par
00424         \}\par
00425 \par
00433         {\cf17 template}<{\cf18 size_t} N>\par
00434         {\cf17 constexpr} {\cf17 inline}\par
00435         {\cf18 void} move_arg_N(base_N_t<N>&& arg) {\cf17 noexcept} \{\par
00436                 base_t& cthis\{{\cf17 static_cast<}base_t*{\cf17 >}({\cf17 this})\};\par
00438                 {\cf17 constexpr} {\cf17 auto} Z\{std::min(N,L)\};\par
00439                 {\cf17 constexpr} {\cf17 auto} W\{std::max(N,L)\};\par
00440                 {\cf19 if} {\cf17 constexpr} (Z==L) \{\par
00441                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00442                                 cthis[ix]=std::move(arg[ix]);\par
00443                 \}\par
00444                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (W==L) \{\par
00445                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < Z ; ++ix)\par
00446                                 cthis[ix]=std::move(arg[ix]);\par
00447                         {\cf19 for}({\cf18 size_t} ix\{Z\} ; ix < W ; ++ix)\par
00448                                 cthis[ix]=std::move(dig_0());\par
00449                 \}\par
00450                 {\cf19 else} \{\par
00451                         cthis=std::move(arg);\par
00452                 \}\par
00453         \}\par
00454 \par
00455 {\cf17 public}:\par
00456 \par
00461         {\cf17 template}<{\cf18 size_t} N>\par
00462         {\cf17 constexpr} {\cf17 inline}\par
00463         reg_digs_t({\cf17 const} base_N_t<N> & arg)\par
00464         noexcept : base_t\{copy_arg_N<N>(arg)\} \{\}\par
00465 \par
00470         {\cf17 template}<{\cf18 size_t} N>\par
00471         {\cf17 constexpr} {\cf17 inline}\par
00472         reg_digs_t({\cf17 const} base_N_t<N> && arg)\par
00473         noexcept : base_t\{move_arg_N<N>(std::move(arg))\} \{\}\par
00474 \par
00475 public :\par
00476 \par
00484         {\cf17 template}<{\cf17 typename} ... Ints_type>\par
00485                 {\cf17 requires} (({\cf17 sizeof}...(Ints_type)) == L)\par
00486         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00487         base_t normalize(Ints_type ... digits_pow_i)\par
00488         {\cf17 noexcept} \{\par
00491                 {\cf17 using }pack_type         = {\cf17 typename} utilities::pack2array<Ints_type...>;\par
00494                 {\cf17 using }unique_type = {\cf17 typename} pack_type::elem_type;\par
00495 \par
00497 \par
00512                 {\cf17 using namespace }NumRepr::type_traits;\par
00513                 {\cf17 using }SUInt_type =\par
00514                         {\cf17 typename} std::conditional_t<\par
00515                                 is_unsigned_type_v<UINT_T>,\par
00516                                         {\cf17 typename} std::conditional_t<\par
00517                                                         is_unsigned_type_v<unique_type>,\par
00518                                                         {\cf17 typename} std::conditional_t<\par
00519                                                                 gt_sz_v<UINT_T,unique_type>,\par
00520                                                                         sig_UInt_for_UInt_t<UINT_T>,\par
00521                                                                         sig_UInt_for_UInt_t<unique_type>\par
00522                                                         >,\par
00523                                                         {\cf17 typename} std::conditional_t<\par
00524                                                                 gt_sz_v<UINT_T,unique_type>,\par
00525                                                                         sig_UInt_for_UInt_t<UINT_T>,\par
00526                                                                         sig_UInt_for_SInt_t<unique_type>\par
00527                                                         >\par
00528                                         >,\par
00529                                         {\cf17 typename} std::conditional_t<\par
00530                                                         is_unsigned_type_v<unique_type>,\par
00531                                                         {\cf17 typename} std::conditional_t<\par
00532                                                                 ge_sz_v<UINT_T,unique_type>,\par
00533                                                                         sig_UInt_for_SInt_t<sig_SInt_for_UInt_t<UINT_T>>,\par
00534                                                                         sig_UInt_for_SInt_t<sig_SInt_for_UInt_t<unique_type>>\par
00535                                                         >,\par
00536                                                         {\cf17 typename} std::conditional_t<\par
00537                                                                 gt_sz_v<UINT_T,unique_type>,\par
00538                                                                         sig_UInt_for_SInt_t<sig_SInt_for_UInt_t<UINT_T>>,\par
00539                                                                         sig_UInt_for_SInt_t<sig_SInt_for_SInt_t<unique_type>>\par
00540                                                         >\par
00541                                         >\par
00542                         >;\par
00543                 std::array<SUInt_type,L> ret_array\{((dig_t(digits_pow_i))())...\};\par
00544                 base_t ret;\par
00545 \par
00546                 {\cf19 for} ({\cf18 size_t} ix\{ 0 \}; ix < L; ++ix) \{\par
00547                         ret[ix] = dig_t(ret_array[ix]);\par
00548                 \}\par
00549 \par
00550                 {\cf19 return} ret;\par
00551         \}\par
00552 \par
00553 {\cf17 public}:\par
00554 \par
00557 \par
00558         {\cf17 template}<type_traits::integral_c ... Ints_type>\par
00559                 {\cf17 requires} (({\cf17 sizeof}...(Ints_type))==L)\par
00560         {\cf17 constexpr} {\cf17 inline} reg_digs_t(Ints_type ... dig_pow_i) noexcept :\par
00561                 base_t(normalize<Ints_type...>((dig_t(dig_pow_i))()...)) \{\par
00562                         this->reverse();\par
00563                 \}\par
00564 \par
00568 \par
00571         {\cf17 template}<{\cf18 size_t} N>\par
00572         {\cf17 constexpr} {\cf17 inline}\par
00573         {\cf17 const} reg_digs_t & operator = ({\cf17 const} reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
00574         \{\par
00575                 {\cf19 if} ({\cf17 this}!= &arg)\par
00576                         copy_arg_N<N>(arg);\par
00577                 {\cf19 return} (*{\cf17 this});\par
00578         \}\par
00579 \par
00582         {\cf17 template}<{\cf18 size_t} N>\par
00583         {\cf17 constexpr} {\cf17 inline}\par
00584         reg_digs_t & operator = (reg_N_digs_t<N> & arg) {\cf17 noexcept}\par
00585         \{\par
00586                 {\cf19 if} ({\cf17 this} != &arg)\par
00587                         copy_arg_N<N>(arg);\par
00588                 {\cf19 return} (*{\cf17 this});\par
00589         \}\par
00590 \par
00593         {\cf17 template}<{\cf18 size_t} N>\par
00594         {\cf17 constexpr} {\cf17 inline}\par
00595         {\cf17 const} base_t & operator = (reg_N_digs_t<N>&& arg) {\cf17 noexcept}\par
00596         \{\par
00597                 {\cf19 if} ({\cf17 this} != &arg)\par
00598                         move_arg_N<N>(std::move(arg));\par
00599                 {\cf19 return} (*{\cf17 this});\par
00600         \}\par
00601 \par
00603         {\cf17 constexpr} {\cf17 inline}\par
00604         reg_digs_t & operator = ({\cf17 const} dig_t & arg)\par
00605         {\cf17 noexcept} \{\par
00606                 {\cf19 if} ((&(r_cthis(0)))!=(&arg)) \{\par
00607                         r_cthis().set_0();\par
00608                         r_cthis(0) = arg;\par
00609                 \}\par
00610                 {\cf19 return} (*{\cf17 this});\par
00611         \}\par
00612 \par
00615         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00616         {\cf17 constexpr} {\cf17 inline}\par
00617         {\cf17 const} reg_digs_t& operator = (Int_Type arg) {\cf17 noexcept} \{\par
00618                 {\cf17 using }type_traits::maxbase;\par
00619                 {\cf17 constexpr} sint128_t B_128t_v\{{\cf17 static_cast<}sint128_t{\cf17 >}(B)\};\par
00620                 {\cf17 constexpr} {\cf18 bool} puede_multiplicarse\{\par
00621                                 (maxbase<sint128_t>()/B_128t_v) > 0\par
00622                 \};\par
00623                 {\cf19 if} ((&(this->m_dc)) != (&arg)) \{\par
00624                         sint128_t creg_g\{{\cf17 static_cast<}sint128_t{\cf17 >}(arg)\};\par
00625                         sint128_t BasePowIx\{B_128t_v\};\par
00626                         {\cf19 for}({\cf18 size_t} k\{1u\} ; k < L ; ++k) \{\par
00627                                 {\cf19 if} {\cf17 constexpr} (puede_multiplicarse)\par
00628                                         BasePowIx *= B_128t_v;\par
00629                                 {\cf19 else}\par
00630                                         {\cf19 break};\par
00631                         \}\par
00632                         {\cf19 while} (creg_g < 0) \{\par
00633                                 creg_g += BasePowIx;\par
00634                         \}\par
00635                         {\cf19 for}({\cf18 size_t} k\{0u\} ; k < L ; ++k)\{\par
00636                                 r_cthis(k) = dig_t(creg_g%B_128t_v);\par
00637                                 creg_g /= B_128t_v;\par
00638                         \}\par
00639                 \}\par
00640                 {\cf19 return} (cr_cthis());\par
00641         \}\par
00642 \par
00646 \par
00647         {\cf17 template}<type_traits::{\cf18 int}egral_c Int_Type>\par
00649         {\cf17 constexpr} {\cf17 inline} {\cf17 operator} Int_Type() const noexcept \{\par
00650                 {\cf17 using }type_traits::maxbase;\par
00651                 uint64_t retInt\{0\};\par
00652                 uint64_t BasePowIx\{1\};\par
00653                 {\cf19 for}({\cf18 size_t} k\{0\} ; k < L ; ++k) \{\par
00654                         retInt += cr_cthis_at(k)*BasePowIx;\par
00655                         BasePowIx *= B;\par
00656                         {\cf19 if}(     (k+1 < L)\par
00657                                                 &&\par
00658                                         (maxbase<Int_Type>() < (retInt+((cr_cthis_at(k+1)*BasePowIx)))\par
00659                                 ))\par
00660                         \{       {\cf19 return} retInt; \}\par
00661                 \}\par
00662                 {\cf19 return} retInt;\par
00663         \}\par
00664 \par
00665 private :\par
00670         {\cf17 constexpr} dig_t* data() noexcept \{\par
00671                 {\cf19 return} (this->base_t::data());\par
00672         \}\par
00673 \par
00674 public :\par
00679         {\cf17 constexpr} {\cf17 const} dig_t* {\cf17 const} data() const noexcept \{\par
00680                 {\cf19 return} ({\cf17 static_cast<}{\cf17 const }dig_t*{\cf17 >}(this->base_t::data()));\par
00681         \}\par
00682 \par
00683         {\cf17 inline} {\cf17 constexpr}\par
00684         {\cf17 decltype}({\cf17 auto}) cpy_data() {\cf17 const} {\cf17 noexcept} \{\par
00685                 {\cf19 return} (*(this->base_t::data()));\par
00686         \}\par
00687 \par
00689         {\cf17 inline} {\cf17 constexpr}\par
00690         {\cf17 const} dig_t& operator[]({\cf18 size_t} ix) {\cf17 const} {\cf17 noexcept} \{\par
00691                 {\cf19 return} (cr_cthis_at(ix));\par
00692         \}\par
00693 \par
00695         {\cf17 inline} {\cf17 constexpr}\par
00696         dig_t& operator[]({\cf18 size_t} ix) {\cf17 noexcept} \{\par
00697                 {\cf19 return} (r_cthis_at(ix));\par
00698         \}\par
00699 \par
00700 \par
00708 \par
00709         {\cf17 constexpr} {\cf17 inline}\par
00710         {\cf18 void} set_0() noexcept\par
00711         \{       r_cthis().fill(dig_0());        \}\par
00712 \par
00713         {\cf17 constexpr} {\cf17 inline}\par
00714         {\cf18 void} set_1() noexcept\par
00715         \{       r_cthis().fill(dig_0());\par
00716                 r_cthis()[0].set_1();   \}\par
00717 \par
00718         {\cf17 constexpr} {\cf17 inline}\par
00719         {\cf18 void} set_Bm1() noexcept\par
00720         \{       r_cthis().fill(dig_0());\par
00721                 r_cthis()[0].set_Bm1(); \}\par
00722 \par
00723         {\cf17 constexpr} {\cf17 inline}\par
00724         {\cf18 void} set_dig(dig_t d) {\cf17 noexcept}\par
00725         \{       r_cthis().fill(d);\par
00726                 r_cthis()[0] = d;       \}\par
00727 \par
00728         {\cf17 constexpr} {\cf17 inline}\par
00729         {\cf18 void} set_fill_dig(dig_t d) {\cf17 noexcept}\par
00730         \{       r_cthis().fill(d);      \}\par
00731 \par
00732         {\cf17 constexpr} {\cf17 inline}\par
00733         {\cf18 void} set_fill_1() noexcept\par
00734         \{       r_cthis().fill(dig_1());        \}\par
00735 \par
00736 \par
00737         {\cf17 constexpr} {\cf17 inline}\par
00738         {\cf18 void} set_fill_Bm1() noexcept\par
00739         \{       r_cthis().fill(dig_Bm1());      \}\par
00740 \par
00741 \par
00751 \par
00754         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i  es inicio}\par
00755                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00756                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00757         {\cf17 constexpr} {\cf17 inline}\par
00758         {\cf18 void} set_interval_0() {\cf17 noexcept} \{\par
00759                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00760                         r_cthis(ix).set_0();\par
00761         \}\par
00762 \par
00765         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} N_i,{\cf18 size_t} N_pf> {\cf20 // i  es inicio}\par
00766                                                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00767                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00768         {\cf17 constexpr} {\cf17 inline}\par
00769         {\cf18 void} set_interval_Bm1() {\cf17 noexcept} \{\par
00770                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00771                         r_cthis(ix).set_Bm1();\par
00772         \}\par
00773 \par
00776         {\cf17 template}<{\cf18 size_t} N_i,{\cf18 size_t} N_pf>        {\cf20 // i  es inicio}\par
00777                                                                                                                                                 {\cf20 // pf es pasado el final}\par
00778                 {\cf17 requires} ((N_i < N_pf)&&(N_pf <= L))\par
00779         {\cf17 constexpr} {\cf17 inline}\par
00780         {\cf18 void} set_interval_dig(dig_t dig) {\cf17 noexcept} \{\par
00781                 {\cf19 for} ({\cf18 size_t} ix\{N_i\} ; ix < N_pf ; ++ix)\par
00782                         r_cthis(ix) = dig;\par
00783         \}\par
00784 \par
00788 \par
00789         {\cf17 inline} {\cf17 constexpr}\par
00790         {\cf18 bool} is_0() const noexcept\par
00791         \{\par
00792                 {\cf17 auto} it\{this->cbegin()\};\par
00793                 {\cf17 const} {\cf17 auto} itend\{this->cend()\};\par
00794                 {\cf19 while}(it != itend) \{\par
00795                         {\cf19 if}(it->is_not_0())\par
00796                                 {\cf19 return} {\cf17 false};\par
00797                         ++it;\par
00798                 \}\par
00799                 {\cf19 return} {\cf17 true};\par
00800         \}\par
00801 \par
00802         {\cf17 inline} {\cf17 constexpr}\par
00803         {\cf18 bool} is_1() const noexcept \{\par
00804                 {\cf19 if} (cr_cthis(0).is_not_1())\par
00805                         {\cf19 return} {\cf17 false};\par
00806                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix<L ; ++ix) \{\par
00807                         {\cf19 if}(cr_cthis(ix).is_not_0())\par
00808                                 {\cf19 return} {\cf17 false};\par
00809                 \}\par
00810                 {\cf19 return} {\cf17 true};\par
00811         \}\par
00812 \par
00813         {\cf17 inline} {\cf17 constexpr}\par
00814         {\cf18 bool} is_Bm1() const noexcept \{\par
00815                 {\cf19 if} (cr_cthis(0).is_not_Bm1())\par
00816                         {\cf19 return} {\cf17 false};\par
00817                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix<L ; ++ix) \{\par
00818                         {\cf19 if}(cr_cthis(ix).is_not_0())\par
00819                                 {\cf19 return} {\cf17 false};\par
00820                 \}\par
00821                 {\cf19 return} {\cf17 true};\par
00822         \}\par
00823 \par
00824         {\cf17 inline} {\cf17 constexpr}\par
00825         {\cf18 bool} is_B() const noexcept\par
00826         \{\par
00827                 {\cf19 if} {\cf17 constexpr} (L == 1) {\cf19 return} {\cf17 false};\par
00828                 {\cf19 else} \{\par
00829                         {\cf19 if} (cr_cthis(0).is_not_0())\par
00830                                 {\cf19 return} {\cf17 false};\par
00831                         {\cf19 if} (cr_cthis(1).is_not_1())\par
00832                                 {\cf19 return} {\cf17 false};\par
00833                         {\cf19 for} ({\cf18 size_t} ix\{ 2 \}; ix < L; ++ix) \{\par
00834                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00835                                         {\cf19 return} {\cf17 false};\par
00836                         \}\par
00837                         {\cf19 return} {\cf17 true};\par
00838                 \}\par
00839         \}\par
00840 \par
00841         {\cf17 inline} {\cf17 constexpr}\par
00842         {\cf18 bool} is_Bp1() const noexcept \{\par
00843                 {\cf19 if} {\cf17 constexpr} (L == 1) {\cf19 return} {\cf17 false};\par
00844                 {\cf19 else} \{\par
00845                         {\cf19 if} (cr_cthis(0).is_not_1())\par
00846                                 {\cf19 return} {\cf17 false};\par
00847                         {\cf19 if} (cr_cthis(1).is_not_1())\par
00848                                 {\cf19 return} {\cf17 false};\par
00849                         {\cf19 for} ({\cf18 size_t} ix\{ 2 \}; ix < L; ++ix) \{\par
00850                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00851                                         {\cf19 return} {\cf17 false};\par
00852                         \}\par
00853                         {\cf19 return} {\cf17 true};\par
00854                 \}\par
00855         \}\par
00856 \par
00857         {\cf17 template}<{\cf18 size_t} n>\par
00858                 {\cf17 requires} (n<L)\par
00859         {\cf17 inline} {\cf17 constexpr}\par
00860         {\cf18 bool} is_B_pow_m1() {\cf17 const} {\cf17 noexcept}\par
00861         \{\par
00862                 {\cf19 if} {\cf17 constexpr} (n == 0) \{\par
00863                         {\cf19 return} cr_cthis().is_0();\par
00864                 \}\par
00865                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (n == 1) \{\par
00866                         {\cf19 return} cr_cthis().is_Bm1();\par
00867                 \}\par
00868                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (n == 2) \{\par
00869                         {\cf19 if} (cr_cthis(1).is_not_Bm1() || cr_cthis(0).is_not_Bm1())\par
00870                                 {\cf19 return} {\cf17 false};\par
00871                         {\cf19 for}({\cf18 size_t} ix\{2\} ; ix < L ; ++ix)\par
00872                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00873                                         {\cf19 return} {\cf17 false};\par
00874                         {\cf19 return} {\cf17 true};\par
00875                 \}\par
00876                 {\cf19 else} \{\par
00877                         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < n ; ++ix)\par
00878                                 {\cf19 if} (cr_cthis(ix).is_not_Bm1())\par
00879                                         {\cf19 return} {\cf17 false};\par
00880                         {\cf19 for}({\cf18 size_t} ix\{n\} ; ix < L ; ++ix)\par
00881                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00882                                         {\cf19 return} {\cf17 false};\par
00883                         {\cf19 return} {\cf17 true};\par
00884                 \}\par
00885         \}\par
00886 \par
00887         {\cf17 template}<{\cf18 size_t} n>\par
00888                 {\cf17 requires} (n<L-1)\par
00889         {\cf17 inline} {\cf17 constexpr}\par
00890         {\cf18 bool} is_B_pow() {\cf17 const} {\cf17 noexcept}\par
00891         \{\par
00892                 {\cf19 if} {\cf17 constexpr} (n == 0) \{\par
00893                         {\cf19 if} (cr_cthis(0).is_not_1())\par
00894                                 {\cf19 return} {\cf17 false};\par
00895                         {\cf19 for} ({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
00896                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00897                                         {\cf19 return} {\cf17 false};\par
00898                         {\cf19 return} {\cf17 true};\par
00899                 \}\par
00900                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (n == 1) \{\par
00901                         {\cf19 if} (cr_cthis(0).is_not_0())\par
00902                                 {\cf19 return} {\cf17 false};\par
00903                         {\cf19 if} (cr_cthis(1).is_not_1())\par
00904                                 {\cf19 return} {\cf17 false};\par
00905                         {\cf19 for} ({\cf18 size_t} ix\{2\} ; ix < L ; ++ix)\par
00906                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00907                                         {\cf19 return} {\cf17 false};\par
00908                         {\cf19 return} {\cf17 true};\par
00909                 \}\par
00910                 {\cf19 else} {\cf19 if} {\cf17 constexpr} (n == 2) \{\par
00911                         {\cf19 if} (cr_cthis(0).is_not_0() || cr_cthis(1).is_not_0())\par
00912                                 {\cf19 return} {\cf17 false};\par
00913                         {\cf19 if} (cr_cthis(2).is_not_1())\par
00914                                 {\cf19 return} {\cf17 false};\par
00915                         {\cf19 for} ({\cf18 size_t} ix\{3\} ; ix < L ; ++ix)\par
00916                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00917                                         {\cf19 return} {\cf17 false};\par
00918                         {\cf19 return} {\cf17 true};\par
00919                 \}\par
00920                 {\cf19 else} \{\par
00921                         {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < n ; ++ix)\par
00922                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00923                                         {\cf19 return} {\cf17 false};\par
00924                         {\cf19 if} (cr_cthis(n).is_not_1())\par
00925                                 {\cf19 return} {\cf17 false};\par
00926                         {\cf19 for} ({\cf18 size_t} ix\{n+1\} ; ix < L ; ++ix)\par
00927                                 {\cf19 if} (cr_cthis(ix).is_not_0())\par
00928                                         {\cf19 return} {\cf17 false};\par
00929                         {\cf19 return} {\cf17 true};\par
00930                 \}\par
00931         \}\par
00932 \par
00933         {\cf17 inline} {\cf17 constexpr}\par
00934         {\cf18 bool} is_any_B_pow() const noexcept\par
00935         \{\par
00936                 {\cf17 const} {\cf17 auto} pred_not_0 = [](dig_t d)\{{\cf19 return} (d.is_not_0());\};\par
00937                 {\cf17 const} {\cf17 auto} it\{std::find_if(cr_cthis().cbegin(),cr_cthis().cend(),pred_not_0)\};\par
00938                 {\cf19 if} (it != cr_cthis().cend()) \{\par
00939                         {\cf17 const} int64_t card\{std::count_if(cr_cthis().cbegin(),cr_cthis().cend(),pred_not_0)\};\par
00940                         {\cf19 if} (card != 1)\par
00941                                 {\cf19 return} {\cf17 false};\par
00942                         {\cf19 else}\par
00943                                 {\cf19 return} (it->is_0());\par
00944                 \}\par
00945                 {\cf19 return} {\cf17 false};\par
00946         \}\par
00947 \par
00948         {\cf17 inline} {\cf17 constexpr}\par
00949         {\cf18 bool} is_filled_of_1() const noexcept \{\par
00950                 {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\par
00951                         {\cf19 if} (cr_cthis(ix).is_not_1())\par
00952                                 {\cf19 return} {\cf17 false};\par
00953                 {\cf19 return} {\cf17 true};\par
00954         \}\par
00955 \par
00956         {\cf17 inline} {\cf17 constexpr}\par
00957         {\cf18 bool} is_filled_of_Bm1() const noexcept \{\par
00958                 {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\par
00959                         {\cf19 if} (cr_cthis_at(ix).is_not_Bm1())\par
00960                                 {\cf19 return} {\cf17 false};\par
00961                 {\cf19 return} {\cf17 true};\par
00962         \}\par
00963 \par
00964         {\cf17 inline} {\cf17 constexpr}\par
00965         {\cf18 bool} is_filled_of(dig_t d){\cf17  const }\{\par
00966                 {\cf19 for} ({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\par
00967                         {\cf19 if} (cr_cthis(ix) != d)\par
00968                                 {\cf19 return} {\cf17 false};\par
00969                 {\cf19 return} {\cf17 true};\par
00970         \}\par
00971 \par
00981 \par
00983         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00984         reg_digs_t cat({\cf17 const} reg_digs_t & arg) {\cf17 noexcept}\par
00985         \{       {\cf19 return} std::move(reg_digs_t\{arg\});      \}\par
00986 \par
00988         {\cf17 template}<{\cf18 size_t} M>\par
00989         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
00990                 reg_N_digs_t<L+M>\par
00991                 cat({\cf17 const} reg_digs_t& larg,{\cf17 const} reg_N_digs_t<M>& rarg)\par
00992         {\cf17 noexcept} \{\par
00993                 base_N_t<L+M> ret;\par
00994                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\par
00995                         ret[ix] = larg[ix];\par
00996                 {\cf19 for}({\cf18 size_t} ix\{L\} ; ix < M ; ++ix)\par
00997                         ret[ix] = rarg[ix];\par
00998                 {\cf19 return} std::move(ret);\par
00999         \}\par
01000 \par
01002         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01003         reg_N_digs_t<L+1> cat({\cf17 const} reg_digs_t & larg,dig_t rarg)\par
01004         {\cf17 noexcept} \{\par
01005                 reg_N_digs_t<L+1> ret;\par
01006                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix)\par
01007                         ret[ix] = larg[ix];\par
01008                 ret[L] = rarg;\par
01009                 {\cf19 return} std::move(ret);\par
01010         \}\par
01011 \par
01013         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01014         reg_N_digs_t<1+L> cat(dig_t larg,{\cf17 const} reg_digs_t & rarg)\par
01015         {\cf17 noexcept} \{\par
01016                 reg_N_digs_t<1+L> ret;\par
01017                 ret[0] = larg;\par
01018                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L+1 ; ++ix)\par
01019                         ret[ix] = rarg[ix-1];\par
01020                 {\cf19 return} std::move(ret);\par
01021         \}\par
01022 \par
01024         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01025         reg_N_digs_t<1> cat(dig_t larg) {\cf17 noexcept}\par
01026         \{       {\cf19 return} std::move(reg_N_digs_t<1>\{larg\});        \}\par
01027 \par
01029         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01030         reg_N_digs_t<2> cat(dig_t larg,dig_t rarg) {\cf17 noexcept} \{\par
01031                 reg_N_digs_t<2> ret;\par
01032                 ret[0] = larg;\par
01033                 ret[1] = rarg;\par
01034                 {\cf19 return} std::move(ret);\par
01035         \}\par
01036 \par
01039         {\cf17 template}<{\cf17 typename} T0,{\cf17 typename} ... Ts>\par
01040                 {\cf17 requires} (\par
01041                         ((std::is_same_v<Ts,dig_t>)&&...)&&\par
01042                         (std::is_same_v<T0,dig_t>)\par
01043                 )\par
01044         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01045         reg_N_digs_t<1+({\cf17 sizeof} ... (Ts))>\par
01046                                 cat(T0 dig0,Ts ... dig_pack) {\cf17 noexcept} \{\par
01047                 {\cf19 return} cat(dig_0,dig_pack...);\par
01048         \}\par
01049 \par
01052         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} ... Ts>\par
01053                 {\cf17 requires} (\par
01054                         ((std::is_same_v<Ts,dig_t>)&&...)       &&\par
01055                         (std::is_same_v<T,dig_t>)\par
01056                 )\par
01057         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01058         reg_N_digs_t<L+1+({\cf17 sizeof} ... (Ts))>\par
01059                 cat(reg_digs_t larg,T dig,Ts ... dig_pack) {\cf17 noexcept} \{\par
01060                 {\cf19 return} cat(larg,cat(dig,dig_pack...));\par
01061         \}\par
01062 \par
01065         {\cf17 template}<{\cf17 typename} T,{\cf17 typename} ... Ts>\par
01066                 {\cf17 requires} (\par
01067                         ((std::is_same_v<Ts,dig_t>)&&...)       &&\par
01068                         (std::is_same_v<T,dig_t>)\par
01069                 )\par
01070         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01071                 reg_N_digs_t<L+1+({\cf17 sizeof} ... (Ts))>\par
01072                 cat(T dig,Ts ... dig_pack,reg_digs_t rarg)\par
01073         {\cf17 noexcept} \{\par
01074                 {\cf19 return} cat(cat(dig,dig_pack...),rarg);\par
01075         \}\par
01076 \par
01081         {\cf17 template}<{\cf18 size_t} N,{\cf18 size_t} ... N_pack>\par
01082                 {\cf17 requires} ((N>0)&&((N_pack>0)&&...))\par
01083         {\cf17 static} {\cf17 constexpr} {\cf17 inline}\par
01084                 reg_N_digs_t<N+(...+(N_pack))>\par
01085                 cat(reg_N_digs_t<N> larg,reg_N_digs_t<N_pack> ... rarg_pack)\par
01086                 {\cf17 noexcept}        \{\par
01087                 {\cf19 return} cat(larg,rarg_pack...);\par
01088         \}\par
01089 \par
01091         {\cf17 template}<{\cf18 size_t} ibegin,{\cf18 size_t} iend>\par
01092                 {\cf17 requires} ((iend <= L)&&(ibegin < L)&&(ibegin != iend))\par
01093         {\cf17 constexpr} {\cf17 inline}\par
01094         reg_N_digs_t<(ibegin < iend)?(iend-ibegin):(ibegin-iend)>\par
01095         subregister() const noexcept \{\par
01096                 const reg_digs_t & cthis\{*this\};\par
01097                 {\cf19 if} {\cf17 constexpr} (ibegin < iend) \{\par
01098                         reg_N_digs_t<iend-ibegin> ret;\par
01099                         {\cf19 for}({\cf18 size_t} ix\{ibegin\} ; ix < iend ; ++ix) \{\par
01100                                 ret[ix-ibegin] = cthis[ix];\par
01101                         \}\par
01102                         {\cf19 return} ret;\par
01103                 \}\par
01104                 {\cf19 else} \{\par
01105                         reg_N_digs_t<iend-ibegin> ret;\par
01106                         {\cf19 for}(int64_t ix\{iend\} ; ix > ibegin-1 ; --ix) \{\par
01107                                 ret[ix-ibegin] = cthis[L-1-ix];\par
01108                         \}\par
01109                         {\cf19 return} ret;\par
01110                 \}\par
01111         \}\par
01112 \par
01117 \par
01118         {\cf17 constexpr} {\cf17 inline}\par
01119         {\cf17 const} reg_digs_t & mC_Bm1() noexcept \{\par
01120                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix) \{\par
01121                                 r_cthis(ix).mC_Bm1();\par
01122                 \}\par
01123                 {\cf19 return} (cr_cthis());\par
01124         \}\par
01125 \par
01126         {\cf17 constexpr} {\cf17 inline}\par
01127         {\cf17 const} reg_digs_t & mC_B() noexcept \{\par
01128                 r_cthis().mC_Bm1();\par
01129                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix) \{\par
01130                         {\cf19 if} (r_cthis(ix).is_not_Bm1()) \{\par
01131                                 ++r_cthis(ix);\par
01132                                 {\cf19 return} (cr_cthis());\par
01133                         \}\par
01134                         {\cf19 else} \{\par
01135                                 r_cthis(ix).set_0();\par
01136                         \}\par
01137                 \}\par
01138                 {\cf19 return} (cr_cthis());\par
01139         \}\par
01140 \par
01141         {\cf17 constexpr} {\cf17 inline}\par
01142         reg_digs_t C_Bm1() const noexcept\par
01143         \{       {\cf19 return} std::move(cp_cthis().mC_Bm1()); \}\par
01144 \par
01145         {\cf17 constexpr} {\cf17 inline}\par
01146         reg_digs_t C_B() const noexcept\par
01147         \{ {\cf19 return} std::move(cp_cthis().mC_B());  \}\par
01148 \par
01152 \par
01153         {\cf17 constexpr} {\cf17 inline}\par
01154         reg_digs_t operator !() const noexcept\par
01155         \{ {\cf19 return} C_Bm1(); \}\par
01156 \par
01157         {\cf17 constexpr} {\cf17 inline}\par
01158         reg_digs_t operator -() const noexcept\par
01159         \{ {\cf19 return} C_B(); \}\par
01160 \par
01161 public :\par
01163 \par
01168         {\cf17 constexpr} {\cf17 inline}\par
01169         reg_digs_t operator << ({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept} \{\par
01170                 {\cf19 for}(int32_t ix\{L-1-n\} ; ix > -1 ; --ix) \{\par
01171                         cp_cthis(ix+n)  = cr_cthis(ix);\par
01172                 \}\par
01173                 {\cf19 for}(int32_t ix\{0\} ; ix < n ; ++ix) \{\par
01174                         cp_cthis(ix+n)  =       dig_0();\par
01175                 \}\par
01176                 {\cf19 return} (cp_cthis());\par
01177         \}\par
01178 \par
01180 \par
01181         {\cf17 constexpr} {\cf17 inline}\par
01182         {\cf17 const} reg_digs_t & operator <<= ({\cf18 size_t} n) {\cf17 noexcept} \{\par
01183                 reg_digs_t & cthis\{*{\cf17 this}\};\par
01184                 {\cf19 for}(int32_t ix\{L-1-n\} ; ix > -1 ; --ix) \{\par
01185                         cthis[ix+n]     = cthis[ix];\par
01186                 \}\par
01187                 {\cf19 for}(int32_t ix\{0\} ; ix < n ; ++ix) \{\par
01188                         cthis[ix]       = dig_0();\par
01189                 \}\par
01190                 {\cf19 return} (*{\cf17 this});\par
01191         \}\par
01192 \par
01193         {\cf17 constexpr} {\cf17 inline}\par
01194         {\cf17 const} reg_digs_t & operator >>= ({\cf18 size_t} n) {\cf17 noexcept} \{\par
01195                 reg_digs_t & cthis\{*{\cf17 this}\};\par
01196                 {\cf17 constexpr} int64_t Ls = {\cf17 static_cast<}int64_t{\cf17 >}(L);\par
01197                 {\cf17 const}           int64_t ns = {\cf17 static_cast<}int64_t{\cf17 >}(n);\par
01198                 {\cf19 for}(int64_t ix\{0\} ; ix < Ls-ns ; ++ix) \{\par
01199                         cthis[ix]               = cthis[ix+n];\par
01200                 \}\par
01201                 {\cf19 for}(int64_t ix\{Ls-ns\} ; ix < Ls ; ++ix) \{\par
01202                         cthis[ix]               =       dig_0();\par
01203                 \}\par
01204                 {\cf19 return} (*{\cf17 this});\par
01205         \}\par
01206 \par
01207         {\cf17 constexpr} {\cf17 inline}\par
01208         reg_digs_t operator >> ({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept} \{\par
01209                 reg_digs_t ret\{*{\cf17 this}\};\par
01210                 ret >>= n;\par
01211                 {\cf19 return} ret;\par
01212         \}\par
01213 \par
01214         {\cf17 constexpr} {\cf17 inline}\par
01215         reg_digs_t rem_B({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept} \{\par
01216                 reg_digs_t ret\{*{\cf17 this}\};\par
01217                 ret <<= L-n;\par
01218                 {\cf19 return} ret;\par
01219         \}\par
01220 \par
01221         {\cf17 constexpr} {\cf17 inline}\par
01222         {\cf17 const} reg_digs_t & m_rem_B({\cf18 size_t} n) {\cf17 noexcept} \{\par
01223                 reg_digs_t & cthis\{*{\cf17 this}\};\par
01224                 cthis <<= L-n;\par
01225                 {\cf19 return} (*{\cf17 this});\par
01226         \}\par
01227 \par
01228 \par
01229         {\cf17 constexpr} {\cf17 inline}\par
01230         reg_digs_t mer_B({\cf18 size_t} n) {\cf17 const} {\cf17 noexcept} \{\par
01231                 reg_digs_t ret\{*{\cf17 this}\};\par
01232                 ret >>= L-n;\par
01233                 {\cf19 return} (ret);\par
01234         \}\par
01235 \par
01236         {\cf17 constexpr} {\cf17 inline}\par
01237         {\cf17 const} reg_digs_t & m_mer_B({\cf18 size_t} n) {\cf17 noexcept} \{\par
01238                 reg_digs_t& cthis\{*{\cf17 this}\};\par
01239                 cthis >>= L-n;\par
01240                 {\cf19 return} (cthis);\par
01241         \}\par
01242 \par
01243         {\cf17 constexpr} {\cf17 inline}\par
01244         {\cf17 const} reg_digs_t & operator |= ({\cf17 const} base_t & rarg) {\cf17 const} {\cf17 noexcept} \{\par
01245                 reg_digs_t& cthis\{*{\cf17 this}\};\par
01246                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix) \{\par
01247                         cthis[ix] |= rarg[ix];\par
01248                 \}\par
01249                 {\cf19 return} (cthis);\par
01250         \}\par
01251 \par
01252         {\cf17 constexpr} {\cf17 inline}\par
01253         reg_digs_t operator | ({\cf17 const} reg_digs_t & rarg) {\cf17 const} {\cf17 noexcept} \{\par
01254                 reg_digs_t ret\{*{\cf17 this}\};\par
01255                 ret |= rarg;\par
01256                 {\cf19 return} (ret);\par
01257         \}\par
01258 \par
01259         {\cf17 constexpr} {\cf17 inline}\par
01260         {\cf17 const} reg_digs_t& operator &= ({\cf17 const} reg_digs_t & rarg) {\cf17 noexcept} \{\par
01261                 reg_digs_t& cthis\{*{\cf17 this}\};\par
01262                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < L ; ++ix) \{\par
01263                         cthis[ix] &= rarg[ix];\par
01264                 \}\par
01265                 {\cf19 return} (cthis);\par
01266         \}\par
01267 \par
01268         {\cf17 constexpr} {\cf17 inline}\par
01269         reg_digs_t operator & ({\cf17 const} reg_digs_t & rarg) {\cf17 noexcept} \{\par
01270                 reg_digs_t ret\{*{\cf17 this}\};\par
01271                 ret &= rarg;\par
01272                 {\cf19 return} (ret);\par
01273         \}\par
01274 \par
01279         {\cf17 inline} {\cf17 constexpr}\par
01280         int64_t index_of_MSDig() const noexcept \{\par
01281                 {\cf19 for}(int64_t ix\{L-1\} ; ix > -1 ; --ix) \{\par
01282                         {\cf19 if} (cr_cthis_at(ix).is_not_0())\par
01283                                 {\cf19 return} ix;\par
01284                 \}\par
01285                 {\cf19 return} (-1);\par
01286         \}\par
01287 \par
01293 \par
01295         {\cf17 constexpr} {\cf17 inline}\par
01296         {\cf18 bool} operator == ({\cf17 const} dig_t& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01297                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01298                 {\cf19 if} (cthis[0] != rarg)\par
01299                         {\cf19 return} {\cf17 false};\par
01300                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
01301                         {\cf19 if} (cthis[ix].is_not_0())\par
01302                                 {\cf19 return} {\cf17 false};\par
01303                 {\cf19 return} {\cf17 true};\par
01304         \}\par
01305 \par
01306         {\cf17 constexpr} {\cf17 inline}\par
01307         {\cf18 bool} operator != ({\cf17 const} dig_t& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01308                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01309                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
01310                         {\cf19 if} (cthis[ix].is_not_0())\par
01311                                 {\cf19 return} {\cf17 true};\par
01312                 {\cf19 if} (cthis[0] != rarg)\par
01313                         {\cf19 return} {\cf17 true};\par
01314                 {\cf19 return} {\cf17 false};\par
01315 \par
01316         \}\par
01317 \par
01318         {\cf17 constexpr} {\cf17 inline}\par
01319         {\cf18 bool} operator > ({\cf17 const} dig_t& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01320                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01321                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
01322                         {\cf19 if} (cthis[ix].is_not_0())\par
01323                                 {\cf19 return} {\cf17 true};\par
01324                 {\cf19 if} (cthis[0] > rarg)\par
01325                         {\cf19 return} {\cf17 true};\par
01326                 {\cf19 return} {\cf17 false};\par
01327         \}\par
01328 \par
01329         {\cf17 constexpr} {\cf17 inline}\par
01330         {\cf18 bool} operator < ({\cf17 const} dig_t& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01331                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01332                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
01333                         {\cf19 if} (cthis[ix].is_not_0())\par
01334                                 {\cf19 return} {\cf17 false};\par
01335                 {\cf19 if} (cthis[0] >= rarg)\par
01336                         {\cf19 return} {\cf17 false};\par
01337                 {\cf19 return} {\cf17 true};\par
01338         \}\par
01339 \par
01340         {\cf17 constexpr} {\cf17 inline}\par
01341         {\cf18 bool} operator >= ({\cf17 const} dig_t& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01342                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01343                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
01344                         {\cf19 if} (cthis[ix].is_not_0())\par
01345                                 {\cf19 return} {\cf17 true};\par
01346                 {\cf19 if} (cthis[0] >= rarg)\par
01347                         {\cf19 return} {\cf17 true};\par
01348                 {\cf19 return} {\cf17 false};\par
01349         \}\par
01350 \par
01351         {\cf17 constexpr} {\cf17 inline}\par
01352         {\cf18 bool} operator <= ({\cf17 const} dig_t& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01353                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01354                 {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < L ; ++ix)\par
01355                         {\cf19 if} (cthis[ix].is_not_0())\par
01356                                 {\cf19 return} {\cf17 false};\par
01357                 {\cf19 if} (cthis[0] > rarg)\par
01358                         {\cf19 return} {\cf17 false};\par
01359                 {\cf19 else}\par
01360                         {\cf19 return} {\cf17 true};\par
01361         \}\par
01362 \par
01366         {\cf17 template}<{\cf18 size_t} M>\par
01367         {\cf17 constexpr} {\cf17 inline}\par
01368         {\cf18 bool} operator == ({\cf17 const} reg_N_digs_t<M>& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01369                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01370 \par
01371                 {\cf17 constexpr} {\cf18 size_t} P\{std::min(L,M)\};\par
01372                 {\cf17 constexpr} {\cf18 size_t} Q\{std::max(L,M)\};\par
01373                 {\cf17 constexpr} {\cf18 bool} L_gt_M\{L>M\};\par
01374 \par
01375                 {\cf19 if} {\cf17 constexpr} (L!=M) \{\par
01376                         {\cf19 for} ({\cf18 size_t} ix\{P\} ; ix < Q ; ++ix) \{\par
01377                                 {\cf19 if} {\cf17 constexpr} (L_gt_M) \{\par
01378                                         {\cf19 if} (cthis[ix].is_not_0())\par
01379                                                 {\cf19 return} {\cf17 false};\par
01380                                 \}\par
01381                                 {\cf19 else} \{\par
01382                                         {\cf19 if} (rarg[ix].is_not_0())\par
01383                                                 {\cf19 return} {\cf17 false};\par
01384                                 \}\par
01385                         \}\par
01386                 \}\par
01387                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < P ; ++ix)\par
01388                         {\cf19 if} (cthis[ix] != rarg[ix])\par
01389                                 {\cf19 return} {\cf17 false};\par
01390                 {\cf19 return} {\cf17 true};\par
01391         \}\par
01392 \par
01393         {\cf17 template}<{\cf18 size_t} M>\par
01394         {\cf17 constexpr} {\cf17 inline}\par
01395         {\cf18 bool} operator != ({\cf17 const} reg_N_digs_t<M>& rarg) {\cf17 const} {\cf17 noexcept}  \{\par
01396                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01397 \par
01398                 {\cf17 constexpr} {\cf18 size_t} P\{std::min(L,M)\};\par
01399                 {\cf17 constexpr} {\cf18 size_t} Q\{std::max(L,M)\};\par
01400                 {\cf17 constexpr} {\cf18 bool} L_gt_M\{L>M\};\par
01401 \par
01402                 {\cf19 if} {\cf17 constexpr} (L!=M) \{\par
01403                         {\cf19 for} ({\cf18 size_t} ix\{P\} ; ix < Q ; ++ix) \{\par
01404                                 {\cf19 if} {\cf17 constexpr} (L_gt_M) \{\par
01405                                         {\cf19 if} (cthis[ix].is_not_0())\par
01406                                                 {\cf19 return} {\cf17 true};\par
01407                                 \}\par
01408                                 {\cf19 else} \{\par
01409                                         {\cf19 if} (rarg[ix].is_not_0())\par
01410                                                 {\cf19 return} {\cf17 true};\par
01411                                 \}\par
01412                         \}\par
01413                 \}\par
01414                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < P ; ++ix)\par
01415                         {\cf19 if} (cthis[ix] != rarg[ix])\par
01416                                 {\cf19 return} {\cf17 true};\par
01417                 {\cf19 return} {\cf17 false};\par
01418         \}\par
01419 \par
01420         {\cf17 template}<{\cf18 size_t} M>\par
01421         {\cf17 constexpr} {\cf17 inline}\par
01422         {\cf18 bool} operator > ({\cf17 const} reg_N_digs_t<M>& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01423                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01424                 {\cf17 constexpr} {\cf18 size_t} P\{std::min(L,M)\};\par
01425                 {\cf17 constexpr} {\cf18 size_t} Q\{std::max(L,M)\};\par
01426                 {\cf17 constexpr} {\cf18 bool} L_gt_M\{L>M\};\par
01427 \par
01428                 {\cf19 if} {\cf17 constexpr} (L != M) \{\par
01429                         {\cf19 for}({\cf18 size_t} ix\{P\} ; ix < Q ; ++ix) \{\par
01430                                 {\cf19 if} {\cf17 constexpr} (L>M) \{\par
01431                                         {\cf19 if} (cthis[ix].is_not_0())\par
01432                                                 {\cf19 return} {\cf17 true};\par
01433                                 \}\par
01434                                 {\cf19 else} \{\par
01435                                         {\cf19 if} (rarg[ix].is_not_0())\par
01436                                                 {\cf19 return} {\cf17 false};\par
01437                                 \}\par
01438                         \}\par
01439                 \}\par
01440 \par
01441                 {\cf19 for}(int32_t ix\{L\} ; ix > -1 ; --ix)\par
01442                         {\cf19 if} (cthis[ix] > rarg[ix])\par
01443                                 {\cf19 return} {\cf17 true};\par
01444                 {\cf19 return} {\cf17 false};\par
01445         \}\par
01446 \par
01447         {\cf17 template}<{\cf18 size_t} M>\par
01448         {\cf17 constexpr} {\cf17 inline}\par
01449         {\cf18 bool} operator < ({\cf17 const} reg_N_digs_t<M>& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01450                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01451                 {\cf17 constexpr} {\cf18 size_t} P\{std::min(L,M)\};\par
01452                 {\cf17 constexpr} {\cf18 size_t} Q\{std::max(L,M)\};\par
01453                 {\cf17 constexpr} {\cf18 bool} L_gt_M\{L>M\};\par
01454 \par
01455                 {\cf19 if} {\cf17 constexpr} (L != M) \{\par
01456                         {\cf19 for}({\cf18 size_t} ix\{P\} ; ix < Q ; ++ix) \{\par
01457                                 {\cf19 if} {\cf17 constexpr} (L_gt_M) \{\par
01458                                         {\cf19 if} (cthis[ix].is_not_0())\par
01459                                                 {\cf19 return} {\cf17 false};\par
01460                                 \}\par
01461                                 {\cf19 else} \{\par
01462                                         {\cf19 if} (rarg[ix].is_not_0())\par
01463                                                 {\cf19 return} {\cf17 true};\par
01464                                 \}\par
01465                         \}\par
01466                 \}\par
01467 \par
01468                 {\cf19 for}(int32_t ix\{L\} ; ix > -1 ; --ix)\par
01469                         {\cf19 if} (cthis[ix] < rarg[ix])\par
01470                                 {\cf19 return} {\cf17 true};\par
01471                 {\cf19 return} {\cf17 false};\par
01472         \}\par
01473 \par
01474         {\cf17 template}<{\cf18 size_t} M>\par
01475         {\cf17 constexpr} {\cf17 inline}\par
01476         {\cf18 bool} operator >= ({\cf17 const} reg_N_digs_t<M>& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01477                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01478                 {\cf19 return} (!(cthis < rarg));       \}\par
01479 \par
01480         {\cf17 template}<{\cf18 size_t} M>\par
01481         {\cf17 constexpr} {\cf17 inline}\par
01482         {\cf18 bool} operator <= ({\cf17 const} reg_N_digs_t<M>& rarg) {\cf17 const} {\cf17 noexcept} \{\par
01483                 {\cf17 const} reg_digs_t & cthis\{*{\cf17 this}\};\par
01484                 {\cf19 return} (!(cthis > rarg));       \}\par
01485 \par
01487 \par
01488         {\cf17 template}<{\cf18 size_t} M>\par
01489         {\cf17 constexpr} {\cf17 inline}\par
01490         std::strong_ordering operator <=> ({\cf17 const} reg_N_digs_t<M>& arg) {\cf17 const}\par
01491         {\cf17 noexcept} \{\par
01492                 {\cf17 const} reg_digs_t& cthis\{*{\cf17 this}\};\par
01493                 {\cf19 if} (cthis == arg)\par
01494                         {\cf19 return} std::strong_ordering::equal;\par
01495                 {\cf19 else} {\cf19 if} (cthis < arg)\par
01496                         {\cf19 return} std::strong_ordering::less;\par
01497                 {\cf19 else}\par
01498                         {\cf19 return} std::strong_ordering::greater;\par
01499         \}\par
01500 \par
01502         {\cf17 constexpr} {\cf17 inline}\par
01503         std::weak_ordering operator <=> ({\cf17 const} dig_t & arg) {\cf17 const} {\cf17 noexcept}\par
01504         \{\par
01505                 {\cf17 const} reg_digs_t& cthis\{*{\cf17 this}\};\par
01506                 {\cf19 if} (cthis > arg)\par
01507                         {\cf19 return} std::weak_ordering::greater;\par
01508                 {\cf19 else} {\cf19 if} (cthis < arg)\par
01509                         {\cf19 return} std::weak_ordering::less;\par
01510                 {\cf19 else}\par
01511                         {\cf19 return} std::weak_ordering::equivalent;\par
01512         \}\par
01515 \par
01516   {\cf17 static}\par
01517   {\cf18 bool} is_type_template_string_id(std::string in) {\cf17 noexcept} \{\par
01518     {\cf19 return}      (\par
01519       (in == {\cf22 "reg_digs_t"})||\par
01520                         (in == {\cf22 "reg_digs_"})||\par
01521                         (in == {\cf22 "reg_digs"})||\par
01522       (in == {\cf22 "reg_dig"})||\par
01523       (in == {\cf22 "reg_di"})||\par
01524       (in == {\cf22 "reg_d"})||\par
01525       (in == {\cf22 "reg_"})||\par
01526       (in == {\cf22 "reg"})||\par
01527       (in == {\cf22 "re"})||\par
01528       (in == {\cf22 "r"})\par
01529     );\par
01530   \}\par
01531 \par
01532   {\cf17 static}\par
01533   std::string to_type_template_string_id() noexcept\par
01534   \{     {\cf19 return} std::string\{{\cf22 "reg_digs"}\}; \}\par
01535 \par
01536   {\cf17 static}\par
01537   {\cf18 size_t} size_of_type_template_string_id() noexcept\par
01538   \{     {\cf19 return} (to_type_template_string_id()).size();   \}\par
01539 \par
01540 \par
01543   {\cf17 static}\par
01544   {\cf18 bool} get_type_template_string_id_token(std::istream& is)\par
01545   \{\par
01546         {\cf18 char} input_char = type_traits::nullchar<char>;\par
01547     std::string old_input_string\{{\cf22 ""}\};\par
01548     std::string new_input_string\{{\cf22 ""}\};\par
01549     {\cf19 while}({\cf17 true}) \{\par
01550       is >> input_char;\par
01551       new_input_string += input_char;\par
01552       {\cf19 if} (is_type_template_string_id(new_input_string)) \{\par
01553         old_input_string = new_input_string;\par
01554       \}\par
01555       {\cf19 else} \{\par
01556         std::cerr << {\cf22 "Has cometido un error, tenias que escribir "}\par
01557         << {\cf22 "\\" "} << to_type_template_string_id()\par
01558         << {\cf22 " \\"  y has escrito "}\par
01559         << new_input_string << std::endl;\par
01560         std::cerr << {\cf22 "Considera que has escrito "}\par
01561         << old_input_string\par
01562         << {\cf22 " y continua escribiendo a partir de ahi"};\par
01563         new_input_string = old_input_string;\par
01564       \}\par
01565 \par
01566       {\cf19 if} (new_input_string==to_type_template_string_id())\par
01567         {\cf19 return} {\cf17 true};\par
01568       {\cf19 else}\par
01569         {\cf19 return} {\cf17 false};\par
01570     \}\par
01571   \}\par
01572 \};\par
01573 \par
01575 {\cf17 template}<u{\cf18 int}128_t B,{\cf18 size_t} L>\par
01576 {\cf17 using }register_of_digits_t =\par
01577         reg_digs_t<\par
01578                 type_traits::TypeFromIntNumber_t<B>,\par
01579                 {\cf17 static_cast<}type_traits::TypeFromIntNumber_t<B>{\cf17 >}(B),\par
01580                 L\par
01581         >;\par
01582 \par
01590 \par
01592 {\cf17 template}<{\cf17 typename} UInt_t, UInt_t B, {\cf18 size_t} N>\par
01593         {\cf17 requires} (N>0)\par
01594 {\cf17 constexpr} {\cf17 inline}\par
01595 reg_digs_t<UInt_t,B,N> concat({\cf17 const} reg_digs_t<UInt_t,B,N>& larg) {\cf17 noexcept}\par
01596 \{\par
01597         {\cf19 return} reg_digs_t<UInt_t,B,N>\{larg\};\par
01598 \}\par
01599 \par
01601 {\cf17 template}<{\cf17 typename} UInt_t, UInt_t B, {\cf18 size_t} N,{\cf18 size_t} M>\par
01602         {\cf17 requires} ((N>0)&&(M>0))\par
01603 {\cf17 constexpr} {\cf17 inline}\par
01604 reg_digs_t<UInt_t,B,N+M> concat(\par
01605                 {\cf17 const} reg_digs_t<UInt_t,B,N>& larg,\par
01606                 {\cf17 const} reg_digs_t<UInt_t,B,M>& rarg\par
01607         ) {\cf17 noexcept} \{\par
01608         reg_digs_t<UInt_t,B,N+M> ret;\par
01609         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < N ; ++ix)\par
01610                 ret[ix] = larg[ix];\par
01611         {\cf19 for}({\cf18 size_t} ix\{N\} ; ix < M ; ++ix)\par
01612                 ret[ix] = rarg[ix];\par
01613         {\cf19 return} ret;\par
01614 \}\par
01615 \par
01617 {\cf17 template}<{\cf17 typename} UInt_t, UInt_t B, {\cf18 size_t} N>\par
01618         {\cf17 requires} (N > 0)\par
01619 {\cf17 constexpr} {\cf17 inline}\par
01620 reg_digs_t<UInt_t,B,N+1> concat(\par
01621                 {\cf17 const} reg_digs_t<UInt_t,B,N>& larg,\par
01622                 dig_t<UInt_t,B> rarg\par
01623         ) {\cf17 noexcept} \{\par
01624         reg_digs_t<UInt_t,B,N+1> ret;\par
01625         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < N ; ++ix)\par
01626                 ret[ix] = larg[ix];\par
01627         ret[N] = rarg;\par
01628         {\cf19 return} ret;\par
01629 \}\par
01630 \par
01632 {\cf17 template}<{\cf17 typename} UInt_t, UInt_t B, {\cf18 size_t} M>\par
01633         {\cf17 requires} (M > 0)\par
01634 {\cf17 constexpr} {\cf17 inline}\par
01635 reg_digs_t<UInt_t,B,1+M> concat(\par
01636                 dig_t<UInt_t,B> larg,\par
01637                 {\cf17 const} reg_digs_t<UInt_t,B,M>& rarg\par
01638         ) {\cf17 noexcept} \{\par
01639         reg_digs_t<UInt_t,B,1+M> ret;\par
01640         ret[0] = larg;\par
01641         {\cf19 for}({\cf18 size_t} ix\{1\} ; ix < M+1 ; ++ix)\par
01642                 ret[ix] = rarg[ix-1];\par
01643         {\cf19 return} ret;\par
01644 \}\par
01645 \par
01647 {\cf17 template}<{\cf17 typename} UInt_t, UInt_t B>\par
01648 {\cf17 constexpr} {\cf17 inline}\par
01649 reg_digs_t<UInt_t,B,1> concat(dig_t<UInt_t,B> larg) {\cf17 noexcept}\par
01650 \{       {\cf19 return} reg_digs_t<UInt_t,B,1>\{larg\};    \}\par
01651 \par
01653 {\cf17 template}<{\cf17 typename} UInt_t, UInt_t B>\par
01654 {\cf17 constexpr} {\cf17 inline}\par
01655 reg_digs_t<UInt_t,B,2> concat(dig_t<UInt_t,B> larg,dig_t<UInt_t,B> rarg) {\cf17 noexcept}\par
01656 \{       reg_digs_t<UInt_t,B,2> ret;\par
01657         ret[0] = larg;\par
01658         ret[1] = rarg;\par
01659         {\cf19 return} ret;             \}\par
01660 \par
01664 {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf17 typename} T0,{\cf17 typename} ... Ts>\par
01665         {\cf17 requires} (\par
01666                                                 ((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&...)\par
01667                                                 &&\par
01668                                                 (std::is_same_v<T0,dig_t<UInt_t,B>>)\par
01669         )\par
01670 {\cf17 constexpr} {\cf17 inline}\par
01671 reg_digs_t<UInt_t,B,1+({\cf17 sizeof} ... (Ts))> concat(T0 dig0,Ts ... dig_pack)\par
01672 {\cf17 noexcept} \{\par
01673         {\cf19 return} concat(dig0,dig_pack...);\par
01674 \}\par
01675 \par
01679 {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} N,{\cf17 typename} T,{\cf17 typename} ... Ts>\par
01680         {\cf17 requires} (((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&...)&&(std::is_same_v<T,dig_t<UInt_t,B>>)&&(N>0))\par
01681 {\cf17 constexpr} {\cf17 inline}\par
01682 reg_digs_t<UInt_t,B,N+1+({\cf17 sizeof} ... (Ts))> concat(\par
01683                                                                                         reg_digs_t<UInt_t,B,N> larg,\par
01684                                                                                         T dig,\par
01685                                                                                         Ts ... dig_pack\par
01686         ) {\cf17 noexcept} \{ {\cf19 return} concat(larg,concat(dig,dig_pack...));       \}\par
01687 \par
01691 {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} M,{\cf17 typename} T,{\cf17 typename} ... Ts>\par
01692         {\cf17 requires}        (\par
01693                 ((std::is_same_v<Ts,dig_t<UInt_t,B>>)&&...)\par
01694                 &&\par
01695                 (std::is_same_v<T,dig_t<UInt_t,B>>)\par
01696                 &&\par
01697                 (M>0)           )\par
01698 {\cf17 constexpr} {\cf17 inline}\par
01699 reg_digs_t<UInt_t,B,M+1+({\cf17 sizeof} ... (Ts))> concat(\par
01700                                                                                                                 T dig,\par
01701                                                                                                                 Ts ... dig_pack,\par
01702                                                                                                                 reg_digs_t<UInt_t,B,M> rarg\par
01703         )\par
01704 {\cf17 noexcept} \{ {\cf19 return} concat(concat(dig,dig_pack...),rarg); \}\par
01705 \par
01709 {\cf17 template}<{\cf17 typename} UInt_t,UInt_t B,{\cf18 size_t} N,{\cf18 size_t} ... N_pack>\par
01710         {\cf17 requires} ((N>0)&&((N_pack>0)&&...))\par
01711 {\cf17 constexpr} {\cf17 inline}\par
01712 reg_digs_t<UInt_t,B,N+(...+(N_pack))>\par
01713         concat(reg_digs_t<UInt_t,B,N> larg,reg_digs_t<UInt_t,B,N_pack> ... rarg_pack)\par
01714         {\cf17 noexcept} \{      {\cf19 return} concat(larg,rarg_pack...); \}\par
01715 \par
01716 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01717   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01718 {\cf17 constexpr} {\cf17 inline}\par
01719 reg_digs_t<UINT_T,B,N> {\cf17 operator} << (\par
01720         {\cf17 const} reg_digs_t<UINT_T,B,N>& larg,\par
01721         {\cf18 size_t} n\par
01722         ) {\cf17 noexcept} \{\par
01723         reg_digs_t<UINT_T,B,N> cparg\{larg\};\par
01724         {\cf19 for}(std::int32_t ix\{N-1-n\} ; ix > -1 ; --ix) \{\par
01725                 cparg[ix+n]     = larg[ix];\par
01726         \}\par
01727         {\cf19 for}(std::int32_t ix\{0\} ; ix < n ; ++ix) \{\par
01728                 cparg[ix]               = dig_t<UINT_T,B>::dig_0();\par
01729         \}\par
01730         {\cf19 return} cparg;\par
01731 \}\par
01732 \par
01733 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01734   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01735 {\cf17 constexpr} {\cf17 inline}\par
01736 {\cf17 const} reg_digs_t<UINT_T,B,N> & {\cf17 operator} <<= (\par
01737         reg_digs_t<UINT_T,B,N>& larg,\par
01738         {\cf18 size_t} n\par
01739         ) {\cf17 noexcept} \{\par
01740         {\cf19 for}(std::int32_t ix\{N-1-n\} ; ix > -1 ; --ix) \{\par
01741                 larg[ix+n]      = larg[ix];\par
01742         \}\par
01743         {\cf19 for}(std::int32_t ix\{0\} ; ix < n ; ++ix) \{\par
01744                 larg[ix]        = dig_t<UINT_T,B>::dig_0();\par
01745         \}\par
01746         {\cf19 return} (larg);\par
01747 \}\par
01748 \par
01749 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01750   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01751 {\cf17 constexpr} {\cf17 inline}\par
01752 {\cf17 const} reg_digs_t<UINT_T,B,N> & {\cf17 operator} >>= (\par
01753         reg_digs_t<UINT_T,B,N>& larg,\par
01754         {\cf18 size_t} n\par
01755         ) {\cf17 noexcept} \{\par
01756         {\cf19 for}(std::int32_t ix\{0\} ; ix < N-n ; ++ix) \{\par
01757                 larg[ix]                = larg[ix+n];\par
01758         \}\par
01759         {\cf19 for}(std::int32_t ix\{N-n\} ; ix < N ; ++ix) \{\par
01760                 larg[ix]                =       dig_t<UINT_T,B>::dig_0();\par
01761         \}\par
01762         {\cf19 return} (larg);\par
01763 \}\par
01764 \par
01765 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01766   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01767 {\cf17 constexpr} {\cf17 inline}\par
01768 reg_digs_t<UINT_T,B,N> {\cf17 operator} >> (\par
01769         {\cf17 const} reg_digs_t<UINT_T,B,N> & larg,\par
01770         {\cf18 size_t} n\par
01771         ) {\cf17 noexcept} \{\par
01772         {\cf19 return} (reg_digs_t<UINT_T,B,N>\{larg\}.ref_data() >>= n);\par
01773 \}\par
01774 \par
01775 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01776 {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01777 {\cf17 constexpr} {\cf17 inline}\par
01778 reg_digs_t<UINT_T,B,N> rem_B({\cf17 const} reg_digs_t<UINT_T,B,N> & larg,{\cf18 size_t} n)\par
01779 {\cf17 noexcept} \{\par
01780         reg_digs_t<UINT_T,B,N> ret\{larg\};\par
01781         ret <<= N-n;\par
01782         {\cf19 return} ret;\par
01783 \}\par
01784 \par
01785 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01786 {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01787 {\cf17 constexpr} {\cf17 inline}\par
01788 {\cf17 const} reg_digs_t<UINT_T,B,N> & m_rem_B(reg_digs_t<UINT_T,B,N>& larg,{\cf18 size_t} n)\par
01789 {\cf17 noexcept} \{\par
01790         larg <<= N-n;\par
01791         {\cf19 return} (larg);\par
01792 \}\par
01793 \par
01794 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01795 {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01796 {\cf17 constexpr} {\cf17 inline}\par
01797 reg_digs_t<UINT_T,B,N> mer_B({\cf17 const} reg_digs_t<UINT_T,B,N> & larg,{\cf18 size_t} n)\par
01798 {\cf17 noexcept} \{\par
01799         reg_digs_t<UINT_T,B,N> ret\{larg\};\par
01800         ret >>= N-n;\par
01801         {\cf19 return} ret;\par
01802 \}\par
01803 \par
01804 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01805 {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01806 {\cf17 constexpr} {\cf17 inline}\par
01807 {\cf17 const} reg_digs_t<UINT_T,B,N> & m_mer_B(reg_digs_t<UINT_T,B,N>& larg,{\cf18 size_t} n)\par
01808 {\cf17 noexcept} \{\par
01809         larg >>= N-n;\par
01810         {\cf19 return} (larg);\par
01811 \}\par
01812 \par
01813 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01814   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01815 {\cf17 constexpr} {\cf17 inline}\par
01816 {\cf17 const} reg_digs_t<UINT_T,B,N> & {\cf17 operator} |= (\par
01817                                                 reg_digs_t<UINT_T,B,N> & larg,\par
01818                                                 {\cf17 const} reg_digs_t<UINT_T,B,N> & rarg\par
01819 ) {\cf17 noexcept} \{\par
01820         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < N ; ++ix) \{\par
01821                 larg[ix] |= rarg[ix];\par
01822         \}\par
01823         {\cf19 return} (larg);\par
01824 \}\par
01825 \par
01826 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01827   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01828 {\cf17 constexpr} {\cf17 inline}\par
01829 reg_digs_t<UINT_T,B,N> {\cf17 operator} | (\par
01830                         {\cf17 const} reg_digs_t<UINT_T,B,N> & larg,\par
01831                         {\cf17 const} reg_digs_t<UINT_T,B,N> & rarg\par
01832 ) {\cf17 noexcept} \{\par
01833         reg_digs_t ret\{larg\};\par
01834         ret |= rarg;\par
01835         {\cf19 return} (ret);\par
01836 \}\par
01837 \par
01838 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01839   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01840 {\cf17 constexpr} {\cf17 inline}\par
01841 {\cf17 const} reg_digs_t<UINT_T,B,N> & {\cf17 operator} &= (\par
01842         reg_digs_t<UINT_T,B,N> & larg,\par
01843         {\cf17 const} reg_digs_t<UINT_T,B,N> & rarg\par
01844 ) {\cf17 noexcept} \{\par
01845         {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < N ; ++ix) \{\par
01846                 larg[ix] &= rarg[ix];\par
01847         \}\par
01848         {\cf19 return} (larg);\par
01849 \}\par
01850 \par
01851 {\cf17 template}<u{\cf18 int}_type_for_radix_c UINT_T,UINT_T B,{\cf18 size_t} N>\par
01852   {\cf17 requires} ((suitable_base<UINT_T,B>())&&(N > 0))\par
01853 {\cf17 constexpr} {\cf17 inline}\par
01854 reg_digs_t<UINT_T,B,N> {\cf17 operator} & (\par
01855                 reg_digs_t<UINT_T,B,N> & larg,\par
01856                 {\cf17 const} reg_digs_t<UINT_T,B,N> & rarg\par
01857 ) {\cf17 noexcept} \{\par
01858         reg_digs_t<UINT_T,B,N> ret\{larg\};\par
01859         ret &= rarg;\par
01860         {\cf19 return} (ret);\par
01861 \}\par
01863 {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B,{\cf18 size_t} N>\par
01864 {\cf17 constexpr} {\cf17 inline}\par
01865 reg_digs_t<UINT_T,B,N> m_incr(reg_digs_t<UINT_T,B,N>& rarg) {\cf17 noexcept} \{\par
01866         {\cf20 //using SIG_UINT_T = typename type_traits::sig_UInt_for_UInt_t<UINT_T>;}\par
01867         {\cf17 using }dig_t                      = dig_t<UINT_T,B>;\par
01868 \par
01869         dig_t carry\{dig_t::dig_0()\};\par
01870         {\cf19 for}({\cf18 size_t} i=0 ; i < N ; ++i) \{\par
01871                 {\cf19 if} (i==0) \{\par
01872                         {\cf19 if} (rarg[0].is_Bm1()) \{\par
01873                                 rarg[0].set_0();\par
01874                                 carry.set_1();\par
01875                         \}\par
01876                         {\cf19 else} \{\par
01877                                 ++rarg[0];\par
01878                                 carry.set_0();\par
01879                                 {\cf19 break};\par
01880                         \}\par
01881                 \}\par
01882                 {\cf19 else} \{\par
01883                         {\cf19 if} (carry.is_not_0()) \{\par
01884                                 {\cf19 if} (rarg[i].is_Bm1()) \{\par
01885                                         rarg[i].set_0();\par
01886                                         carry.set_1();\par
01887                                 \}\par
01888                                 {\cf19 else} \{\par
01889                                         ++rarg[i];\par
01890                                         carry.set_0();\par
01891                                         {\cf19 break};\par
01892                                 \}\par
01893                         \}\par
01894                         {\cf19 else} \{\par
01895                                 carry.set_0();\par
01896                                 {\cf19 break};\par
01897                         \}\par
01898                 \}\par
01899         \}\par
01900         {\cf19 return} (rarg);\par
01901 \}\par
01902 \par
01903 {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B>\par
01904 {\cf17 constexpr} {\cf17 inline}\par
01905 dig_t<UINT_T,B>\par
01906 m_sum_digs_carryin1(dig_t<UINT_T,B>& left,dig_t<UINT_T,B> right) {\cf17 noexcept} \{\par
01907 \par
01908         {\cf17 using           }dig_t                   = dig_t<UINT_T,B>;\par
01909         {\cf17 constexpr} dig_t d_0 = dig_t::dig_0();\par
01910         {\cf17 constexpr} dig_t d_1 = dig_t::dig_1();\par
01911 \par
01912         {\cf17 const} dig_t left_CBm1\{left.C_Bm1()\};\par
01913         {\cf19 if}(left.is_Bm1()) \{\par
01914                 left = right;\par
01915                 {\cf19 return} d_1;\par
01916         \}\par
01917         {\cf19 else} {\cf19 if} (right.is_Bm1()) \{\par
01918                 {\cf19 return} d_1;\par
01919         \}\par
01920         {\cf19 else} {\cf19 if} (left_CBm1 < right+d_1) \{\par
01921                 left = right-left_CBm1;\par
01922                 {\cf19 return} d_1;\par
01923         \}\par
01924         {\cf19 else} \{\par
01925                 left += right;\par
01926                 ++left;\par
01927                 {\cf19 return} d_0;\par
01928         \}\par
01929 \}\par
01930 \par
01931 {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B>\par
01932 {\cf17 constexpr} {\cf17 inline}\par
01933 dig_t<UINT_T,B>\par
01934 m_sum_digs_carryin0(dig_t<UINT_T,B>& left,dig_t<UINT_T,B> right) {\cf17 noexcept} \{\par
01935 \par
01936         {\cf17 using }dig_t                      = dig_t<UINT_T,B>;\par
01937         {\cf17 constexpr} dig_t d_0 = dig_t::dig_0();\par
01938         {\cf17 constexpr} dig_t d_1 = dig_t::dig_1();\par
01939 \par
01940         {\cf17 const} dig_t left_CBm1\{left.C_Bm1()\};\par
01941         {\cf19 if} (left_CBm1 >= right)\{\par
01942                 left += right;\par
01943                 {\cf19 return} d_0;\par
01944         \}\par
01945         {\cf19 else} \{\par
01946                 left = right-left_CBm1;\par
01947                 --left;\par
01948                 {\cf19 return} d_1;\par
01949         \}\par
01950 \}\par
01951 \par
01952 {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B,{\cf18 size_t} N>\par
01953         {\cf17 constexpr} {\cf17 inline}\par
01954         dig_t<UINT_T,B>\par
01955         m_sum(\par
01956                 reg_digs_t<UINT_T,B,N>& larg,\par
01957                 {\cf17 const} reg_digs_t<UINT_T,B,N>& rarg\par
01958         ) {\cf17 noexcept}\par
01959 \{\par
01960         {\cf17 using }dig_t                      = dig_t<UINT_T,B>;\par
01961         {\cf17 constexpr} dig_t d_0 = dig_t::dig_0();\par
01962 \par
01963         dig_t carry\{d_0\};\par
01964         {\cf19 for}({\cf18 size_t} i=0 ; i < N ; ++i) \{\par
01965                 {\cf17 const} dig_t left_CBm1\{larg[i].C_Bm1()\};\par
01966                 {\cf19 if} (carry.is_0()) \{\par
01967                         carry = m_sum_digs_carryin0(larg[i],rarg[i]);\par
01968                 \}\par
01969                 {\cf19 else} \{\par
01970                         carry = m_sum_digs_carryin1(larg[i],rarg[i]);\par
01971                 \}\par
01972         \}\par
01973         {\cf19 return} carry;\par
01974 \}\par
01975 \par
01978 {\cf17 template}<{\cf17 typename} UINT_T, UINT_T B, {\cf18 size_t} N>\par
01979         {\cf17 requires} (N>1)\par
01980 {\cf17 constexpr} {\cf17 inline}\par
01981 reg_digs_t<UINT_T,B,N> aprox_units_divB({\cf17 const} reg_digs_t<UINT_T,B,N>& arg) {\cf17 noexcept}\par
01983 \{\par
01988         {\cf17 using }dig_t = dig_t<UINT_T,B>;\par
01989         reg_digs_t<UINT_T,B,N> cparg\{arg\};\par
01990         {\cf19 if} ((cparg >> 1).is_0()) \{\par
01991                 {\cf19 return} cparg;\par
01992         \}\par
01993         {\cf19 else} {\cf19 if} ((cparg[0]<= dig_t\{B/2\})||(cparg.is_any_B_pow())) \{\par
01994                 cparg >>= 1;\par
01995                 {\cf19 return} cparg;\par
01996         \}\par
01997         {\cf19 else} {\cf19 if} (cparg[N-1].is_not_Bm1()) \{\par
01998                 cparg >>= 1;\par
01999                 m_incr(cparg);\par
02000                 {\cf19 return} cparg;\par
02001         \}\par
02002         {\cf19 else} \{\par
02003                 {\cf17 auto} temp = arg.template subregister<1,N>();\par
02004                 {\cf19 if} (temp.is_filled_of_Bm1())\{\par
02006                         cparg.set_0();\par
02007                         cparg[N-1].set_1();\par
02008                         {\cf19 return} cparg;\par
02009                 \}\par
02010                 {\cf19 else} \{\par
02012                         cparg >>= 1;\par
02013                         m_incr(cparg);\par
02014                         {\cf19 return} cparg;\par
02015                 \}\par
02016         \}\par
02017 \} \par
02019 \par
02021 {\cf17 template}<{\cf17 typename} UINT_T, UINT_T B, {\cf18 size_t} N, {\cf18 size_t} n>\par
02022         {\cf17 requires} ((n > 0) && (n < N) && (N > 1)) \par
02023 {\cf17 constexpr} {\cf17 inline}\par
02024 reg_digs_t<UINT_T,B,N> aprox_units_divB_n({\cf17 const} reg_digs_t<UINT_T,B,N>& arg) {\cf17 noexcept}\par
02025 \{\par
02026         {\cf19 if} {\cf17 constexpr} (n == N-1)\{\par
02027                 {\cf19 return} aprox_units_divB<UINT_T,B,N>(arg);\par
02028         \}\par
02029         {\cf19 else} \{\par
02030                 reg_digs_t<UINT_T,B,N> cparg\{arg\}; {\cf20 // n = N-x => x = N-n}\par
02031                 {\cf19 for}({\cf18 size_t} ix\{0\} ; ix < N-n ; ++ix) \{\par
02032                         cparg = aprox_units_divB<UINT_T,B,N>(cparg);\par
02033                 \}\par
02034                 {\cf19 return} cparg;\par
02035         \}\par
02036 \}\par
02037 \par
02040 {\cf17 template}<{\cf17 typename} UINT_T, UINT_T B, {\cf18 size_t} N>\par
02041         {\cf17 requires} (N > 0)\par
02042 {\cf17 constexpr} {\cf17 inline}\par
02046 std::array<type_traits::sig_UInt_for_UInt_t<UINT_T>,2>\par
02047 aprox_coc_rem(\par
02048                 {\cf17 const} reg_digs_t<UINT_T,B,N>& rem,\par
02049                 {\cf17 const} reg_digs_t<UINT_T,B,N>& dsor\par
02050 ) {\cf17 noexcept} \{\par
02051         {\cf17 using }SIG_UINT_T = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
02052 \par
02053         std::array<SIG_UINT_T,2> ret;\par
02054 \par
02055         {\cf17 const} {\cf18 size_t} dsor_msb\{{\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(dsor.index_of_MSDig())\};\par
02056         {\cf17 const} SIG_UINT_T rem_uint \{SIG_UINT_T(rem)\};\par
02057         {\cf17 const} SIG_UINT_T dsor_uint \{dsor[dsor_msb]()\};\par
02058 \par
02059         SIG_UINT_T coc_calculado = rem_uint / dsor_uint;\par
02060         SIG_UINT_T rem_calculado = rem_uint % dsor_uint;\par
02061 \par
02062         {\cf19 if} (dsor_msb==0) \{\par
02064                 {\cf20 //const SIG_UINT_T rem_uint \{SIG_UINT_T(rem)\};}\par
02065                 {\cf20 //const SIG_UINT_T dsor_uint \{dsor[0]()\};}\par
02066                 {\cf20 //SIG_UINT_T coc_calculado = rem_uint / dsor_uint;}\par
02067                 {\cf20 //SIG_UINT_T rem_calculado = rem_uint % dsor_uint;}\par
02068                 {\cf17 const} SIG_UINT_T rem_aprox \{SIG_UINT_T(dsor)*coc_calculado+rem_calculado\};\par
02069 \par
02070                 ret[1] = rem_calculado;\par
02071                 ret[0] = coc_calculado;\par
02072                 {\cf19 return} ret;\par
02073         \}\par
02074         {\cf19 else} \{\par
02077                 reg_digs_t<UINT_T,B,N> dsor_red\{dsor\};\par
02078                 uint64_t ix\{0\};\par
02079                 {\cf19 for}( ; ix < N ; ++ix) \{\par
02080                         dsor_red = aprox_units_divB<UINT_T,B,N>(dsor_red);\par
02081                         {\cf19 if} (dsor_red.template index_of_MSDig<UINT_T,B,N>() == 1)\par
02082                                 {\cf19 break};\par
02083                 \}\par
02084                 reg_digs_t<UINT_T,B,N> rem_red\{rem\};\par
02085 \par
02086                 {\cf19 for}(int64_t iy\{ix\} ; iy > -1 ; --iy) \{\par
02087                         rem_red = aprox_units_divB<UINT_T,B,N>(rem_red);\par
02088                 \}\par
02089 \par
02090                 {\cf17 const} SIG_UINT_T dsor_uint \{SIG_UINT_T(dsor_red)\};\par
02091                 {\cf17 const} SIG_UINT_T rem_uint \{SIG_UINT_T(rem_red)\};\par
02092                 {\cf17 const} reg_digs_t<UINT_T,B,N> rem_aprox \{\par
02093                         dsor*dig_t\{coc_calculado\}+dig_t\{rem_calculado\}\par
02094                 \};\par
02095 \par
02096                 {\cf19 if} ((rem_aprox <= rem)&&(rem_aprox + dsor > rem)) \{\par
02098                         ret[1] = rem_calculado;\par
02099                         ret[0] = coc_calculado;\par
02100                         {\cf19 return} ret;\par
02101                 \}\par
02102                 {\cf19 else} {\cf19 if} (rem_aprox > rem) \{\par
02104                         --coc_calculado;\par
02105                         rem_calculado += dsor_uint;\par
02106                         {\cf19 return} aprox_coc_rem<UINT_T,B,N>(rem,dsor,coc_calculado,rem_calculado);\par
02107                 \}\par
02108                 {\cf19 else} \{\par
02110                         ++coc_calculado;\par
02111                         rem_calculado -= dsor_uint;\par
02112                         {\cf19 return} aprox_coc_rem<UINT_T,B,N>(rem,dsor,coc_calculado,rem_calculado);\par
02113                 \}\par
02114         \}\par
02115 \}\par
02116 \par
02119 {\cf17 template}<{\cf17 typename} UINT_T, UINT_T B, {\cf18 size_t} N>\par
02120         {\cf17 requires} (N > 0)\par
02121 {\cf17 constexpr} {\cf17 inline}\par
02125 std::array<type_traits::sig_UInt_for_UInt_t<UINT_T>,2>\par
02126 aprox_coc_rem(\par
02127                 {\cf17 const} reg_digs_t<UINT_T,B,N>& rem         ,\par
02128                 {\cf17 const} reg_digs_t<UINT_T,B,N>& dsor      ,\par
02129                 type_traits::sig_UInt_for_UInt_t<UINT_T> coc_calculado  ,\par
02130                 type_traits::sig_UInt_for_UInt_t<UINT_T> rem_calculado\par
02131         ) {\cf17 noexcept}\par
02132 \{ \par
02134         {\cf17 using }SIG_UINT_T = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
02135         std::array<SIG_UINT_T,2> ret;\par
02136         {\cf17 const} {\cf18 size_t} dsor_msb\{{\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(dsor.index_of_MSDig())\};\par
02137         {\cf19 if} (dsor_msb==0) \{\par
02139                 {\cf17 const} SIG_UINT_T rem_aprox \{SIG_UINT_T(dsor)*coc_calculado+rem_calculado\};\par
02140                 {\cf17 const} SIG_UINT_T rem_uint \{SIG_UINT_T(rem)\};\par
02141                 {\cf17 const} SIG_UINT_T dsor_uint \{dsor[0]()\};\par
02142                 {\cf19 if} ((rem_aprox <= rem_uint)&&(rem_aprox + dsor_uint > rem_uint)) \{\par
02144                         ret[1] = rem_calculado;\par
02145                         ret[0] = coc_calculado;\par
02146                         {\cf19 return} ret;\par
02147                 \}\par
02148                 {\cf19 else} {\cf19 if} (rem_aprox > rem) \{\par
02150                         --coc_calculado;\par
02151                         rem_calculado += dsor_uint;\par
02152                         {\cf19 return} aprox_coc_rem<UINT_T,B,N>(rem,dsor,coc_calculado,rem_calculado);\par
02153                 \}\par
02154                 {\cf19 else} \{\par
02156                         ++coc_calculado;\par
02157                         rem_calculado -= dsor_uint;\par
02158                         {\cf19 return} aprox_coc_rem<UINT_T,B,N>(rem,dsor,coc_calculado,rem_calculado);\par
02159                 \}\par
02161         \}\par
02162         {\cf19 else} \{\par
02165                 reg_digs_t<UINT_T,B,N> dsor_red\{dsor\};\par
02166                 int32_t ix\{0\};\par
02167                 {\cf19 for}( ; ix < N ; ++ix) \{\par
02168                         dsor_red = aprox_units_divB<UINT_T,B,N>(dsor_red);\par
02169                         {\cf19 if} (dsor_red.template index_of_MSDig<UINT_T,B,N>() == 1)\par
02170                                 {\cf19 break};\par
02171                 \}\par
02172                 reg_digs_t<UINT_T,B,N> rem_red\{rem\};\par
02173                 {\cf19 for}( ; ix > -1 ; --ix) \{\par
02174                         rem_red = aprox_units_divB<UINT_T,B,N>(rem_red);\par
02175                 \}\par
02176 \par
02177                 {\cf17 const} SIG_UINT_T dsor_uint \{SIG_UINT_T(dsor_red)\};\par
02178                 {\cf17 const} SIG_UINT_T rem_uint \{SIG_UINT_T(rem_red)\};\par
02179                 {\cf17 const} reg_digs_t<UINT_T,B,N> rem_aprox \{dsor*dig_t\{coc_calculado\}+dig_t\{rem_calculado\}\};\par
02180 \par
02181                 {\cf19 if} ((rem_aprox <= rem)&&(rem_aprox + dsor > rem)) \{\par
02183                         ret[1] = rem_calculado;\par
02184                         ret[0] = coc_calculado;\par
02185                         {\cf19 return} ret;\par
02186                 \}\par
02187                 {\cf19 else} {\cf19 if} (rem_aprox > rem) \{\par
02189                         --coc_calculado;\par
02190                         rem_calculado += dsor_uint;\par
02191                         {\cf19 return} aprox_coc_rem<UINT_T,B,N>(rem,dsor,coc_calculado,rem_calculado);\par
02192                 \}\par
02193                 {\cf19 else} \{\par
02195                         ++coc_calculado;\par
02196                         rem_calculado -= dsor_uint;\par
02197                         {\cf19 return} aprox_coc_rem<UINT_T,B,N>(rem,dsor,coc_calculado,rem_calculado);\par
02198                 \}\par
02199         \}\par
02200 \}\par
02202 \par
02204 {\cf17 template}<{\cf17 typename} UINT_T,UINT_T B,{\cf18 size_t} N,{\cf18 size_t} M>\par
02205         {\cf17 requires} (N > 0)&&(M > 0)\par
02206 {\cf17 constexpr} {\cf17 inline}\par
02207 std::array<reg_digs_t<UINT_T,B,std::max(N,M)>,2>\par
02208 fediv(\par
02209         {\cf17 const} reg_digs_t<UINT_T,B,N> & larg,\par
02210         {\cf17 const} reg_digs_t<UINT_T,B,M> & rarg\par
02211 ) {\cf17 noexcept} \{\par
02212 \par
02213         {\cf17 constexpr} {\cf18 size_t} MaxParam = std::max(N,M);\par
02214         {\cf17 using }base_t = reg_digs_t<UINT_T,B,MaxParam>;\par
02215         {\cf17 using }SIG_UINT_T = type_traits::sig_UInt_for_UInt_t<UINT_T>;\par
02216 \par
02217         {\cf17 using }ret_type = std::array<base_t,2>;\par
02218 \par
02219         base_t dndo\{larg\};\par
02220         base_t dsor\{rarg\};\par
02221 \par
02222         {\cf17 const} int32_t dsor_MSDig\{larg.index_of_MSDig()\};\par
02224         {\cf17 const} int32_t dndo_MSDig\{rarg.index_of_MSDig()\};\par
02226         {\cf17 const} {\cf18 size_t}  dist_dndo_dsor\{std::abs(dndo_MSDig-dndo_MSDig)\};\par
02227 \par
02228         base_t rem\{base_t::regd_0()\};\par
02229         base_t coc\{base_t::regd_0()\};\par
02230 \par
02231         {\cf19 if} (is_0(dsor)) \{\par
02232                 ret_type ret;\par
02233                 ret[0] = std::move(coc);\par
02234                 ret[1] = std::move(rem);\par
02235                 {\cf19 return} ret;\par
02236         \}\par
02237         {\cf19 else} {\cf19 if} (is_1(dsor)) \{\par
02238                 ret_type ret;\par
02239                 ret[0] = dndo;\par
02240                 ret[1].set_0();\par
02241                 {\cf19 return} ret;\par
02242         \}\par
02243         {\cf19 else} {\cf19 if} (dndo < dsor) \{\par
02244                 ret_type ret;\par
02245                 ret[0].set_0();\par
02246                 ret[1] = dndo;\par
02247                 {\cf19 return} ret;\par
02248         \}\par
02249         {\cf19 else} {\cf19 if} (dndo == dsor) \{\par
02250                 ret_type ret;\par
02251                 ret[0].set_1();\par
02252                 ret[1].set_0();\par
02253                 {\cf19 return} ret;\par
02254         \}\par
02255         {\cf19 else} \{\par
02256                 int64_t pl_dndo\{dndo_MSDig-dsor_MSDig+1\};\par
02257                 {\cf19 for}(int64_t ix\{dsor_MSDig\},iy\{dndo_MSDig\} ; ix>-1 ; --ix,--iy) \{\par
02258                         rem[ix] = dndo[iy];\par
02259                 \}\par
02260 \par
02261                 {\cf19 for}({\cf18 size_t} numloops\{0\} ; numloops<dist_dndo_dsor ; ++numloops)\par
02262                 \{\par
02263                         {\cf19 if} (rem == dsor) \{\par
02264                                 coc <<= 1;\par
02265                                 coc[0] = base_t::dig_1();\par
02266                                 rem = base_t::regd_0();\par
02267                                 --pl_dndo;\par
02268                                 rem[0] = dndo[pl_dndo];\par
02269                         \}\par
02270                         {\cf19 else} {\cf19 if} (rem < dsor) \{\par
02271                                 coc <<= 1;\par
02272                                 coc[0] = base_t::dig_0();\par
02273                                 rem <= 1;\par
02274                                 --pl_dndo;\par
02275                                 rem[0] = dndo[pl_dndo];\par
02276                         \}\par
02280                         {\cf19 else} \{\par
02281                                 {\cf17 auto} ret\{aprox_coc_rem<N>(rem,dsor)\};\par
02282                                 SIG_UINT_T coc_dig\{ret[0]\};\par
02283                                 SIG_UINT_T rem_dig\{ret[1]\};\par
02284 \par
02285                                 coc <<= 1;      {\cf20 // coc = coc * B}\par
02286                                 coc[0] = dig_t(coc_dig); {\cf20 // coc = coc + D  ; B-1 >= D > 1}\par
02287                                 --pl_dndo;\par
02288                                 rem <<= 1;\par
02289                                 rem[0] = dndo[pl_dndo];\par
02290                         \}\par
02291                 \}\par
02292                 std::array<reg_digs_t<UINT_T,B,std::max(N,M)>,2> ret;\par
02293                 ret[0] = coc;\par
02294                 ret[1] = rem;\par
02295                 {\cf19 return} ret;\par
02296         \}\par
02297 \}\par
02298 \par
02300   {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
02301   {\cf18 bool} get_digit_token(std::istream& is,dig_t<UINT_T,B>& dig_value)\par
02302   \{\par
02303     std::string old_input_string\{{\cf22 ""}\};\par
02304     std::string new_input_string\{{\cf22 ""}\};\par
02305     {\cf18 size_t} index\{0\};\par
02306     {\cf18 char} input_char = type_traits::nullchar<char>;\par
02307     UINT_T uint_value = 0;\par
02308     dig_value = dig_t<UINT_T,B>::dig_0();\par
02309     {\cf19 while}({\cf17 true}) \{\par
02310       is >> input_char;\par
02311       {\cf19 if} ((index==0)&&(lex::is_separator(input_char))) \{\par
02312         new_input_string += input_char;\par
02313         old_input_string = new_input_string;\par
02314         ++index;\par
02315       \}\par
02316       {\cf19 else} {\cf19 if} ((index == 0)&&(! lex::is_separator(input_char))) \{\par
02317         std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
02318         << {\cf22 " escribir \\" "} << {\cf23 '#'} << {\cf22 " \\"  y has escrito "}\par
02319         << new_input_string << std::endl;\par
02320         std::cerr << {\cf22 "Considera que has escrito "}\par
02321         << old_input_string\par
02322         << {\cf22 " y continua escribiendo a partir de ahi"};\par
02323         new_input_string = old_input_string;\par
02324       \}\par
02325       {\cf19 else} {\cf19 if}((index>=1) && lex::is_digit(input_char)) \{\par
02326         {\cf19 if} (lex::digit_value(input_char) < B) \{\par
02327           new_input_string += input_char;\par
02328           uint_value *= B;\par
02329           uint_value += lex::digit_value(input_char);\par
02330           {\cf19 if} (uint_value < B) \{\par
02331             old_input_string = new_input_string;\par
02332             dig_value = dig_t<UINT_T,B>(uint_value);\par
02333             ++index;\par
02334           \}\par
02335           {\cf19 else} \{\par
02336             old_input_string = {\cf22 "#"};\par
02337             std::cerr << {\cf22 "Has cometido un error, tenias que "}\par
02338             << {\cf22 "poner un valor menor que la base y has "}\par
02339             << {\cf22 "puesto \\" "} << uint_value << {\cf22 " \\" escrito como \\" "}\par
02340             << new_input_string << {\cf22 " \\" "} << std::endl;\par
02341             uint_value = 0;\par
02342             {\cf19 return} {\cf17 false};\par
02343           \}\par
02344         \}\par
02345         {\cf19 else} {\cf19 if}((index>=1) &&\par
02346                                                                 ! lex::is_digit(input_char) &&\par
02347                                                                 (input_char != {\cf23 '_'})\par
02348                                         ) \{\par
02349           std::cerr << {\cf22 "El caracter "}\par
02350                                                                                 << input_char\par
02351                                                                                 << {\cf22 " no es valido aqui "}\par
02352                                                                                 << std::endl;\par
02353           uint_value = 0;\par
02354           {\cf19 return} {\cf17 false};\par
02355         \}\par
02356       \}\par
02357       {\cf19 else} {\cf19 if}((index>1)&&(input_char == {\cf23 '_'})) \{\par
02358         {\cf19 return} {\cf17 true};\par
02359       \}\par
02360       {\cf19 else}\{\par
02361         std::cerr << {\cf22 "Has cometido un error, tenias que escribir "}\par
02362         << {\cf22 " \\" "} << {\cf22 "#digdigdig..._"}\par
02363         << {\cf22 " \\"  y has escrito "}\par
02364         << new_input_string << std::endl;\par
02365         uint_value = 0;\par
02366         {\cf19 return} {\cf17 false};\par
02367       \}\par
02368     \}\par
02369   \}\par
02370 \par
02372   {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c T,T B>\par
02373   {\cf18 bool} get_radix_token(std::istream& is) \{\par
02374     {\cf19 return} dig_t<T,B>::get_radix_token(is);\par
02375   \}\par
02376 \par
02377   {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c T,T B,{\cf18 size_t} L>\par
02378   {\cf18 bool} get_digit_loop_token (\par
02379                 std::istream& is,reg_digs_t<T,B,L>& value\par
02380         ) {\cf17 noexcept} \{\par
02381                 {\cf18 size_t} idx\{0\};\par
02382                 {\cf19 while}({\cf17 true}) \{\par
02383                         {\cf19 if}(idx < L) \{\par
02384                                 {\cf19 if} (get_digit_token(is,value[idx])) \{\par
02385                                         ++idx;\par
02386                                 \}\par
02387                                 {\cf19 else} \{\par
02388                                         {\cf19 for}(;idx < L;++idx) \{\par
02389                                                 value[idx] = 0;\par
02390                                         \}\par
02391                                         std::cerr << {\cf22 " error consiguiendo el digito "} << idx\par
02392                                                                                 << std::endl;\par
02393                                         std::cerr << {\cf22 " digitos a 0 a partir del indice = "} << idx\par
02394                                                                                 << std::endl;\par
02395                                         {\cf19 return} {\cf17 false};\par
02396                                 \}\par
02397                         \}\par
02398                         {\cf19 if} (idx >= L)\par
02399                                 {\cf19 return} {\cf17 true};\par
02400                 \}\par
02401         \}\par
02402 \par
02403         {\cf17 template}<type_traits::{\cf18 unsigned}_{\cf18 int}egral_c T,T B,{\cf18 size_t} L>\par
02404         {\cf18 bool} read (std::istream& is,reg_digs_t<T,B,L>& value)\par
02405         {\cf17 noexcept} \{\par
02406                 {\cf20 //std::cerr}\par
02407                 reg_digs_t<T,B,L> default_value\{\};\par
02408                 {\cf18 bool} type_token = reg_digs_t<T,B,L>::get_type_template_string_id_token(is);\par
02409                 {\cf19 if} (type_token) \{\par
02410                         {\cf19 if} (get_digit_loop_token(is,value)) \{\par
02411                                 {\cf19 if} (dig_t<T,B>::get_radix_token(is)) \{\par
02412                                         {\cf19 return} {\cf17 true};\par
02413                                 \}\par
02414                                 {\cf19 else} \{\par
02415                                         value = default_value;\par
02416                                         {\cf19 return} {\cf17 false};\par
02417                                 \}\par
02418                         \}\par
02419                         {\cf19 else} \{\par
02420                                 value = default_value;\par
02421                                 {\cf19 return} {\cf17 false};\par
02422                         \}\par
02423                 \} {\cf19 else} \{\par
02424                         value = default_value;\par
02425                         {\cf19 return} {\cf17 false};\par
02426                 \}\par
02427         \}\par
02428 \par
02431   {\cf17 using namespace }type_traits;\par
02432         {\cf17 template}<u{\cf18 int}128_t B>\par
02433         {\cf17 using }digit_t = dig_t<\par
02434                         TypeFromIntNumber_t<static_cast<uint128_t>(B)>,\par
02435                         {\cf17 static_cast<}TypeFromIntNumber_t<static_cast<uint128_t>(B){\cf17 >}>({\cf17 static_cast<}uint128_t{\cf17 >}(B))\par
02436                 >;\par
02437         {\cf17 template}<u{\cf18 int}128_t B, {\cf18 size_t} L>\par
02438         {\cf17 using }register_digs_t = reg_digs_t<\par
02439                         TypeFromIntNumber_t<static_cast<uint128_t>(B)>,\par
02440                         {\cf17 static_cast<}TypeFromIntNumber_t<static_cast<uint128_t>(B){\cf17 >}>({\cf17 static_cast<}uint128_t{\cf17 >}(B)),\par
02441                         L\par
02442         >;\par
02443 \par
02445         {\cf17 template}<{\cf17 typename} Int_Type,Int_Type Base,{\cf18 size_t} Length>\par
02446                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>()&&(Length > 0))\par
02447         std::istream &\par
02448         operator >> (std::istream & is,reg_digs_t<Int_Type,Base,Length> & arg) \{\par
02449                 {\cf17 enum} estado_e \{\par
02450                         e0ini   , e1r           , e1e           , e1g                   , e1sep         ,\par
02451                         e1d             , e1i           , e2g           , e2start       , e2dig         ,\par
02452                         e2dp    , e2end , e2B           , e3dig         , e0fin\par
02453                 \};\par
02455                 {\cf17 constexpr} {\cf18 size_t} longitud_cadena\par
02456                         \{\par
02457                                 (\par
02458                                         (Length+1)*\par
02459                                         {\cf17 static_cast<}{\cf18 size_t}{\cf17 >}(\par
02460                                                 std::ceil(\par
02461                                                         (\par
02462                                                                 std::log2({\cf17 static_cast<}{\cf18 long} {\cf18 double}{\cf17 >}(Base)) + 1\par
02463                                                         )\par
02464                                                 )\par
02465                                         )\par
02466                                 )       +16\par
02467                         \};\par
02468                 std::string sds\{\};\par
02469                 sds.resize(longitud_cadena);\par
02470                 sds.assign(longitud_cadena,{\cf23 '\\0'});\par
02472                 {\cf17 using }inttype           = {\cf17 typename} type_traits::sig_UInt_for_UInt_t<Int_Type>;\par
02473                 {\cf17 using }dig_t                     = dig_t<Int_Type,Base>;\par
02474                 {\cf17 using }reg_digs_t        = reg_digs_t<Int_Type,Base,Length>;\par
02476                 {\cf18 size_t}  indice\{0\};\par
02478                 Int_Type digito\{0\};\par
02479                 {\cf18 size_t} longitud\{0\};\par
02480                 inttype numero_base_recogido\{0\};\par
02482                 reg_digs_t& numero_ret\{arg\};\par
02484                 estado_e est_act = e0ini;\par
02486                 {\cf18 char} c = type_traits::nullchar<char>;\par
02488                 is >> sds;\par
02490                 {\cf19 do} \{\par
02491                 c = sds[indice];\par
02492                         {\cf19 switch}(est_act) \{\par
02493                                 {\cf19 case} e0ini :\par
02494                                         \{\par
02495                                                 {\cf19 if} (c=={\cf23 'r'}) \{\par
02496                                                         est_act = e1r;\par
02497                                                 \} {\cf19 else} \{\par
02498                                                         est_act = e0ini;\par
02499                                                 \}\par
02500                                         \}\par
02501                                         {\cf19 break};\par
02502                                 {\cf19 case} e1r :\par
02503                                         \{\par
02504                                                 \{\par
02505                                                         {\cf19 if} (c=={\cf23 'e'}) \{\par
02506                                                                 est_act = e1e;\par
02507                                                         \}\par
02508                                                         {\cf19 else} \{\par
02509                                                                 est_act = e0ini;\par
02510                                                         \}\par
02511                                                 \}\par
02512                                         \}\par
02513                                         {\cf19 break};\par
02514                                 {\cf19 case} e1e :\par
02515                                         \{\par
02516                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
02517                                                         est_act = e1g;\par
02518                                                 \}\par
02519                                                 {\cf19 else}  \{\par
02520                                                         est_act = e0ini;\par
02521                                                 \}\par
02522                                         \}\par
02523                                         {\cf19 break};\par
02524                                 {\cf19 case} e1g :\par
02525                                         \{\par
02526                                                 {\cf19 if} (c=={\cf23 '_'}) \{\par
02527                                                         est_act = e1sep;\par
02528                                                 \}\par
02529                                                 {\cf19 else}  \{\par
02530                                                         est_act = e0ini;\par
02531                                                 \}\par
02532                                         \}\par
02533                                         {\cf19 break};\par
02534                                 {\cf19 case} e1sep :\par
02535                                         \{\par
02536                                                 {\cf19 if} (c=={\cf23 'd'}) \{\par
02537                                                         est_act = e1d;\par
02538                                                 \}\par
02539                                                 {\cf19 else}  \{\par
02540                                                         est_act = e0ini;\par
02541                                                 \}\par
02542                                         \}\par
02543                                         {\cf19 break};\par
02544                                 {\cf19 case} e1d :\par
02545                                         \{\par
02546                                                 {\cf19 if} (c=={\cf23 'i'}) \{\par
02547                                                         est_act = e1i;\par
02548                                                 \}\par
02549                                                 {\cf19 else}  \{\par
02550                                                         est_act = e0ini;\par
02551                                                 \}\par
02552                                         \}\par
02553                                         {\cf19 break};\par
02554                                 {\cf19 case} e1i :\par
02555                                         \{\par
02556                                                 {\cf19 if} (c=={\cf23 'g'}) \{\par
02557                                                         est_act = e2g;\par
02558                                                 \}\par
02559                                                 {\cf19 else}  \{\par
02560                                                         est_act = e0ini;\par
02561                                                 \}\par
02562                                         \}\par
02563                                         {\cf19 break};\par
02564                                 {\cf19 case} e2g :\par
02565                                         \{\par
02566                                                 {\cf19 if} (c=={\cf23 '#'}) \{\par
02567                                                         est_act = e2start;\par
02568                                                 \}\par
02569                                                 {\cf19 else}  \{\par
02570                                                         est_act = e0ini;\par
02571                                                 \}\par
02572                                         \}\par
02573                                         {\cf19 break};\par
02574                                 {\cf19 case} e2start :\par
02575                                         \{\par
02576                                                 {\cf19 if} (((c>={\cf23 '0'})&&(c<={\cf23 '9'}))&&(std::abs(c-{\cf23 '0'})<Base)) \{\par
02577                                                         est_act = e2dig;\par
02578                                                         digito = (c-{\cf23 '0'});\par
02579                                                         longitud = 0;\par
02580                                                         numero_base_recogido = 0;\par
02581                                                         numero_ret = reg_digs_t::regd_0();\par
02582                                                 \}\par
02583                                                 {\cf19 else}  \{\par
02584                                                         est_act = e0ini;\par
02585                                                         digito = 0;\par
02586                                                         longitud = 0;\par
02587                                                         numero_base_recogido = 0;\par
02588                                                         numero_ret = reg_digs_t::regd_0();\par
02589                                                 \}\par
02590                                         \}\par
02591                                         {\cf19 break};\par
02592                                 {\cf19 case} e2dig :\par
02593                                         \{\par
02594                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
02595                                                 {\cf17 const} {\cf18 bool} dig_lt_Base\{digito<Base\};\par
02596                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{dig_c && dig_lt_Base\};\par
02597                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{c_es_dig_B && (longitud <= Length-1)\};\par
02598                                                 {\cf17 const} {\cf18 bool} tt_dig_B_cdl \{(c=={\cf23 ':'})&&dig_lt_Base&&(longitud <= Length-1)\};\par
02599                                                 {\cf17 const} {\cf18 bool} tf_dig_B_cdl \{(c=={\cf23 '#'})&&dig_lt_Base&&(longitud == Length-1)\};\par
02600                                                 {\cf19 if} (dig_B_cdl) \{\par
02601                                                         digito *= 10;\par
02602                                                         digito += (c-{\cf23 '0'});\par
02603                                                         est_act = e2dig;\par
02604                                                 \}\par
02605                                                 {\cf19 else} {\cf19 if} (tt_dig_B_cdl) \{\par
02606                                                         est_act = e2dp;\par
02607                                                 \}\par
02608                                                 {\cf19 else} {\cf19 if} (tf_dig_B_cdl) \{\par
02609                                                         est_act = e2end;\par
02610                                                 \}\par
02611                                                 {\cf19 else}  \{\par
02612                                                         est_act = e0ini;\par
02613                                                         digito = 0;\par
02614                                                         longitud = 0;\par
02615                                                         numero_base_recogido = 0;\par
02616                                                         numero_ret = reg_digs_t::regd_0();\par
02617                                                 \}\par
02618                                         \}\par
02619                                         {\cf19 break};\par
02620                                 {\cf19 case} e2dp :\par
02621                                         \{\par
02622                                                 {\cf17 const} {\cf18 bool} dig_c \{(c >= {\cf23 '0'}) && (c <= {\cf23 '9'})\};\par
02623                                                 {\cf17 const} {\cf18 bool} c_es_dig_B \{(std::abs(c-{\cf23 '0'})<Base) && (digito<Base)\};\par
02624                                                 {\cf17 const} {\cf18 bool} dig_B_cdl \{dig_c && c_es_dig_B && (longitud < Length-1)\};\par
02625                                                 {\cf17 const} {\cf18 bool} rdig_B_cdl \{dig_c && c_es_dig_B && dig_B_cdl\};\par
02626                                                 {\cf19 if} (rdig_B_cdl) \{\par
02627                                                         est_act = e2dig;\par
02628                                                         numero_ret[Length-1-longitud] = dig_t(digito);\par
02629                                                         ++longitud;\par
02630                                                         digito = c-{\cf23 '0'};\par
02631                                                 \}\par
02632                                                 {\cf19 else}  \{\par
02633                                                         est_act = e0ini;\par
02634                                                         digito = 0;\par
02635                                                         longitud = 0;\par
02636                                                         numero_base_recogido = 0;\par
02637                                                         indice = 0;\par
02638                                                         numero_ret = reg_digs_t::regd_0();\par
02639                                                 \}\par
02640                                         \}\par
02641                                         {\cf19 break};\par
02642                                 {\cf19 case} e2end :\par
02643                                         \{\par
02644                                                 {\cf17 const} {\cf18 bool} c_es_sepfin \{c == {\cf23 'B'}\};\par
02645                                                 {\cf17 const} {\cf18 bool} d_es_digB \{digito < Base\};\par
02646                                                 {\cf17 const} {\cf18 bool} l_coincide \{longitud == Length-1\};{\cf20 // llega al cero ?}\par
02647                                                 {\cf17 const} {\cf18 bool} rdigB_cdl \{c_es_sepfin && d_es_digB && l_coincide\};\par
02648                                                 {\cf19 if} (rdigB_cdl) \{\par
02649                                                         est_act = e2B;\par
02650                                                         numero_ret[Length-1-longitud] = dig_t(digito);\par
02651                                                         digito = 0;\par
02652                                                         longitud = 0;\par
02653                                                 \}\par
02654                                                 {\cf19 else}  \{\par
02655                                                         est_act = e0ini;\par
02656                                                         indice = 0;\par
02657                                                         digito = 0;\par
02658                                                         longitud = 0;\par
02659                                                         numero_ret = reg_digs_t::regd_0();\par
02660                                                 \}\par
02661                                         \}\par
02662                                         {\cf19 break};\par
02663                                 {\cf19 case} e2B :\par
02664                                         \{\par
02665                                                 {\cf19 if} ((c >= {\cf23 '0'})&&(c <= {\cf23 '9'})) \{\par
02666                                                         est_act = e3dig;\par
02667                                                         numero_base_recogido = c-{\cf23 '0'};\par
02668                                                         digito = 0;\par
02669                                                 \}\par
02670                                                 {\cf19 else}  \{\par
02671                                                         est_act = e0ini;\par
02672                                                         digito = 0;\par
02673                                                         longitud = 0;\par
02674                                                         numero_base_recogido = 0;\par
02675                                                         numero_ret = reg_digs_t::regd_0();\par
02676                                                 \}\par
02677                                         \}\par
02678                                         {\cf19 break};\par
02679                                 {\cf19 case} e3dig :\par
02680                                         \{\par
02681                                                 {\cf17 const} {\cf18 bool} espacio_c \{c < 16\};\par
02682                                                 {\cf17 const} {\cf18 bool} digito_c \{(c>={\cf23 '0'}) && (c<={\cf23 '9'})\};\par
02683                                                 {\cf17 const} {\cf18 bool} num_base_lt_Base \{numero_base_recogido < Base\};\par
02684                                                 {\cf17 const} {\cf18 bool} num_base_eq_Base \{numero_base_recogido == Base\};\par
02685                                                 {\cf19 if} (digito_c && num_base_lt_Base) \{\par
02686                                                         est_act = e3dig;\par
02687                                                         numero_base_recogido *= 10;\par
02688                                                         numero_base_recogido += (c-{\cf23 '0'});\par
02689                                                 \}\par
02690                                                 {\cf19 else} {\cf19 if} (espacio_c && num_base_eq_Base) \{\par
02691                                                         numero_base_recogido *= 10;\par
02692                                                         numero_base_recogido += (c-{\cf23 '0'});\par
02693                                                                 est_act = e0fin;\par
02694                                                                 numero_base_recogido = 0;\par
02695                                                 \}\par
02696                                                 {\cf19 else}  \{\par
02697                                                         est_act = e0ini;\par
02698                                                         numero_base_recogido = 0;\par
02699                                                 \}\par
02700                                         \}\par
02701                                         {\cf19 break};\par
02702                                 {\cf19 case} e0fin :\par
02703                                         \{\par
02704                                                 est_act = e0fin;\par
02705                                         \}\par
02706                         \}\par
02707                         ++indice;\par
02708                 \} {\cf19 while} (est_act!=e0fin);\par
02709 \par
02710                 {\cf19 return} (is);\par
02711         \}\par
02712 \par
02713         {\cf17 template}<{\cf17 typename} Int_Type,Int_Type Base,{\cf18 size_t} Long>\par
02714                 {\cf17 requires} (type_traits::suitable_base<Int_Type,Base>())\par
02715         std::ostream &\par
02716         {\cf17 operator} << (\par
02717                         std::ostream & os,\par
02718                         {\cf17 const} reg_digs_t<Int_Type,Base,Long> & arg)\par
02719         \{\par
02720                 {\cf17 using }inttype = ullint_t;\par
02721                 os << {\cf22 "reg_dig#"};\par
02722                 {\cf19 for}(int32_t ix\{Long-1\} ; ix > 0 ; --ix) \{\par
02723                                 os << static_cast<inttype>(arg[ix]());\par
02724                                 os << {\cf23 ':'};\par
02725                 \}\par
02726                 os << static_cast<inttype>(arg[0]());\par
02727                 os << {\cf22 "#B"};\par
02728                 os << static_cast<inttype>(Base);\par
02729                 {\cf19 return} (os);\par
02730         \}\par
02731 \par
02732 \} {\cf20 // CLOSE NAMESPACE NUMREPR}\par
02733 \par
02734 {\cf21 #endif }{\cf20 // REG_DIGS_T_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo test_dig_t.hpp\par \pard\plain 
{\tc\tcl2 \v test_dig_t.hpp}
{\xe \v test_dig_t.hpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "pardigs_t.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para test_dig_t.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "test__dig__t_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b NumRepr}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_constr_UINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_constr_SINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_constr_defecto_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_constr_copia_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_constr_movimiento_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_assign_UINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_assign_SINT_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_assign_copia_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_assign_movimiento_dig_t} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_preincrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_postincrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_predecrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_postdecrement} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_add_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_add_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_substract_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_substract_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_mult_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_mult_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_ediv_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_ediv_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_erem_assign} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_erem_assign_uint} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_add} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_add_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_substract} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_substract_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_multiply} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_multiply_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_edivision} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_edivision_int} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_C_B} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_operator_C_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_prop_C_B_eq_inv_C_B} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_prop_C_Bm1_eq_inv_C_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_prop_C_B_minus_1_eq_C_Bm1} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_unary_operator_minus} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<type_traits::allowable_base_type_c UINT_T, UINT_T B> \par
requires (type_traits::suitable_base<UINT_T,B>())void {\b NumRepr::display_unary_operator_neg} ()\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
test_dig_t.hpp\par \pard\plain 
{\tc\tcl2 \v test_dig_t.hpp}
{\xe \v test_dig_t.hpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TEST_DIG_T_HPP_INCLUDED}\par
00002 {\cf21 #define TEST_DIG_T_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include "pardigs_t.hpp"}\par
00005 \par
00006 {\cf17 namespace }NumRepr \{\par
00007 \par
00008 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00009         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00010 {\cf18 void} display_constr_UINT_dig_t()\{\par
00011         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00012         ullint k\{0\};\par
00013         {\cf19 for} (ullint i\{0\} ; i<1030 ; ++i) \{\par
00014                 base_B_dig_t unidades(i);\par
00015                 {\cf19 if} ((k%{\cf17 static_cast<}ullint{\cf17 >}(B))!={\cf17 static_cast<}ullint{\cf17 >}(B-1)) \{\par
00016                         std::cout << k << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00017                 \}\par
00018                 {\cf19 else} \{\par
00019                         std::cout << k << {\cf22 "->"} << unidades << {\cf22 "|"} << std::endl;\par
00020                 \}\par
00021                 ++k;\par
00022         \}\par
00023         std::cout << std::endl;\par
00024 \}\par
00025 \par
00026 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00027         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00028 {\cf18 void} display_constr_SINT_dig_t()\{\par
00029         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00030         sllint k\{-1000\}; sllint kold\{0\};\par
00031         {\cf19 for} (sllint i\{-1030\} ; i<1030 ; ++i) \{\par
00032                 base_B_dig_t unidades(i);\par
00033                 {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))!={\cf17 static_cast<}sllint{\cf17 >}(B-1)) \{\par
00034                         {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))==0) \{\par
00035                                 std::cout << k << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00036                         \}\par
00037                         {\cf19 else} \{\par
00038                                 std::cout << k << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00039                         \}\par
00040                 \}\par
00041                 {\cf19 else} \{\par
00042                         std::cout << kold << {\cf22 "->"} << unidades << {\cf22 "|"} << std::endl;\par
00043                 \}\par
00044                 ++k;\par
00045         \}\par
00046         std::cout << std::endl;\par
00047 \}\par
00048 \par
00049 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00050         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00051 {\cf18 void} display_constr_defecto_dig_t()\{\par
00052         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00053         base_B_dig_t unidades_parentesis=base_B_dig_t();\par
00054         std::cout << {\cf22 "unidades llamadas con parentesis vacios : "}\par
00055                                                 << unidades_parentesis << std::endl;\par
00056         base_B_dig_t unidades_llaves\{\};\par
00057         std::cout << {\cf22 "unidades llamadas con llaves vacias : "}\par
00058                                                 << unidades_llaves << std::endl;\par
00059         base_B_dig_t unidades;\par
00060         std::cout << {\cf22 "unidades llamadas sin inicializacion aparente : "}\par
00061                                                 << unidades << std::endl;\par
00062 \}\par
00063 \par
00064 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00065         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00066 {\cf18 void} display_constr_copia_dig_t()\{\par
00067         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00068         \{\par
00069                 base_B_dig_t unidades({\cf17 static_cast<}UINT_T{\cf17 >}((B/2)+1));\par
00070                 base_B_dig_t unidades_copiadas(unidades);\par
00071                 std::cout << unidades << {\cf22 " =?= "} << unidades_copiadas << std::endl;\par
00072         \}\par
00073         \{\par
00074                 base_B_dig_t unidades\{{\cf17 static_cast<}UINT_T{\cf17 >}((B/2)+1)\};\par
00075                 base_B_dig_t unidades_copiadas(unidades);\par
00076                 std::cout << unidades << {\cf22 " =?= "} << unidades_copiadas << std::endl;\par
00077         \}\par
00078         \{\par
00079                 base_B_dig_t unidades={\cf17 static_cast<}UINT_T{\cf17 >}((B/2)+1);\par
00080                 base_B_dig_t unidades_copiadas(unidades);\par
00081                 std::cout << unidades << {\cf22 " =?= "} << unidades_copiadas << std::endl;\par
00082         \}\par
00083 \}\par
00084 \par
00085 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00086         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00087 {\cf18 void} display_constr_movimiento_dig_t()\{\par
00088         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00089         \{\par
00090                 base_B_dig_t A((B/2)+1);\par
00091                 std::cout << A <<std::endl;\par
00092                 base_B_dig_t unidades(std::move(A));\par
00093                 std::cout << unidades << std::endl;\par
00094                 std::cout << A << std::endl;\par
00095         \}\par
00096         \{\par
00097                 base_B_dig_t A\{(B/2)+1\};\par
00098                 std::cout << A << std::endl;\par
00099                 base_B_dig_t unidades(std::move(A));\par
00100                 std::cout << unidades << std::endl;\par
00101                 std::cout << A << std::endl;\par
00102         \}\par
00103         \{\par
00104                 base_B_dig_t A=(B/2)+1;\par
00105                 base_B_dig_t unidades(std::move(A));\par
00106                 std::cout << unidades << std::endl;\par
00107                 std::cout << A << std::endl;\par
00108         \}\par
00109 \}\par
00110 \par
00111 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00112         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00113 {\cf18 void} display_operator_assign_UINT_dig_t()                                                                       \{\par
00114         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00115         ullint k\{0\}; ullint kold\{0\};\par
00116         {\cf19 for} (ullint i\{0\} ; i<1024+6 ; ++i)                                                                              \{\par
00117                 base_B_dig_t unidades;\par
00118                 unidades = i;\par
00119                 {\cf19 if} ((k%{\cf17 static_cast<}ullint{\cf17 >}(B))!={\cf17 static_cast<}ullint{\cf17 >}(B-1))               \{\par
00120                         {\cf19 if} ((k%{\cf17 static_cast<}ullint{\cf17 >}(B))==0)\par
00121                                 std::cout << kold << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00122                         {\cf19 else}\par
00123                                 std::cout << kold << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00124                         ++k;                                                                                                            \}\par
00125                 {\cf19 else}                                                                                                                    \{\par
00126                         std::cout << kold << {\cf22 "->"} << unidades << {\cf22 "|"} << std::endl;\par
00127                         ++k;\par
00128                         kold = k;                                                                                                       \}       \}\par
00129         std::cout << std::endl;                                                                                                 \}\par
00130 \par
00131 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00132         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00133 {\cf18 void} display_operator_assign_SINT_dig_t()\{\par
00134         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00135         sllint k\{0\};\par
00136         {\cf19 for} (sllint i\{-1000\} ; i<1001 ; ++i) \{\par
00137                 base_B_dig_t unidades;\par
00138                 unidades = i;\par
00139                 {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))!={\cf17 static_cast<}sllint{\cf17 >}(B-1)) \{\par
00140                         std::cout << i << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00141                 \}\par
00142                 {\cf19 else}\par
00143                         std::cout << i << {\cf22 "->"} << unidades << {\cf22 "|"} << std::endl;\par
00144                 ++k;\par
00145         \}\par
00146         std::cout << std::endl;\par
00147 \}\par
00148 \par
00149 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00150         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00151 {\cf18 void} display_operator_assign_copia_dig_t()\{\par
00152         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00153         sllint k\{0\};\par
00154         {\cf19 for} (sllint i\{-1000\} ; i<1001 ; ++i) \{\par
00155                 base_B_dig_t A\{i\};\par
00156                 base_B_dig_t unidades;\par
00157                 unidades = A;\par
00158                 {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))!={\cf17 static_cast<}sllint{\cf17 >}(B-1)) \{\par
00159                         {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))==0)\par
00160                                 std::cout << i << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00161                         {\cf19 else} \{\par
00162                                 std::cout << i << {\cf22 "->"} << unidades << {\cf22 ";"};\par
00163                         \}\par
00164                 \}\par
00165                 {\cf19 else} \{\par
00166                         std::cout << i << {\cf22 "->"} << unidades << {\cf22 "|"} << std::endl;\par
00167                 \}\par
00168                 ++k;\par
00169         \}\par
00170         std::cout << std::endl;                                                                                 \}\par
00171 \par
00172 {\cf17 template}<type_traits::allowable_base_type_c UINT_T,UINT_T B>\par
00173         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00174 {\cf18 void} display_operator_assign_movimiento_dig_t()                                                         \{\par
00175         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00176         sllint k\{0\};\par
00177 \par
00178         {\cf19 for} (sllint i\{-1000\} ; i<1001 ; ++i)                                                                    \{\par
00179                 base_B_dig_t A\{i\};\par
00180                 base_B_dig_t C\{A\};\par
00181                 base_B_dig_t unidades\{\};\par
00182                 unidades = A;\par
00183                 {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))!={\cf17 static_cast<}sllint{\cf17 >}(B-1))                        \{\par
00184                         {\cf19 if} ((k%{\cf17 static_cast<}sllint{\cf17 >}(B))==0)\par
00185                                 std::cout << i << {\cf22 "|1->"} << unidades << {\cf22 ";"} << C << {\cf22 "-;-"};\par
00186                         {\cf19 else}                                                            \{\par
00187                                 std::cout << i << {\cf22 "|2->"} << unidades << {\cf22 ";"} << C << {\cf22 "-;-"};  \}\}\par
00188                 {\cf19 else}                                                                                                                    \{\par
00189                         std::cout << i << {\cf22 "|3->"} << unidades << C << {\cf22 "-|"} << std::endl; \}\par
00190                 ++k;\par
00191         \}\par
00192         std::cout << std::endl;\par
00193 \}\par
00194 \par
00195 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00196         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00197 {\cf18 void} display_operator_preincrement() \{\par
00198         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00199         std::uint64_t contador_buenos\{\};\par
00200         std::uint64_t contador_malos\{\};\par
00201         std::int64_t md\{\};\par
00202         base_B_dig_t uds\{\};\par
00203         {\cf19 for}(std::int64_t idx\{0\} ; idx < 2*B+1 ; ++idx) \{\par
00204                 {\cf19 if} ((++uds).get()==((++md)%B))\par
00205                         ++contador_buenos;\par
00206                 {\cf19 else}\par
00207                         ++contador_malos;\par
00208         \}\par
00209         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00210         std::cout       << {\cf22 "___BEGIN__TESTS__PRE_INCREMENTOS___BEGIN___"}<< std::endl;\par
00211         std::cout       << {\cf22 " Numero de incrementos correctos    = "}\par
00212                                 << contador_buenos                                      << std::endl;\par
00213         std::cout       << {\cf22 " Numero de incrementos fallidos             = "}\par
00214                                 << contador_malos                                       << std::endl;\par
00215         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00216                                 << contador_buenos+contador_malos       << std::endl;\par
00217         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00218                                 << {\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)<< std::endl;\par
00219         std::cout       << {\cf22 "___END____TESTS__PRE_INCREMENTOS_____END___"}<< std::endl;\par
00220         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00221 \}\par
00222 \par
00223 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00224         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00225 {\cf18 void} display_operator_postincrement() \{\par
00226         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00227         std::uint64_t contador_buenos\{\};\par
00228         std::uint64_t contador_malos\{\};\par
00229         std::int64_t md\{\};\par
00230         base_B_dig_t uds\{\};\par
00231         {\cf19 for}(std::int64_t idx\{0\} ; idx < 2*B+1 ; ++idx) \{\par
00232                 {\cf19 if} ((uds++).get()==((md++)%B))\par
00233                         ++contador_buenos;\par
00234                 {\cf19 else}\par
00235                         ++contador_malos;\par
00236         \}\par
00237         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00238         std::cout       << {\cf22 "___BEGIN__TESTS__POSTINCREMENTOS___BEGIN___"}<< std::endl;\par
00239         std::cout       << {\cf22 " Numero de incrementos correctos    = "}\par
00240                                 << contador_buenos                                      << std::endl;\par
00241         std::cout       << {\cf22 " Numero de incrementos fallidos             = "}\par
00242                                 << contador_malos                                       << std::endl;\par
00243         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00244                                 << contador_buenos+contador_malos       << std::endl;\par
00245         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00246                                 << {\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)<< std::endl;\par
00247         std::cout       << {\cf22 "___END____TESTS__POSTINCREMENTOS_____END___"}<< std::endl;\par
00248         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00249 \}\par
00250 \par
00251 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00252         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00253 {\cf18 void} display_operator_predecrement() \{\par
00254         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00255         std::uint64_t contador_buenos\{\};\par
00256         std::uint64_t contador_malos\{\};\par
00257         std::int64_t md\{2*B+1\};\par
00258         base_B_dig_t uds\{B+1\};\par
00259         {\cf19 for}(std::int64_t idx\{0\} ; idx < 2*B+1 ; ++idx) \{\par
00260                 {\cf19 if} ((--uds).get()==((--md)%B))\par
00261                         ++contador_buenos;\par
00262                 {\cf19 else}\par
00263                         ++contador_malos;\par
00264         \}\par
00265         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00266         std::cout       << {\cf22 "___BEGIN__TESTS__PRE_DECREMENTOS___BEGIN___"}<< std::endl;\par
00267         std::cout       << {\cf22 " Numero de decrementos correctos    = "}\par
00268                                 << contador_buenos                                      << std::endl;\par
00269         std::cout       << {\cf22 " Numero de decrementos fallidos             = "}\par
00270                                 << contador_malos                                       << std::endl;\par
00271         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00272                                 << contador_buenos+contador_malos       << std::endl;\par
00273         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00274                                 << {\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)<< std::endl;\par
00275         std::cout       << {\cf22 "___END____TESTS__PRE_DECREMENTOS_____END___"}<< std::endl;\par
00276         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00277 \}\par
00278 \par
00279 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00280         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00281 {\cf18 void} display_operator_postdecrement() \{\par
00282         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00283         std::uint64_t contador_buenos\{\};\par
00284         std::uint64_t contador_malos\{\};\par
00285         std::int64_t md\{2*B+1\};\par
00286         base_B_dig_t uds\{B+1\};\par
00287         {\cf19 for}(std::int64_t idx\{0\} ; idx < 2*B+1 ; ++idx) \{\par
00288                 {\cf19 if} ((uds--).get()==((md--)%B))\par
00289                         ++contador_buenos;\par
00290                 {\cf19 else}\par
00291                         ++contador_malos;\par
00292         \}\par
00293         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00294         std::cout       << {\cf22 "___BEGIN__TESTS__POSTDECREMENTOS___BEGIN___"}<< std::endl;\par
00295         std::cout       << {\cf22 " Numero de decrementos correctos    = "}\par
00296                                 << contador_buenos                                      << std::endl;\par
00297         std::cout       << {\cf22 " Numero de decrementos fallidos             = "}\par
00298                                 << contador_malos                                       << std::endl;\par
00299         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00300                                 << contador_buenos+contador_malos       << std::endl;\par
00301         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00302                                 << {\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)<< std::endl;\par
00303         std::cout       << {\cf22 "___END____TESTS__POSTDECREMENTOS_____END___"}<< std::endl;\par
00304         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00305 \}\par
00306 \par
00307 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00308         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00309 {\cf18 void} display_operator_add_assign() \{\par
00310         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00311         std::uint64_t contador_buenos\{\};\par
00312         std::uint64_t contador_malos\{\};\par
00313         std::int64_t md\{0\};\par
00314         std::int64_t nd\{0\};\par
00315         base_B_dig_t nos\{0\};\par
00316         base_B_dig_t uds\{0\};\par
00317         {\cf19 for}(std::int64_t idx_nos\{0\} ; idx_nos < 2*B+1 ; ++idx_nos) \{\par
00318                 {\cf19 for}(std::int64_t idx_uds\{0\} ; idx_uds < 2*B+1 ; ++idx_uds) \{\par
00319                         uds = md;\par
00320                         uds += nos;\par
00321                         {\cf19 if} (uds.get() == (md+nd)%B)\par
00322                                 ++contador_buenos;\par
00323                         {\cf19 else}\par
00324                                 ++contador_malos;\par
00325                         ++md;\par
00326                 \}\par
00327                 ++nd;\par
00328                 nos = nd;\par
00329         \}\par
00330         {\cf17 constexpr} std::uint64_t ciclos\{\par
00331                 {\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)*{\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)\};\par
00332         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00333         std::cout       << {\cf22 "___BEGIN__TESTS____ADD_&_ASSIGN____BEGIN___"}<< std::endl;\par
00334         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00335                                 << contador_buenos                                                              << std::endl;\par
00336         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00337                                 << contador_malos                                                               << std::endl;\par
00338         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00339                                 << contador_buenos+contador_malos                               << std::endl;\par
00340         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00341                                 << ciclos                                                                               << std::endl;\par
00342         std::cout       << {\cf22 "___END_____TESTS____ADD_&_ASSIGN_____END___"}<< std::endl;\par
00343         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00344 \}\par
00345 \par
00346 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00347         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00348 {\cf18 void} display_operator_add_assign_uint() \{\par
00349         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00350         std::uint64_t contador_buenos\{\};\par
00351         std::uint64_t contador_malos\{\};\par
00352         {\cf19 for}(std::int64_t nd\{0\} ; nd < 2*B+1 ; ++nd) \{\par
00353                 {\cf19 for}(std::int64_t md\{0\} ; md < 2*B+1 ; ++md) \{\par
00354                         base_B_dig_t uds\{md\};\par
00355                         uds += nd;\par
00356                         {\cf19 if} (uds.get() == ((md+nd)%B))\par
00357                                 ++contador_buenos;\par
00358                         {\cf19 else}\par
00359                                 ++contador_malos;\par
00360                 \}\par
00361         \}\par
00362         {\cf17 constexpr} std::uint64_t ciclos\{\par
00363                 {\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)*{\cf17 static_cast<}std::uint64_t{\cf17 >}(2*B+1)\};\par
00364         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00365         std::cout       << {\cf22 "___BEGIN__TESTS_ADD_&_ASSIGN_UINT__BEGIN___"}<< std::endl;\par
00366         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00367                                 << contador_buenos                                                              << std::endl;\par
00368         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00369                                 << contador_malos                                                               << std::endl;\par
00370         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00371                                 << contador_buenos+contador_malos                               << std::endl;\par
00372         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00373                                 << ciclos                                                                               << std::endl;\par
00374         std::cout       << {\cf22 "___END____TESTS_ADD_&_ASSIGN_UINT____END___"}<< std::endl;\par
00375         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00376 \}\par
00377 \par
00378 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00379         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00380 {\cf18 void} display_operator_substract_assign() \{\par
00381         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00382         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00383         std::uint64_t contador_buenos\{\};\par
00384         std::uint64_t contador_malos\{\};\par
00385         std::uint64_t contador\{\};\par
00386         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00387                 {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00388                         std::int64_t mmd\{md\};\par
00389                         base_B_dig_t nos\{nd\};\par
00390                         base_B_dig_t uds\{mmd\};\par
00391                         uds -= nos;\par
00392                         mmd -= nd;\par
00393 \par
00394                         {\cf19 while} (mmd<0)\par
00395                                 mmd += int64_B;\par
00396                         {\cf19 while} (mmd>=int64_B)\par
00397                                 mmd -= int64_B;\par
00398 \par
00399                         {\cf19 if} (uds.get() == mmd)\par
00400                                 ++contador_buenos;\par
00401                         {\cf19 else}\par
00402                                 ++contador_malos;\par
00403 \par
00404                         ++contador;\par
00405                 \}\par
00406         \}\par
00407         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00408         std::cout       << {\cf22 "__BEGIN__TESTS_SUBSTRACT_&_ASSIGN__BEGIN___"}<< std::endl;\par
00409         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00410                                 << contador_buenos                                                              << std::endl;\par
00411         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00412                                 << contador_malos                                                               << std::endl;\par
00413         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00414                                 << contador_buenos+contador_malos                               << std::endl;\par
00415         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00416                                 << contador                                                                             << std::endl;\par
00417         std::cout       << {\cf22 "__END____TESTS_SUBSTRACT_&_ASSIGN____END___"}<< std::endl;\par
00418         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00419 \}\par
00420 \par
00421 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00422         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00423 {\cf18 void} display_operator_substract_assign_uint() \{\par
00424         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00425         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00426         std::uint64_t contador_buenos\{\};\par
00427         std::uint64_t contador_malos\{\};\par
00428         std::uint64_t contador\{\};\par
00429         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00430                 {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00431                         std::int64_t mmd\{md\};\par
00432                         base_B_dig_t uds\{mmd\};\par
00433                         uds -= nd;\par
00434                         mmd -= nd;\par
00435                         {\cf19 while} (mmd<0) \{\par
00436                                 mmd += B;\par
00437                         \}\par
00438                         {\cf19 while} (mmd>=B) \{\par
00439                                 mmd -= B;\par
00440                         \}\par
00441                         {\cf19 if} (uds.get() == mmd) \{\par
00442                                 ++contador_buenos;\par
00443                         \}\par
00444                         {\cf19 else} \{\par
00445                                 ++contador_malos;\par
00446                         \}\par
00447                         ++contador;\par
00448                 \}\par
00449         \}\par
00450         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00451         std::cout       << {\cf22 "_BEGIN_TESTS_SUBSTRACT_&_ASSIGN_INT_BEGIN__"}<< std::endl;\par
00452         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00453                                 << contador_buenos                                                              << std::endl;\par
00454         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00455                                 << contador_malos                                                               << std::endl;\par
00456         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00457                                 << contador_buenos+contador_malos                               << std::endl;\par
00458         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00459                                 << contador                                                                             << std::endl;\par
00460         std::cout       << {\cf22 "_END___TESTS_SUBSTRACT_&_ASSIGN_INT__END___"}<< std::endl;\par
00461         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00462 \}\par
00463 \par
00464 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00465         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00466 {\cf18 void} display_operator_mult_assign() \{\par
00467         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00468         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00469         std::uint64_t contador_buenos\{\};\par
00470         std::uint64_t contador_malos\{\};\par
00471         std::uint64_t contador\{\};\par
00472         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00473                 {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00474                         std::int64_t mmd\{md\};\par
00475                         base_B_dig_t nos\{nd\};\par
00476                         base_B_dig_t uds\{mmd\};\par
00477                         uds *= nos;\par
00478                         mmd *= nd;\par
00479 \par
00480                         {\cf19 while} (mmd<0)\par
00481                                 mmd += int64_B;\par
00482                         {\cf19 while} (mmd>=int64_B)\par
00483                                 mmd -= int64_B;\par
00484 \par
00485                         {\cf19 if} (uds.get() == mmd)\par
00486                                 ++contador_buenos;\par
00487                         {\cf19 else}\par
00488                                 ++contador_malos;\par
00489 \par
00490                         ++contador;\par
00491                 \}\par
00492         \}\par
00493         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00494         std::cout       << {\cf22 "__BEGIN__TESTS____MULT_&_ASSIGN____BEGIN___"}<< std::endl;\par
00495         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00496                                 << contador_buenos                                                              << std::endl;\par
00497         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00498                                 << contador_malos                                                               << std::endl;\par
00499         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00500                                 << contador_buenos+contador_malos                               << std::endl;\par
00501         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00502                                 << contador                                                                             << std::endl;\par
00503         std::cout       << {\cf22 "__END____TESTS____MULT_&_ASSIGN______END___"}<< std::endl;\par
00504         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00505 \}\par
00506 \par
00507 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00508         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00509 {\cf18 void} display_operator_mult_assign_uint() \{\par
00510         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00511         {\cf17 constexpr} std::int32_t int32_B\{B\};\par
00512         std::uint32_t contador_buenos\{\};\par
00513         std::uint32_t contador_malos\{\};\par
00514         std::uint32_t contador\{\};\par
00515         {\cf19 for}(std::int32_t nd\{1-int32_B\} ; nd < int32_B ; ++nd) \{\par
00516                 {\cf19 for}(std::int32_t md\{1-int32_B\} ; md < int32_B ; ++md) \{\par
00517                         std::int32_t mmd\{md\};\par
00518                         base_B_dig_t uds\{mmd\};\par
00519                         uds *= nd;\par
00520                         mmd *= nd;\par
00521                         {\cf19 while} (mmd<0) \{\par
00522                                 mmd += B;\par
00523                         \}\par
00524                         {\cf19 while} (mmd>=int32_B) \{\par
00525                                 mmd -= B;\par
00526                         \}\par
00527                         {\cf19 if} (uds.get() == mmd) \{\par
00528                                 ++contador_buenos;\par
00529                         \}\par
00530                         {\cf19 else} \{\par
00531                                 ++contador_malos;\par
00532                         \}\par
00533                         ++contador;\par
00534                 \}\par
00535         \}\par
00536         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00537         std::cout       << {\cf22 "_BEGIN_TESTS___MULT_&_ASSIGN_INT____BEGIN__"}<< std::endl;\par
00538         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00539                                 << contador_buenos                                                              << std::endl;\par
00540         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00541                                 << contador_malos                                                               << std::endl;\par
00542         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00543                                 << contador_buenos+contador_malos                               << std::endl;\par
00544         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00545                                 << contador                                                                             << std::endl;\par
00546         std::cout       << {\cf22 "_END___TESTS___MULT_&_ASSIGN_INT_____END___"}<< std::endl;\par
00547         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00548 \}\par
00549 \par
00550 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00551         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00552 {\cf18 void} display_operator_ediv_assign() \{\par
00553         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00554         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00555         std::uint64_t contador_buenos\{\};\par
00556         std::uint64_t contador_malos\{\};\par
00557         std::uint64_t contador\{\};\par
00558         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00559                 {\cf19 if} ((nd%int64_B) != 0) \{\par
00560                         {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00561                                 base_B_dig_t uds\{md\};\par
00562                                 std::int64_t mmd\{md\};\par
00563                                 {\cf19 while} (mmd<0)\par
00564                                         mmd += int64_B;\par
00565                                 base_B_dig_t nos\{nd\};\par
00566                                 std::int64_t nnd\{nd\};\par
00567                                 {\cf19 while} (nnd<0)\par
00568                                         nnd += int64_B;\par
00569 \par
00570                                 uds /= nos;\par
00571                                 mmd /= nnd;\par
00572 \par
00573                                 {\cf19 while} (mmd<0)\par
00574                                         mmd += int64_B;\par
00575                                 {\cf19 while} (mmd>=int64_B)\par
00576                                         mmd -= int64_B;\par
00577 \par
00578                                 {\cf19 if} (uds.get() == mmd)\par
00579                                         ++contador_buenos;\par
00580                                 {\cf19 else}\par
00581                                         ++contador_malos;\par
00582 \par
00583                                 ++contador;\par
00584                         \}\par
00585                 \}\par
00586         \}\par
00587         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00588         std::cout       << {\cf22 "__BEGIN__TESTS____EDIV_&_ASSIGN____BEGIN___"}<< std::endl;\par
00589         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00590                                 << contador_buenos                                                              << std::endl;\par
00591         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00592                                 << contador_malos                                                               << std::endl;\par
00593         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00594                                 << contador_buenos+contador_malos                               << std::endl;\par
00595         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00596                                 << contador                                                                             << std::endl;\par
00597         std::cout       << {\cf22 "__END____TESTS____EDIV_&_ASSIGN______END___"}<< std::endl;\par
00598         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00599 \}\par
00600 \par
00601 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00602         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00603 {\cf18 void} display_operator_ediv_assign_uint() \{\par
00604         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00605         {\cf17 constexpr} std::int32_t int32_B\{B\};\par
00606         std::uint32_t contador_buenos\{\};\par
00607         std::uint32_t contador_malos\{\};\par
00608         std::uint32_t contador\{\};\par
00609         {\cf19 for}(std::int32_t nd\{1-int32_B\} ; nd < int32_B ; ++nd) \{\par
00610                 {\cf19 if} (nd != 0) \{\par
00611                         {\cf19 for}(std::int32_t md\{1-int32_B\} ; md < int32_B ; ++md) \{\par
00612                                 std::int32_t mmd\{md\};\par
00613                                 std::int32_t nnd\{nd\};\par
00614                                 base_B_dig_t uds\{mmd\};\par
00615 \par
00616                                 {\cf19 while} (mmd<0) \{\par
00617                                         mmd += int32_B;\par
00618                                 \}\par
00619                                 {\cf19 while} (nnd<0) \{\par
00620                                         nnd += int32_B;\par
00621                                 \}\par
00622 \par
00623                                 uds /= nnd;\par
00624                                 mmd /= nnd;\par
00625 \par
00626                                 {\cf19 while} (mmd<0) \{\par
00627                                         mmd += B;\par
00628                                 \}\par
00629                                 {\cf19 while} (mmd>=int32_B) \{\par
00630                                         mmd -= B;\par
00631                                 \}\par
00632 \par
00633                                 {\cf19 if} (uds.get() == mmd) \{\par
00634                                         ++contador_buenos;\par
00635                                 \}\par
00636                                 {\cf19 else} \{\par
00637                                         ++contador_malos;\par
00638                                 \}\par
00639 \par
00640                                 ++contador;\par
00641                         \}\par
00642                 \}\par
00643         \}\par
00644         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00645         std::cout       << {\cf22 "_BEGIN_TESTS___EDIV_&_ASSIGN_INT____BEGIN__"}<< std::endl;\par
00646         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00647                                 << contador_buenos                                                              << std::endl;\par
00648         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00649                                 << contador_malos                                                               << std::endl;\par
00650         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00651                                 << contador_buenos+contador_malos                               << std::endl;\par
00652         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00653                                 << contador                                                                             << std::endl;\par
00654         std::cout       << {\cf22 "_END___TESTS___EDIV_&_ASSIGN_INT_____END___"}<< std::endl;\par
00655         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00656 \}\par
00657 \par
00658 \par
00659 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00660         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00661 {\cf18 void} display_operator_erem_assign() \{\par
00662         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00663         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00664         std::uint64_t contador_buenos\{\};\par
00665         std::uint64_t contador_malos\{\};\par
00666         std::uint64_t contador\{\};\par
00667         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00668                 {\cf19 if} (nd != 0) \{\par
00669                         {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00670                                 std::int64_t mmd\{md\};\par
00671                                 std::int64_t nnd\{nd\};\par
00672                                 base_B_dig_t nos\{nd\};\par
00673                                 base_B_dig_t uds\{mmd\};\par
00674 \par
00675                                 {\cf19 while} (mmd<0)\par
00676                                         mmd += int64_B;\par
00677                                 {\cf19 while} (nnd<0)\par
00678                                         nnd += int64_B;\par
00679 \par
00680                                 uds %= nos;\par
00681                                 mmd %= nnd;\par
00682 \par
00683                                 {\cf19 while} (mmd<0)\par
00684                                         mmd += int64_B;\par
00685                                 {\cf19 while} (mmd>=int64_B)\par
00686                                         mmd -= int64_B;\par
00687 \par
00688                                 {\cf19 if} (uds.get() == mmd)\par
00689                                         ++contador_buenos;\par
00690                                 {\cf19 else}\par
00691                                         ++contador_malos;\par
00692 \par
00693                                 ++contador;\par
00694                         \}\par
00695                 \}\par
00696         \}\par
00697         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00698         std::cout       << {\cf22 "__BEGIN__TESTS____EREM_&_ASSIGN____BEGIN___"}<< std::endl;\par
00699         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00700                                 << contador_buenos                                                              << std::endl;\par
00701         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00702                                 << contador_malos                                                               << std::endl;\par
00703         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00704                                 << contador_buenos+contador_malos                               << std::endl;\par
00705         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00706                                 << contador                                                                             << std::endl;\par
00707         std::cout       << {\cf22 "__END____TESTS____EREM_&_ASSIGN______END___"}<< std::endl;\par
00708         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00709 \}\par
00710 \par
00711 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00712         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00713 {\cf18 void} display_operator_erem_assign_uint() \{\par
00714         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00715         {\cf17 constexpr} std::int32_t int32_B\{B\};\par
00716         std::uint32_t contador_buenos\{\};\par
00717         std::uint32_t contador_malos\{\};\par
00718         std::uint32_t contador\{\};\par
00719         {\cf19 for}(std::int32_t nd\{1-int32_B\} ; nd < int32_B ; ++nd) \{\par
00720                 {\cf19 if} (nd != 0) \{\par
00721                         {\cf19 for}(std::int32_t md\{1-int32_B\} ; md < int32_B ; ++md) \{\par
00722                                 std::int32_t mmd\{md\};\par
00723                                 std::int32_t nnd\{nd\};\par
00724                                 base_B_dig_t uds\{mmd\};\par
00725 \par
00726                                 {\cf19 while} (mmd<0) \{\par
00727                                         mmd += int32_B;\par
00728                                 \}\par
00729                                 {\cf19 while} (nnd<0) \{\par
00730                                         nnd += int32_B;\par
00731                                 \}\par
00732 \par
00733                                 uds %= nnd;\par
00734                                 mmd %= nnd;\par
00735 \par
00736                                 {\cf19 while} (mmd<0) \{\par
00737                                         mmd += B;\par
00738                                 \}\par
00739                                 {\cf19 while} (mmd>=int32_B) \{\par
00740                                         mmd -= B;\par
00741                                 \}\par
00742 \par
00743                                 {\cf19 if} (uds.get() == mmd) \{\par
00744                                         ++contador_buenos;\par
00745                                 \}\par
00746                                 {\cf19 else} \{\par
00747                                         ++contador_malos;\par
00748                                 \}\par
00749 \par
00750                                 ++contador;\par
00751                         \}\par
00752                 \}\par
00753         \}\par
00754         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00755         std::cout       << {\cf22 "_BEGIN_TESTS___EREM_&_ASSIGN_INT____BEGIN__"}<< std::endl;\par
00756         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00757                                 << contador_buenos                                                              << std::endl;\par
00758         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00759                                 << contador_malos                                                               << std::endl;\par
00760         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00761                                 << contador_buenos+contador_malos                               << std::endl;\par
00762         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00763                                 << contador                                                                             << std::endl;\par
00764         std::cout       << {\cf22 "_END___TESTS___EREM_&_ASSIGN_INT_____END___"}<< std::endl;\par
00765         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00766 \}\par
00767 \par
00768 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00769         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00770 {\cf18 void} display_operator_add() \{\par
00771         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00772         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00773         std::uint64_t contador_buenos\{\};\par
00774         std::uint64_t contador_malos\{\};\par
00775         std::uint64_t contador\{\};\par
00776         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00777                         {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00778                                 std::int64_t suma_int\{md+nd\};\par
00779                                 base_B_dig_t nos\{nd\};\par
00780                                 base_B_dig_t uds\{md\};\par
00781                                 base_B_dig_t suma_dig\{nos+uds\};\par
00782 \par
00783                                 {\cf19 while} (suma_int < 0)\par
00784                                         suma_int += int64_B;\par
00785                                 {\cf19 while} (suma_int >= int64_B)\par
00786                                         suma_int -= int64_B;\par
00787 \par
00788                                 {\cf19 if} (suma_dig.get() == suma_int)\par
00789                                         ++contador_buenos;\par
00790                                 {\cf19 else}\par
00791                                         ++contador_malos;\par
00792 \par
00793                                 ++contador;\par
00794                         \}\par
00795         \}\par
00796         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00797         std::cout       << {\cf22 "___BEGIN_______TESTS____SUMA_______BEGIN___"}<< std::endl;\par
00798         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00799                                 << contador_buenos                                                              << std::endl;\par
00800         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00801                                 << contador_malos                                                               << std::endl;\par
00802         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00803                                 << contador_buenos+contador_malos                               << std::endl;\par
00804         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00805                                 << contador                                                                             << std::endl;\par
00806         std::cout       << {\cf22 "___END_________TESTS____SUMA_________END___"}<< std::endl;\par
00807         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00808 \}\par
00809 \par
00810 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00811         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00812 {\cf18 void} display_operator_add_int() \{\par
00813         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00814         {\cf17 constexpr} std::int32_t int32_B\{B\};\par
00815         std::uint32_t contador_buenos\{\};\par
00816         std::uint32_t contador_malos\{\};\par
00817         std::uint32_t contador\{\};\par
00818         {\cf19 for}(std::int32_t nd\{1-int32_B\} ; nd < int32_B ; ++nd) \{\par
00819                         {\cf19 for}(std::int32_t md\{1-int32_B\} ; md < int32_B ; ++md) \{\par
00820                                 std::int32_t suma_int\{md+nd\};\par
00821                                 base_B_dig_t uds\{md\};\par
00822                                 base_B_dig_t suma_dig\{uds+nd\};\par
00823 \par
00824                                 {\cf19 while} (suma_int < 0)\par
00825                                         suma_int += int32_B;\par
00826                                 {\cf19 while} (suma_int >= int32_B)\par
00827                                         suma_int -= int32_B;\par
00828 \par
00829                                 {\cf19 if} (suma_dig.get() == suma_int)\par
00830                                         ++contador_buenos;\par
00831                                 {\cf19 else}\par
00832                                         ++contador_malos;\par
00833 \par
00834                                 ++contador;\par
00835                         \}\par
00836         \}\par
00837         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00838         std::cout       << {\cf22 "___BEGIN______TESTS_SUMA_INT_______BEGIN___"}<< std::endl;\par
00839         std::cout       << {\cf22 " Numero de sumasignaciones correctas= "}\par
00840                                 << contador_buenos                                                              << std::endl;\par
00841         std::cout       << {\cf22 " Numero de sumasignaciones fallidas = "}\par
00842                                 << contador_malos                                                               << std::endl;\par
00843         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00844                                 << contador_buenos+contador_malos                               << std::endl;\par
00845         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00846                                 << contador                                                                             << std::endl;\par
00847         std::cout       << {\cf22 "___END________TESTS_SUMA_INT_________END___"}<< std::endl;\par
00848         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00849 \}\par
00850 \par
00851 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00852         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00853 {\cf18 void} display_operator_substract() \{\par
00854         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00855         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00856         std::uint64_t contador_buenos\{\};\par
00857         std::uint64_t contador_malos\{\};\par
00858         std::uint64_t contador\{\};\par
00859         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00860                         {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00861                                 std::int64_t suma_int\{md-nd\};\par
00862                                 base_B_dig_t nos\{nd\};\par
00863                                 base_B_dig_t uds\{md\};\par
00864                                 base_B_dig_t suma_dig\{uds-nos\};\par
00865 \par
00866                                 {\cf19 while} (suma_int < 0)\par
00867                                         suma_int += int64_B;\par
00868                                 {\cf19 while} (suma_int >= int64_B)\par
00869                                         suma_int -= int64_B;\par
00870 \par
00871                                 {\cf19 if} (suma_dig.get() == suma_int)\par
00872                                         ++contador_buenos;\par
00873                                 {\cf19 else}\par
00874                                         ++contador_malos;\par
00875 \par
00876                                 ++contador;\par
00877                         \}\par
00878         \}\par
00879         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00880         std::cout       << {\cf22 "___BEGIN_____TESTS__SUBSTRACT______BEGIN___"}<< std::endl;\par
00881         std::cout       << {\cf22 " Numero de restas correctas                 = "}\par
00882                                 << contador_buenos                                                              << std::endl;\par
00883         std::cout       << {\cf22 " Numero de restas fallidas                  = "}\par
00884                                 << contador_malos                                                               << std::endl;\par
00885         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00886                                 << contador_buenos+contador_malos                               << std::endl;\par
00887         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00888                                 << contador                                                                             << std::endl;\par
00889         std::cout       << {\cf22 "___END_______TESTS__SUBSTRACT________END___"}<< std::endl;\par
00890         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00891 \}\par
00892 \par
00893 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00894         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00895 {\cf18 void} display_operator_substract_int() \{\par
00896         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00897         {\cf17 constexpr} std::int32_t int32_B\{B\};\par
00898         std::uint32_t contador_buenos\{\};\par
00899         std::uint32_t contador_malos\{\};\par
00900         std::uint32_t contador\{\};\par
00901         {\cf19 for}(std::int32_t nd\{1-int32_B\} ; nd < int32_B ; ++nd) \{\par
00902                         {\cf19 for}(std::int32_t md\{1-int32_B\} ; md < int32_B ; ++md) \{\par
00903                                 std::int32_t suma_int\{md-nd\};\par
00904                                 base_B_dig_t uds\{md\};\par
00905                                 base_B_dig_t suma_dig\{uds-nd\};\par
00906 \par
00907                                 {\cf19 while} (suma_int < 0)\par
00908                                         suma_int += int32_B;\par
00909                                 {\cf19 while} (suma_int >= int32_B)\par
00910                                         suma_int -= int32_B;\par
00911 \par
00912                                 {\cf19 if} (suma_dig.get() == suma_int)\par
00913                                         ++contador_buenos;\par
00914                                 {\cf19 else}\par
00915                                         ++contador_malos;\par
00916 \par
00917                                 ++contador;\par
00918                         \}\par
00919         \}\par
00920         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00921         std::cout       << {\cf22 "___BEGIN______TESTS_RESTA_INT______BEGIN___"}<< std::endl;\par
00922         std::cout       << {\cf22 " Numero de restas correctas                 = "}\par
00923                                 << contador_buenos                                                              << std::endl;\par
00924         std::cout       << {\cf22 " Numero de restas fallidas                  = "}\par
00925                                 << contador_malos                                                               << std::endl;\par
00926         std::cout   << {\cf22 " Numero total de pruebas                        = "}\par
00927                                 << contador_buenos+contador_malos                               << std::endl;\par
00928         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"        = "}\par
00929                                 << contador                                                                             << std::endl;\par
00930         std::cout       << {\cf22 "___END________TESTS_RESTA_INT________END___"}<< std::endl;\par
00931         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00932 \}\par
00933 \par
00934 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00935         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00936 {\cf18 void} display_operator_multiply() \{\par
00937         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00938         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
00939         std::uint64_t contador_buenos\{\};\par
00940         std::uint64_t contador_malos\{\};\par
00941         std::uint64_t contador\{\};\par
00942         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
00943                         {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
00944                                 std::int64_t result_int\{md*nd\};\par
00945                                 base_B_dig_t nos\{nd\};\par
00946                                 base_B_dig_t uds\{md\};\par
00947                                 base_B_dig_t result_dig\{uds*nos\};\par
00948 \par
00949                                 {\cf19 while} (result_int < 0)\par
00950                                         result_int += int64_B;\par
00951                                 {\cf19 while} (result_int >= int64_B)\par
00952                                         result_int -= int64_B;\par
00953 \par
00954                                 {\cf19 if} (result_dig.get() == result_int)\par
00955                                         ++contador_buenos;\par
00956                                 {\cf19 else}\par
00957                                         ++contador_malos;\par
00958 \par
00959                                 ++contador;\par
00960                         \}\par
00961         \}\par
00962         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00963         std::cout       << {\cf22 "___BEGIN___TESTS_MULTIPLICACIONES__BEGIN___"}<< std::endl;\par
00964         std::cout       << {\cf22 " Numero de multiplicaciones correctas       = "}\par
00965                                 << contador_buenos                                                              << std::endl;\par
00966         std::cout       << {\cf22 " Numero de multiplicaciones fallidas        = "}\par
00967                                 << contador_malos                                                               << std::endl;\par
00968         std::cout   << {\cf22 " Numero total de pruebas                                = "}\par
00969                                 << contador_buenos+contador_malos                               << std::endl;\par
00970         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                = "}\par
00971                                 << contador                                                                             << std::endl;\par
00972         std::cout       << {\cf22 "___END_____TESTS_MULTIPLICACIONES____END___"}<< std::endl;\par
00973         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
00974 \}\par
00975 \par
00976 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
00977         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
00978 {\cf18 void} display_operator_multiply_int() \{\par
00979         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
00980         {\cf17 constexpr} std::int32_t int32_B\{B\};\par
00981         std::uint32_t contador_buenos\{\};\par
00982         std::uint32_t contador_malos\{\};\par
00983         std::uint32_t contador\{\};\par
00984         {\cf19 for}(std::int32_t nd\{1-int32_B\} ; nd < int32_B ; ++nd) \{\par
00985                         {\cf19 for}(std::int32_t md\{1-int32_B\} ; md < int32_B ; ++md) \{\par
00986                                 std::int32_t result_int\{md*nd\};\par
00987                                 base_B_dig_t uds\{md\};\par
00988                                 base_B_dig_t result_dig\{uds*nd\};\par
00989 \par
00990                                 {\cf19 while} (result_int < 0)\par
00991                                         result_int += int32_B;\par
00992                                 {\cf19 while} (result_int >= int32_B)\par
00993                                         result_int -= int32_B;\par
00994 \par
00995                                 {\cf19 if} (result_dig.get() == result_int)\par
00996                                         ++contador_buenos;\par
00997                                 {\cf19 else}\par
00998                                         ++contador_malos;\par
00999 \par
01000                                 ++contador;\par
01001                         \}\par
01002         \}\par
01003         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01004         std::cout       << {\cf22 "__BEGIN_TESTS_MULTIPLICACIONES_INT_BEGIN___"}<< std::endl;\par
01005         std::cout       << {\cf22 " Numero de multiplicaciones correctas       = "}\par
01006                                 << contador_buenos                                                              << std::endl;\par
01007         std::cout       << {\cf22 " Numero de multiplicaciones fallidas        = "}\par
01008                                 << contador_malos                                                               << std::endl;\par
01009         std::cout   << {\cf22 " Numero total de pruebas                                = "}\par
01010                                 << contador_buenos+contador_malos                               << std::endl;\par
01011         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                = "}\par
01012                                 << contador                                                                             << std::endl;\par
01013         std::cout       << {\cf22 "___END__TESTS_MULTIPLICACIONES_INT___END___"}<< std::endl;\par
01014         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01015 \}\par
01016 \par
01017 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01018         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01019 {\cf18 void} display_operator_edivision() \{\par
01020         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01021         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01022         std::uint64_t contador_buenos\{\};\par
01023         std::uint64_t contador_malos\{\};\par
01024         std::uint64_t contador\{\};\par
01025         {\cf19 for}(std::int64_t nd\{-1\} ; nd < int64_B ; ++nd) \{\par
01026                 {\cf19 if} (nd%B != 0) \{\par
01027                         {\cf19 for}(std::int64_t md\{-1\} ; md < int64_B ; ++md) \{\par
01028 \par
01029                                 base_B_dig_t nos\{nd\};\par
01030                                 base_B_dig_t uds\{md\};\par
01031                                 base_B_dig_t result_dig\{uds/nos\};\par
01032                                 base_B_dig_t prueba_ediv_dig\{uds-(result_dig*nos)\};\par
01033 \par
01034                                 std::int64_t mmd\{md\};\par
01035                                 {\cf19 while} (mmd < 0)\par
01036                                         mmd += int64_B;\par
01037                                 {\cf19 while} (mmd >= int64_B)\par
01038                                         mmd -= int64_B;\par
01039                                 std::int64_t nnd\{nd\};\par
01040                                 {\cf19 while} (nnd < 0)\par
01041                                         nnd += int64_B;\par
01042                                 {\cf19 while} (nnd >= int64_B)\par
01043                                         nnd -= int64_B;\par
01044                                 std::int64_t result_int\{mmd/nnd\};\par
01045                                 {\cf19 while} (result_int < 0)\par
01046                                         result_int += int64_B;\par
01047                                 {\cf19 while} (result_int >= int64_B)\par
01048                                         result_int -= int64_B;\par
01049                                 std::int64_t prueba_ediv_int\{mmd-(result_int*nnd)\};\par
01050                                 {\cf19 while} (prueba_ediv_int < 0)\par
01051                                         prueba_ediv_int += int64_B;\par
01052                                 {\cf19 while} (prueba_ediv_int >= int64_B)\par
01053                                         prueba_ediv_int -= int64_B;\par
01054                                 {\cf19 if} (prueba_ediv_dig.get() == prueba_ediv_int) \{\par
01055                                         ++contador_buenos;\par
01056                                 \}\par
01057                                 {\cf19 else} \{\par
01058                                         ++contador_malos;\par
01059                                 \}\par
01060                                 ++contador;\par
01061                         \}\par
01062                 \}\par
01063         \}\par
01064         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01065         std::cout       << {\cf22 "___BEGIN_____TESTS_EDIVISIONES_____BEGIN___"}<< std::endl;\par
01066         std::cout       << {\cf22 " Numero de divisiones euclideas correctas   = "}\par
01067                                 << contador_buenos                                                              << std::endl;\par
01068         std::cout       << {\cf22 " Numero de divisiones euclideas fallidas    = "}\par
01069                                 << contador_malos                                                               << std::endl;\par
01070         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01071                                 << contador_buenos+contador_malos                               << std::endl;\par
01072         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01073                                 << contador                                                                             << std::endl;\par
01074         std::cout       << {\cf22 "___END_______TESTS_EDIVISIONES_______END___"}<< std::endl;\par
01075         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01076 \}\par
01077 \par
01078 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01079         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01080 {\cf18 void} display_operator_edivision_int() \{\par
01081         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01082         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01083         std::uint64_t contador_buenos\{\};\par
01084         std::uint64_t contador_malos\{\};\par
01085         std::uint64_t contador\{\};\par
01086         {\cf19 for}(std::int64_t nd\{1-int64_B\} ; nd < int64_B ; ++nd) \{\par
01087                 {\cf19 if} (nd%B != 0) \{\par
01088                         {\cf19 for}(std::int64_t md\{1-int64_B\} ; md < int64_B ; ++md) \{\par
01089                                 std::int64_t mmd\{md\};\par
01090                                 {\cf19 while} (mmd < 0)\par
01091                                         mmd += int64_B;\par
01092                                 {\cf19 while} (mmd >= int64_B)\par
01093                                         mmd -= int64_B;\par
01094                                 std::int64_t nnd\{nd\};\par
01095                                 {\cf19 while} (nnd < 0)\par
01096                                         nnd += int64_B;\par
01097                                 {\cf19 while} (nnd >= int64_B)\par
01098                                         nnd -= int64_B;\par
01099                                 std::int64_t result_int\{mmd/nnd\};\par
01100                                 {\cf19 while} (result_int < 0)\par
01101                                         result_int += int64_B;\par
01102                                 {\cf19 while} (result_int >= int64_B)\par
01103                                         result_int -= int64_B;\par
01104 \par
01105                                 base_B_dig_t uds\{mmd\};\par
01106                                 base_B_dig_t result_dig\{uds/nnd\};\par
01107 \par
01108                                 {\cf19 if} (result_dig.get() == result_int)\par
01109                                         ++contador_buenos;\par
01110                                 {\cf19 else}\par
01111                                         ++contador_malos;\par
01112 \par
01113                                 ++contador;\par
01114                         \}\par
01115                 \}\par
01116         \}\par
01117         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01118         std::cout       << {\cf22 "__BEGIN___TESTS_EDIVISIONES_INT____BEGIN___"}<< std::endl;\par
01119         std::cout       << {\cf22 " Numero de divisiones euclideas correctas   = "}\par
01120                                 << contador_buenos                                                              << std::endl;\par
01121         std::cout       << {\cf22 " Numero de divisiones euclideas fallidas    = "}\par
01122                                 << contador_malos                                                               << std::endl;\par
01123         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01124                                 << contador_buenos+contador_malos                               << std::endl;\par
01125         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01126                                 << contador                                                                             << std::endl;\par
01127         std::cout       << {\cf22 "___END____TESTS_EDIVISIONES_INT______END___"}<< std::endl;\par
01128         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01129 \}\par
01130 \par
01131 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01132         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01133 {\cf18 void} display_operator_C_B() \{\par
01134         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01135         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01136         std::uint64_t contador_buenos\{\};\par
01137         std::uint64_t contador_malos\{\};\par
01138         std::uint64_t contador\{\};\par
01139         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01140                         std::int64_t nnd\{nd\};\par
01141                         {\cf19 while} (nnd < 0)\par
01142                                 nnd += int64_B;\par
01143                         {\cf19 while} (nnd >= int64_B)\par
01144                                 nnd -= int64_B;\par
01145 \par
01146                         std::int64_t result_int\{int64_B-nnd\};\par
01147                         {\cf19 while} (result_int < 0)\par
01148                                 result_int += int64_B;\par
01149                         {\cf19 while} (result_int >= int64_B)\par
01150                                 result_int -= int64_B;\par
01151 \par
01152                         base_B_dig_t uds\{nnd\};\par
01153                         base_B_dig_t result_dig\{uds.C_B()\};\par
01154 \par
01155                         {\cf19 if} (result_dig.get() == result_int)\par
01156                                 ++contador_buenos;\par
01157                         {\cf19 else}\par
01158                                 ++contador_malos;\par
01159 \par
01160                         ++contador;\par
01161         \}\par
01162         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01163         std::cout       << {\cf22 "__BEGIN___TESTS_COMPLEMENTO_BASE___BEGIN___"}<< std::endl;\par
01164         std::cout       << {\cf22 " Numero de complementos a la base correctas = "}\par
01165                                 << contador_buenos                                                              << std::endl;\par
01166         std::cout       << {\cf22 " Numero de complementos a la base fallidos  = "}\par
01167                                 << contador_malos                                                               << std::endl;\par
01168         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01169                                 << contador_buenos+contador_malos                               << std::endl;\par
01170         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01171                                 << contador                                                                             << std::endl;\par
01172         std::cout       << {\cf22 "__END_____TESTS_COMPLEMENTO_BASE_____END___"}<< std::endl;\par
01173         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01174 \}\par
01175 \par
01176 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01177         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01178 {\cf18 void} display_operator_C_Bm1() \{\par
01179         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01180         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01181         std::uint64_t contador_buenos\{\};\par
01182         std::uint64_t contador_malos\{\};\par
01183         std::uint64_t contador\{\};\par
01184         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01185                         std::int64_t nnd\{nd\};\par
01186                         {\cf19 while} (nnd < 0)\par
01187                                 nnd += int64_B;\par
01188                         {\cf19 while} (nnd >= int64_B)\par
01189                                 nnd -= int64_B;\par
01190 \par
01191                         std::int64_t result_int\{int64_B-nnd-1\};\par
01192                         {\cf19 while} (result_int < 0)\par
01193                                 result_int += int64_B;\par
01194                         {\cf19 while} (result_int >= int64_B)\par
01195                                 result_int -= int64_B;\par
01196 \par
01197                         base_B_dig_t uds\{nnd\};\par
01198                         base_B_dig_t result_dig\{uds.C_Bm1()\};\par
01199 \par
01200                         {\cf19 if} (result_dig.get() == result_int)\par
01201                                 ++contador_buenos;\par
01202                         {\cf19 else}\par
01203                                 ++contador_malos;\par
01204 \par
01205                         ++contador;\par
01206         \}\par
01207         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01208         std::cout       << {\cf22 "__BEGIN__TESTS_COMPLEMENTO_BASEm1__BEGIN___"}<< std::endl;\par
01209         std::cout       << {\cf22 " Numero de complementos a la Bm1 correctas  = "}\par
01210                                 << contador_buenos                                                              << std::endl;\par
01211         std::cout       << {\cf22 " Numero de complementos a la Bm1 fallidos   = "}\par
01212                                 << contador_malos                                                               << std::endl;\par
01213         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01214                                 << contador_buenos+contador_malos                               << std::endl;\par
01215         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01216                                 << contador                                                                             << std::endl;\par
01217         std::cout       << {\cf22 "__END_____TESTS_COMPLEMENTO_BASEm1___END___"}<< std::endl;\par
01218         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01219 \}\par
01220 \par
01221 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01222         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01223 {\cf18 void} display_prop_C_B_eq_inv_C_B() \{\par
01224         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01225         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01226         std::uint64_t contador_buenos\{\};\par
01227         std::uint64_t contador_malos\{\};\par
01228         std::uint64_t contador\{\};\par
01229         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01230                         base_B_dig_t uds\{nd\};\par
01231                         base_B_dig_t result_interm_dig\{uds.C_B()\};\par
01232                         base_B_dig_t result_dig\{result_interm_dig.C_B()\};\par
01233 \par
01234                         {\cf19 if} (result_dig == uds)\par
01235                                 ++contador_buenos;\par
01236                         {\cf19 else}\par
01237                                 ++contador_malos;\par
01238 \par
01239                         ++contador;\par
01240         \}\par
01241         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01242         std::cout       << {\cf22 "__BEGIN__TESTS_dig.C_B().C_B()=dig__BEGIN__"}<< std::endl;\par
01243         std::cout       << {\cf22 " Numero de C_B(C_B())=Id() correctas        = "}\par
01244                                 << contador_buenos                                                              << std::endl;\par
01245         std::cout       << {\cf22 " Numero de C_B(C_B())=Id() fallidos = "}\par
01246                                 << contador_malos                                                               << std::endl;\par
01247         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01248                                 << contador_buenos+contador_malos                               << std::endl;\par
01249         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01250                                 << contador                                                                             << std::endl;\par
01251         std::cout       << {\cf22 "__END____TESTS_dig.C_B().C_B()=dig____END__"}<< std::endl;\par
01252         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01253 \}\par
01254 \par
01255 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01256         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01257 {\cf18 void} display_prop_C_Bm1_eq_inv_C_Bm1() \{\par
01258         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01259         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01260         std::uint64_t contador_buenos\{\};\par
01261         std::uint64_t contador_malos\{\};\par
01262         std::uint64_t contador\{\};\par
01263         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01264                         base_B_dig_t uds\{nd\};\par
01265                         base_B_dig_t result_interm_dig\{uds.C_Bm1()\};\par
01266                         base_B_dig_t result_dig\{result_interm_dig.C_Bm1()\};\par
01267 \par
01268                         {\cf19 if} (result_dig == uds)\par
01269                                 ++contador_buenos;\par
01270                         {\cf19 else}\par
01271                                 ++contador_malos;\par
01272 \par
01273                         ++contador;\par
01274         \}\par
01275         std::cout       << {\cf22 "_______________________________________________"}<< std::endl;\par
01276         std::cout       << {\cf22 "__BEGIN__TESTS_dig.C_Bm1().C_Bm1()=dig__BEGIN__"}<< std::endl;\par
01277         std::cout       << {\cf22 " Numero de C_Bm1(C_Bm1())=Id() correctas    = "}\par
01278                                 << contador_buenos                                                              << std::endl;\par
01279         std::cout       << {\cf22 " Numero de C_B(C_B())=Id() fallidos = "}\par
01280                                 << contador_malos                                                               << std::endl;\par
01281         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01282                                 << contador_buenos+contador_malos                               << std::endl;\par
01283         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01284                                 << contador                                                                             << std::endl;\par
01285         std::cout       << {\cf22 "__END____TESTS_dig.C_Bm1().C_Bm1()=dig____END__"}<< std::endl;\par
01286         std::cout       << {\cf22 "_______________________________________________"}<< std::endl;\par
01287 \}\par
01288 \par
01289 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01290         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01291 {\cf18 void} display_prop_C_B_minus_1_eq_C_Bm1() \{\par
01292         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01293         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01294         std::uint64_t contador_buenos\{\};\par
01295         std::uint64_t contador_malos\{\};\par
01296         std::uint64_t contador\{\};\par
01297         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01298                         base_B_dig_t uds\{nd\};\par
01299                         base_B_dig_t uds_C_Bm1_p1\{uds.C_Bm1()\};\par
01300                         ++uds_C_Bm1_p1;\par
01301                         base_B_dig_t uds_C_B\{uds.C_B()\};\par
01302 \par
01303                         {\cf19 if} (uds_C_Bm1_p1 == uds_C_B)\par
01304                                 ++contador_buenos;\par
01305                         {\cf19 else}\par
01306                                 ++contador_malos;\par
01307 \par
01308                         ++contador;\par
01309         \}\par
01310         std::cout       << {\cf22 "_______________________________________________"}<< std::endl;\par
01311         std::cout       << {\cf22 "__BEGIN__TESTS_dig.C_Bm1()+1=dig.C_B()__BEGIN__"}<< std::endl;\par
01312         std::cout       << {\cf22 " Numero de C_Bm1(C_Bm1())=Id() correctas    = "}\par
01313                                 << contador_buenos                                                              << std::endl;\par
01314         std::cout       << {\cf22 " Numero de C_B(C_B())=Id() fallidos = "}\par
01315                                 << contador_malos                                                               << std::endl;\par
01316         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01317                                 << contador_buenos+contador_malos                               << std::endl;\par
01318         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01319                                 << contador                                                                             << std::endl;\par
01320         std::cout       << {\cf22 "__END____TESTS_dig.C_Bm1()+1=dig.C_B()____END__"}<< std::endl;\par
01321         std::cout       << {\cf22 "_______________________________________________"}<< std::endl;\par
01322 \}\par
01323 \par
01324 \par
01325 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01326         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01327 {\cf18 void} display_unary_operator_minus() \{\par
01328         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01329         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01330         std::uint64_t contador_buenos\{\};\par
01331         std::uint64_t contador_malos\{\};\par
01332         std::uint64_t contador\{\};\par
01333         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01334                         std::int64_t nnd\{nd\};\par
01335                         {\cf19 while} (nnd < 0)\par
01336                                 nnd += int64_B;\par
01337                         {\cf19 while} (nnd >= int64_B)\par
01338                                 nnd -= int64_B;\par
01339 \par
01340                         std::int64_t result_int\{int64_B-nnd\};\par
01341                         {\cf19 while} (result_int < 0)\par
01342                                 result_int += int64_B;\par
01343                         {\cf19 while} (result_int >= int64_B)\par
01344                                 result_int -= int64_B;\par
01345 \par
01346                         base_B_dig_t uds\{nnd\};\par
01347                         base_B_dig_t result_dig\{-uds\};\par
01348 \par
01349                         {\cf19 if} (result_dig.get() == result_int)\par
01350                                 ++contador_buenos;\par
01351                         {\cf19 else}\par
01352                                 ++contador_malos;\par
01353 \par
01354                         ++contador;\par
01355         \}\par
01356         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01357         std::cout       << {\cf22 "__BEGIN___TESTS_OPERATOR_-_UNARIO__BEGIN___"}<< std::endl;\par
01358         std::cout       << {\cf22 " Numero de cambios de signo correctas       = "}\par
01359                                 << contador_buenos                                                              << std::endl;\par
01360         std::cout       << {\cf22 " Numero de cambios de signo fallidos        = "}\par
01361                                 << contador_malos                                                               << std::endl;\par
01362         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01363                                 << contador_buenos+contador_malos                               << std::endl;\par
01364         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01365                                 << contador                                                                             << std::endl;\par
01366         std::cout       << {\cf22 "__END_____TESTS_OPERATOR_-_UNARIO____END___"}<< std::endl;\par
01367         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01368 \}\par
01369 \par
01370 {\cf17 template}<type_traits::allowable_base_type_c UINT_T, UINT_T B>\par
01371         {\cf17 requires} (type_traits::suitable_base<UINT_T,B>())\par
01372 {\cf18 void} display_unary_operator_neg() \{\par
01373         {\cf17 using }base_B_dig_t = dig_t<UINT_T,B>;\par
01374         {\cf17 constexpr} std::int64_t int64_B\{B\};\par
01375         std::uint64_t contador_buenos\{\};\par
01376         std::uint64_t contador_malos\{\};\par
01377         std::uint64_t contador\{\};\par
01378         {\cf19 for}(std::int64_t nd\{-2*int64_B\} ; nd < 2*int64_B ; ++nd) \{\par
01379                         std::int64_t nnd\{nd\};\par
01380                         {\cf19 while} (nnd < 0)\par
01381                                 nnd += int64_B;\par
01382                         {\cf19 while} (nnd >= int64_B)\par
01383                                 nnd -= int64_B;\par
01384 \par
01385                         std::int64_t result_int\{int64_B-nnd-1\};\par
01386                         {\cf19 while} (result_int < 0)\par
01387                                 result_int += int64_B;\par
01388                         {\cf19 while} (result_int >= int64_B)\par
01389                                 result_int -= int64_B;\par
01390 \par
01391                         base_B_dig_t uds\{nnd\};\par
01392                         base_B_dig_t result_dig\{!uds\};\par
01393 \par
01394                         {\cf19 if} (result_dig.get() == result_int)\par
01395                                 ++contador_buenos;\par
01396                         {\cf19 else}\par
01397                                 ++contador_malos;\par
01398 \par
01399                         ++contador;\par
01400         \}\par
01401         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01402         std::cout       << {\cf22 "__BEGIN___TESTS_OPERATOR_!_UNARIO__BEGIN___"}<< std::endl;\par
01403         std::cout       << {\cf22 " Numero de negaciones correctas     = "}\par
01404                                 << contador_buenos                                                              << std::endl;\par
01405         std::cout       << {\cf22 " Numero de negaciones fallidas      = "}\par
01406                                 << contador_malos                                                               << std::endl;\par
01407         std::cout   << {\cf22 " Numero total de pruebas                                        = "}\par
01408                                 << contador_buenos+contador_malos                               << std::endl;\par
01409         std::cout   << {\cf22 " Numero limite del ciclo \\"for\\"                        = "}\par
01410                                 << contador                                                                             << std::endl;\par
01411         std::cout       << {\cf22 "__END_____TESTS_OPERATOR_!_UNARIO____END___"}<< std::endl;\par
01412         std::cout       << {\cf22 "___________________________________________"}<< std::endl;\par
01413 \}\par
01414 \par
01415 \}\par
01416 {\cf21 #endif }{\cf20 // TEST_DIG_T_HPP_INCLUDED}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Referencia del Archivo utilities.hpp\par \pard\plain 
{\tc\tcl2 \v utilities.hpp}
{\xe \v utilities.hpp}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tuple>}\par
{\f2 #include <array>}\par
{\f2 #include "basic_types.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Dependencia gr\'E1fica adjunta para utilities.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "utilities_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Gr\'E1fico de los archivos que directa o indirectamente incluyen a este archivo:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "utilities_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Clases\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::pack2tuple< Ts >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::local_void_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::for_each_same_type< Head_t, Tail_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::for_each_same_type< Head_t >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::pack2array< Ts >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
END: TEMPLATE GENERICO Y SUS ESPECIALIZACIONES. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::pow_B_to_E_t< Base, Exp >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA ANTIGUA PERO SEGURA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::pow_B_to_E_t< Base, 2 >}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::pow_B_to_E_t< Base, 1 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::pow_B_to_E_t< Base, 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::tuple_builder_t< IntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
TEMPLATE GENERAL. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::tuple_builder_t< EndIntObj_ct-1, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == ENDINTOBJ_CT-1. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::tuple_builder_t< BeginIntObj_ct, BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
ESPECIALIZACION DONDE INTOBJ_CT == BEGININTOBJ_CT. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b utilities::special::tuple_user_constructor_t< BeginIntObj_ct, EndIntObj_ct, Base, Funct_tt >}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b utilities}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b utilities::special}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Concepts\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b utilities::all_are_the_same_type_c}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
concept {\b utilities::there_is_one_or_more_c}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T> using {\b utilities::uintspair} = typename std::array< UINT_T, 2 >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T, UINT_T B> using {\b utilities::uintspairlist} = typename std::array< uintspair< UINT_T >, B >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::type_traits::unsigned_integral_c} UINT_T, UINT_T B> using {\b utilities::uintspairtbl} = typename std::array< uintspairlist< UINT_T, B >, B >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Funciones\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class... Ts> \par
requires ( all_are_the_same_type_c<Ts...> && there_is_one_or_more_c<Ts...> )void {\b utilities::assign_with_order} (auto &dest, const Ts &... args) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::usint_t} B, {\b NumRepr::usint_t} L> consteval {\b NumRepr::uint128_t} {\b utilities::special::Base_pow_to_Size} () noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
FORMA SENCILLA DE CONSEGUIR POTENCIAS DE UNA BASE EN COMPILE TIME. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t start, std::size_t Base, std::size_t ... Is, template< std::size_t, std::size_t > typename Funct_tt, typename ... Ts> constexpr void {\b utilities::special::ctf_helper} (std::index_sequence< Is... >, std::tuple< Ts... > const &t) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t start, std::size_t end, std::size_t Base, template< typename, std::size_t, std::size_t > typename Funct_tt, typename ... Ts> constexpr void {\b utilities::special::ct_for} (std::tuple< Ts... > const &t) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<auto B, auto L, typename A > constexpr {\b NumRepr::uint128_t} {\b utilities::special::conversion_to_int} (const A &arg) noexcept\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
CONVERSION DE REGISTRO DE DIGITOS A ENTERO EN TIEMPO DE COMPILACION. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b NumRepr::usint_t} Base, {\b NumRepr::usint_t} Exp> constexpr {\b NumRepr::uint128_t} {\b utilities::special::Pow_B2L_v} = pow_B_to_E_t<Base,Exp>::value\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::int64_t BeginIntObj_ct, std::int64_t EndIntObj_ct, std::int64_t Base, template< std::int64_t, std::int64_t > class Funct_tt> constexpr auto {\b utilities::special::tuple_constr_v}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utilities.hpp\par \pard\plain 
{\tc\tcl2 \v utilities.hpp}
{\xe \v utilities.hpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Ir a la documentaci\'F3n de este archivo.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef UTILITIES_HPP_INCLUDED}\par
00002 {\cf21 #define UTILITIES_HPP_INCLUDED}\par
00003 \par
00004 {\cf21 #include <tuple>}\par
00005 {\cf21 #include <array>}\par
00006 {\cf21 #include "basic_types.hpp"}\par
00007 \par
00008 {\cf17 namespace }utilities \{\par
00009 {\cf17 template}<NumRepr::type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T>\par
00010 {\cf17 using }uintspair         = {\cf17 typename} std::array<UINT_T,2>;\par
00011 {\cf17 template}<NumRepr::type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00012 {\cf17 using }uintspairlist = {\cf17 typename} std::array<uintspair<UINT_T>,B>;\par
00013 {\cf17 template}<NumRepr::type_traits::{\cf18 unsigned}_{\cf18 int}egral_c UINT_T,UINT_T B>\par
00014 {\cf17 using }uintspairtbl      = {\cf17 typename} std::array<uintspairlist<UINT_T,B>,B>;\par
00015 \par
00038 \par
00039 {\cf17 template}<{\cf17 typename}...Ts>\par
00040 {\cf17 struct }pack2tuple \{\par
00041         {\cf17 using }tuple_type = std::tuple<Ts...>;\par
00042         {\cf17 static} {\cf17 constexpr} {\cf18 unsigned} pack_size() noexcept \{{\cf19 return} ({\cf17 sizeof}...(Ts));\}\par
00043         {\cf17 constexpr} tuple_type operator()(Ts&& ...args) {\cf17 noexcept} \{\par
00044                 tuple_type  content = std::make_tuple(std::forward(args...));\par
00045                 {\cf19 return}  std::move(content);\par
00046         \}\par
00047         {\cf17 template}<{\cf18 unsigned} K>\par
00048         {\cf17 using }elem_type =  {\cf17 typename} std::tuple_element<K,tuple_type>::type;\par
00049         {\cf17 template}<{\cf18 unsigned} J>\par
00050         {\cf17 static} {\cf17 constexpr} elem_type<J>::type get(Ts&& ...args) {\cf17 noexcept} \{\par
00051                 tuple_type  content = std::make_tuple(std::forward(args...));\par
00052                 elem_type<J> ret\{std::get<J>(std::forward(content))\};\par
00053                 {\cf19 return} ret;\par
00054         \}\par
00055 \};\par
00068 \par
00073 \par
00074 {\cf17 struct }local_void_t \{\};\par
00075 \par
00076 {\cf17 template}<{\cf17 class }Head_t,{\cf17 class}...Tail_t>\par
00077 {\cf17 struct }for_each_same_type \{\par
00078         {\cf17 using }second_t = std::tuple_element<0,std::tuple<Tail_t...>>::type;\par
00079         {\cf17 constexpr} {\cf17 static}\par
00080         {\cf18 bool} are_same_type_v = (\par
00081         (std::is_same_v<Head_t,second_t>)\par
00082                 &&      (for_each_same_type<Tail_t...>::are_same_type_v)\par
00083         );\par
00084 \};\par
00085 \par
00086 {\cf17 template}<{\cf17 class} Head_t>\par
00087 {\cf17 struct }for_each_same_type<Head_t> \{\par
00088         {\cf17 constexpr} {\cf17 static} {\cf18 bool} are_same_type_v = {\cf17 true};\par
00089 \};\par
00090 \par
00091 {\cf17 template}<{\cf17 typename}...Ts>\par
00092 {\cf17 concept }all_are_the_same_type_c = {\cf17 requires}(Ts...) \{\par
00093         for_each_same_type<Ts...>::are_same_type_v;\par
00094 \};\par
00095 \par
00096 {\cf17 template}<{\cf17 typename}...Ts>\par
00097 {\cf17 concept }there_is_one_or_more_c = {\cf17 requires}(Ts...) \{\par
00098         (({\cf17 sizeof}...(Ts))>0);\par
00099 \};\par
00100 \par
00102 \par
00103 {\cf17 template}<{\cf17 typename}...Ts>\par
00104         {\cf17 requires}  (all_are_the_same_type_c<Ts...>&&there_is_one_or_more_c<Ts...>)\par
00105 {\cf17 struct} pack2array \{\par
00106         {\cf17 using }array_type = std::array<\par
00107                                                 {\cf17 typename} pack2tuple<Ts...>::elem_type<0>,\par
00108                                                 ({\cf17 sizeof}...(Ts))\par
00109                                         >;\par
00110         {\cf17 static} {\cf17 constexpr} std::size_t pack_size() noexcept \{\par
00111                 {\cf19 return} ({\cf17 sizeof}...(Ts));\par
00112         \}\par
00113 \par
00114         {\cf17 constexpr} array_type operator()(Ts&& ...args) {\cf17 const} {\cf17 noexcept} \{\par
00115                 {\cf17 constexpr} array_type  content = array_type\{std::forward(args...)\};\par
00116                 {\cf19 return}  content;\par
00117         \}\par
00118 \par
00119         {\cf17 using }elem_type =  {\cf17 typename} pack2tuple<Ts...>::elem_type<0>;\par
00120 \par
00121         {\cf17 template}<std::{\cf18 size_t} J>\par
00122         {\cf17 static} {\cf17 constexpr} elem_type get(Ts&& ...args) {\cf17 noexcept} \{\par
00123                 {\cf17 constexpr} array_type  content = \{std::forward(args...)\};\par
00124                 {\cf17 constexpr} elem_type ret\{std::get<J>(std::forward(content))\};\par
00125                 {\cf19 return} ret;\par
00126         \}\par
00127 \par
00131 \par
00132         {\cf17 template} <std::size_t... I>\par
00133         {\cf17 static} {\cf17 constexpr} {\cf18 void} for_each_impl(\par
00134                 array_type& iarray,\par
00135                 {\cf17 const} Ts...args,\par
00136                 std::index_sequence<I...>\par
00137         ) {\cf17 noexcept}\par
00138         \{\par
00139                 ( ( iarray[I] = std::get<I>( std::make_tuple(args...) ) ) , ...);\par
00140                 {\cf19 return};\par
00141         \}\par
00142 \par
00143         {\cf17 static} {\cf17 constexpr}\par
00144         {\cf18 void} for_each(array_type& iarray,{\cf17 const} Ts...args) noexcept \{\par
00145                 {\cf17 constexpr} {\cf18 unsigned} size_of_pack\{{\cf17 sizeof}...(args)\};\par
00146                 for_each_impl(\par
00147                         iarray,\par
00148                         args...,\par
00149                         std::make_index_sequence<size_of_pack>\{\}\par
00150                 );\par
00151                 {\cf19 return};\par
00152         \}\par
00153 \};\par
00154 \par
00155 {\cf17 template}<{\cf17 class}... Ts>\par
00156         {\cf17 requires}        (\par
00157                           all_are_the_same_type_c<Ts...>\par
00158                 &&      there_is_one_or_more_c<Ts...>\par
00159         )\par
00160 {\cf18 void} assign_with_order(\par
00161         {\cf17 auto}& dest ,\par
00162         {\cf17 const} Ts&... args\par
00163         ) {\cf17 noexcept}\par
00164 \{\par
00165         pack2array<Ts...>::for_each(dest,args...);\par
00166         {\cf19 return};\par
00167 \}\par
00173 \par
00174 {\cf17 namespace }special \{\par
00175 \par
00177 {\cf17 template}<NumRepr::us{\cf18 int}_t B,NumRepr::us{\cf18 int}_t L>\par
00178 {\cf17 consteval} {\cf17 inline}\par
00179 NumRepr::uint128_t Base_pow_to_Size() noexcept \{\par
00180         {\cf17 constexpr} NumRepr::uint128_t Bc\{B\};\par
00181         {\cf19 if} {\cf17 constexpr} (L==0)\par
00182                 {\cf19 return} {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(1);\par
00183         {\cf19 else} {\cf19 if} {\cf17 constexpr} (L==1)\par
00184                 {\cf19 return} {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Bc);\par
00185         {\cf19 else} {\cf19 if} {\cf17 constexpr} (L==2)\par
00186                 {\cf19 return} {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Bc*Bc);\par
00187         {\cf19 else}\par
00188                 {\cf19 return} {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Bc*Base_pow_to_Size<B,L-1>());\par
00189 \}\par
00190 \par
00192 {\cf17 template}<NumRepr::us{\cf18 int}_t Base,NumRepr::us{\cf18 int}_t Exp>\par
00193 {\cf17 struct }pow_B_to_E_t \{\par
00194         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t base                        = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Base);\par
00195         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t exponent    = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Exp);\par
00196         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t value                       = base*(pow_B_to_E_t<base,exponent-1>::value);\par
00197 \};\par
00198 {\cf17 template}<NumRepr::us{\cf18 int}_t Base>\par
00199 {\cf17 struct }pow_B_to_E_t<Base,2> \{\par
00200         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t base                        = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Base);\par
00201         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t exponent    = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(2);\par
00202         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t value                       = base*base;\par
00203 \};\par
00204 {\cf17 template}<NumRepr::us{\cf18 int}_t Base>\par
00205 {\cf17 struct }pow_B_to_E_t<Base,1> \{\par
00206         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t base                        = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Base);\par
00207         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t exponent    = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(1);\par
00208         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t value                       = base;\par
00209 \};\par
00210 {\cf17 template}<NumRepr::us{\cf18 int}_t Base>\par
00211 {\cf17 struct }pow_B_to_E_t<Base,0> \{\par
00212         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t base                        = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(Base);\par
00213         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t exponent    = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(0);\par
00214         {\cf17 static} {\cf17 constexpr} NumRepr::uint128_t value                       = {\cf17 static_cast<}NumRepr::uint128_t{\cf17 >}(1);\par
00215 \};\par
00216 \par
00217 {\cf17 template}<NumRepr::us{\cf18 int}_t Base,NumRepr::us{\cf18 int}_t Exp>\par
00218 {\cf17 constexpr} NumRepr::uint128_t Pow_B2L_v = pow_B_to_E_t<Base,Exp>::value;\par
00219 \par
00222 \par
00224 {\cf17 template}<\par
00225                 std::int64_t IntObj_ct,\par
00226                 std::int64_t BeginIntObj_ct,\par
00227                 std::int64_t EndIntObj_ct,\par
00228                 std::int64_t Base,\par
00229                 {\cf17 template}<std::{\cf18 int}64_t,std::{\cf18 int}64_t> {\cf17 class }Funct_tt\par
00230         >\par
00231         {\cf17 requires} ((BeginIntObj_ct >= EndIntObj_ct)&&(IntObj_ct >= BeginIntObj_ct))\par
00232 {\cf17 struct} tuple_builder_t \{\par
00233 \par
00234         {\cf17 using }type = std::int64_t;\par
00235 \par
00236         {\cf17 static} {\cf17 constexpr} std::int64_t   unit  = {\cf17 static_cast<}std::int64_t{\cf17 >}(1);\par
00237 \par
00238         {\cf17 static} {\cf17 constexpr} std::int64_t   value\{IntObj_ct\};\par
00239         {\cf17 static} {\cf17 constexpr} std::int64_t   begin_value\{BeginIntObj_ct\};\par
00240         {\cf17 static} {\cf17 constexpr} std::int64_t   end_value\{EndIntObj_ct\};\par
00241 \par
00242         {\cf17 static} {\cf17 consteval}\par
00243         {\cf17 decltype}({\cf17 auto}) build()\par
00244         {\cf17 noexcept} \{\par
00245                 {\cf19 return}\par
00246                         std::tuple_cat(\par
00247                                 std::make_tuple(std::make_tuple(value,Funct_tt<Base,value>\{\}())),\par
00248                                 tuple_builder_t<value+unit,begin_value,end_value,Base,Funct_tt>::build()\par
00249                         );\par
00250         \}\par
00251 \par
00252 \};\par
00253 \par
00255 {\cf17 template}<\par
00256                 std::int64_t BeginIntObj_ct,\par
00257                 std::int64_t EndIntObj_ct,\par
00258                 std::int64_t Base,\par
00259                 {\cf17 template}<std::{\cf18 int}64_t,std::{\cf18 int}64_t> {\cf17 class }Funct_tt\par
00260         >\par
00261 {\cf17 struct }tuple_builder_t<EndIntObj_ct-1,BeginIntObj_ct,EndIntObj_ct,Base,Funct_tt> \{\par
00262 \par
00263         {\cf17 using }type = std::int64_t;\par
00264 \par
00265         {\cf17 static} {\cf17 constexpr} std::int64_t   unit  = {\cf17 static_cast<}std::int64_t{\cf17 >}(1);\par
00266 \par
00267         {\cf17 static} {\cf17 constexpr} std::int64_t   value\{EndIntObj_ct-unit\};\par
00268         {\cf17 static} {\cf17 constexpr} std::int64_t   begin_value\{BeginIntObj_ct\};\par
00269         {\cf17 static} {\cf17 constexpr} std::int64_t   end_value\{EndIntObj_ct\};\par
00270 \par
00271         {\cf17 static} {\cf17 consteval}\par
00272         {\cf17 decltype}({\cf17 auto}) build()\par
00273         {\cf17 noexcept} \{\par
00274                 {\cf19 return} std::make_tuple(std::make_tuple(value,Funct_tt<Base,value>\{\}()));\par
00275         \}\par
00276 \par
00277 \};\par
00278 \par
00280 {\cf17 template}<\par
00281                 std::int64_t BeginIntObj_ct,\par
00282                 std::int64_t EndIntObj_ct,\par
00283                 std::int64_t Base,\par
00284                 {\cf17 template}<std::{\cf18 int}64_t,std::{\cf18 int}64_t> {\cf17 class }Funct_tt\par
00285         >\par
00286         {\cf17 requires} (BeginIntObj_ct <= EndIntObj_ct)\par
00287 {\cf17 struct} tuple_builder_t<BeginIntObj_ct,BeginIntObj_ct,EndIntObj_ct,Base,Funct_tt> \{\par
00288 \par
00289         {\cf17 using }type = std::int64_t;\par
00290 \par
00291         {\cf17 static} {\cf17 constexpr} type   unit  = 1;\par
00292 \par
00293         {\cf17 static} {\cf17 constexpr} type   value\{BeginIntObj_ct\};\par
00294         {\cf17 static} {\cf17 constexpr} type   begin_value\{BeginIntObj_ct\};\par
00295         {\cf17 static} {\cf17 constexpr} type   end_value\{EndIntObj_ct\};\par
00296 \par
00297         {\cf17 static} {\cf17 consteval}\par
00298         {\cf17 decltype}({\cf17 auto}) build()\par
00299         {\cf17 noexcept} \{\par
00300                 {\cf19 return}\par
00301                         std::tuple_cat(\par
00302                                 std::make_tuple(\par
00303                                         std::make_tuple(value,Funct_tt<Base,value>\{\}())\par
00304                                 ),\par
00305                                 tuple_builder_t<begin_value+unit,begin_value,end_value,Base,Funct_tt>::build()\par
00306                         );\par
00307         \}\par
00308 \par
00309 \};\par
00310 \par
00311 {\cf17 template}<\par
00312         std::int64_t BeginIntObj_ct,\par
00313         std::int64_t EndIntObj_ct,\par
00314         std::int64_t Base,\par
00315         {\cf17 template}<std::{\cf18 int}64_t,std::{\cf18 int}64_t> {\cf17 class }Funct_tt\par
00316 >\par
00317         {\cf17 requires} (BeginIntObj_ct < EndIntObj_ct)\par
00318 {\cf17 struct} tuple_user_constructor_t \{\par
00319         {\cf17 static} {\cf17 constexpr} {\cf17 auto} value =\par
00320                 tuple_builder_t<\par
00321                                 BeginIntObj_ct,\par
00322                                 BeginIntObj_ct,\par
00323                                 EndIntObj_ct,\par
00324                                 Base,\par
00325                                 Funct_tt\par
00326                 >::build();\par
00327 \};\par
00328 \par
00329 {\cf17 template}<\par
00330         std::int64_t BeginIntObj_ct,\par
00331         std::int64_t EndIntObj_ct,\par
00332         std::int64_t Base,\par
00333         {\cf17 template}<std::{\cf18 int}64_t,std::{\cf18 int}64_t> {\cf17 class }Funct_tt\par
00334 >\par
00335         {\cf17 requires} (BeginIntObj_ct < EndIntObj_ct)\par
00336 {\cf17 constexpr} {\cf17 auto} tuple_constr_v =\par
00337         tuple_user_constructor_t<\par
00338                         BeginIntObj_ct,\par
00339                         EndIntObj_ct,\par
00340                         Base,\par
00341                         Funct_tt\par
00342         >::build();\par
00343 \par
00344 {\cf17 template} <\par
00345         std::size_t start,\par
00346         std::size_t Base,\par
00347         std::size_t ... Is,\par
00348         {\cf17 template}<\par
00349                 std::size_t,\par
00350                 std::size_t\par
00351         > {\cf17 typename} Funct_tt,\par
00352         {\cf17 typename} ... Ts\par
00353 >\par
00354 {\cf17 constexpr}\par
00355 {\cf18 void} ctf_helper (\par
00356         std::index_sequence<Is...>,\par
00357         std::tuple<Ts...> {\cf17 const} & t\par
00358 ) {\cf17 noexcept} \{\par
00359         (Funct_tt<Base,Is>\{\}(std::get<start + Is>(t)), ...);\par
00360 \}\par
00361 \par
00362 {\cf17 template} <\par
00363         std::size_t start,\par
00364         std::size_t end,\par
00365         std::size_t Base,\par
00366         {\cf17 template}<\par
00367                 {\cf17 typename},\par
00368                 std::size_t,\par
00369                 std::size_t\par
00370         > {\cf17 typename} Funct_tt,\par
00371         {\cf17 typename} ... Ts\par
00372 >\par
00373 {\cf17 constexpr}\par
00374 {\cf18 void} ct_for (std::tuple<Ts...> {\cf17 const} & t) {\cf17 noexcept} \{\par
00375         ctf_helper<start,Base,Funct_tt>(std::make_index_sequence<end-start>\{\}, t);\par
00376 \}\par
00377 \par
00379 {\cf17 template}<auto B,auto L,{\cf17 typename} A>\par
00380 {\cf17 constexpr} {\cf17 inline}\par
00381 NumRepr::uint128_t\par
00382 conversion_to_int({\cf17 const} A& arg) {\cf17 noexcept} \{\par
00383         {\cf17 using }NumRepr::uint128_t;\par
00384         {\cf17 using }NumRepr::sint128_t;\par
00385         {\cf17 constexpr} uint128_t base\{{\cf17 static_cast<}uint128_t{\cf17 >}(B)\};\par
00386         uint128_t acc\{arg[L-1]()\};\par
00387         {\cf19 for}(sint128_t ix\{L-2\} ; ix > -1 ; --ix) \{\par
00388                 acc *= base;\par
00389                 acc += {\cf17 static_cast<}uint128_t{\cf17 >}(arg[ix]());\par
00390         \};\par
00391         {\cf19 return} acc;\par
00392 \}\par
00393 \par
00394 \par
00395 \par
00396 \}\par
00397 \par
00398 \}\par
00399 \par
00400 {\cf21 #endif }{\cf20 // UTILITIES_HPP_INCLUDED}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \'CDndice\par 
\pard\plain 
{\tc \v \'CDndice}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
